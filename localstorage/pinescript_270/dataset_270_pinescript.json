{"messages": [{"role": "user", "content": "Release Notes:                                                    - Minor styling changes"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"HyperTrend [LuxAlgo]\", \"LuxAlgo - HyperTrend\", overlay = true)\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nmult = input.float(5, 'Multiplicative Factor', minval = 0)\nslope = input.float(14, 'Slope', minval = 0)\nwidth = input.float(80, 'Width %', minval = 0, maxval = 100) / 100\n//Style\nbullCss = input.color( color.teal, 'Average Color', inline = 'avg', group = 'Style'\nbearCss = input.color( color.red, ''              , inline = 'avg', group = 'Style'\narea = input.string('Gradient', 'Area', options = ['Gradient', 'Solid'], group = 'Style'\nupperCss = input.color( color.new(color.red, 70), 'Upper Area', group = 'Style')\nlowerCss = input.color( color.new(color.teal, 70)   , 'Lower Area', group = 'Style'\n//-----------------------------------------------------------------------------}\n//Calculation\n//-----------------------------------------------------------------------------{\nvar float upper = na\nvar float lower = na\nvar float avg   = close\nvar hold = 0.\nvar os = 1.\n    atr = nz(ta.atr(200)) * mult\navg := math.abs(close - avg) > atr ? \n  math.avg(close, avg)\n  : avg + os * (hold / mult / slope)\nos := math.sign(avg - avg[1])\nhold := os != os[1] ? atr : hold\nupper := avg + width * hold\nlower := avg - width * hold\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\ncss = os == 1 ? bullCss : bearCss\nplot_upper = plot(upper, 'Upper', na)\nplot_avg = plot(avg, 'Average', os != os[1] ? na : css)\nplot_lower = plot(lower, 'Lower', na)\nvar color upper_topcol = na\nvar color upper_btmcol = na\nvar color lower_topcol = na\nvar color lower_btmcol = na\n//Fill\nif area == 'Gradient'\n    upper_topcol := upperCss\n    upper_btmcol := color.new(chart.bg_color, 100)\n    lower_topcol := color.new(chart.bg_color, 100)\n    lower_btmcol := lowerCss\nelse\n    upper_topcol := upperCss\n    upper_btmcol := upperCss\n    lower_topcol := lowerCss\n    lower_btmcol := lowerCss\n//Upper Area\nfill(plot_upper, plot_avg\n  , top_color = os != os[1] ? na : upper_topcol\n  , bottom_color = os != os[1] ? na : upper_btmcol\n  , top_value = upper\n  , bottom_value = avg)\n//Lower Area\nfill(plot_avg, plot_lower\n  , top_color = os != os[1] ? na : lower_topcol\n  , bottom_color = os != os[1] ? na : lower_btmcol\n  , top_value = avg\n  , bottom_value = lower)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    - Updated factor range calculation - Minor changes"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"SuperTrend AI (Clustering) [LuxAlgo]\", \"LuxAlgo - SuperTrend AI\", overlay\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input(10, 'ATR Length')\nminMult = input.int(1, 'Factor Range', minval = 0, inline = 'factor')\nmaxMult = input.int(5, '', minval = 0, inline = 'factor')\nstep    = input.float(.5, 'Step', minval = 0, step = 0.1)\n//Trigger error\nif minMult > maxMult\n    runtime.error('Minimum factor is greater than maximum factor in the range')\nperfAlpha = input.float(10, 'Performance Memory', minval = 2)\nfromCluster = input.string('Best', 'From Cluster', options = ['Best', 'Average', 'Worst'\n//Optimization\nmaxIter = input.int(1000, 'Maximum Iteration Steps', minval = 0, group = 'Optimization'\nmaxData = input.int(10000, 'Historical Bars Calculation', minval = 0, group = 'Optimization'\n//Style\nbearCss = input( color.red, 'Trailing Stop', inline = 'ts', group = 'Style')\nbullCss = input( color.teal, '', inline = 'ts', group = 'Style')\namaBearCss = input( color.new(color.red, 50), 'AMA', inline = 'ama', group = 'Style'\namaBullCss = input( color.new(color.teal, 50), '', inline = 'ama', group = 'Style'\nshowGradient = input(true, 'Candle Coloring', group = 'Style')\nshowSignals = input(true, 'Show Signals', group = 'Style')\n//Dashboard\nshowDash  = input(true, 'Show Dashboard', group = 'Dashboard')\ndashLoc  = input.string('Top Right', 'Location', options = ['Top Right', 'Bottom Right'\ntextSize = input.string('Small', 'Size'        , options = ['Tiny', 'Small', 'Normal'\n//-----------------------------------------------------------------------------}\n//UDT's\n//-----------------------------------------------------------------------------{\ntype supertrend\n    float upper = hl2\n    float lower = hl2\n    float output\n    float perf = 0\n    float factor\n    int trend = 0\ntype vector\n    array<float> out\n//-----------------------------------------------------------------------------}\n//Supertrend\n//-----------------------------------------------------------------------------{\nvar holder = array.new<supertrend>(0)\nvar factors = array.new<float>(0)\n//Populate supertrend type array\nif barstate.isfirst\n    for i = 0 to int((maxMult - minMult) / step)\n        factors.push(minMult + i * step)\n        holder.push(supertrend.new())\natr = ta.atr(length)\n//Compute Supertrend for multiple factors\nk = 0\nfor factor in factors\n    get_spt = holder.get(k)\n    up = hl2 + atr * factor\n    dn = hl2 - atr * factor\n        get_spt.trend := close > get_spt.upper ? 1 : close < get_spt.lower ? 0 : get_spt\n    get_spt.upper := close[1] < get_spt.upper ? math.min(up, get_spt.upper) : up\n    get_spt.lower := close[1] > get_spt.lower ? math.max(dn, get_spt.lower) : dn\n        diff = nz(math.sign(close[1] - get_spt.output))\n    get_spt.perf += 2/(perfAlpha+1) * (nz(close - close[1]) * diff - get_spt.perf)\n    get_spt.output := get_spt.trend == 1 ? get_spt.lower : get_spt.upper\n    get_spt.factor := factor\n    k += 1\n//-----------------------------------------------------------------------------}\n//K-means clustering\n//-----------------------------------------------------------------------------{\nfactor_array = array.new<float>(0)\ndata = array.new<float>(0)\n//Populate data arrays\nif last_bar_index - bar_index <= maxData\n    for element in holder\n        data.push(element.perf)\n        factor_array.push(element.factor)\n//Intitalize centroids using quartiles\ncentroids = array.new<float>(0)\ncentroids.push(data.percentile_linear_interpolation(25))\ncentroids.push(data.percentile_linear_interpolation(50))\ncentroids.push(data.percentile_linear_interpolation(75))\n//Intialize clusters\nvar array<vector> factors_clusters = na\nvar array<vector> perfclusters = na\nif last_bar_index - bar_index <= maxData\n    for _ = 0 to maxIter\n        factors_clusters := array.from(vector.new(array.new<float>(0)), vector.new\n        perfclusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new\n                //Assign value to cluster\n        i = 0\n        for value in data\n            dist = array.new<float>(0)\n            for centroid in centroids\n                dist.push(math.abs(value - centroid))\n            idx = dist.indexof(dist.min())\n            perfclusters.get(idx).out.push(value)\n            factors_clusters.get(idx).out.push(factor_array.get(i))\n            i += 1\n        //Update centroids\n        new_centroids = array.new<float>(0)\n        for cluster_ in perfclusters\n            new_centroids.push(cluster_.out.avg())\n        //Test if centroid changed\n        if new_centroids.get(0) == centroids.get(0) and new_centroids.get(1) == centroids\n            break\n        centroids := new_centroids\n//-----------------------------------------------------------------------------}\n//Signals and trailing stop\n//-----------------------------------------------------------------------------{\n//Get associated supertrend\nvar float target_factor = na\nvar float perf_idx = na\nvar float perf_ama = na\nvar from = switch fromCluster\n    'Best' => 2\n    'Average' => 1\n    'Worst' => 0\n//Performance index denominator\nden = ta.ema(math.abs(close - close[1]), int(perfAlpha))\nif not na(perfclusters)\n    //Get average factors within target cluster \n    target_factor := nz(factors_clusters.get(from).out.avg(), target_factor)\n        //Get performance index of target cluster \n    perf_idx := math.max(nz(perfclusters.get(from).out.avg()), 0) / den\n//Get new supertrend\nvar upper = hl2\nvar lower = hl2\nvar os = 0\nup = hl2 + atr * target_factor\ndn = hl2 - atr * target_factor\nupper := close[1] < upper ? math.min(up, upper) : up\nlower := close[1] > lower ? math.max(dn, lower) : dn\nos := close > upper ? 1 : close < lower ? 0 : os\nts = os ? lower : upper\n//Get trailing stop adaptive MA\nif na(ts[1]) and not na(ts)\n    perf_ama := ts\nelse\n    perf_ama += perf_idx * (ts - perf_ama)\n//-----------------------------------------------------------------------------}\n//Dashboard\n//-----------------------------------------------------------------------------{\nvar table_position = dashLoc == 'Bottom Left' ? position.bottom_left \n  : dashLoc == 'Top Right' ? position.top_right \n  : position.bottom_right\nvar table_size = textSize == 'Tiny' ? size.tiny \n  : textSize == 'Small' ? size.small \n  : size.normal\nvar tb = table.new(table_position, 4, 4\n  , bgcolor =  #1e222d\n  , border_color =  #373a46\n  , border_width = 1\n  , frame_color =  #373a46\n  , frame_width = 1)\nif showDash\n    if barstate.isfirst\n        tb.cell(0, 0, 'Cluster', text_color =  color.white, text_size = table_size\n        tb.cell(0, 1, 'Best', text_color =  color.white, text_size = table_size)\n        tb.cell(0, 2, 'Average', text_color =  color.white, text_size = table_size\n        tb.cell(0, 3, 'Worst', text_color =  color.white, text_size = table_size)\n            tb.cell(1, 0, 'Size', text_color =  color.white, text_size = table_size)\n        tb.cell(2, 0, 'Centroid Dispersion', text_color =  color.white, text_size\n        tb.cell(3, 0, 'Factors', text_color =  color.white, text_size = table_size\n        if barstate.islast\n        topN = perfclusters.get(2).out.size()\n        midN = perfclusters.get(1).out.size()\n        btmN = perfclusters.get(0).out.size()\n        //Size\n        tb.cell(1, 1, str.tostring(topN), text_color =  color.white, text_size = \n        tb.cell(1, 2, str.tostring(midN), text_color =  color.white, text_size = \n        tb.cell(1, 3, str.tostring(btmN), text_color =  color.white, text_size = \n                //Content\n        tb.cell(3, 1, str.tostring(factors_clusters.get(2).out), text_color =  color.white\n        tb.cell(3, 2, str.tostring(factors_clusters.get(1).out), text_color =  color.white\n        tb.cell(3, 3, str.tostring(factors_clusters.get(0).out), text_color =  color.white\n        //Calculate dispersion around centroid\n        i = 0\n        for cluster_ in perfclusters\n            disp = 0.\n            if cluster_.out.size() > 1\n                for value in cluster_.out\n                    disp += math.abs(value - centroids.get(i))\n                        disp /= switch i\n                0 => btmN\n                1 => midN\n                2 => topN\n            i += 1\n            tb.cell(2, 4 - i, str.tostring(disp, '#.####'), text_color =  color.white\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\ncss = os ? bullCss : bearCss\nplot(ts, 'Trailing Stop', os != os[1] ? na : css)\nplot(perf_ama, 'Trailing Stop AMA',\n  ta.cross(close, perf_ama) ? na\n  : close > perf_ama ? amaBullCss : amaBearCss)\n//Candle coloring\nbarcolor(showGradient ? color.from_gradient(perf_idx, 0, 1, color.new(css, 80), css\n//Signals\nn = bar_index\nif showSignals\n    if os > os[1]\n        label.new(n, ts, str.tostring(int(perf_idx * 10))\n          , color = bullCss\n          , style = label.style_label_up\n          , textcolor =  color.white\n          , size = size.tiny)\n    if os < os[1]\n        label.new(n, ts, str.tostring(int(perf_idx * 10))\n          , color = bearCss\n          , style = label.style_label_down\n          , textcolor =  color.white\n          , size = size.tiny)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Master Pattern indicator is derived from the framework proposed by Wyckoff and automatically displays major/minor patterns and their associated expansion lines on the chart. Liquidity levels are also included and can be used as targets/stops. Note that the Liquidity levels are plotted retrospectively as they are based on pivots. \ud83d\udd36 USAGE The Master Pattern indicator detects contraction phases in the markets (characterized by a lower high and higher low). The resulting average from the latest swing high/low is used as expansion line. Price breaking the contraction range upwards highlights a bullish master pattern, while a break downward highlights a bearish master pattern. During the expansion phase price can tend to be stationary around the expansion level. This phase is then often followed by the price significantly deviating from the expansion line, highlighting a markup phase. Expansion lines can also be used as support/resistance levels. \ud83d\udd39 Major/Minor Patterns The script can classify patterns as major or minor patterns. Major patterns occur when price breaks both the upper and lower extremity of a contraction range, with their contraction area highlighted with a border, while minor patterns have only a single extremity broken. \ud83d\udd36 SETTINGS Contraction Detection Lookback: Lookback used to detect the swing points used to detect the contraction range. Liquidity Levels: Lookback for the swing points detection used as liquidity levels. Higher values return longer term liquidity levels. Show Major Pattern: Display major patterns. Show Minor Pattern: Display minor patterns."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"Master Pattern [LuxAlgo]\", \"LuxAlgo - Master Pattern Indicator\", overlay\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input.int(3, 'Contraction Detection Lookback', minval = 1)\nliqLength = input.int(20, 'Liquidity Levels', minval = 1)\nshowMajor = input(true, 'Show Major Pattern')\nshowMinor = input(true, 'Show Minor Pattern')\n//Style\nbullCss = input.color( color.teal, 'Bullish Pattern', inline = 'bull', group = 'Pattern Style'\nshowBullBox = input(true, 'Area', inline = 'bull', group = 'Pattern Style')\nshowBullLvl = input(true, 'Line', inline = 'bull', group = 'Pattern Style')\nbearCss = input.color( color.red, 'Bearish Pattern', inline = 'bear', group = 'Pattern Style'\nshowBearBox = input(true, 'Area', inline = 'bear', group = 'Pattern Style')\nshowBearLvl = input(true, 'Line', inline = 'bear', group = 'Pattern Style')\n//Liquidity Style\nshowLiq = input(true, 'Show Liquidity Levels', group = 'Liquidity')\nbullLiqCss = input.color( color.teal, 'Upper Liquidity', group = 'Liquidity')\nbearLiqCss = input.color( color.red, 'Lower Liquidity', group = 'Liquidity')\n//-----------------------------------------------------------------------------}\n//UDT\n//-----------------------------------------------------------------------------{\ntype mp\n    box area\n    line avg\n    bool breakup\n    bool breakdn\n//-----------------------------------------------------------------------------}\n//Detect contraction\n//-----------------------------------------------------------------------------{\nvar phy = 0., var phx = 0, var pht = 0.\nvar ply = 0., var plx = 0, var plt = 0.\nvar float top = na\nvar float btm = na\nn = bar_index\nph = ta.pivothigh(length, length)\npl = ta.pivotlow(length, length)\nif ph\n    pht := math.sign(ph - phy)\n    phy := ph\n    if pht == -1 and plt == 1\n        top := ph\n        btm := ply\n        phx := n-length\nif pl\n    plt := math.sign(pl - ply)\n    ply := pl\n    if pht  == -1 and plt == 1\n        top := phy\n        btm := pl\n        plx := n-length\n//-----------------------------------------------------------------------------}\n//Set pattern\n//-----------------------------------------------------------------------------{\nvar mp master = mp.new()\n//Detect master pattern\nisbull = high[length] > top and top > btm\nisbear = low[length] < btm and top > btm\nif isbull or isbear\n    css = isbull ? bullCss : bearCss\n    master.avg.set_x2(n-length)\n    val = math.avg(top, btm)\n    //Create new master pattern object\n    master := mp.new(\n      (isbull and showBullBox) or (isbear and showBearBox) ? box.new(math.max(phx,\n      , (isbull and showBullLvl) or (isbear and showBearLvl) ? line.new(n-length, \n      , isbull\n      , isbear)\n    top := na\n    btm := na\n//Determine if pattern switch to major\nif master.breakup\n    if low < master.area.get_bottom()\n        if not showMajor\n            master.area.delete()\n            master.avg.delete()\n        else\n            master.area.set_border_color(bullCss)\n            if not showMinor\n                master.area.set_bgcolor(color.new(bullCss, 50))\n                master.avg.set_color(bullCss)\nelse if master.breakdn\n    if high > master.area.get_top()\n        if not showMajor\n            master.area.delete()\n            master.avg.delete()\n        else\n            master.area.set_border_color(bearCss)\n            if not showMinor\n                master.area.set_bgcolor(color.new(bearCss, 50))\n                master.avg.set_color(bearCss)\n//Set friction level x2 coordinate to current bar\nif not na(master.avg)\n    master.avg.set_x2(n)\n//-----------------------------------------------------------------------------}\n//Liquidity levels\n//-----------------------------------------------------------------------------{\nvar line liqup = na, var liqup_reach = false\nvar line liqdn = na, var liqdn_reach = false\nliqph = ta.pivothigh(liqLength, liqLength)\nliqpl = ta.pivotlow(liqLength, liqLength)\n//Set upper liquidity\nif liqph and showLiq\n    if not liqup_reach\n        liqup.set_x2(n-liqLength)\n    liqup := line.new(n-liqLength, liqph, n, liqph, color = bullLiqCss, style = line.style_dotted\n    liqup_reach := false\nelse if not liqup_reach and showLiq\n    liqup.set_x2(n)\n    if high > liqup.get_y1()\n        liqup_reach := true\n//Set lower liquidity\nif liqpl and showLiq\n    if not liqdn_reach\n        liqdn.set_x2(n-liqLength)\n    liqdn := line.new(n-liqLength, liqpl, n, liqpl, color = bearLiqCss, style = line.style_dotted\n    liqdn_reach := false\nelse if not liqdn_reach and showLiq\n    liqdn.set_x2(n)\n    if low < liqdn.get_y1()\n        liqdn_reach := true\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Support & Resistance Dynamic indicator aims to return real-time predictive support and resistance zones that are relevant to a detected trend. This makes this indicator similar to our previously published Predictive Ranges indicator. Users can additionally extend the most recent historical support and resistance zones. \ud83d\udd36 USAGE Hypothetical resistance levels in an up-trend or supports in a down-trend would tend to be broken more easily, as such the indicator primary objective is to return reliable real-time support and resistance levels by taking this into account. When the market is up-trending the indicator will only return support zones, while a down-trending market will cause the indicator to only return resistance zones. If the price significantly breaks a support/resistance, rendering it unreliable, it can be a sign of a potential reversal. Users can return support/resistance levels/zones for shorter-term trends by reducing the Multiplicative Factor setting. \ud83d\udd39 Extension Users can extend past estimated support/resistance levels, the amount of extended levels is determined by the users. Certain levels can stay relevant in the future, and can also aid in measuring the significance of a breakout, with further past levels being reached being indicative of more significant trends. \ud83d\udd36 DETAILS To determine if the price is up-trending or down-trending in order to show either support or resistance, the same method used in the predictive ranges script is used. A central tendency is estimated, if price significantly deviates from it upward an uptrend is detected, else a significant deviation downward would indicate a downtrend. The central tendency estimate is used for the construction of the support and resistance levels. \ud83d\udd36 SETTINGS Multiplicative Factor: Determines the frequency at which new supports/resistances are returned, with lower values returning more frequent levels/zones. ATR Length: ATR averaging length used as deviation threshold for the central tendency estimate. Extend Last: Determines the amount of most recent historical supports/resistances to extend to the latest bar."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"Support & Resistance Dynamic [LuxAlgo]\", \"LuxAlgo - Support & Resistance Dynamic\"\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nmult = input.float(8., 'Multiplicative Factor', minval = 0, step = .5)\natrLen = input.int(50, 'ATR Length', minval = 0)\nextLast = input.int(4, 'Extend Last', minval = 0)\n//Style\nsupCss = input.color( #089981, 'Support\u2004\u2004\u2004\u2004', inline = 'sup', group = 'Style')\nsupAreaCss = input( color.new(#089981, 80), 'Areas', inline = 'sup', group = 'Style'\nresCss = input.color( #f23645, 'Resistance', inline = 'res', group = 'Style')\nresAreaCss = input( color.new(#f23645, 80), 'Areas', inline = 'res', group = 'Style'\nextLvls = input(true, 'Extend Levels', group = 'Style')\nextArea = input(true, 'Extend Areas', group = 'Style')\n//-----------------------------------------------------------------------------}\n//UDT\n//-----------------------------------------------------------------------------{\ntype sr\n    float y\n    float area\n    int x\n    bool support\n//-----------------------------------------------------------------------------}\n//Calculation\n//-----------------------------------------------------------------------------{\nvar records = array.new<sr>(0)  \nvar float avg = close\nvar hold_atr = 0.\nvar os = 0\nn = bar_index\nbreakout_atr = nz(ta.atr(atrLen)) * mult\navg := math.abs(close - avg) > breakout_atr ? close : avg\nhold_atr := avg == close ? breakout_atr : hold_atr\nos := avg > avg[1] ? 1 : avg < avg[1] ? 0 : os\nupper_res = os == 0 ? avg + hold_atr / mult : na\nlower_res = os == 0 ? avg + hold_atr / mult / 2 : na\nupper_sup = os == 1 ? avg - hold_atr / mult / 2: na\nlower_sup = os == 1 ? avg - hold_atr / mult : na\nif close == avg\n    if os == 1\n        records.unshift(sr.new(lower_sup, upper_sup, time, true))\n    else\n        records.unshift(sr.new(upper_res, lower_res, time, false))\n//-----------------------------------------------------------------------------}\n//Extensions\n//-----------------------------------------------------------------------------{\nvar lines = array.new<line>(0)\nvar boxes = array.new<box>(0)\nif barstate.isfirst and extLast > 0\n    for i = 0 to extLast-1\n        if extLvls\n            lines.push(line.new(na,na,na,na, xloc.bar_time, style = line.style_dashed\n        if extArea\n            boxes.push(box.new(na,na,na,na,na, xloc = xloc.bar_time))\nif barstate.islast and extLast > 0\n    for i = 0 to extLast-1\n        get_sr = records.get(i)\n                if extLvls\n            get_line = lines.get(i)\n            get_line.set_xy1(get_sr.x, get_sr.y)\n            get_line.set_xy2(time, get_sr.y)\n            get_line.set_color(get_sr.support ? supCss : resCss)\n                if extArea\n            get_box = boxes.get(i)\n            get_box.set_lefttop(get_sr.x, get_sr.area)\n            get_box.set_rightbottom(time, get_sr.y)\n            get_box.set_bgcolor(get_sr.support ? supAreaCss : resAreaCss)\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\n//Plot supports\nplot_upper_sup = plot(upper_sup, 'Upper Support', na\n  , style = plot.style_linebr)\nplot_lower_sup = plot(lower_sup, 'Lower Support', close == avg ? na : supCss\n  , style = plot.style_linebr)\n//Plot resistances\nplot_upper_res = plot(upper_res, 'Upper Resistance', close == avg ? na : resCss\n  , style = plot.style_linebr)\nplot_lower_res = plot(lower_res, 'Lower Resistance', na\n  , style = plot.style_linebr)\n//Fills\nfill(plot_upper_sup, plot_lower_sup, supAreaCss, 'Support Area')\nfill(plot_upper_res, plot_lower_res, resAreaCss, 'Resistance Area')\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Improvements!  Alerts Added"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 Zeiierman\n//@version=5\nindicator(title='Machine Learning Momentum Index (MLMI) [Zeiierman]', shorttitle='Machine Learning Momentum Index (MLMI)'\n// ~~ ToolTips {\nt1 =\"This parameter controls the number of neighbors to consider while making a prediction using the k-N\nt2 =\"The parameter controls the length of the trend used in computing the momentum. This length refers t\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Input Parameters {\nnumNeighbors   = input(200, title='Prediction Data (k)', tooltip=t1)\nmomentumWindow = input.int(20, step=2, minval=10, maxval=200, title='Trend Length'\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Moving Averages & RSI {\nMA_quick    = ta.wma(close, 5)\nMA_slow     = ta.wma(close, 20)\nrsi_quick   = ta.wma(ta.rsi(close, 5),momentumWindow)\nrsi_slow    = ta.wma(ta.rsi(close, 20),momentumWindow)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Crossover Conditions {\npos  = ta.crossover(MA_quick, MA_slow)\nneg  = ta.crossunder(MA_quick, MA_slow)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Type Definition {\ntype Data\n    array<float> parameter1\n    array<float> parameter2\n    array<float> priceArray\n    array<float> resultArray\n// Create a Data object\nvar data = Data.new(array.new_float(1, 0), array.new_float(1, 0), array.new_float(\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Method that saves the last trade and temporarily holds the current one. {\nmethod storePreviousTrade(Data d, p1, p2) =>\n    d.parameter1.push(d.parameter1.get(d.parameter1.size() - 1))\n    d.parameter2.push(d.parameter2.get(d.parameter2.size() - 1))\n    d.priceArray.push(d.priceArray.get(d.priceArray.size() - 1))\n    d.resultArray.push(close >= d.priceArray.get(d.priceArray.size() - 1) ? 1 : -1\n    d.parameter1.set(d.parameter1.size() - 1, p1)\n    d.parameter2.set(d.parameter2.size() - 1, p2)\n    d.priceArray.set(d.priceArray.size() - 1, close)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Method to Make Prediction {\nmethod knnPredict(Data d, p1, p2, k) =>\n    // Create a Distance Array\n    distances = array.new_float(0)\n    n = d.parameter1.size() - 1\n    for i = 0 to n\n        distance = math.sqrt(math.pow(p1 - d.parameter1.get(i), 2) + math.pow(p2 -\n        distances.push(distance)\n    // Get Neighbors\n    sortedDistances = distances.copy()\n    sortedDistances.sort()\n    selectedDistances = sortedDistances.slice( 0, math.min(k, sortedDistances.size\n    maxDist  = selectedDistances.max()\n    neighbors = array.new_float(0)\n    for i = 0 to distances.size() - 1\n        if distances.get(i) <= maxDist\n            neighbors.push(d.resultArray.get(i))\n    // Return Prediction\n    prediction = neighbors.sum()\n    prediction\nif pos or neg\n    data.storePreviousTrade(rsi_slow, rsi_quick)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Plots {\nprediction    = data.knnPredict(rsi_slow, rsi_quick, numNeighbors)\nprediction_   = plot(prediction, color= color.new(#426eff, 0), title=\"MLMI Prediction\"\nprediction_ma = ta.wma(prediction, 20)\nplot(prediction_ma, color= color.new(#31ffc8, 0), title=\"WMA of MLMI Prediction\")\nhline(0, title=\"Mid Level\")\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Gradient Fill {\nupper         = ta.highest(prediction,2000)\nlower         = ta.lowest(prediction,2000) \nupper_        = upper - ta.ema(ta.stdev(prediction,20),20)\nlower_        = lower + ta.ema(ta.stdev(prediction,20),20)\nchannel_upper = plot(upper, color = na, editable = false, display = display.none)\nchannel_lower = plot(lower, color = na, editable = false, display = display.none)\nchannel_mid   = plot(0, color = na, editable = false, display = display.none)\n// ~~ Channel Gradient Fill {\nfill(channel_mid, channel_upper, top_value =  upper, bottom_value = 0, bottom_color\nfill(channel_mid, channel_lower, top_value =  0, bottom_value = lower, bottom_color\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Overbought/Oversold Gradient Fill {\nfill(prediction_, channel_mid, upper, upper_, top_color =  color.new(color.lime, \nfill(prediction_, channel_mid, lower_,  lower,  top_color =  color.new(color.red,\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Alerts {\nP_OB_Over   = ta.crossover(prediction,upper_)\nP_OB_Under  = ta.crossunder(prediction,upper_)\nP_OS_Over   = ta.crossover(prediction,lower_)\nP_OS_Under  = ta.crossunder(prediction,lower_)\nP_Mid_Over  = ta.crossover(prediction,0)\nP_Mid_Under = ta.crossunder(prediction,0)\nP_MA_Over   = ta.crossover(prediction,prediction_ma)\nP_MA_Under  = ta.crossunder(prediction,prediction_ma)\nalertcondition(P_OB_Over,  title = \"MLMI Crossover OB\",  message = \"MLMI Crossover OB\"\nalertcondition(P_OB_Under, title = \"MLMI Crossunder OB\", message = \"MLMI Crossunder OB\"\nalertcondition(P_OS_Over,  title = \"MLMI Crossover OS\",  message = \"MLMI Crossover OS\"\nalertcondition(P_OS_Under, title = \"MLMI Crossunder OS\", message = \"MLMI Crossunder OS\"\nalertcondition(P_Mid_Over, title = \"MLMI Crossover 50\",  message = \"MLMI Crossover 50\"\nalertcondition(P_Mid_Under,title = \"MLMI Crossunder 50\", message = \"MLMI Crossunder 50\"\nalertcondition(P_MA_Over,  title = \"MLMI Crossover Ma\",  message = \"MLMI Crossover Ma\"\nalertcondition(P_MA_Under, title = \"MLMI Crossunder Ma\", message = \"MLMI Crossunder Ma\"\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}]}
{"messages": [{"role": "user", "content": "The QQE (Quantitative Qualitative Estimation) Weighted Oscillator improves on its original version by weighting the RSI based on the indications given by the trailing stop, requiring more effort in order for a cross with the trailing stop to occur. \ud83d\udd36 USAGE The QQE Weighted Oscillator is comprised of a smoothed RSI oscillator and a trailing stop derived from this same RSI. The oscillator can be used to indicate whether the market is overbought/oversold as well as an early indication of trend reversals thanks to the leading nature of the RSI. Using higher Factor values will return a longer-term trailing stop. Like with a regular RSI divergence can be indicative of a reversal. Further weighting will control how much \"effort\" is required for the trailing stop to cross the RSI. For example. For example, an RSI above the trailing stop will require a higher degree of negative price variations in order for a potential cross to occur when using higher weights. This can cause higher weightings to return more cyclical and smoother results. \ud83d\udd36 SETTINGS Length: Length of the RSI oscillator. Factor: Multiplicative factor used for the trailing stop calculation. Smooth: Degree of smoothness of the RSI oscillator. Weight: Degree of weighting used for the RSI calculation."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"QQE Weighted Oscillator [LuxAlgo]\", \"LuxAlgo - QQE Weighted Oscillator\")\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input.int(14, minval = 1)\nfactor = input.float(4.236, minval = 0)\nsmooth = input.int(5, minval = 1)\nweight = input.float(2)\nsrc    = input(close)\n//Style\nrsiCss = input( #3179f5, 'RSI', group = 'Style')\ntsBearCss = input( color.red, 'Trailing Stop', group = 'Style', inline = 'inline1'\ntsBullCss = input( color.teal, '', group = 'Style', inline = 'inline1')\n//-----------------------------------------------------------------------------}\n//Weighted QQE\n//-----------------------------------------------------------------------------{\nvar ts = 0.\nvar rsi = 0.\ndelta = src - src[1]\nw = nz(delta * (rsi - ts) > 0 ? weight : 1, 1)\n//Rsi\nnum = ta.rma(delta * w, length)\nden = ta.rma(math.abs(delta * w), length)\nrsi := 50 * ta.ema(num / den, smooth) + 50\n//Trailing stop\ndiff = ta.rma(math.abs(rsi - rsi[1]), length)\ncrossover = ta.crossover(rsi, ts)\ncrossunder = ta.crossunder(rsi, ts)\nts := nz(crossover ? rsi - diff * factor\n  : crossunder ? rsi + diff * factor\n  : rsi > ts ? math.max(rsi - diff * factor, ts)\n  : math.min(rsi + diff * factor, ts), rsi)\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\ncss = rsi > ts ? tsBullCss : tsBearCss\nplot_rsi = plot(rsi, 'RSI', rsiCss)\nplot_ts  = plot(ts, 'Traling Stop', css)\nfill(plot_rsi, plot_ts, rsi, ts, color.new(rsiCss, 50), color.new(css, 50))\nhline(70)\nhline(30)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "\u2588 Overview The Volume SuperTrend AI is an advanced technical indicator used to predict trends in price movements by utilizing a combination of traditional SuperTrend calculation and AI techniques, particularly the k-nearest neighbors (KNN) algorithm.  The Volume SuperTrend AI is designed to provide traders with insights into potential market trends, using both volume-weighted moving averages (VWMA) and the k-nearest neighbors (KNN) algorithm. By combining these approaches, the indicator aims to offer more precise predictions of price trends, offering bullish and bearish signals. \u2588 How It Works Volume Analysis: By utilizing volume-weighted moving averages (VWMA), the Volume SuperTrend AI emphasizes the importance of trading volume in the trend direction, allowing it to respond more accurately to market dynamics. Artificial Intelligence Integration - k-Nearest Neighbors (k-NN) Algorithm: The k-NN algorithm is employed to intelligently examine historical data points, measuring distances between current parameters and previous data. The nearest neighbors are utilized to create predictive modeling, thus adapting to intricate market patterns. \u2588 How to use Trend Identification The Volume SuperTrend AI indicator considers not only price movement but also trading volume, introducing an extra dimension to trend analysis. By integrating volume data, the indicator offers a more nuanced and robust understanding of market trends. When trends are supported by high trading volumes, they tend to be more stable and reliable. In practice, a green line displayed beneath the price typically suggests an upward trend, reflecting a bullish market sentiment. Conversely, a red line positioned above the price signals a downward trend, indicative of bearish conditions. Trend Continuation signals The AI algorithm is the fundamental component in the coloring of the Volume SuperTrend. This integration serves as a means of predicting the trend while preserving the inherent characteristics of the SuperTrend. By maintaining these essential features, the AI-enhanced Volume SuperTrend allows traders to more accurately identify and capitalize on trend continuation signals.  TrailingStop The Volume SuperTrend AI indicator serves as a dynamic trailing stop loss, adjusting with both price movement and trading volume. This approach protects profits while allowing the trade room to grow, taking into account volume for a more nuanced response to market changes. \u2588 Settings AI Settings: Neighbors (k): This setting controls the number of nearest neighbors to consider in the k-Nearest Neighbors (k-NN) algorithm. By adjusting this parameter, you can directly influence the sensitivity of the model to local fluctuations in the data. A lower value of k may lead to predictions that closely follow short-term trends but may be prone to noise. A higher value of k can provide more stable predictions, considering the broader context of market trends, but might lag in responsiveness. Data (n): This setting refers to the number of data points to consider in the model. It allows the user to define the size of the dataset that will be analyzed. A larger value of n may provide more comprehensive insights by considering a wider historical context but can increase computational complexity. A smaller value of n focuses on more recent data, possibly providing quicker insights but might overlook longer-term trends. AI Trend Settings: Price Trend & Prediction Trend: These settings allow you to adjust the lengths of the weighted moving averages that are used to calculate both the price trend and the prediction trend. Shorter lengths make the trends more responsive to recent price changes, capturing quick market movements. Longer lengths smooth out the trends, filtering out noise, and highlighting more persistent market directions. AI Trend Signals: This toggle option enables or disables the trend signals generated by the AI. Activating this function may assist traders in identifying key trend shifts and opportunities for entry or exit. Disabling it may be preferred when focusing on other aspects of the analysis. Super Trend Settings: Length: This setting determines the length of the SuperTrend, affecting how it reacts to price changes. A shorter length will produce a more sensitive SuperTrend, reacting quickly to price fluctuations. A longer length will create a smoother SuperTrend, reducing false alarms but potentially lagging behind real market changes. Factor: This parameter is the multiplier for the Average True Range (ATR) in SuperTrend calculation. By adjusting the factor, you can control the distance of the SuperTrend from the price. A higher factor makes the SuperTrend further from the price, giving more room for price movement but possibly missing shorter-term signals. A lower factor brings the SuperTrend closer to the price, making it more reactive but possibly more prone to false signals. Moving Average Source: This setting lets you choose the type of moving average used for the SuperTrend calculation, such as Simple Moving Average (SMA), Exponential Moving Average (EMA), etc. Different types of moving averages provide various characteristics to the SuperTrend, enabling customization to align with individual trading strategies and market conditions. ----------------- Disclaimer The information contained in my Scripts/Indicators/Ideas/Algos/Systems does not constitute financial advice or a solicitation to buy or sell any securities of any type. I will not accept liability for any loss or damage, including without limitation any loss of profit, which may arise directly or indirectly from the use of or reliance on such information. All investments involve risk, and the past performance of a security, industry, sector, market, financial product, trading strategy, backtest, or individual's trading does not guarantee future results or returns. Investors are fully responsible for any investment decisions they make. Such decisions should be based solely on an evaluation of their financial circumstances, investment objectives, risk tolerance, and liquidity needs. My Scripts/Indicators/Ideas/Algos/Systems are only for educational purposes!"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 Zeiierman\n//@version=5 \nindicator(\"Volume SuperTrend AI (Expo)\", overlay=true) \n// ~~ ToolTips {\nt1=\"Number of nearest neighbors in KNN algorithm (k): Increase to consider more neighbors, providing a \nt2=\"Length of weighted moving average for price (KNN_PriceLen): Higher values create a smoother price l\nt3=\"Length of the SuperTrend (len): Increase for a smoother trend line, ideal for identifying long-term\nt4=\"Type of moving average for SuperTrend calculation (maSrc): Choose based on desired characteristics.\nt5=\"Color for bullish trend (upCol): Select to visually identify upward trends. \\n\\nColor for bearish t\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Input settings for K and N values\nk  = input.int(3, title = \"Neighbors\", minval=1, maxval=100,inline=\"AI\", group=\"AI Settings\"\nn_ = input.int(10, title =\"Data\", minval=1, maxval=100,inline=\"AI\", group=\"AI Settings\"\nn  = math.max(k,n_)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Input settings for prediction values\nKNN_PriceLen = input.int(20, title=\"Price Trend\", minval=2, maxval=500, step=10,inline\nKNN_STLen    = input.int(100, title=\"Prediction Trend\", minval=2, maxval=500, step\naisignals    = input.bool(true,title=\"AI Trend Signals\",inline=\"signal\", group=\"AI Trend\"\nBullish_col  = input.color( color.lime,\"\",inline=\"signal\", group=\"AI Trend\")\nBearish_col  = input.color( color.red,\"\",inline=\"signal\", group=\"AI Trend\")\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Define SuperTrend parameters\nlen    = input.int(10, \"Length\", minval=1,inline=\"SuperTrend\", group=\"Super Trend Settings\"\nfactor = input.float(3.0,step=.1,inline=\"SuperTrend\", group=\"Super Trend Settings\"\nmaSrc  = input.string(\"WMA\",\"Moving Average Source\",[\"SMA\",\"EMA\",\"WMA\",\"RMA\",\"VWMA\"\nupCol  = input.color( color.lime,\"Bullish Color\",inline=\"col\", group=\"Super Trend Coloring\"\ndnCol  = input.color( color.red,\"Bearish Color\",inline=\"col\", group=\"Super Trend Coloring\"\nneCol  = input.color( color.blue,\"Neutral Color\",inline=\"col\", group=\"Super Trend Coloring\"\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Calculate the SuperTrend based on the user's choice\nvwma = switch maSrc\n    \"SMA\"  => ta.sma(close*volume, len) / ta.sma(volume, len)\n    \"EMA\"  => ta.ema(close*volume, len) / ta.ema(volume, len)\n    \"WMA\"  => ta.wma(close*volume, len) / ta.wma(volume, len)\n    \"RMA\"  => ta.rma(close*volume, len) / ta.rma(volume, len)\n    \"VWMA\" => ta.vwma(close*volume, len) / ta.vwma(volume, len)\natr = ta.atr(len)\nupperBand = vwma + factor * atr\nlowerBand = vwma - factor * atr\nprevLowerBand = nz(lowerBand[1])\nprevUpperBand = nz(upperBand[1])\nlowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand\nupperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand\nint direction = na\nfloat superTrend = na\nprevSuperTrend = superTrend[1]\nif na(atr[1])\n    direction := 1\nelse if prevSuperTrend == prevUpperBand\n    direction := close > upperBand ? -1 : 1\nelse\n    direction := close < lowerBand ? 1 : -1\nsuperTrend := direction == -1 ? lowerBand : upperBand\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Collect data points and their corresponding labels\nprice  = ta.wma(close,KNN_PriceLen)\nsT     = ta.wma(superTrend,KNN_STLen)\ndata   = array.new_float(n) \nlabels = array.new_int(n) \nfor i = 0 to n - 1\n    data.set(i, superTrend[i]) \n    label_i = price[i] > sT[i] ? 1 : 0 \n    labels.set(i, label_i) \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Define a function to compute distance between two data points\ndistance(x1, x2) => \n    math.abs(x1 - x2)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Define the weighted k-nearest neighbors (KNN) function\nknn_weighted(data, labels, k, x) =>\n    n1 = data.size() \n    distances = array.new_float(n1) \n    indices   = array.new_int(n1) \n    // Compute distances from the current point to all other points\n    for i = 0 to n1 - 1 \n        x_i = data.get(i)\n        dist = distance(x, x_i) \n        distances.set(i, dist)\n        indices.set(i, i)\n    // Sort distances and corresponding indices in ascending order\n    // Bubble sort method\n    for i = 0 to n1 - 2\n        for j = 0 to n1 - i - 2\n            if distances.get(j) > distances.get(j + 1)\n                tempDist = distances.get(j) \n                distances.set(j, distances.get(j + 1))\n                distances.set(j + 1, tempDist)\n                tempIndex = indices.get(j)\n                indices.set(j, indices.get(j + 1))\n                indices.set(j + 1, tempIndex)\n    // Compute weighted sum of labels of the k nearest neighbors\n    weighted_sum = 0.\n    total_weight = 0.\n    for i = 0 to k - 1\n        index = indices.get(i)\n        label_i = labels.get(index)\n        weight_i = 1 / (distances.get(i) + 1e-6) \n        weighted_sum += weight_i * label_i\n        total_weight += weight_i\n    weighted_sum / total_weight \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Classify the current data point\ncurrent_superTrend = superTrend\nlabel_             = knn_weighted(data, labels, k, current_superTrend)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Plot\ncol = label_ == 1?upCol:label_ == 0?dnCol:neCol\nplot(current_superTrend, color=col, title=\"Volume Super Trend AI\")\nupTrend   = plot(superTrend==lowerBand?current_superTrend:na, title=\"Up Volume Super Trend AI\"\nMiddle    = plot((open + close) / 2, display=display.none, editable=false)\ndownTrend = plot(superTrend==upperBand?current_superTrend:na, title=\"Down Volume Super Trend AI\"\nfill_col  = color.new(col,90)\nfill(Middle, upTrend, fill_col, fillgaps=false,title=\"Up Volume Super Trend AI\")\nfill(Middle, downTrend, fill_col, fillgaps=false, title=\"Down Volume Super Trend AI\"\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Ai Super Trend Signals\nStart_TrendUp = col==upCol and (col[1]!=upCol or col[1]==neCol) and aisignals\nStart_TrendDn = col==dnCol and (col[1]!=dnCol or col[1]==neCol) and aisignals\nTrendUp       = direction == -1 and direction[1] == 1  and label_ == 1 and aisignals\nTrendDn       = direction == 1  and direction[1] ==-1  and label_ == 0 and aisignals\nplotshape(Start_TrendUp?superTrend:na, location=location.absolute, style= shape.circle\nplotshape(Start_TrendDn?superTrend:na, location=location.absolute, style= shape.circle\nplotshape(TrendUp?superTrend:na, location=location.absolute, style= shape.triangleup\nplotshape(TrendDn?superTrend:na, location=location.absolute, style= shape.triangledown\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Alerts {\nalertcondition(Start_TrendUp, title =\"1 Bullish Trend Start\", message = \"AI Bullish Trend Start\"\nalertcondition(Start_TrendDn, title  =\"2 Bearish Trend Start\", message = \"AI Bearish Trend Start\"\nalertcondition((Start_TrendUp or Start_TrendDn), title =\"3 Any Trend Start\", message\nalertcondition(TrendUp, title = \"4 Bullish Trend Signal\", message = \"AI Bullish Trend Signal\"\nalertcondition(TrendDn, title = \"5 Bearish Trend Signal\", message = \"AI Bearish Trend Signal\"\nalertcondition((TrendUp or TrendDn),title = \"6 Any Trend Signal\", message =\"Any AI Trend Signal\"\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Improvements!  Alerts Added                             Release Notes:                         Tooltips Added"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 Zeiierman {\n//@version=5\n/// K-Nearest Neighbors (KNN) Trend Prediction Algorithm\n// This code consists of two main parts:\n// 1) KNN Moving Average (KNN MA): This part takes the k closest values from a window of the x most \n//    to calculate a weighted average, emphasizing similar recent values. It gives a smoother repres\n//    the price trend and helps to filter out noise.\n// 2) KNN Classifier: This part predicts the future price direction (Positive, Negative, or Neutral)\n//    the price movement based on the properties of its k nearest neighbors. It considers recent pri\n//    and calculates Euclidean distances to classify the trend direction.\n// Together, these elements create a powerful tool for traders to predict price trends.\nindicator('AI Trend Navigator [K-Neighbor]', overlay=true)\n//~~}\n// ~~ Tooltips {\nt1 =\"PriceValue and TargetValue determine the parameters for price calculation and trend targeting. Pric\nt2 =\"numberOfClosestValues sets the number of closest values that are considered when calculating the KN\nt3 =\"smoothingPeriod sets the period for the moving average applied to the KNN classifier. Adjusting the\nt4 =\"This option controls the background color for the trend prediction. Enabling it will change the bac\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Inputs {\nPriceValue   = input.string(\"hl2\", options = [\"hl2\",\"VWAP\"], group=\"\", inline=\"Target\"\nTargetValue  = input.string(\"Volatility\", options = [\"Price Action\",\"VWAP\", \"Volatility\"\n// Input parameters for the KNN Moving Average\nnumberOfClosestValues = input.int(15, \"Number of Closest Values\", 2, 200, tooltip=\nsmoothingPeriod       = input.int(50, \"Smoothing Period\", 2, 500, tooltip=t3) // User input to define the smoothing period for m\nwindowSize            = math.max(numberOfClosestValues, 30) // Ensures that windowSize is at least as large as\n// knn Color\nUpknn_col   = input.color( color.lime, title=\"\", group=\"KNN Color\", inline=\"knn col\"\nDnknn_col   = input.color( color.red, title=\"\", group=\"KNN Color\", inline=\"knn col\"\nNeuknn_col  = input.color( color.orange, title=\"\", group=\"KNN Color\", inline=\"knn col\"\n// MA knn Color\nMaknn_col   = input.color( color.teal, title=\"\", group=\"MA KNN Color\", inline=\"MA knn col\"\n// BG Color\nbgcolor = input.bool(true, title=\"Trend Prediction Color\", group=\"BG Color\", inline\nUp_col  = input.color( color.lime, title=\"\", group=\"BG Color\", inline=\"bg\")\nDn_col  = input.color( color.red, title=\"\", group=\"BG Color\", inline=\"bg\")\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ kNN Classifier {\n// Function to calculate the mean of k closest values to the target within a window\n// Choose the value input based on user selection\nvalue_in = switch PriceValue\n    \"hl2\"  => hl2\n    \"VWAP\" => ta.vwap(close)\nmeanOfKClosest(target) => // Declares a function named meanOfKClosest, which accepts a target value as an argument.\n    closestDistances = array.new_float(numberOfClosestValues, 1e10) // Initializes an array to store distances.\n    closestValues = array.new_float(numberOfClosestValues, 0.0) // Initializes an array to store closest values.\n    for i = 1 to windowSize // Loop through the window of size windowSize.\n        value = value_in[i] // Gets the value for the ith bar.\n        distance = math.abs(target - value) // Calculates the absolute difference between the \n        maxDistIndex = 0 // Initializes an index to store the maximum distance.\n        maxDistValue = array.get(closestDistances, 0) // Retrieves the maximum distance value from the c\n        for j = 1 to numberOfClosestValues - 1 // Loop to find the maximum distance among the clo\n            if array.get(closestDistances, j) > maxDistValue\n                maxDistIndex := j\n                maxDistValue := array.get(closestDistances, j)\n        if distance < maxDistValue // Replaces the maximum distance if a smaller one \n            array.set(closestDistances, maxDistIndex, distance)\n            array.set(closestValues, maxDistIndex, value)\n    closestValues.sum() / numberOfClosestValues // Returns the mean of the k closest values.\n// Choose the target input based on user selection\ntarget_in = switch TargetValue\n    \"Price Action\"  => ta.rma(close, 2) \n    \"VWAP\"          => ta.vwap(close)\n    \"Volatility\"    => ta.atr(14)\n// Initializes the KNN Moving Average.\nknnMA = meanOfKClosest(target_in)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ kNN Prediction {\n// Function to calculate KNN Classifier\nprice = math.avg(knnMA, close) // Calculates the average between knnMA and close price.\nc     = ta.rma(knnMA[1], smoothingPeriod) // Calculates the moving average of knnMA's previo\no     = ta.rma(knnMA, smoothingPeriod) // Calculates the moving average of knnMA with smo\n// Defines KNN function to perform classification\nknn(price) => // Declares a function named knn, which accepts price and K as arguments.\n    Pos_count = 0 // Initializes a variable to count positive candles.\n    Neg_count = 0 // Initializes a variable to count negative candles.\n    min_distance = 10e10 // Initializes the minimum distance.\n    nearest_index = 0 // Initializes the index of the nearest neighbor.\n    for j = 1 to 10 // Loop to search through the last 10 bars to find the closest neighbor.\n        distance = math.sqrt(math.pow(price[j] - price, 2)) // Calculates the Euclidean distance.\n        if distance < min_distance // If a smaller distance is found and it's not the\n            min_distance := distance\n            nearest_index := j\n            Neg = c[nearest_index] > o[nearest_index] // Checks if the nearest neighbor is a positive ta\n            Pos = c[nearest_index] < o[nearest_index] // Checks if the nearest neighbor is a negative ta\n            if Pos // Increments the positive count if the condition is met.\n                Pos_count += 1\n            if Neg // Increments the negative count if the condition is met.\n                Neg_count += 1\n    output = Pos_count>Neg_count?1:-1 // Returns the prediction based on the count.\n// Calls KNN function and smooths the prediction\nknn_prediction_raw = knn(price) // Calls the knn function and stores the result in\nknn_prediction     = ta.wma(knn_prediction_raw, 3) // Smooths the prediction using a 3-period moving \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Plots {\n// Plots for display on the chart\nknnMA_          = ta.wma(knnMA,5)\nknnMA_col       = knnMA_>knnMA_[1]?Upknn_col:knnMA_<knnMA_[1]?Dnknn_col:Neuknn_col\nClassifier_Line = plot(knnMA_,\"Knn Classifier Line\", knnMA_col)\nMAknn_          = ta.rma(knnMA, smoothingPeriod)\nplot(MAknn_,\"Average Knn Classifier Line\" ,Maknn_col) // Plots the moving average of knnMA with smoothin\ngreen = knn_prediction < 0.5\nred   = knn_prediction > -0.5 \nbgcolor( green and bgcolor? color.new(Dn_col,80) : \n red and bgcolor ? color.new(Up_col,80) : na) // Sets the background color based on the predicti\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~ Alerts {\nknnMA_cross_Over_Ma      = ta.crossover(knnMA_,MAknn_)\nknnMA_cross_Under_Ma     = ta.crossunder(knnMA_,MAknn_)\nknnMA_cross_Over_Close   = ta.crossover(knnMA_,close)\nknnMA_cross_Under_Close  = ta.crossunder(knnMA_,close)\nknnMA_Switch_Up          = knnMA_[1]<knnMA_ and knnMA_[1]<=knnMA_[2]\nknnMA_Switch_Dn          = knnMA_[1]>knnMA_ and knnMA_[1]>=knnMA_[2]\nknnMA_Neutral            = knnMA_col==Neuknn_col and knnMA_col[1]!=Neuknn_col\ngreenBG                  = green and not green[1]\nredBG                    = red and not red[1]\nalertcondition(knnMA_cross_Over_Ma,  title = \"Knn Crossover Average Knn\",  message\nalertcondition(knnMA_cross_Under_Ma, title = \"Knn Crossunder Average Knn\", message\nalertcondition(knnMA_cross_Over_Close,  title = \"Knn Crossover Close\",  message = \nalertcondition(knnMA_cross_Under_Close, title = \"Knn Crossunder Close\", message = \nalertcondition(knnMA_Switch_Up,  title = \"Knn Switch Up\",  message = \"Knn Switch Up\"\nalertcondition(knnMA_Switch_Dn, title = \"Knn Switch Dn\", message = \"Knn Switch Dn\"\nalertcondition(knnMA_Neutral, title = \"Knn is Neutral\", message = \"Knn is Neutral\"\nalertcondition(greenBG, title = \"Positive Prediction\", message = \"Positive Prediction\"\nalertcondition(redBG, title = \"Negative Prediction\", message = \"Negative Prediction\"\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}]}
{"messages": [{"role": "user", "content": "This indicator is made to look for Inverse Fair Value Gaps (IFVGs) and show rejections from relevant areas. Fair Value Gaps (FVGs) are created when there is an energetic move that leaves a gap between the preceding and following candle's wicks. When that area is violated, we may consider that area as an Inverse FVG, treating it along the lines of a \"support turned resistance\" type setup with proper context. Once a Fair Value Gap (FVG) is found with sufficient user-defined displacement, it is saved until price fully closes through that area, at which point it becomes an IFVG, which is also saved until price once again closes through that area. Users can select a specific time period from which to look for and save FVGs, such as during the New York trading session in the following example. Lastly, users can enable rejections that look for swing lows in bullish FVGs/IFVGs and swing highs in bearish FVGs/IFVGs. The following picture shows an instance of rejections from both regular and inverse FVGs, meaning the pivots were formed in a mutually shared area between a FVG and IFVG."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 tradeforopp\n//@version=5\nindicator(\"Inverse FVG with Rejections [TFO]\", \"Inverse FVG [TFO]\", true)\n// -------------------------------------------------- Inputs ---------------------------------------\nvar g_SET = \"Settings\"\nshow_rfvg = input.bool(true, \"Show Regular FVG\", inline = \"RFVG\", group = g_SET)\nshow_ifvg = input.bool(true, \"Show Inverse FVG\", inline = \"IFVG\", group = g_SET)\nrfvg_color = input.color( color.new(color.blue, 50), \"\", inline = \"RFVG\", group =\nifvg_color = input.color( color.new(color.red, 50), \"\", inline = \"IFVG\", group = \ndisp_x = input.int(3, \"Displacement\", 1, 10, tooltip = \"Larger Displacement will require larger FVGs\"\ndisp_limit = input.int(10, \"Display Limit\", 1, 50, tooltip = \"The maximum amount of FVGs and IFVGs to display\"\nsession = input.session(\"0000-0000\", \"Session\", tooltip = \"FVGs will only be saved if they are created withi\nvar g_RJ = \"Rejections\"\nps = input.int(1, \"Rejection Strength\", tooltip = \"Larger values will require larger fractals/swing \nshow_rrj = input.bool(false, \"Regular FVG\", inline = \"RRJ\", tooltip = \"Show rejections made within regular FVGs\"\nshow_irj = input.bool(false, \"Inverse FVG\", inline = \"IRJ\", tooltip = \"Show rejections made within inverse FVGs\"\nshow_brj = input.bool(true, \"Regular + Inverse FVG\", inline = \"BRJ\", tooltip = \"Show rejections made within both regular and inve\nrrj_color = input.color( color.blue, \"\", inline = \"RRJ\", group = g_RJ)\nirj_color = input.color( color.red, \"\", inline = \"IRJ\", group = g_RJ)\nbrj_color = input.color( color.black, \"\", inline = \"BRJ\", group = g_RJ)\n// -------------------------------------------------- Inputs ---------------------------------------\n// -------------------------------------------------- Logic ----------------------------------------\nt = not na(time(\"\", session, \"America/New_York\"))\nbull = close[2] > open[2]\nfvg = bull ? (high[3] < low[1] and low[2] <= high[3] and high[2] >= low[1]) : (low\nfvg_len = bull ? low[1] - high[3] : low[3] - high[1]\natr_check = fvg_len > ta.atr(50) * disp_x / 10\nvar reg_fvg = array.new_box()\nvar reg_fvg_ce = array.new_line()\nvar reg_fvg_side = array.new_string()\nvar inv_fvg = array.new_box()\nvar inv_fvg_ce = array.new_line()\nvar inv_fvg_side = array.new_string()\nsolid_color(color x) =>\n    color.new(x, 0)\nif t[2] and fvg and atr_check\n    top = bull ? low[1] : low[3]\n    bottom = bull ? high[3] : high[1]\n    reg_fvg.unshift(box.new(time[2], top, time, bottom, xloc = xloc.bar_time, extend\n    reg_fvg_ce.unshift(line.new(time[2], math.avg(top, bottom), time, math.avg(top\n    reg_fvg_side.unshift(bull ? 'bull' : 'bear')\nif reg_fvg.size() > 0\n    for i = reg_fvg.size() - 1 to 0\n        remove_bull = reg_fvg_side.get(i) == 'bull' and close[1] < reg_fvg.get(i).\n        remove_bear = reg_fvg_side.get(i) == 'bear' and close[1] > reg_fvg.get(i).\n        if remove_bull or remove_bear\n            inv_fvg.unshift(box.copy(reg_fvg.get(i)))\n            inv_fvg_ce.unshift(line.copy(reg_fvg_ce.get(i)))\n            inv_fvg.get(0).set_bgcolor(show_ifvg ? ifvg_color : na)\n            inv_fvg_ce.get(0).set_color(show_ifvg ? solid_color(ifvg_color) : na)\n            box.delete(reg_fvg.get(i))\n            line.delete(reg_fvg_ce.get(i))\n            reg_fvg.remove(i)\n            reg_fvg_ce.remove(i)\n            reg_fvg_side.remove(i)\n                        if remove_bear\n                inv_fvg_side.unshift('inv bear')\n            else if remove_bull\n                inv_fvg_side.unshift('inv bull')\n    if reg_fvg.size() > disp_limit\n        box.delete(reg_fvg.pop())\n        line.delete(reg_fvg_ce.pop())\n        reg_fvg_side.pop()\nif inv_fvg.size() > 0\n    for i = inv_fvg.size() - 1 to 0\n        remove_inv_bear = inv_fvg_side.get(i) == 'inv bear' and close[1] < inv_fvg\n        remove_inv_bull = inv_fvg_side.get(i) == 'inv bull' and close[1] > inv_fvg\n        if remove_inv_bear or remove_inv_bull\n            box.delete(inv_fvg.get(i))\n            line.delete(inv_fvg_ce.get(i))\n            inv_fvg.remove(i)\n            inv_fvg_ce.remove(i)\n            inv_fvg_side.remove(i)\n    if inv_fvg.size() > disp_limit\n        box.delete(inv_fvg.pop())\n        line.delete(inv_fvg_ce.pop())\n        inv_fvg_side.pop()\nreg_rj_bear = false\nreg_rj_bull = false\ninv_rj_bear = false\ninv_rj_bull = false\nif math.min(reg_fvg.size(), inv_fvg.size()) > 0\n    for i = 0 to reg_fvg.size() - 1\n        _rrj_bear = ta.pivothigh(high, ps, ps) and high[ps] >= reg_fvg.get(i).get_bottom\n        _rrj_bull = ta.pivotlow(low, ps, ps) and low[ps] >= reg_fvg.get(i).get_bottom\n        if _rrj_bear\n            reg_rj_bear := true\n        if _rrj_bull\n            reg_rj_bull := true\n    for i = 0 to inv_fvg.size() - 1\n        _irj_bear = ta.pivothigh(high, ps, ps) and high[ps] >= inv_fvg.get(i).get_bottom\n        _irj_bull = ta.pivotlow(low, ps, ps) and low[ps] >= inv_fvg.get(i).get_bottom\n        if _irj_bear\n            inv_rj_bear := true\n        if _irj_bull\n            inv_rj_bull := true\nplotshape(show_rrj and reg_rj_bear[1], color = rrj_color, size = size.small, location\nplotshape(show_rrj and reg_rj_bull[1], color = rrj_color, size = size.small, location\nplotshape(show_irj and inv_rj_bear[1], color = irj_color, size = size.small, location\nplotshape(show_irj and inv_rj_bull[1], color = irj_color, size = size.small, location\nplotshape(show_brj and reg_rj_bear[1] and inv_rj_bear[1], color = brj_color, size \nplotshape(show_brj and reg_rj_bull[1] and inv_rj_bull[1], color = brj_color, size \n// -------------------------------------------------- Logic ----------------------------------------"}]}
{"messages": [{"role": "user", "content": "The Liquidity Levels/Voids (VP) is a script designed to detect liquidity voids & levels by measuring traded volume at all price levels on the market between two swing points and highlighting the distribution of the liquidity voids & levels at specific price levels.  \ud83d\udd36 USAGE Liquidity is a fundamental market force that shapes the trajectory of assets. The creation of a liquidity level comes as a result of an initial imbalance of supply/demand, which forms what we know as a swing high or swing low. As more players take positions in the market, these are levels that market participants will use as a historical reference to place their stops. When the levels are then re-tested, a decision will be made. The binary outcome here can be a breakout of the level or a reversal back to the mean. Liquidity voids are sudden price changes that occur in the market when the price jumps from one level to another with little trading activity (low volume), creating an imbalance in price. The price tends to fill or retest the liquidity voids area, and traders understand at which price level institutional players have been active. Liquidity voids are a valuable concept in trading, as they provide insights about where many orders were injected, creating this inefficiency in the market. The price tends to restore the balance. \ud83d\udd36 SETTINGS The script takes into account user-defined parameters and detects the liquidity voids based on them, where detailed usage for each user-defined input parameter in indicator settings is provided with the related input's tooltip. \ud83d\udd39 Liquidity Levels / Voids Liquidity Levels/Voids: Color customization option for Unfilled Liquidity Levels/Voids. Detection Length: Lookback period used for the calculation of Swing Levels. Threshold %: Threshold used for the calculation of the Liquidity Levels & Voids. Sensitivity: Adjusts the number of levels between two swing points, as a result, the height of a level is determined, and then based on the above-given threshold the level is checked if it matches the liquidity level/void conditions.    Filled Liquidity Levels/Voids: Toggles the visibility of the Filled Liquidity Levels/Voids and color customization option for Filled Liquidity Levels/Voids.   \ud83d\udd39 Other Features Swing Highs/Lows: Toggles the visibility of the Swing Levels, where tooltips present statistical information, such as price, price change, and cumulative volume between the two swing levels detected based on the detection length specified above, Coloring options to customize swing low and swing high label colors, and Size option to adjust the size of the labels.   \ud83d\udd39 Display Options Mode: Controls the lookback length of detection and visualization.  # Bars: Lookback length customization, in case Mode is set to Present.  \ud83d\udd36 RELATED SCRIPTS Liquidity-Voids-FVG Buyside-Sellside-Liquidity Swing-Volume-Profiles"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n //@version=5\nindicator(\"Liquidity Levels/Voids (VP) [LuxAlgo]\", \"LuxAlgo - Liquidity Levels/Voids (VP)\"\n//------------------------------------------------------------------------------\n// Settings\n//-----------------------------------------------------------------------------{\nmdTT = 'The mode option controls the number of visual objects presented, where\\n\\n- Historical, takes into \nmode = input.string('Present', title = 'Mode', options =['Present', 'Historical'],\nback = input.int   (360, ' # Bars', minval = 100, maxval = 5000, step = 10, inline\ngrpLQ = 'Liquidity Levels / Voids'\nliqUC = input.color( color.new(#1848cc, 79), 'Liquidity Levels/Voids', inline = 'UFL'\nppLen = input.int(47, \"Detection Length\", minval = 1, group = grpLQ, tooltip = 'Lookback period used for the calculation of Swing\nliqT  = input.int(21, 'Threshold %', minval = 1, maxval = 51, group = grpLQ, tooltip\nvpLev = input.int(27, 'Sensitivity' , minval = 10, maxval = 100, step = 1, group =\nliqFD = input.bool(false, 'Filled Liquidity Levels/Voids', inline = 'FL', group = \nliqFC = input.color( color.new(#787b86, 79), '', inline = 'FL', group = grpLQ)\nothGR = 'Other Features'\nppLev = input.bool(false, 'Swing Highs/Lows', inline = 'ppLS', group = othGR, tooltip\nppLCB = input.color( color.new(#f23645, 0), '', inline = 'ppLS', group = othGR)\nppLCS = input.color( color.new(#089981, 0), '', inline = 'ppLS', group = othGR)\nppLS  = input.string('Small', \"\", options=['Tiny', 'Small', 'Normal'], inline = 'ppLS'\n//-----------------------------------------------------------------------------}\n// User Defined Types\n//-----------------------------------------------------------------------------{\n// @type        bar properties with their values \n//\n// @field h     (float) high price of the bar\n// @field l     (float) low price of the bar\n// @field v     (float) volume of the bar\n// @field i     (int)   index of the bar\ntype bar\n    float h = high\n    float l = low\n    float v = volume\n    int   i = bar_index\n// @type        store pivot high/low and index data \n//\n// @field x     (int)    last pivot bar index\n// @field x1    (int)    previous pivot bar index\n// @field h     (float)  last pivot high\n// @field h1    (float)  previous pivot high\n// @field l     (float)  last pivot low\n// @field l1    (float)  previous pivot low\ntype pivotPoint\n    int    x\n    int    x1\n    float  h\n    float  h1\n    float  l\n    float  l1\n// @type        maintain liquidity data \n//\n// @field b     (array<bool>) array maintains price levels where liquidity exists\n// @field bx    (array<box>)  array maintains visual object of price levels where liquidity exists\ntype liquidity\n    bool [] b\n    box  [] bx\n// @type        maintain volume profile data \n//\n// @field vs    (array<float>) array maintains tolal traded volume\n// @field vp    (array<box>)   array maintains visual object of each price level\ntype volumeProfile\n    float [] vs\n    box   [] vp\n//-----------------------------------------------------------------------------}\n// Variables\n//-----------------------------------------------------------------------------{\nbar b = bar.new()\nvar pivotPoint pp = pivotPoint.new()\nvar liquidity[] aLIQ = array.new<liquidity> (1, liquidity.new(array.new <bool> (vpLev\nvar liquidity[] dLIQ = array.new<liquidity> (1, liquidity.new(array.new <bool> (na\nvolumeProfile aVP  = volumeProfile.new(array.new <float> (vpLev + 1, 0.), array.new\nqBXs = 0\n//-----------------------------------------------------------------------------}\n// Functions/methods\n//-----------------------------------------------------------------------------{\n// @function        calcuates highest price, lowest price and cumulative volume of the given range\n//                     \n// @param _l        (int)  length of the range\n// @param _c        (bool) check\n// @param _o        (int)  offset \n//\n// @returns         (float, float, float) highest, lowest and cumulative volume\nf_calcHLV(_l, _c, _o) =>\n    if _c\n        l = low [_o]\n        h = high[_o]\n        v  = 0.\n                for x = 0 to _l - 1\n            l := math.min(low [_o + x], l)\n            h := math.max(high[_o + x], h)\n            v += volume[_o + x]\n        l := math.min(low [_o + _l], l)\n        h := math.max(high[_o + _l], h)\n                [h, l, v]\n//-----------------------------------------------------------------------------}\n// Calculations\n//-----------------------------------------------------------------------------{\nper  = mode == 'Present' ? last_bar_index - b.i <= back : true\nnzV  = nz(b.v)\nppS = switch ppLS\n    'Tiny'   => size.tiny\n    'Small'  => size.small\n    'Normal' => size.normal\npp_h = ta.pivothigh(ppLen, ppLen)\npp_l = ta.pivotlow (ppLen, ppLen)\nif not na(pp_h)\n    pp.h1 := pp.h\n    pp.h  := pp_h\nif not na(pp_l)\n    pp.l1 := pp.l\n    pp.l  := pp_l\ngo = not na(pp_h) or not na(pp_l) \nif go \n    pp.x1 := pp.x\n    pp.x  := b.i\nvpLen = pp.x - pp.x1\n[pHst, pLst, tV] = f_calcHLV(vpLen, go, ppLen)\npStp = (pHst - pLst) / vpLev\nif go and nzV and pStp > 0 and b.i > vpLen and vpLen > 0 and per\n    for bIt = vpLen to 1\n        l = 0\n        bI = bIt + ppLen\n                for pLev = pLst to pHst by pStp\n            if b.h[bI] >= pLev and b.l[bI] < pLev + pStp\n                aVP.vs.set(l, aVP.vs.get(l) + nzV[bI] * ((b.h[bI] - b.l[bI]) == 0 \n            l += 1\n    aLIQ.unshift(liquidity.new(array.new <bool> (vpLev, false), array.new <box> (na\n    cLIQ = aLIQ.get(0)\n    for l = vpLev - 1 to 0\n        if aVP.vs.get(l) / aVP.vs.max() < liqT\n            cLIQ.b.set(l, true)\n            cLIQ.bx.unshift(box.new(b.i[ppLen], pLst + (l + 0.00) * pStp, b.i[ppLen\n        else\n            cLIQ.bx.unshift(box.new(na, na, na, na))\n            cLIQ.b.set(l, false)\n    for bIt = 0 to vpLen\n        bI = bIt + ppLen\n        int qBX = cLIQ.bx.size()\n        for bx = 0 to (qBX > 0 ? qBX - 1 : na)\n            if bx < cLIQ.bx.size()\n                if cLIQ.b.get(bx) \n                    cBX = cLIQ.bx.get(bx)\n                    mBX = math.avg(cBX.get_bottom(), cBX.get_top())\n                                        if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) \n                        cBX.set_left(b.i[bI])\n                        cLIQ.b.set(bx, false)\n    for bI = ppLen to 0\n        int qBX = cLIQ.bx.size()\n        for bx = (qBX > 0 ? qBX - 1 : na) to 0\n            if bx < cLIQ.bx.size()\n                cBX = cLIQ.bx.get(bx)\n                mBX = math.avg(box.get_bottom(cBX), box.get_top(cBX))\n                                if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) or math.sign\n                    if liqFD\n                        cBX.set_bgcolor(liqFC)\n                    else\n                        cBX.delete()\n                    cLIQ.bx.remove(bx)\n                else\n                    cBX.set_right(b.i[bI])\nfor i = aLIQ.size() - 1 to 0\n    x = aLIQ.get(i)\n    int qBX = x.bx.size()\n    qBXs := qBXs + qBX\n    if qBXs > 500\n        aLIQ.pop()\n            for bx = (qBX > 0 ? qBX - 1 : na) to 0\n        if bx < x.bx.size()\n            cBX = x.bx.get(bx)\n            mBX = math.avg(box.get_bottom(cBX), box.get_top(cBX))\n            if math.sign(close[1] - mBX) != math.sign(low - mBX) or math.sign(close\n                //cBX.delete()\n                if liqFD\n                    cBX.set_bgcolor(liqFC)\n                else\n                    cBX.delete()\n                x.bx.remove(bx)\n            else\n                cBX.set_right(b.i)\nif ppLev and (mode == 'Present' ? last_bar_index - b.i <= back * 1.318 : true)\n    statTip = '\\n -Traded Volume : ' + str.tostring(tV, format.volume) + ' (' + str.tostring\n    if not na(pp_h)\n        swH = pp.h > pp.h1 ? \"HH\" : pp.h < pp.h1 ? \"LH\" : na\n        label.new(b.i[ppLen], pp.h, swH, xloc.bar_index, yloc.price, color(na), label.style_label_down\n    if not na(pp_l)\n        swL = pp.l < pp.l1 ? \"LL\" : pp.l > pp.l1 ? \"HL\" : na\n        label.new(b.i[ppLen], pp.l ,swL, xloc.bar_index, yloc.price, color(na), label.style_label_up\nvpLen := barstate.islast ? last_bar_index - pp.x + ppLen  : 1\npHst  := ta.highest(b.h, vpLen > 0 ? vpLen + 1 : 1)\npLst  := ta.lowest (b.l, vpLen > 0 ? vpLen + 1 : 1)\npStp  := (pHst - pLst) / vpLev\nif barstate.islast and nzV and vpLen > 0 and pStp > 0\n    tLIQ = dLIQ.shift()\n    if tLIQ.bx.size() > 0\n        for i = 0 to tLIQ.bx.size() - 1\n            tLIQ.bx.shift().delete()\n        tLIQ.b.shift()\n    for bI = vpLen to 1 //1 to vpLen\n        l = 0\n        for pLev = pLst to pHst by pStp\n            if b.h[bI] >= pLev and b.l[bI] < pLev + pStp\n                aVP.vs.set(l, aVP.vs.get(l) + nzV[bI] * ((b.h[bI] - b.l[bI]) == 0 \n            l += 1\n        dLIQ.unshift(liquidity.new(array.new <bool> (na), array.new <box> (na)))\n    cLIQ = dLIQ.get(0)\n    for l = 0 to vpLev - 1\n        if aVP.vs.get(l) / aVP.vs.max() < liqT\n            cLIQ.b.unshift(true)\n            cLIQ.bx.unshift(box.new(b.i, pLst + (l + 0.00) * pStp, b.i, pLst + (l \n        else\n            cLIQ.bx.unshift(box.new(na, na, na, na))\n            cLIQ.b.unshift(false)\n    for bI = 0 to vpLen\n        int qBX = cLIQ.bx.size()\n        for bx = 0 to (qBX > 0 ? qBX - 1 : na)\n            if bx < cLIQ.bx.size()\n                if cLIQ.b.get(bx) \n                    cBX = cLIQ.bx.get(bx)\n                    mBX = math.avg(cBX.get_bottom(), cBX.get_top())\n                                    if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) \n                        cBX.set_left(b.i[bI])\n                        cLIQ.b.set(bx, false)\n //-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The AI SuperTrend Clustering Oscillator is an oscillator returning the most bullish/average/bearish centroids given by multiple instances of the difference between SuperTrend indicators. This script is an extension of our previously posted SuperTrend AI indicator that makes use of k-means clustering. If you want to learn more about it see:  \ud83d\udd36 USAGE The AI SuperTrend Clustering Oscillator is made of 3 distinct components, a bullish output (always the highest), a bearish output (always the lowest), and a \"consensus\" output always within the two others. The general trend is given by the consensus output, with a value above 0 indicating an uptrend and under 0 indicating a downtrend. Using a higher minimum factor will weigh results toward longer-term trends, while lowering the maximum factor will weigh results toward shorter-term trends. Strong trends are indicated when the bullish/bearish outputs are indicating an opposite sentiment. A strong bullish trend would for example be indicated when the bearish output is above 0, while a strong bearish trend would be indicated when the bullish output is below 0. When the consensus output is indicating a specific trend direction, an opposite indication from the bullish/bearish output can highlight a potential reversal or retracement. \ud83d\udd36 DETAILS The indicator construction is based on finding three clusters from the difference between the closing price and various SuperTrend using different factors. The centroid of each cluster is then returned. This operation is done over all historical bars. The highest cluster will be composed of the differences between the price and SuperTrends that are the highest, thus creating a more bullish group. The lowest cluster will be composed of the differences between the price and SuperTrends that are the lowest, thus creating a more bearish group. The consensus cluster is composed of the differences between the price and SuperTrends that are not significant enough to be part of the other clusters. \ud83d\udd36 SETTINGS ATR Length: ATR period used for the calculation of the SuperTrends. Factor Range: Determine the minimum and maximum factor values for the calculation of the SuperTrends. Step: Increments of the factor range. Smooth: Degree of smoothness of each output from the indicator.  \ud83d\udd39 Optimization This group of settings affects the runtime performances of the script. Maximum Iteration Steps: Maximum number of iterations allowed for finding centroids. Excessively low values can return a better script load time but poor clustering. Historical Bars Calculation: Calculation window of the script (in bars)."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"AI SuperTrend Clustering Oscillator [LuxAlgo]\", \"LuxAlgo - AI SuperTrend Clustering Oscillator\"\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input(10, 'ATR Length')\nminMult = input.int(1, 'Factor Range', minval = 0, inline = 'factor')\nmaxMult = input.int(5, '', minval = 0, inline = 'factor')\nstep    = input.float(.5, 'Step', minval = 0, step = 0.1)\nsmooth = input.float(1, minval = 1)\n//Trigger error\nif minMult > maxMult\n    runtime.error('Minimum factor is greater than maximum factor in the range')\n//Optimization\nmaxIter = input.int(1000, 'Maximum Iteration Steps', minval = 0, group = 'Optimization'\nmaxData = input.int(10000, 'Historical Bars Calculation', minval = 0, group = 'Optimization'\n//Style\nbullCss = input( color.new(#5b9cf6, 50), 'Bullish', inline = 'bull', group = 'Style'\nstrongBullCss = input( color.new(#5b9cf6, 28), 'Strong', inline = 'bull', group =\nneutCss = input( #9598a1, 'Neutral', inline = 'neut', group = 'Style')\nbearCss = input( color.new(#f77c80, 50), 'Bearish', inline = 'bear', group = 'Style'\nstrongBearCss = input( color.new(#f77c80, 28), 'Strong', inline = 'bear', group =\n//-----------------------------------------------------------------------------}\n//UDT's\n//-----------------------------------------------------------------------------{\ntype supertrend\n    float upper = hl2\n    float lower = hl2\n    float output\n    int trend\ntype vector\n    array<float> out\n//-----------------------------------------------------------------------------}\n//Supertrend\n//-----------------------------------------------------------------------------{\nvar holder = array.new<supertrend>(0)\nvar factors = array.new<float>(0)\n//Populate supertrend type array\nif barstate.isfirst\n    for i = 0 to int((maxMult - minMult) / step)\n        factors.push(minMult + i * step)\n        holder.push(supertrend.new())\natr = ta.atr(length)\n//Compute Supertrend for multiple factors\nk = 0\nfor factor in factors\n    get_spt = holder.get(k)\n    up = hl2 + atr * factor\n    dn = hl2 - atr * factor\n        get_spt.upper := close[1] < get_spt.upper ? math.min(up, get_spt.upper) : up\n    get_spt.lower := close[1] > get_spt.lower ? math.max(dn, get_spt.lower) : dn\n    get_spt.trend := close > get_spt.upper ? 1 : close < get_spt.lower ? 0 : get_spt\n    get_spt.output := get_spt.trend == 1 ? get_spt.lower : get_spt.upper\n    k += 1\n//-----------------------------------------------------------------------------}\n//K-means clustering\n//-----------------------------------------------------------------------------{\ndata = array.new<float>(0)\n//Populate data arrays\nif last_bar_index - bar_index <= maxData\n    for element in holder\n        data.push(close - element.output)\n//Intitalize centroids using quartiles\ncentroids = array.new<float>(0)\ncentroids.push(data.percentile_linear_interpolation(25))\ncentroids.push(data.percentile_linear_interpolation(50))\ncentroids.push(data.percentile_linear_interpolation(75))\n//Intialize clusters\nvar array<vector> clusters = na\nif last_bar_index - bar_index <= maxData\n    for _ = 0 to maxIter\n        clusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new\n                //Assign value to cluster\n        for value in data\n            dist = array.new<float>(0)\n            for centroid in centroids\n                dist.push(math.abs(value - centroid))\n            idx = dist.indexof(dist.min())\n            if idx != -1\n                clusters.get(idx).out.push(value)\n                    //Update centroids\n        new_centroids = array.new<float>(0)\n        for cluster_ in clusters\n            new_centroids.push(cluster_.out.avg())\n        //Test if centroid changed\n        if new_centroids.get(0) == centroids.get(0) and new_centroids.get(1) == centroids\n            break\n        centroids := new_centroids\n//-----------------------------------------------------------------------------}\n//Get centroids\n//-----------------------------------------------------------------------------{\n//Get associated supertrend\nvar float bull = 0\nvar float neut = 0\nvar float bear = 0\nvar den = 0\nif not na(clusters)\n    bull += 2/(smooth+1) * nz(centroids.get(2) - bull)\n    neut += 2/(smooth+1) * nz(centroids.get(1) - neut)\n    bear += 2/(smooth+1) * nz(centroids.get(0) - bear)\n    den += 1\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\nplot_bull = plot(math.max(bull, 0), color = na, editable = false)\nplot_bull_ext = plot(math.max(bear, 0), 'Strong Bullish'\n  , bear > 0 ? strongBullCss : na\n  , style = plot.style_circles)\nplot_bear = plot(math.min(bear, 0), color = na, editable = false)\nplot_bear_ext = plot(math.min(bull, 0), 'Strong Bearish'\n  , bull < 0 ? strongBearCss : na\n  , style = plot.style_circles)\nplot(neut, 'Consensus', neutCss)\nfill(plot_bull, plot_bull_ext, bull, math.max(bear, 0), bullCss, color.new(chart.bg_color\nfill(plot_bear_ext, plot_bear, math.min(bull, 0), bear, color.new(chart.bg_color, \nhline(0, linestyle = hline.style_solid)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Support and Resistance Signals MTF  indicator aims to identify undoubtedly one of the key concepts of technical analysis Support and Resistance Levels and more importantly, the script aims to capture and highlight major price action movements, such as Breakouts, Tests of the Zones, Retests of the Zones, and Rejections.  The script supports Multi-TimeFrame (MTF) functionality allowing users to analyze and observe the Support and Resistance Levels/Zones and their associated Signals from a higher timeframe perspective.  This script is an extended version of our previously published Support-and-Resistance-Levels-with-Breaks script from 2020. Identification of key support and resistance levels/zones is an essential ingredient to successful technical analysis. \ud83d\udd36 USAGE Support and resistance are key concepts that help traders understand, analyze and act on chart patterns in the financial markets. Support describes a price level where a downtrend pauses due to demand for an asset increasing, while resistance refers to a level where an uptrend reverses as a sell-off happens. The creation of support and resistance levels comes as a result of an initial imbalance of supply/demand, which forms what we know as a swing high or swing low. This script starts its processing using the swing highs/lows. Swing Highs/Lows are levels that many of the market participants use as a historical reference to place their trading orders (buy, sell, stop loss), as a result, those price levels potentially become and serve as key support and resistance levels.  One of the important features of the script is the signals it provides. The script follows the major price movements and highlights them on the chart.  \ud83d\udd39 Breakouts (non-repaint)  A breakout is a price moving outside a defined support or resistance level, the significance of the breakout can be measured by examining the volume.  This script is not filtering them based on volume but provides volume information for the bar where the breakout takes place. \ud83d\udd39 Retests Retest is a case where the price action breaches a zone and then revisits the level breached.   \ud83d\udd39 Tests Test is a case where the price action touches the support or resistance zones.     \ud83d\udd39 Rejections Rejections are pin bar patterns with high trading volume.  Finally, Multi TimeFrame (MTF) functionality allows users to analyze and observe the Support and Resistance Levels/Zones and their associated Signals from a higher timeframe perspective. \ud83d\udd36 SETTINGS The script takes into account user-defined parameters to detect and highlight the zones, levels, and signals. \ud83d\udd39 Support & Resistance Settings Detection Timeframe: Set the indicator resolution, the users may examine higher timeframe detection on their chart timeframe.   Detection Length: Swing levels detection length Check Previous Historical S&R Level: enables the script to check the previous historical levels.  \ud83d\udd39 Signals Breakouts: Toggles the visibility of the Breakouts, enables customization of the color and the size of the visuals   Tests: Toggles the visibility of the Tests, enables customization of the color and the size of the visuals   Retests: Toggles the visibility of the Retests, enables customization of the color and the size of the visuals   Rejections: Toggles the visibility of the Rejections, enables customization of the color and the size of the visuals    \ud83d\udd39 Others Sentiment Profile: Toggles the visibility of the Sentiment Profiles Bullish Nodes: Color option for Bullish Nodes Bearish Nodes: Color option for Bearish Nodes  \ud83d\udd36 RELATED SCRIPTS Support-and-Resistance-Levels-with-Breaks Buyside-Sellside-Liquidity Liquidity-Levels-Voids"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n //@version=5\nindicator(\"Support and Resistance Signals MTF [LuxAlgo]\", 'LuxAlgo - Support and Resistance Signals MTF'\n//------------------------------------------------------------------------------\n// Settings\n//-----------------------------------------------------------------------------{\nsrGR   = 'Support & Resistance Settings'\nsrTF   = input.string('Chart', 'Detection Timeframe', options=['Chart', '15 Minutes'\nsrLN   = input(15, 'Detection Length', group = srGR)\nsrHST  = input(true, 'Check Previous Historical S&R Level', group = srGR)\nsrMR   = input.float(1.3, 'Support Resistance Margin', minval = .1, maxval = 10, step\nsrSLC  = input( color.new(#089981, 53), '\u2004\u2004\u2004- Support, \u2004\u2004\u2004\u2004Lines', inline = 'srS', group\nsrSZC  = input( color.new(#089981, 83), 'Zones', inline = 'srS', group = srGR)\nsrRLC  = input( color.new(#f23645, 53), '\u2004\u2004\u2004- Resistance, Lines', inline = 'srR', \nsrRZC  = input( color.new(#f23645, 83), 'Zones', inline = 'srR', group = srGR)\nmnMR   = input.float(2, 'Manupulation Margin', minval = .1, maxval = 10, step = .1\nmnSZC  = input( color.new(#089981, 43), '\u2004\u2004\u2004- Support Zones', inline = 'mn', group\nmnRZC  = input( color.new(#f23645, 43), 'Resistance Zones', inline = 'mn', group \nsigGR  = 'Signals'\nsrBUC  = input( color.new(#089981, 33), 'Breakouts, Bullish', inline = 'srB', group\nsrBDC  = input( color.new(#f23645, 33), 'Bearish', inline = 'srB', group = sigGR)\nsrBS   = input.string('Tiny', \"\", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'\nsrTUC  = input( color.new(#2962ff, 33), 'Tests, \u2004\u2004\u2004\u2004\u2004\u2004\u2004Bullish', inline = 'srT', group\nsrTDC  = input( color.new(#e040fb, 33), 'Bearish', inline = 'srT', group = sigGR)\nsrTS   = input.string('Tiny', \"\", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'\nsrRUC  = input( color.new(#089981, 33), 'Retests, \u2004\u2004\u2004\u2004Bullish', inline = 'srR', group\nsrRDC  = input( color.new(#f23645, 33), 'Bearish', inline = 'srR', group = sigGR)\nsrRS   = input.string('Tiny', \"\", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'\nsrPUC  = input( color.new(#089981, 33), 'Rejections, Bullish', inline = 'srP', group\nsrPDC  = input( color.new(#f23645, 33), 'Bearish', inline = 'srP', group = sigGR)\nsrPS   = input.string('Tiny', \"\", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'\n//mssUC  = input(color.new(#3179f5, 13), 'Market Structure Shifts', inline = 'mss', group = sigGR)\n//mssDC  = input(color.new(#ff9800, 13), '', inline = 'mss', group = sigGR)\n//mssS   = input.string('Large', \"\u2004\u2004\u2004\", options=['Large', 'Huge', 'None'], inline = 'mss', \nothGR  = 'Others'\nswSH   = input.string('None', \"Swing Levels\", options=['Auto', 'Small', 'Normal', \nswHC   = input( color.new(#f23645, 33), 'H', inline = 'sw', group = othGR)\nswLC   = input( color.new(#089981, 33), 'L', inline = 'sw', group = othGR)\n//-----------------------------------------------------------------------------}\n// User Defined Types\n//-----------------------------------------------------------------------------{\n// @type        bar properties with their values \n//\n// @field o     (float) open price of the bar\n// @field h     (float) high price of the bar\n// @field l     (float) low price of the bar\n// @field c     (float) close price of the bar\n// @field v     (float) volume of the bar\n// @field i     (int) index of the bar\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    float v = volume\n    int   i = bar_index\n// @type        store pivot high/low and index data \n//\n// @field x     (int)    last pivot bar index\n// @field x1    (int)    previous pivot bar index\n// @field h     (float)  last pivot high\n// @field h1    (float)  previous pivot high\n// @field l     (float)  last pivot low\n// @field l1    (float)  previous pivot low\n// @field hx    (bool)   pivot high cross status\n// @field lx    (bool)   pivot low cross status\ntype pivotPoint\n    int    x\n    int    x1\n    float  h\n    float  h1\n    float  l\n    float  l1\n    bool   hx\n    bool   lx\n// @type        stores support and resistance visuals and signal status \n//\n// @field bx    (box)   support and resistance zones\n// @field lq    (box)   liquidity sweeps\n// @field ln    (line)  support and resistance levels\n// @field b     (bool)  breakout status\n// @field b     (bool)  test status\n// @field b     (bool)  retest status\n// @field b     (bool)  liqudation status\ntype SnR\n    box    bx\n    box    lq\n    line   ln\n    bool   b\n    bool   t\n    bool   r\n    bool   l\n//-----------------------------------------------------------------------------}\n// Variables\n//-----------------------------------------------------------------------------{\nbar b = bar.new()\nvar pivotPoint pp  = pivotPoint.new()\nvar SnR[] R = array.new<SnR> (1, SnR.new(box(na), box(na), line(na), false, false,\nvar SnR[] S = array.new<SnR> (1, SnR.new(box(na), box(na), line(na), false, false,\nvar SnR lR = SnR.new(box(na), box(na), line(na), false, false, false, false)\nvar SnR lS = SnR.new(box(na), box(na), line(na), false, false, false, false)\nvar float RpCHG = na\nvar float SpCHG = na\nvar int mss = 0\n//-----------------------------------------------------------------------------}\n// General Calculations\n//-----------------------------------------------------------------------------{\nint tf_m = switch srTF\n    \"Chart\"      => timeframe.isintraday ? timeframe.multiplier : timeframe.isdaily\n    \"15 Minutes\" => 15\n    \"1 Hour\"     => 60\n    \"4 Hours\"    => 240\n    \"1 Day\"      => 1440\n    \"1 Week\"     => 10080\nch_m  = if timeframe.isintraday\n    timeframe.multiplier\nelse if timeframe.isdaily\n    1440\nelse if timeframe.isweekly\n    10080\nelse if timeframe.ismonthly\n    10080 * 30\nsrLN := srLN * tf_m / ch_m\npHST = ta.highest(b.h, srLN)\npLST = ta.lowest (b.l, srLN)\natr   = ta.atr(17)\nisLLS = math.abs(b.l - math.min(b.o, b.c)) >= 1.618 * atr\nisLUS = math.abs(b.h - math.max(b.o, b.c)) >= 1.618 * atr\nisHV  = nz(b.v) >= 1.618 * ta.sma(nz(b.v), 17)\nisLV  = nz(b.v) <= 0.618 * ta.sma(nz(b.v), 17)\nvST   = isHV ? '\\n *High Trading Activity' : isLV ? '\\n *Low Trading Activity' : '\\n *Average Trading Activity'\nsrBUC := srBS != 'None' ? srBUC : color(na)\nsrBDC := srBS != 'None' ? srBDC : color(na)\nsrBTC  = srBS != 'None' ?  color.white : color(na)\nsrTUC := srTS != 'None' ? srTUC : color(na)\nsrTDC := srTS != 'None' ? srTDC : color(na)\nsrTTC  = srTS != 'None' ?  color.white : color(na)\nsrRUC := srRS != 'None' ? srRUC : color(na)\nsrRDC := srRS != 'None' ? srRDC : color(na)\nsrRTC  = srRS != 'None' ?  color.white : color(na)\n//-----------------------------------------------------------------------------}\n// Functions/methods\n//-----------------------------------------------------------------------------{\n// @function        calcuates cumulative volume of the given range\n//                     \n// @param _l        (int)  length of the range\n// @param _o        (int)  offset \n//\n// @returns         (float) cumulative volume\nf_getTradedVolume(_l, _o) =>\n    v = 0.\n    for x = 0 to _l - 1\n        v += volume[_o + x]\n    v\n// @function        converts size strings to enumerated values\n//                     \n// @param _l        (string) size string\n//\n// @returns         (enumeration) size enumerated value\nf_getSize(_s) =>\n    switch _s\n        'Tiny'   => size.tiny\n        'Small'  => size.small\n        'Normal' => size.normal\n        'Large'  => size.large\n        'Huge'   => size.huge\n        => size.auto\n//-----------------------------------------------------------------------------}\n// Calculations\n//-----------------------------------------------------------------------------{\npp_h  = ta.pivothigh(srLN, srLN)\nif not na(pp_h)\n    pp.h1 := pp.h \n    pp.h  := pp_h\n    pp.x1 := pp.x\n    pp.x  := b.i[srLN]\n    pp.hx := false\n    RpCHG := (pHST - pLST) / pHST\n    //lS.b  := false\n    if R.size() > 1 \n        lR := R.get(0)\n        lRt = R.get(1)\n        if pp.h < lR.bx.get_bottom() * (1 - RpCHG * .17 * srMR) or pp.h > lR.bx.get_top\n            if pp.x < lR.bx.get_left() and pp.x + srLN > lR.bx.get_left() //not lR.b\n                na\n            else\n                if pp.h < lRt.bx.get_bottom() * (1 - RpCHG * .17 * srMR) or pp.h >\n                    R.unshift(\n                      SnR.new(\n                      box.new(pp.x, pp.h, b.i, pp.h * (1 - RpCHG * .17 * srMR), border_color\n                      box.new(na, na, na, na, bgcolor = color(na), border_color = \n                      line.new(pp.x, pp.h, b.i, pp.h, color = srRLC, width = srMR \n                      false, false, false, false))\n                    lS.t := false\n                else\n                    lRt.bx.set_right(b.i)\n                    lRt.ln.set_x2(b.i)\n        else\n            lR.bx.set_right(b.i)\n            lR.ln.set_x2(b.i)\n    else\n        R.unshift(\n          SnR.new(\n             box.new(pp.x, pp.h, b.i, pp.h * (1 - RpCHG * .17 * srMR), border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(pp.x, pp.h, b.i, pp.h, color = srRLC, width = srMR <= .5 ? 2\n             false, false, false, false))\n        lS.t := false\n    if swSH != 'None'\n        StS = pp.x - pp.x1\n        tradedVolume = f_getTradedVolume(StS, srLN)\n        swH = pp.h > pp.h1 ? \"Higher High\" : pp.h < pp.h1 ? \"Lower High\" : na\n        rTT = 'Swing High (' + swH + ') : ' + str.tostring(pp.h, format.mintick) +\n              (mss == -1 and pp.h < pp.h1 ? '\\n    *Counter-Trend Move' : '') +\n              '\\n -Price Change : \u2191 %' + str.tostring((pp.h - pp.l) * 100 / pp.l ,\n              (nz(b.v) ? '\\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume\n              '\\n    *Average Volume/Bar : ' + str.tostring(tradedVolume / (StS - \n        label.new(pp.x, pp.h, '\u25c8', color = color(na), style = label.style_label_down\nif b.c[1] > pp.h and b.c > pp.h and not pp.hx \n    pp.hx := true\n    //if mss == -1 and mssS != 'None'\n    //    label.new(b.i + 1, pp.h, '\u2b06', color = color(na), style = label.style_label_center, \n    //    line.new(b.i[2], pp.h, b.i, pp.h, color = mssUC, width = 4)\n    mss := 1\npp_l  = ta.pivotlow (srLN, srLN)\nif not na(pp_l) \n    pp.l1 := pp.l\n    pp.l  := pp_l\n    pp.x1 := pp.x\n    pp.x  := b.i[srLN]\n    pp.lx := false\n    SpCHG := (pHST - pLST) / pHST\n    if S.size() > 2 \n        lS := S.get(0)\n        lSt = S.get(1)\n        //lR.b  := false\n        if pp.l < lS.bx.get_bottom() * (1 - SpCHG * .17 * srMR) or pp.l > lS.bx.get_top\n            if pp.x < lS.bx.get_left() and pp.x + srLN > lS.bx.get_left() //not lR.b\n                na\n            else\n                if pp.l < lSt.bx.get_bottom() * (1 - SpCHG * .17 * srMR) or pp.l >\n                    S.unshift(\n                      SnR.new(\n                      box.new(pp.x, pp.l * (1 + SpCHG * .17 * srMR), b.i, pp.l, border_color\n                      box.new(na, na, na, na, bgcolor = color(na), border_color = \n                      line.new(pp.x, pp.l, b.i, pp.l, color = srSLC, width = srMR \n                      false, false, false, false))\n                    lR.t := false\n                else\n                    lSt.bx.set_right(b.i)\n                    lSt.ln.set_x2(b.i)\n        else\n            lS.bx.set_right(b.i)\n            lS.ln.set_x2(b.i)\n    else\n        S.unshift(\n          SnR.new(\n             box.new(pp.x, pp.l * (1 + SpCHG * .17 * srMR), b.i, pp.l, border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(pp.x, pp.l, b.i, pp.l, color = srSLC, width = srMR <= .5 ? 2\n             false, false, false, false))\n        lR.t := false\n    if swSH != 'None'\n        StS = pp.x - pp.x1\n        tradedVolume = f_getTradedVolume(StS, srLN)\n        swL = pp.l < pp.l1 ? \"Lower Low\" : pp.l > pp.l1 ? \"Higher Low\" : na\n        sTT = 'Swing Low (' + swL + ') : ' + str.tostring(pp.l, format.mintick) + \n              (mss == 1 and pp.l > pp.l1 ? '\\n    *Counter-Trend Move' : '') +\n              '\\n -Price Change : \u2193 %' + str.tostring((pp.h - pp.l) * 100 / pp.h ,\n              (nz(b.v) ? '\\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume\n              '\\n    *Average Volume/Bar : ' + str.tostring(tradedVolume / (StS - \n        label.new(pp.x, pp.l, '\u25c8', color = color(na), style = label.style_label_up\nif b.c[1] < pp.l and b.c < pp.l and not pp.lx \n    pp.lx := true\n    //if mss == 1 and mssS != 'None'\n    //    label.new(b.i[3], pp.l, '\u2b07', color = color(na), style = label.style_label_center, \n    //    line.new(b.i[2], pp.l, b.i, pp.l, color = mssDC, width = 4)\n    mss := -1\nif R.size() > 0\n    lR := R.get(0)\n    if  b.c[1] > lR.bx.get_top() * (1 + RpCHG * .17) and not lR.b\n        lR.bx.set_right(b.i[1])\n        lR.ln.set_x2(b.i[1])\n        if b.c > lR.bx.get_top() * (1 + RpCHG * .17)\n            lR.b := true\n            lR.r := false\n            label.new(b.i[1], b.l[1] * (1 - RpCHG * .017), '\u25b2\\n\\nB', color = srBUC\n            S.unshift(\n             SnR.new(\n             box.new(b.i[1], lR.bx.get_top(), b.i + 1, lR.bx.get_bottom(), border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(b.i[1], lR.bx.get_bottom(), b.i + 1, lR.bx.get_bottom(), color\n             false, false, false, false))\n        else\n            lS.lq.set_lefttop(b.i[1] - 1, lR.bx.get_top())\n            lS.lq.set_rightbottom(b.i + 1, lR.bx.get_top() * (1 + RpCHG * .17 * mnMR\n            lS.lq.set_bgcolor(mnRZC)\n            lS.l := true\n    else if lS.b and b.o < lR.bx.get_top() and b.h > lR.bx.get_bottom() and b.c < \n        label.new(b.i, b.h * (1 + RpCHG * .017), 'R', color = srRDC, style = label.style_label_down\n        lR.r := true //\n        lR.bx.set_right(b.i)\n        lR.ln.set_x2(b.i)\n    else if b.h[1] > lR.bx.get_bottom() and b.c[1] < lR.bx.get_top() and b.c < lR.\n        label.new(b.i[1], b.h[1] * (1 + RpCHG * .017), 'T', color = srTDC, style =\n        lR.t := true\n        lR.bx.set_right(b.i)\n        lR.ln.set_x2(b.i)\n    else if b.h > lR.bx.get_bottom() * (1 - RpCHG * .17) and not lR.b\n        lR.ln.set_x2(b.i)\n    if isLLS[1] and isHV[1] and srPS != 'None' // lS.b and \n        label.new(b.i[1], b.l[1] * (1 - RpCHG * .017), '', color = srPUC, style = \nif R.size() > 1 and lR.b and srHST\n    lRt = R.get(1)\n    if  b.c[1] > lRt.bx.get_top() * (1 + RpCHG * .17) and not lRt.b\n        lRt.bx.set_right(b.i[1])\n        lRt.ln.set_x2(b.i[1])\n        if b.c > lRt.bx.get_top() * (1 + RpCHG * .17)\n            lRt.b := true\n            lRt.r := false\n            label.new(b.i[1], b.l[1] * (1 - RpCHG * .017), '\u25b2\\n\\nB', color = srBUC\n            S.unshift(\n             SnR.new(\n             box.new(b.i[1], lRt.bx.get_top(), b.i + 1, lRt.bx.get_bottom(), border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(b.i[1], lRt.bx.get_bottom(), b.i + 1, lRt.bx.get_bottom(), color\n             false, false, false, false))\n                    else\n            lS.lq.set_lefttop(b.i[1] - 1, lRt.bx.get_top())\n            lS.lq.set_rightbottom(b.i + 1, lRt.bx.get_top() * (1 + RpCHG * .17 * mnMR\n            lS.lq.set_bgcolor(mnRZC)\n            lS.l := true\n    else if lS.b and b.o < lRt.bx.get_top() and b.h > lRt.bx.get_bottom() and b.c \n        label.new(b.i, b.h * (1 + RpCHG * .017), 'R', color = srRDC, style = label.style_label_down\n        lRt.r := true //\n        lRt.bx.set_right(b.i)\n        lRt.ln.set_x2(b.i)\n    else if b.h[1] > lRt.bx.get_bottom() and b.c[1] < lRt.bx.get_top() and b.c < lRt\n        label.new(b.i[1], b.h[1] * (1 + RpCHG * .017), 'T', color = srTDC, style =\n        lRt.t := true\n        lRt.bx.set_right(b.i)\n        lRt.ln.set_x2(b.i)\n    else if b.h > lRt.bx.get_bottom() * (1 - RpCHG * .17) and not lRt.b\n        lRt.ln.set_x2(b.i)\nif S.size() > 0\n    lS := S.get(0)\n    if  b.c[1] < lS.bx.get_bottom() * (1 - SpCHG * .17) and not lS.b // and b.c < lS.bx.get_bottom() * (1 - SpCHG * .17\n        lS.bx.set_right(b.i[1])\n        lS.ln.set_x2(b.i[1])\n        if b.c < lS.bx.get_bottom() * (1 - SpCHG * .17)\n            lS.b := true\n            lS.r := false\n            label.new(b.i[1], b.h[1] * (1 + SpCHG * .017), 'B\\n\\n\u25bc', color = srBDC\n            R.unshift(\n             SnR.new(\n             box.new(b.i[1], lS.bx.get_top(), b.i + 1, lS.bx.get_bottom(), border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(b.i[1], lS.bx.get_top(), b.i + 1, lS.bx.get_top(), color = srRLC\n             false, false, false, false))\n        else\n            lR.lq.set_lefttop(b.i[1] - 1, lS.bx.get_bottom())\n            lR.lq.set_rightbottom(b.i + 1, lS.bx.get_bottom() * (1 - SpCHG * .17 *\n            lR.lq.set_bgcolor(mnSZC)\n            lR.l := true\n    else if lR.b and b.o > lS.bx.get_bottom() and b.l < lS.bx.get_top() and b.c > \n        label.new(b.i, b.l * (1 - SpCHG * .017), 'R', color = srRUC, style = label.style_label_up\n        lS.r := true //\n        lS.bx.set_right(b.i)\n        lS.ln.set_x2(b.i)\n    else if b.l[1] < lS.bx.get_top() and b.c[1] > lS.bx.get_bottom() and b.c > lS.\n        label.new(b.i[1], b.l[1] * (1 - SpCHG * .017), 'T', color = srTUC, style =\n        lS.t := true\n        lS.bx.set_right(b.i)\n        lS.ln.set_x2(b.i)\n    else if b.l < lS.bx.get_top() * (1 + SpCHG * .17) and not lS.b\n        lS.ln.set_x2(b.i)\n    if isLUS[1] and isHV[1] and srPS != 'None' // lR.b and \n        label.new(b.i[1], b.h[1] * (1 + SpCHG * .017), '', color = srPDC, style = \nif S.size() > 1 and lS.b and srHST\n    lSt = S.get(1)\n    if  b.c[1] < lSt.bx.get_bottom() * (1 - SpCHG * .17) and not lSt.b // and b.c < lS.bx.get_bottom() * (1 - SpCHG * .17\n        lSt.bx.set_right(b.i[1])\n        lSt.ln.set_x2(b.i[1])\n        if b.c < lSt.bx.get_bottom() * (1 - SpCHG * .17)\n            lSt.b := true\n            lSt.r := false\n            label.new(b.i[1], b.h[1] * (1 + SpCHG * .017), 'B\\n\\n\u25bc', color = srBDC\n            R.unshift(\n             SnR.new(\n             box.new(b.i[1], lSt.bx.get_top(), b.i + 1, lSt.bx.get_bottom(), border_color\n             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)\n             line.new(b.i[1], lSt.bx.get_top(), b.i + 1, lSt.bx.get_top(), color =\n             false, false, false, false))\n        else\n            lR.lq.set_lefttop(b.i[1] - 1, lSt.bx.get_bottom())\n            lR.lq.set_rightbottom(b.i + 1, lSt.bx.get_bottom() * (1 - SpCHG * .17 \n            lR.lq.set_bgcolor(mnSZC)\n            lR.l := true\n    else if lR.b and b.o > lSt.bx.get_bottom() and b.l < lSt.bx.get_top() and b.c \n        label.new(b.i, b.l * (1 - SpCHG * .017), 'R', color = srRUC, style = label.style_label_up\n        lSt.r := true //\n        lSt.bx.set_right(b.i)\n        lSt.ln.set_x2(b.i)\n    else if b.l[1] < lSt.bx.get_top() and b.c[1] > lSt.bx.get_bottom() and b.c > lSt\n        label.new(b.i[1], b.l[1] * (1 - SpCHG * .017), 'T', color = srTUC, style =\n        lSt.t := true\n        lSt.bx.set_right(b.i)\n        lSt.ln.set_x2(b.i)\n    else if b.l < lSt.bx.get_top() * (1 + SpCHG * .17) and not lSt.b\n        lSt.ln.set_x2(b.i)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Volume Delta Methods (Chart) aims at highlighting the relationship between Buying or Selling Pressure and Price by presenting Volume Delta, and multiple derivatives of volume delta such as Cumulative Volume Delta (CVD), Buy/Sell Volume, Total Volume, etc on top of the Main Price Chart. The script uses two different intrabar (chart bars at a lower timeframe than the chart's) analyses to achieve the most approximate calculation of the \u200bvolume delta and offers fully customizable visualization features using various types of charts such as line, area, baseline, candles, and histograms. The script allows traders to see \"within\" the price bar, provides more transparency over a traditional volume histogram, and also allows users to monitor price and volume activity together. \ud83d\udd36 USAGE Volume delta is the difference between the buying volume and the selling volume, in other words, it is the net demand at a given bar allowing traders a more detailed insight when analyzing the market sentiment. A volume delta greater than 0 indicates more buying than selling pressure, whereas a volume delta less than 0 indicates more selling than buying pressure. Volume delta plus total volume (regular volume) adds additional insight, where the total volume represents all the recorded trades for security that occurs in a given time interval. It is a measurement of the participation, enthusiasm, and interest in a given security. Divergences occur when the polarity of \u200bthe volume delta does not match the polarity of the price bar. The users can enable the display of the numerical values of the volume delta. Cumulative Volume Delta (CVD) is a way of using Volume Delta to measure an asset\u2019s mid-to-long-term buy and sell pressure. It compares buying and selling volume over time and offers insights into market behavior at specific price points. Cumulative Volume Delta is effectively a continuation of the principles of Volume Delta but involves longer time periods and offers different trading signals.  Like the Volume Delta, the Cumulative Volume Delta (CVD) indicator measures the relationship between buy and sell pressure but does not focus on one specific candle in particular. Rather, the Cumulative Volume Delta takes the relative differences and combines them all over an extended time period.  Users have the ability Cumulative Volume Delta in various types of charts along with an optional smoothing line. Placed above price bars options. Interacting with price bar options helps to better identify CVD Divergences. CVD Divergences CVD reveals buying and selling trends that may or may not complement the price trend of the asset itself. Sometimes, price trends can run in contrast to trading behavior \u2014 sell volume can be dominant while the spot price is rising, and vice versa. \ud83d\udd36 DETAILS Theoretically, volume delta is calculated by taking the difference between the volume that traded at the ask price and the volume that traded at the bid price. The most precise calculation method uses tick data but requires huge amounts of data on historical bars, which usually limits the historical depth of charts. This indicator uses two different intrabar analysis methods for the \u200bvolume delta calculation, where intrabars are chart bars at a lower timeframe than the chart's timeframe: The logic used to assign intrabar \u200bvolume to the \"up\" or \"down\". - Buying/Selling pressure of the intrabar option (default)   (close - low) > (high - close) => UP(close - low) < (high - close) => DOWN(close - low) = (high - close) => close - previous close is used - Polarity of the intrabar option close > open => UPclose < open => DOWNclose = open => close - previous close is used \ud83d\udd36 SETTINGS The script takes into account user-defined parameters and performs calculations and presentations based on them, where detailed usage for each user-defined input parameter in indicator settings is provided with the related input's tooltip. \ud83d\udd39 Calculation Settings Calculation Method: Calculation method selection, available options 'Intrabar Buying/Selling Pressure' or 'Intrabar Polarity'. Lower Timeframe Precision: Sets indicator precision, default option is 'Auto'.  \ud83d\udd39 Presentation Settings Volume Delta: Toggles the visibility of the Volume Delta Cumulative Volume Delta: Toggles the visibility of the Cumulative Volume Delta Volume Delta/Price Bar Divergences: Toggles the visibility of the Volume Delta Divergences Volume Delta Numerical Values: Toggles the visibility of the Volume Delta Numerical Values  \ud83d\udd39 Other Features Volume MA: Toggles the visibility of the Volume Moving Average  CVD Smoothing: Toggles the visibility of the Cumulative Volume Delta's Smoothing Line  \ud83d\udd39 Volume Delta, Others Volume Delta: Positive, Negative: Volume Delta color customization options  Volume Histogram: Growing, Falling: Volume Histogram color customization options Display Length: Length of the visual objects presented with this indicator Volume Delta Height: Volume delta height customization options Volume Histogram Height: Volume histogram height customization options Vertical Offset: Volume delta and histogram vertical positioning customization options  \ud83d\udd39 Cumulative Volume Delta, Others CVD Line, Width, and Color: Cumulative Volume Delta - Line Width and Color customization options  CVD Area/Baseline, Gradient Coloring: Cumulative Volume Delta - Area and Baseline background gradient coloring customization options CVD Candles Color, Positive, and Negative: Cumulative Volume Delta - Candles coloring customization options CVD/Smoothing Background: Highlights and adjusts the transparency of the area between the Cumulative Volume Delta Line and it's Smoothing Line  \ud83d\udd36 RELATED SCRIPTS Liquidity-Sentiment-Profile EquiVolume Volume-Footprint"}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n //@version=5\nindicator(\"Volume Delta Methods (Chart) [LuxAlgo]\", \"LuxAlgo - Volume Delta Methods (Chart)\"\n//------------------------------------------------------------------------------\n// Settings\n//-----------------------------------------------------------------------------{\nclGR   = 'Calculation Settings'\nvdCT   = 'This indicator uses two different intrabar analysis methods for the volume delta \n          ' - buying/selling pressure of the intrabar (default), or\\n - polarity of the intrabar\\n\\n'\n          'Note : The most precise calculation method uses tick data but requires huge amounts of data on hist\n          'which usually limits the historical depth of charts'\nvdT1   = 'Intrabar Buying/Selling Pressure' \nvdT2   = 'Intrabar Polarity' \nvdCM   = input.string(vdT1, 'Calculation Method', options = [vdT1, vdT2], group = \ntfTP   = 'The indicator Precision is set by the input of the Lower Timeframe Precision. '\n          'If the Lower Timeframe Precision is set to AUTO, then the Lower Timeframe is determined by the foll\n          ' - Chart Timeframe,  Lower Timeframe\\n'  + \n          '       <= 1 min                1 Sec\\n'  + \n          '       <= 2 min                5 Sec\\n'  + \n          '       <= 3 min                10 Sec\\n' + \n          '       <= 5 min                15 Sec\\n' + \n          '       <= 15 min              30 Sec\\n'  + \n          '       <= 1 hour               1 min\\n'  + \n          '       <= 2 hour               3 min\\n'  + \n          '       <= 4 hour               5 min\\n'  + \n          '       <= 1 day                15 min\\n' + \n          '       <= 1 week              1 hour\\n'  + \n          '       >   1 week              1 day'\nvdLT   = input.string('Auto', 'Lower Timeframe Precision', \n          options=['Auto', '1 Sec', '5 Sec', '10 Sec', '15 Sec', '30 Sec', '1 Min'\nprGR   = 'Presentation Settings'\nvdTT   = 'Volume Delta is the difference between buying and selling pressure. ' + \n          'Theoretically, Volume Delta is calculated by taking the difference of the volume that traded at the\n          'This indicator uses intrabar analysis to achieve the most approximate calculation of the volume \nvlT1   = 'Volume Delta (Unipolarity)'\nvlT2   = 'Volume Delta (Buy/Sell Polarity)'\nvlT3   = 'Volume Delta + Regular Volume (Overlapping)'\nvlT4   = 'Volume Delta + Regular Volume (Non-Overlapping)'\nvdHG   = input.string(vlT3, 'Volume Delta', options = [vlT1, vlT2, vlT3, vlT4, 'None'\ncvdTT  = 'Cumulative Volume Delta (CVD) takes the delta values for every bar and adds them together'\ncvdT1  = 'Line (Overlapping Price Bars)'\ncvdT2  = 'Line (Above Price Bars)'\ncvdT3  = 'Area (Above Price Bars)'\ncvdT4  = 'Baseline (Above Price Bars)'\ncvdT5  = 'Candles (Overlapping Price Bars)'\ncvdSH  = input.string(cvdT4, 'Cumulative Volume Delta', options = [cvdT1, cvdT5, cvdT2\ndvTT   = 'Divergences occur when the polarity of volume delta does not match the polarity of the chart \nvdDV   = input.bool(false, 'Volume Delta/Price Bar Divergences', inline='V7', group\nvdCL   = input.color( color.new(#ff9800, 3), '', inline='V7', group = prGR)\nnvTT   = 'Displays numerical values of the Volume Delta\\n\\n' +\n         ' - green above the bar for positive delta\\n' +\n         ' - red below the bar for negative delta\\n' +\n         ' - orange when the polarity of the volume delete does not match the polarity of the bar'\nvdNV   = input.bool(false, 'Volume Delta Numerical Values', inline='V73', group = \nvdLS  = input.string('Tiny', \"\", options=['Auto', 'Tiny', 'Small', 'Normal'], inline\notGR   = 'Other Features'\nvlTT   = 'Toggles the visibility of the average volume over a selected period of time\\n\\nNote: Applicable whe\nvlMA   = input.bool(true, 'Volume MA', inline='V3', group = otGR, tooltip = vlTT)\nvlLN   = input.int(13, '', inline='V3', minval = 1, group = otGR)\nvlMC   = input.color( color.new(#ff9800, 43), '', inline='V3', group = otGR)\nsigTT  = 'Toggles the visibility of the Smoothing Line, calculated by applying an exponentially weighted movi\n         'Note: Applicable when Cumulative Volume Delta display is enabled'\nsigSH  = input.bool(true, 'CVD Smoothing', inline='SMT1', group = otGR, tooltip = \nsigML  = input.int(7 , \"\",  minval = 1, inline='SMT1', group = otGR)\nsigC   = input.color( color.new(#FF6D00, 33), '', inline='SMT1', group = otGR)\nvdGR   = 'Volume Delta, Others'\nvdUC   = input.color( color.new(#26a69a, 33), 'Volume Delta : Positive' , inline=\nvdDC   = input.color( color.new(#ef5350, 33), 'Negative', inline='V1', group = vdGR\nvlUC   = input.color( color.new(#9598a1, 53), 'Volume Histogram : Growing', inline\nvlDC   = input.color( color.new(#9598a1, 83), 'Falling', inline='V2', group = vdGR\nlnTT   = 'Display Length is the length of the visual objects presented with this indicator. Possible values [\n         'only if a single line and/or a single histogram enabled, second line or histogram will reduce lengh\n         'Note: When an indicator\\'s output is in a different scale from the price scale then the general app\n         'Unlike the general approach, this script presents the visuals on top of the price chart, which requ\n         'to re-scale the indicator\\'s output to fit on top of the price chart. Besides re-scale calculations\n         'also differ which brings us to the limitation of PineScript (number of line, box, label limits) and\nvdLN   = input.int(100, 'Display Length', minval = 5, step = 5, maxval = 500, group\nvdLN  := last_bar_index < vdLN ? last_bar_index : vdLN\nvdPL   = input.string('Bottom', 'Placement', options = ['Top', 'Bottom'], group = \nvdHT   = input.float(.7, 'Volume Delta Height' , minval = .1, maxval = 7, step = .\nvlHT   = input.float(.7, 'Volume Histogram Height' , minval = .1, maxval = 7, step\nvvVO   = input.float(.07, 'Vertical Offset' , minval = -.7, maxval = .7, step = .01\ncvdGR  = \"Cumulative Volume Delta, Others\"\ncvdW   = input.int(2 , \"CVD Line, Width\", minval = 1, maxval = 5, inline='CVD', group\ncvdC   = input.color( color.new(#2962FF, 33), 'Color', inline='CVD', group = cvdGR\ncvdBU  = input.color( color.new(#2962FF, 89), 'CVD Area/Baseline, Gradient Coloring'\ncvdBD  = input.color( color.new(#FF6D00, 89), '', inline='CVD1', group = cvdGR)\ncvdCU  = input.color( color.new(#26a69a, 13), 'CVD Candles Color, Positive' , inline\ncvdCD  = input.color( color.new(#ef5350, 13), 'Negative', inline='CV1', group = cvdGR\nsigBG  = input.bool(true, \"CVD/Smoothing Background\", inline = 'BG', group = cvdGR\nsigBT  = input.int(89 , \"\", inline = 'BG',  minval = 0, maxval = 100, group = cvdGR\n//-----------------------------------------------------------------------------}\n// User Defined Types\n//-----------------------------------------------------------------------------{\n// @type        bar properties with their values \n//\n// @field o     (float) open price of the bar\n// @field h     (float) high price of the bar\n// @field l     (float) low price of the bar\n// @field c     (float) close price of the bar\n// @field v     (float) volume of the bar\n// @field i     (int) index of the bar\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    float v = volume\n    int   i = bar_index\n//-----------------------------------------------------------------------------}\n// Variables\n//-----------------------------------------------------------------------------{\nbar b = bar.new()\nnzV   = nz(b.v)\nvar aCVD = array.new_line()\nvar aVD  = array.new_box()\nvar aBG  = array.new_linefill()\nvar aDV  = array.new_label()\nmInMS = 60 * 1000\n//-----------------------------------------------------------------------------}\n// Functions/Methods\n//-----------------------------------------------------------------------------{\n// @function     Calculates the volume of up and down bars\n//\n// @returns      [float, float] the volume of up bars, and the volume of down bars\nf_calcV() =>\n    uV = 0., dV = 0.\n    switch\n        vdCM == vdT1 and (b.c - b.l) > (b.h - b.c) => uV += nzV\n        vdCM == vdT1 and (b.c - b.l) < (b.h - b.c) => dV -= nzV\n        vdCM == vdT2 and b.c > b.o => uV += nzV\n        vdCM == vdT2 and b.c < b.o => dV -= nzV\n        b.c > nz(b.c[1]) => uV += nzV\n        b.c < nz(b.c[1]) => dV -= nzV\n        nz(uV[1]) > 0 => uV += nzV\n        nz(dV[1]) < 0 => dV -= nzV\n        [uV, dV]\n// @function     Calculates the Lower Timeframe based on the Input or Chart Resolution\n//\n// @returns      [string] Lower Timeframe string\nf_calcLTF(_tf) =>\n    int tfInMs = timeframe.in_seconds() * 1000\n    switch _tf\n        'Auto'   =>  tfInMs <=        1 * mInMS  ? '1S'  : \n                     tfInMs <=        2 * mInMS  ? '5S' : \n                     tfInMs <=        3 * mInMS  ? '10S' : \n                     tfInMs <=        5 * mInMS  ? '15S' : \n                     tfInMs <=       15 * mInMS  ? '30S' : \n                     tfInMs <=       60 * mInMS  ? '1' : \n                     tfInMs <=      120 * mInMS  ? '3' : \n                     tfInMs <=      240 * mInMS  ? '5' : \n                     tfInMs <=     1440 * mInMS  ? '15' : \n                     tfInMs <= 7 * 1440 * mInMS  ? '60' : 'D'\n        '1 Sec'  => '1S'\n        '5 Sec'  => '5S'\n        '10 Sec' => '10S'\n        '15 Sec' => '15S'\n        '30 Sec' => '30S'\n        '1 Min'  => '1'\n        '3 Min'  => '3'\n        '5 Min'  => '5'\n        '15 Min' => '15'\n        '30 Min' => '30'\n        '1 Hour' => '60'\n        '4 Hour' => '240'\n        '1 Day'  => '1D'\n//-----------------------------------------------------------------------------}\n// Calculations\n//-----------------------------------------------------------------------------{\n[uV, dV] = request.security_lower_tf(syminfo.tickerid, f_calcLTF(vdLT), f_calcV())\ntuV  = uV.sum()\ntdV  = dV.sum()\nvd   = tuV + tdV\ncvd  = ta.cum(vd)\nsig  = sigSH ? ta.rma(cvd, sigML) : na\npHST = ta.highest(b.h, vdLN)\npLST = ta.lowest (b.l, vdLN)\npCHG = (pHST - pLST) / pHST\noHST = ta.highest(cvd, vdLN)\noLST = ta.lowest (cvd, vdLN)\nvdHS = ta.highest(vd, vdLN)\nvHST = ta.highest(nzV, vdLN)\nvCHG = nzV/ta.sma(nzV, vlLN)\nbull = b.c > b.o\nvlPL = vdHG == vlT3 ? vdPL : vdPL == 'Top' ? 'Bottom' : 'Top'\nvdHT := vdHG == vlT3 or vdHG == vlT4 ? vdHT + 1.5 : vdHT\nnvS = switch vdLS\n    'Auto'   => size.auto\n    'Tiny'   => size.tiny\n    'Small'  => size.small\n    'Normal' => size.normal\nif barstate.islast and nzV\n    if aCVD.size() > 0\n        for i = 1 to aCVD.size()\n            line.delete(aCVD.shift())\n    if aVD.size() > 0\n        for i = 1 to aVD.size()\n            box.delete(aVD.shift())\n    if aBG.size() > 0\n        for i = 1 to aBG.size()\n            linefill.delete(aBG.shift())\n    if aDV.size() > 0\n        for i = 1 to aDV.size()\n            label.delete(aDV.shift())\n        for bI = 0 to vdLN - 1\n        if array.size(aCVD) < 500\n            if cvdSH != 'None' and cvdSH != cvdT5\n                aCVD.push(line.new(b.i[bI]    , (cvdSH  == cvdT1 ? pLST : cvdSH ==\n                                   b.i[bI + 1], (cvdSH  == cvdT1 ? pLST : cvdSH ==\n                                   xloc.bar_index, extend.none, cvdSH == cvdT4 ? color.from_gradient\n            if cvdSH == cvdT3 or cvdSH == cvdT4\n                aCVD.push(line.new(b.i[bI], pHST * (1 + pCHG * (cvdSH == cvdT4 ? .\n                aBG.push(linefill.new(aCVD.get(vlMA and vdHG == vlT3 or vlMA and vdHG\n            if sigSH and cvdSH != 'None'\n                aCVD.push(line.new(b.i[bI]    , (cvdSH  == cvdT1 or cvdSH == cvdT5\n                                   b.i[bI + 1], (cvdSH  == cvdT1 or cvdSH == cvdT5\n                                   xloc.bar_index, extend.none, sigC, line.style_solid\n            if sigBG and cvdSH != 'None' and sigSH and cvdSH != cvdT3 and cvdSH !=\n                aBG.push(linefill.new(aCVD.get(vlMA and vdHG == vlT3 or vlMA and vdHG\n            if vlMA and vdHG == vlT3 or vlMA and vdHG == vlT4\n                aCVD.push(line.new(b.i[bI]    , (vlPL == 'Top' ? pHST * (1 + pCHG \n                                   b.i[bI + 1], (vlPL == 'Top' ? pHST * (1 + pCHG \n                                   xloc.bar_index, extend.none, vlMC, line.style_solid\n        if array.size(aVD) < 500\n            if vdHG == vlT3 or vdHG == vlT4\n                aVD.push(box.new (b.i[bI],  vlPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  b.i[bI], (vlPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  bull[bI] ? vlUC : vlDC, 2, bgcolor = color(na)))\n            if vdHG != vlT2 and vdHG != 'None'\n                aVD.push(box.new (b.i[bI],  vdPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  b.i[bI], (vdPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  vd[bI] > 0 ? vdUC : vdDC, 2, bgcolor = color(na)\n            if vdHG == vlT2\n                aVD.push(box.new (b.i[bI],  vdPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  b.i[bI], (vdPL == 'Top' ? pHST * (1 + pCHG * vvVO\n                                  vd[bI] > 0 ? vdUC : vdDC, 2, bgcolor = color(na)\n            if cvdSH == cvdT5\n                aVD.push(box.new (b.i[bI], pLST + (cvd[bI] -  oLST) * (pHST - pLST\n                                  b.i[bI], pLST + (cvd[bI + 1] -  oLST) * (pHST - \n                                  vd[bI] > 0 ? cvdCU : cvdCD, 2, bgcolor = color(na\n                    vdS =  'Total Volume : '   + str.tostring(nzV[bI] , format.volume) +\n                 '\\nBuy Volume   : '   + str.tostring(tuV[bI] , format.volume) +\n                 '\\nSell Volume    : ' + str.tostring(-tdV[bI], format.volume) +\n                 '\\nVolume Delta : '   + str.tostring(vd[bI]  , format.volume)\n            if vdNV\n                if math.sign(b.c[bI] - b.o[bI]) != math.sign(vd[bI]) \n                    aDV.push(label.new(b.i[bI], bull[bI] ? b.h[bI] : b.l[bI], str.tostring\n                else\n                    aDV.push(label.new(b.i[bI], bull[bI] ? b.h[bI] : b.l[bI], str.tostring\n            if vdDV and math.sign(b.c[bI] - b.o[bI]) != math.sign(vd[bI])\n                aDV.push(label.new(b.i[bI], b.h[bI] * (1 + pCHG * .04), '', color \n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Adaptive MACD indicator is an adaptive version of the popular Moving Average Convergence Divergence (MACD) oscillator, returning longer-term variations during trending markets and cyclic variations during ranging markets while filtering out noisy variations. \ud83d\udd36 USAGE The proposed oscillator contains all the elements within a regular MACD, such as a signal line and histogram. A MACD value above 0 would indicate up-trending variations, while a value under 0 would be indicating down-trending variations. Just like most oscillators, our proposed Adaptive MACD is able to return divergences with the price. As we can see in the image above ranging markets will make the Adaptive MACD more conservative toward more cyclical conservations, filtering out both noise and longer-term variations. However, when longer-term variations (such as in a trending market) are prominent the oscillator will conserve longer-term variations. The R2 Period setting determines when trending/ranging markets are detected, with higher values returning indications for longer intervals. The fast and slow settings will act similarly to the regular MACD, however, closer values will return more cyclical outputs. The image above compares our proposed MACD (top) with a regular MACD (bottom), both using fast = 19 and slow = 20. \ud83d\udd36 DETAILS It is common to be solely interested in the trend component when the market is trending, however, during a ranging market it is more common to observe a more prominent cyclical/noise component. We want to be able to preserve one of the components at the appropriate market conditions, however, the regular MACD lack the ability to preserve cyclical component with high accuracy. The MACD is an IIR bandpass filter. In order to obtain a lower passband bandwidth and a more symmetrical magnitude response (which would allow to conserve more precise cyclical variations) we can directly change the system calculation: y[t] = (price[t] - price[t-1]) \u00d7 g + ((1 - a1) + (1 - a2)) \u00d7 y[t-1] - (1 - a1) \u00d7 (1 - a2) \u00d7 y[t-2] where: a1 = 2/(fast + 1)a2 = 2/(slow + 1)g = a1 - a2 Using division instead of multiplication on the second feedback weight allows further weighting the 2 samples lagged output, returning a more desirable magnitude response with a higher degree of filtering on both ends of the spectrum as shown in the image below: We are interested in conserving cycles during ranging markets, and longer-term variations during trending markets, we can do this by interpolating between our two filter coefficients: \u03b1 \u00d7 [(1 - a1) \u00d7 (1 - a2)] + (1 - \u03b1) \u00d7 [(1 - a1) / (1 - a2)] where 1 > \u03b1 > 0. \u03b1 is measuring if the market is trending or ranging, with values closer to 1 indicating a trending market. We see that for higher values of \u03b1 the original coefficient of the MACD is used. The image below shows various magnitude responses given multiple values of \u03b1: We use a rolling R-Squared as \u03b1, this measurement has the benefit of indicating if the market is trending or ranging, as well as being constrained within range (0, 1), and having a U-shaped distribution. If you are interested to learn more about the MACD see:  \ud83d\udd36 SETTINGS R2 Period: Calculation window of the R-Squared. Fast: Fast period for the calculation of the Adaptive MACD, lower values will return more noisy results. Slow: Slow period for the calculation of the Adaptive MACD, higher values will return result with longer-term conserved variations. Signal: Period of the EMA applied to the Adaptive MACD."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"Adaptive MACD [LuxAlgo]\", \"LuxAlgo - Adaptive MACD\")\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input.int(20, 'R2 Period', minval = 2)\nfast = input.int(10, minval = 2)\nslow = input.int(20, minval = 2)\nsignal = input.int(9, minval = 2)\n//-----------------------------------------------------------------------------}\n//Ultimate MACD\n//-----------------------------------------------------------------------------{\nvar macd = 0.\nvar lag  = (signal - 1) / 2\nvar a1   = 2 / (fast + 1)\nvar a2   = 2 / (slow + 1)\nr2 = .5 * math.pow(ta.correlation(close, bar_index, length), 2) + .5\nK = r2 * ((1 - a1) * (1 - a2)) + (1 - r2) * ((1 - a1) / (1 - a2))\nmacd := (close - close[1]) * (a1 - a2) + (-a2 - a1 + 2) * nz(macd[1]) - K * nz(macd\nema = ta.ema(macd, signal)\nhist = macd - ema\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\nhist_css = hist > 0 and hist > hist[1] ?  #5b9cf6 \n  : hist > 0 and hist < hist[1] ?  color.new(#5b9cf6, 50)\n  : hist < 0 and hist < hist[1] ?  #f77c80\n  :  color.new(#f77c80, 50)\nplot(hist, 'Histogram', hist_css, 1, plot.style_columns)\nplot(macd, 'MACD', chart.fg_color)\nplot(ema, 'Signal',  #ff5d00)\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added an option to hide the heatmap and convert liquidation ranges from boxes to lines. Thank you @NetoDav for the request (:                                                    Release Notes:                                                    Update to the lower timeframe resolution that is requested.  The user input was removed. Instead, a portion of @Pinecoders coder from their library \"lower_tf\" was used; thank you to them!!  With this change the script will auto-calculate a \"more efficient\" lower timeframe resolution relative to your chart's timeframe. This should improve efficiency! Thank you (:                                                    Release Notes:                                                    Last one for the night (: Fixed an occurrence where, if a non \"USDT.P\" crypto symbol was loaded the indicator would generate a runtime error.  While not an error, the script will now load on non \"USDT.P\" crypto tickers!!  Thank you (:                                                    Release Notes:                                                    Minor update to calculation                                                    Release Notes:                                                    Fix for the previous fix                                                    Release Notes:                                                    Ranges default to \"off\" on non-crypto charts"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at \n// \u00a9 KioseffTrading\n//@version=5\nindicator(\"Volume Dots\", overlay = true, max_lines_count = 500, max_labels_count \n// \nimport            PineCoders/Time/4              as pct\nimport HeWhoMustNotBeNamed/BinaryInsertionSort/1 as HeWho\n// \naction2                        = input.bool  (defval = true, title = \"Show Liquidation Ranges\"\nshowValues                     = input.bool  (defval = true, title = \"Show VOL/OI Values in Grid\"\naction                         = input.string(defval = \"Find As Many Vol/OI Extremities As Possible\"\ndata                           = input.bool  (defval = false, title = \"Use OI Instead Of Volume For Dots?\"\nagg                            = 100 - input.float (minval = 0.01, title = \"Aggressiveness\"\nnake                           = input.bool  (defval = false, title = \"Naked Levels Only?\"\nactint                         = input.int   (defval = 20, title = 'If You Selected \"Show Extremities For The Data On\nti                             = input.bool  (defval = false, title = \"Use Fixed Range\"\nti2                            = input.time  (defval = timestamp(\"04 Apr 2022 00:00 +0300\"\ndt                             = input.int   (defval = 15, title = \"Levels In Table Shown\"\nshowl                          = input.int   (defval = 10, title = \"Lines Shown\",\nlinebool                       = input.bool  (defval = false, title = \"Only Show Lines Within a % of Price\"\nlinedist                       = input.float (defval = 3, title = \"%\", minval = 0\nsrcol                          = input.bool  (defval = false, title = \"Color Lines As Support/Resistance\"\nupcol                          = input.color (defval =  color.lime, title = \"Up Color Vol\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\"\ndncol                          = input.color (defval =  color.red , title = \"Down Color Vol\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\u2005\"\nupcoloi                        = input.color (defval =  color.blue, title = \"OI Up + Price Up\u2005\u2005\u2005\u2005\u2005\u2003\"\ndncoloi                        = input.color (defval =  color.orange , title = \"OI Down + Price Down\"\nupcoloi2                       = input.color (defval =  color.yellow, title = \"OI Up + Price Down\u2003\"\ndncoloi2                       = input.color (defval =  color.purple , title = \"OI Down + Price Up\u2005\u2005\u2005\u2005\u2005\"\nsort                           = input.string(defval = \"Descending\", title = \"Sort Table Data\"\nsiz                            = input.string(defval = \"Normal\", title = \"Table Size\"\nmove                           = input.bool  (defval = true, title = \"Show OI Delta Lines\"\nshowcir                        = input.bool  (defval = true, title = \"Show Violation Circles\"\nbox2Line                       = input.bool (defval = false,         title = \"Change Liquidation Boxes to Lines\"\nminlevl                        = input.string(defval = \"Auto\", title = \"Min Liquidation Level Shown\"\nuserDefinedTime                = input.bool  (defval = false, title = \"Fixed Range\"\ntimtest                        = input.time  (defval = timestamp(\"04 Apr 2023 00:00 +0300\"\ntimtest2                       = input.time  (defval = timestamp(\"20 Apr 2023 00:00 +0300\"\nmethod equal                   (string id, value) => id == value\nmethod notEqual                (string id, value) => id != value\nreq() => \n        cont = switch str.contains(syminfo.ticker, \"T.P\")\n                true => syminfo.ticker + \"_OI\"\n        =>      str.endswith(syminfo.ticker, \"USDT\") ? syminfo.ticker + \".P_OI\" :\n            switch syminfo.type\n        \"crypto\" =>          cont\n        =>                   string(na)\nr3() => \n    [R1, R2, R3, R4, R5] = switch syminfo.type\n        \"crypto\" => [  close-close[1], high, low, open, close    ]\n        => [float(na), float(na), float(na), float(na), float(na)]\n// Thank you PineCoders\nfloat chartTfInMinutes = timeframe.in_seconds() / 60.\nint  ONE_MIN    = 1\nint  ONE_SEC    = ONE_MIN  / 60\nint  ONE_HOUR   = ONE_MIN  * 60\nint  ONE_DAY    = ONE_HOUR * 24\nint  ONE_WEEK   = ONE_DAY  * 7\nbool  marketIs24Hours  = syminfo.type == \"crypto\" or syminfo.type == \"forex\"\nltfint = switch \n    chartTfInMinutes <= ONE_MIN * 30  => \"1\"\n    chartTfInMinutes <= ONE_HOUR      => \"3\"\n    chartTfInMinutes <  ONE_HOUR * 2  => \"5\"\n    chartTfInMinutes <  ONE_HOUR * 4  => \"15\"\n    chartTfInMinutes <  ONE_HOUR * 6  => \"30\"\n    chartTfInMinutes <  ONE_HOUR * 12 => marketIs24Hours ? \"60\"  : \"30\"\n    chartTfInMinutes <  ONE_DAY       => marketIs24Hours ? \"120\" : \"30\"\n    chartTfInMinutes <  ONE_WEEK      => marketIs24Hours ? \"720\" : \"120\"\n// Thank you PineCoders\n[oic, oih, oil, oio, trueOic    ] = request.security_lower_tf(req(), ltfint, r3()\ntimeframeDiff                     = request.security(req(),   timeframe.period, close\n[vol, clo, clo1, hi, lo, clocalc, ltf, volSign] = request.security_lower_tf(syminfo.tickerid\n             [\n             volume, close, close[1], high, low, close - close[1], time, close >=\n             ])\ncomparison(id, value, string ) =>\n        switch string \n                \">\"  => id >  value\n        \">=\" => id >= value\n        \"==\" => id == value\n        \"<=\" => id <= value\n        \"<\"  => id <  value\n        \"!=\" => id != value\nmethod floatGreatEqual   (float  id, value) => comparison(id, value, \">=\") \nmethod floatEqual        (float  id, value) => comparison(id, value, \"==\") \nmethod floatLessEqual    (float  id, value) => comparison(id, value, \"<=\") \nmethod floatNotEqual     (float  id, value) => comparison(id, value, \"!=\") \nmethod intGreatEqual     (int    id, value) => comparison(id, value, \">=\") \nmethod intEqual          (int    id, value) => comparison(id, value, \"==\") \nmethod intLessEqual      (int    id, value) => comparison(id, value, \"<=\") \nmethod intNotEqual       (int    id, value) => comparison(id, value, \"!=\") \n   method HeWhoSort(float [] id, value, order) => \n        HeWho.binary_insertion_sort(id, value, order)\nmethod determine   (bool id, value, value2) =>\n        switch id \n                true => value\n        =>      value2\ntype timeValues\n    float [] Difference \n    float [] Close\n    int   [] Time\ntype dotValues \n        float [] Volume\n    float [] Close\n    float [] Difference\n    float [] OI \n    float [] OI2\n    int   [] Time\n    label [] Circle\n    line  [] Zone\n    float [] Rank\n    float [] perBar\n    float [] volSignArr\n    int      Start\ntype sortedMat\n        float   volM\n    float   oicM\n    int     timM\n    float   cloM\n    float   clcM\n    float   toiM\n    color   colM\n    string  valM\nvar timeMat        = timeValues.new(array.new_float(), array.new_float(), array.new_int\ntimeMat.Difference.unshift(timeframeDiff), timeMat.Close.unshift(close), timeMat.\nvar dotMat = dotValues.new(\n                          array.new_float(), array.new_float(),\n             array.new_float(), array.new_float(),\n             array.new_float(), array.new_int  (), \n             array.new_label(), array.new_line (), \n             array.new_float(), array.new_float(),\n             array.new_float(),        0\n                          )\nobj = switch syminfo.type.equal(\"crypto\")\n        true  => oic\n    false => vol\nif action.notEqual(\"Off\")\n    conditionX = switch action\n                \"Find As Many Vol/OI Extremities As Possible\"   => last_bar_index - bar_index\n                 time >= ti2 and ti and vol.size().intGreatEqual(1)\n                \"Show Extremities For The Data On My Screen\" => time >= chart.left_visible_bar_time\n                     and not ti and vol.size().intGreatEqual(1) or time >= ti2 and\n                => last_bar_index - bar_index <= 500\n    if conditionX\n                if obj.size().intGreatEqual(1)\n                        if action.notEqual(\"Show The Highest Vol./OI Per Bar\")\n                if nake and dotMat.Volume.size().intGreatEqual(1)\n                    for i = 0 to dotMat.Volume.size() - 1\n                        if not na(dotMat.Close.get(i))\n                                                        if     dotMat.Close.get(i).floatLessEqual(high) \n                                if dotMat.Close.get(i).floatGreatEqual(low)\n                                                                    dotMat.Close.set(i, na)\n                for i = math.min(obj.size() - 1, clo.size() - 1) to 0                                                  \n                    dotMat.Volume     .unshift(vol.get(i))     , dotMat.Close    \n                    dotMat.Difference .unshift(clocalc.get(i)) , dotMat.OI       \n                    dotMat.Time       .unshift(ltf.get(i))     , dotMat.OI2      \n                                             dotMat.volSignArr.unshift(volSign.get\n                        else \n                for i = math.min(obj.size() - 1, clo.size() - 1) to 0                                                  \n                    cond = switch data \n                        false => vol.get(i).floatEqual(vol.max())\n                        =>       oic.get(i).floatEqual(math.max(oic.max(), math.abs\n                    if cond \n                                                col = switch data \n                                                        false => color.new(math.sign(clocalc.get(i)).floatEqual\n                                                        =>       color.new(math.sign(oic.get(i)).floatEqual(-1\n                                     math.sign(clocalc.get(i))      .floatEqual(-1\n                                     dncoloi, dncoloi2),  math.sign(clocalc.get(i\n                                     -1).determine(upcoloi2, upcoloi)), 33)\n                        OItxt = switch syminfo.type.equal(\"crypto\")\n                            true => \"\\nOI: \" +  str.tostring(oic.get(i), format.mintick\n                            => \"\"\n                        dotMat.Circle.unshift( \n                                                         label.new(\n                                         time, clo.get(i), \"\u2b24\",\n                                         tooltip   =  \"VOL: \" + (math.sign(clocalc\n                                         str.tostring(vol.get(i), format.volume)  \n                                         xloc      = xloc.bar_time, \n                                         color     =  #000000, \n                                         textcolor = col,\n                                         size      = size.tiny,\n                                         style     = label.style_text_outline\n                                         ))\n                        dotMat.Zone.unshift(\n                                             line.new(time, clo.get(i), time, clo\n                                                             color = col, \n                                                             xloc = xloc.bar_time\n                                                             ))\n                        dotMat.perBar.unshift(data.determine(vol.get(i) , oic.get\n    if vol.size().intEqual(0)\n        dotMat.Start := time\n    var grid     = matrix.new<box>(5, 20)\nif barstate.islast and action.notEqual(\"Off\")\n        if action.notEqual(\"Show The Highest Vol./OI Per Bar\")\n                if dotMat.Circle.size().intGreatEqual(1) \n                        for i = 0 to dotMat.Circle.size() - 1\n                dotMat.Circle.shift().delete()\n                if dotMat.Zone.size()  .intGreatEqual(1)\n                        for i = 0 to dotMat.Zone.size() - 1\n                dotMat.Zone.shift().delete()\n                                  if ti\n                        line.new(            ti2, high, ti2, low, \n                                 xloc = xloc.bar_time  , extend = extend.both, \n                                 color = chart.fg_color, width  = 2   \n                                  )    \n        var count = 1, vcopy = dotMat.Volume.copy(), ocopy = dotMat.OI.copy(), var\n        switch data\n                    false => vcopy.sort(order.descending)\n            =>       ocopy.sort(order.descending)\n                for i = 0 to 249\n            [bool1, bool2, index] = switch data\n                false => [dotMat.Volume.includes(vcopy.get(i)), action.equal(stringBool\n                         vcopy.percentrank(i).floatGreatEqual(agg) , i.intLessEqual\n                                =>       [dotMat.OI.includes(ocopy.get(i))    , action.equal(stringBool\n                         ocopy.percentrank(i).floatGreatEqual(agg) , i.intLessEqual\n            if bool1\n                if bool2\n                    if dotMat.Close.indexof(dotMat.Close.get(index)).intNotEqual(\n                                            append = switch data\n                                                    false         => vcopy.get(i)\n                            true          => ocopy.get(i)\n                        [coloR, strinG] = if not data\n                            switch math.sign(dotMat.Difference.get(index))\n                                -1 => [dncol, \"-\"]\n                                =>    [upcol, \"\" ]\n                        else \n                            switch math.sign(dotMat.Difference.get(index))\n                                -1 => [math.sign(dotMat.OI2.get(index)).floatEqual\n                                =>    [math.sign(dotMat.OI2.get(index)).floatEqual\n                        SM.add_col(SM.columns(), \n                                         array.from(\n                                                     sortedMat.new(volM =  dotMat\n                                                     sortedMat.new(oicM =  dotMat\n                                                     sortedMat.new(timM =  dotMat\n                                                     sortedMat.new(cloM =  dotMat\n                                                     sortedMat.new(clcM =  dotMat\n                                                     sortedMat.new(toiM =  dotMat\n                                                     sortedMat.new(colM =  coloR                       \n                                                     sortedMat.new(valM =  strinG\n                                                                                                         ))\n                                                count += 1, dotMat.Rank.push(append), \n                                               tan3.push(sort.equal(\"Occurrence\")\n                                             .determine(dotMat.Time.get(index), data\n                                             .determine(dotMat.OI.get(index)  , dotMat\n                                             )))\n                                else \n                                        break\n        var uniArr   = array.from(\"\u2776\",\"\u2777\",\"\u2778\",\"\u2779\",\"\u277a\",\"\u277b\",\"\u277c\",\"\u277d\",\"\u277e\",\"\u277f\",\"\u24eb\",\"\u24ec\"\n        colorr       = array.new_color(), var tan2 = array.new_float(), var tan4 \n        for i = 0 to SM.columns() - 1 \n            condition = switch action\n                \"Find As Many Vol/OI Extremities As Possible\" => data.determine(ocopy\n                                                                 vcopy.percentrank\n                                => i.intNotEqual(-1)\n            if condition\n                rank = dotMat.Rank.percentrank(i)\n                SIZE = switch rank.floatNotEqual(-1)\n                    rank <= 10 => size.tiny\n                    rank <= 25 => size.small\n                    rank <= 50 => size.normal\n                    rank <= 75 => size.large\n                    =>            size.huge\n                OItxt = switch syminfo.type.equal(\"crypto\")\n                                        true => \"\\nOI: \" +  str.tostring(SM.row(5).get(i).toiM, format.mintick\n                    =>      \"\"\n                                    dotMat.Circle.push(label.new(int(SM.row(2).get(i).timM), SM.row(3\n                                                                                                  text      = action.equal(stringBool\n                                                 tooltip   = \"VOL: \" + (math.sign\n                                                 str.tostring(SM.row(0).get(i).volM\n                                                                                                  xloc      = xloc.bar_time, \n                                                 color     =  #000000, \n                                                 textcolor = color.new(SM.row(6).\n                                                 size      = action.equal(stringBool\n                                                 style     = label.style_text_outline\n                                                 ))\n                colorr.push(color.new(SM.row(6).get(i).colM, 33)), tan4.push(SM.row\n                tan2.HeWhoSort(sort.equal(\"Occurrence\").determine(SM.row(2).get(i\n        if not nake\n                        if showl.intNotEqual(0)\n                                countLab = 0\n                                for i = 0 to dotMat.Circle.size() - 1\n                                        if dotMat.Circle.get(i).get_x().intGreatEqual(tan4.max(math.min\n                                                if linebool  and dotMat.Circle.get(i).get_y().floatGreatEqual\n                                     and dotMat.Circle.get(i).get_y().floatLessEqual\n                                                             or not linebool\n                            finCol = switch srcol\n                                                                true => dotMat.Circle.get(i).get_y().floatGreatEqual\n                                =>      colorr.get(i)\n                            dotMat.Zone.push(line.new(\n                                                                                  dotMat.Circle.get(i).get_x(), dotMat.Circle.\n                                                 color = finCol,\n                                                 xloc = xloc.bar_time\n                                                 ))\n                            countLab += 1\n                            if countLab.intEqual(showl)\n                                break\n        else \n                        if action.equal(stringBool) or action.equal(\"Show Extremities For The\n                                if dotMat.Circle.size().intGreatEqual(1) \n                                        for i = 0 to dotMat.Circle.size() - 1\n                                                if linebool  and dotMat.Circle.get(i).get_y().floatGreatEqual\n                                     and dotMat.Circle.get(i).get_y().floatGreatEqual\n                                                     or not linebool\n                                                        dotMat.Zone.push(line.new(\n                                                                                  dotMat.Circle.get(i).get_x(),     dotMat\n                                         pct.timeFrom(\"bar\", 40, \"chart\"), dotMat\n                                         xloc  = xloc.bar_time, color = color.new\n                                         ))\n        sz = switch siz\n                    \"Auto\"   =>  size.auto\n            \"Tiny\"   =>  size.tiny\n            \"Small\"  =>  size.small\n            \"Normal\" =>  size.normal\n            \"Large\"  =>  size.large\n            \"Huge\"   =>  size.huge\n        if float(dt).floatGreatEqual(1)\n                    var tab    = table.new(position.top_right, 4, dt+2, frame_width = 1, \n                                                         frame_color  =  color.white\n                                                         border_width = 1, \n                                                         border_color =  color.white\n                                                         nakeCount    = 0\n                for i = 0 to nake.determine(dotMat.Circle.size() - 1, math.min(dt - 1\n                occCond = tan3.indexof(tan2.get(i)) \n                                if sort.equal(\"Occurrence\")\n                    tan3.set(occCond, 0)\n                                if SM.row(0).get(i).volM.floatNotEqual(0)\n                    tab.cell(0, i + 1, text = SM.row(7).get(occCond).valM + str.tostring\n                                                         bgcolor          =  color.new\n                                                         text_color       = SM.row\n                                                         text_size        = sz, \n                                                         text_font_family = font.family_monospace\n                                                         )\n                    tab.cell(1, i + 1, text = str.tostring(SM.row(3).get(occCond)\n                                                         bgcolor          =  color.new\n                                                         text_color       = SM.row\n                                                         text_size        = sz, \n                                                         text_font_family = font.family_monospace\n                                                         )\n                    if not na(oic.sum()) and syminfo.type.equal(\"crypto\")\n                                                tab.cell(2, i + 1, text = str.tostring(SM.row(5).get(occCond\n                                                             bgcolor           = \n                                                             text_color        = \n                                                                                                                                              text_size         = \n                                                             text_font_family  = \n                                                             )\n                    nakeCount += 1\n                    if nakeCount.intEqual(dt)\n                        break\n            tab.cell(0, 0, \"Vol.\" , text_color =  color.white, bgcolor =  color.new\n            tab.cell(1, 0, \"Price\", text_color =  color.white, bgcolor =  color.new\n            if not na(oic.sum()) and syminfo.type.equal(\"crypto\")\n                tab.cell(2, 0, \"OI\", text_color =  color.white, bgcolor =  color.new\n            if dotMat.Circle.size().intEqual(0) and nake\n                                tab.cell(0, 1, \"No Naked Levels Detected\", text_color =  color.white\n                tab.merge_cells(0, 1, 2, 1)\n            if action.notEqual(stringBool)\n                                line.new(dotMat.Start, high, dotMat.Start, low, \n                                             extend = extend.both, \n                                             color  =  color.white, \n                                             width  = 4, \n                                             xloc   = xloc.bar_time\n                                             )\n                                label.new(dotMat.Start, high * 1.01, \n                                     style     = label.style_label_right, \n                                     color     =  #000000,\n                                     xloc      = xloc.bar_time, \n                                     textcolor =  color.white, \n                                     size      = size.small, \n                                     text      = \"Earliest Start Date\"\n                                     )\n    else \n                if dotMat.Circle.size().intGreatEqual(1) \n                        for i = 0 to dotMat.Circle.size() - 1\n                                dotMat.perBar.set(i, math.abs(dotMat.perBar.get(i)))\n                        for i = 0 to dotMat.Circle.size() - 1\n                rank = dotMat.perBar.percentrank(i)\n                                SIZE = switch rank.floatNotEqual(-1)\n                    rank <= 10 => size.tiny\n                    rank <= 25 => size.small\n                    rank <= 50 => size.normal\n                    rank <= 75 => size.large\n                    =>            size.huge\n                dotMat.Circle.get(i).set_size(SIZE)\n                            if i.intLessEqual(showl - 2)\n                                        if linebool\n                        if dotMat.Circle.get(i).get_y().floatGreatEqual(close * (\n                       and dotMat.Circle.get(i).get_y().floatLessEqual (close * (\n                                                    dotMat.Zone.get(i).set_x2(pct.timeFrom(\"bar\", 40, \"chart\"\n                                        else \n                                                dotMat.Zone.get(i).set_x2    (pct.timeFrom(\"bar\", 40, \"chart\"\n                                        switch srcol\n                        true =>  dotMat.Zone.get(i).set_color(dotMat.Circle.get(i\n                                 floatGreatEqual(close).determine(dncol , upcol))\n                                                =>      continue\n// Start\n// Thank you Donovan Wall for the great range filter code!! \nCond_EMA(x, cond, n)=>\n    var val     = array.new_float(0)\n    var ema_val = array.new_float(1)\n    if cond\n        val.push(x)\n        if val.size( )> 1\n            val.remove(0)\n        if na(ema_val.get(0))\n            ema_val.fill(val.get(0))\n        ema_val.set(0, (val.get(0) - ema_val.get(0))*(2/(n + 1)) + ema_val.get(0)\n    EMA = ema_val.get(0)\n    EMA\nrng_size(x, scale, qty, n)=> \n    ATR      = Cond_EMA(ta.tr(true), 1, n)\n    AC       = Cond_EMA(math.abs(x - x[1]), 1, n)\n    rng_size = qty*AC  \nrng_filt(h, l, rng_, n, type, smooth, sn, av_rf, av_n)=>\n    rng_smooth = Cond_EMA(rng_, 1, sn)\n    r          = smooth ? rng_smooth : rng_\n    var rfilt  = array.new_float(2, (h + l)/2)\n    rfilt.set(1, rfilt.get(0))\n        if h - r > rfilt.get(1)\n        rfilt.set(0, h - r)\n    if l + r < rfilt.get(1)\n        rfilt.set(0, l + r)\n    rng_filt1 = rfilt.get(0)\n        hi_band1  = rng_filt1 + r, lo_band1  = rng_filt1 - r\n    rng_filt2 = Cond_EMA(rng_filt1, rng_filt1 != rng_filt1[1], av_n)\n    hi_band2  = Cond_EMA(hi_band1,  rng_filt1 != rng_filt1[1], av_n)\n    lo_band2  = Cond_EMA(lo_band1,  rng_filt1 != rng_filt1[1], av_n)\n        [rng_filt, hi_band, lo_band] = switch av_rf \n             true => [rng_filt2, hi_band2, lo_band2]               \n        =>      [rng_filt1, hi_band1, lo_band1]\n       [hi_band, lo_band, rng_filt]\n[h_band, l_band, filt] = rng_filt(close, close, rng_size((close + close)/2, \"Average Change\"\n// Thank you Donovan Wall for great range filter code!! \n// End\nvar int boxCount = 0\ntype liqValues\n    matrix <float> Average\n    matrix <int>   Violations\n    matrix <float> TickVol\n    matrix <float> TickOI\n    float []       Levels\n    line  []       boxLines\n    line           rightUp\n    line           rightDn\n    line           leftUp\n    line           leftDn\n    line           startU\n    line           startD\nvar liquidation = liqValues.new(\n                                                                  matrix.new<float>(5 , 0   ), matrix.new<int>  (2\n                                 matrix.new<float>(21, 1000), matrix.new<float>(21\n                                             array.new_float(), array.new_line())\n                                             orientation = matrix.new<float>(2, 5\nmethod expCalc(array <float> id)                   => \n    math.exp(id.avg())\nmethod multiply(float id, string PM, float )       =>\n        switch PM\n               \"+\"  => id * (1 + ((1./( float ))  + 0.004))\n        \"-\"  => id * (1 - ((1./( float ))  + 0.004))\nmethod reduced(array <float> id, float , string )  => \n    switch string \n            \"P\" => id.expCalc().multiply(\"+\", float )\n        \"N\" => id.expCalc().multiply(\"-\", float )\nmethod divSubtract(array<float> id, float, float2) =>\n    (id.reduced(float , \"P\") - id.reduced(float2, \"N\")) / 5\nmethod double_binary_search_leftmost(array <float> id, column)                =>\n    n  = id.binary_search_leftmost (orientation.get(0, column))\n    n1 = id.binary_search_leftmost (orientation.get(1, column))\n    [n, n1]\nmethod finSetVol(matrix <float> id, int i, int row, int start, int end)       =>\n        for x = start to end \n        id.set (row, i, id.get(row, i) + liquidation.TickVol.get(i, x))\nmethod finSetOI (matrix <float> id, int i, int row, int start, int end)       =>\n        for x = start to end \n        id.set (row, i, id.get(row, i) + liquidation.TickOI.get(i, x))\nmethod tickSet(matrix<float> id, float value, int column, int loop, int calc) => \n        id.set(math.max(boxCount, 0), column, nz(nz(id.get(math.max(boxCount, 0), column\nmethod netAdjust(array <float> id) => \n    for i = 0 to id.size() - 1\n        if na(id.get(i))\n            id.set(i, 0)\n    for i = id.size() - 2 to 0\n        id.set(i, id.get(i) + id.get(i + 1))\n    if id.size().intGreatEqual(201)\n        for i = id.size() - 1 to 200\n            id.pop()\nif action2 and syminfo.type.equal(\"crypto\")\n    var oiclab  = matrix.new<label>(2)\n    OIgrid     = input.bool (defval = true ,         title = \"Use OI For Grid Color (Instead of Volume) (Crypto\n    heatmap    = input.bool (defval = true ,         title = \"Show Heatmap (Grid)\"\n    ext        = input.bool (defval = false,         title = \"Extend Grid Boxes\",\n    gridWidth  = input.int  (defval = 0,             title = \"Grid Width\",         \n    gridCol    = input.color(defval =  color.white, title = \"Border Color\",       \n    gridUp     = input.color(defval =  color.lime,  title = '\"Up\" Color',         \n    gridDn     = input.color(defval =  color.red,   title = '\"Down\" Color',       \n    var float div = 0\n    if action.equal(\"Off\") and not userDefinedTime \n        bx = box.all, la = label.all, li = line.all, lf = linefill.all\n            if bx.size().intGreatEqual(1) \n                        row = grid.rows(), col = grid.columns()\n            grid.reshape(grid.elements_count(), 1)\n                        for i = 0 to bx.size() - 1\n                if not grid.col(0).includes(bx.get(i))\n                    bx.get(i).delete()\n            grid.reshape(row, col) \n        if la.size().intGreatEqual(1) \n            for i = 0 to la.size() - 1\n                                if not oiclab.row(0).includes(la.get(i)) \n               and not oiclab.row(1).includes(la.get(i))\n                                        la.get(i).delete()\n                if li.size().intGreatEqual(1) \n            for i = 0 to li.size() - 1  \n                li.get(i).delete()\n                if lf.size().intGreatEqual(1) \n            for i = 0 to lf.size() - 1\n                lf.shift().delete()\n        var oicsum    = matrix.new<float>              (2, 0)\n    var int stime = 0, var int sbar = 0\n        if obj.size().intGreatEqual(1) and clocalc.size().intGreatEqual(1)\n        if sbar.intEqual(0) \n                        sbar := bar_index, stime := time\n        cond = switch userDefinedTime \n                        false => filt.floatGreatEqual(filt[1] - atr) and filt.floatLessEqual(\n            =>       time >= timtest and time <= timtest2\n        if cond\n            liquidation.Average.add_col(0, array.from(high, low, math.log(close),\n                        for i = 0 to math.min(obj.size(), clocalc.size()) - 1\n                if syminfo.type.equal(\"crypto\") and OIgrid\n                    if math.sign(clocalc.get(i)).floatEqual(1) \n                        switch math.sign(oic.get(i))\n                            1  => oicsum.add_col(oicsum.columns(), array.from(oic\n                            -1 => oicsum.add_col(oicsum.columns(), array.from(float\n                    else\n                        switch math.sign(oic.get(i))\n                            -1  => oicsum.add_col(oicsum.columns(), array.from(oic\n                            1   => oicsum.add_col(oicsum.columns(), array.from(float\n                                    else \n                    switch math.sign(clocalc.get(i))\n                                               1  => oicsum.add_col(oicsum.columns(), array.from(vol.get\n                        -1 => oicsum.add_col(oicsum.columns(), array.from(float(na\n                                 if liquidation.Levels.size().intGreatEqual(1)\n                for i = 0 to math.min(obj.size(), clocalc.size()) - 1\n                    highest =        liquidation.Levels.binary_search_leftmost (hi\n                    lowest  =        liquidation.Levels.binary_search_leftmost (lo\n                    for x = lowest to highest\n                                                volx = switch math.sign(clocalc.get(i))\n                                                        1 => vol.get(i)\n                            =>   vol.get(i) * -1\n                        liquidation.TickVol.tickSet(volx      , x, i, highest - lowest\n                        liquidation.TickOI .tickSet(obj.get(i), x, i, highest - lowest\n            for i = 0 to 19\n                if not barstate.islast\n                    con = div.floatGreatEqual(500)\n                    [index, pIndex, startIndex] = switch con\n                                                true => [   time    ,  time  [1], stime]\n                        =>       [bar_index, bar_index[1], sbar]\n                    if index >= math.round(startIndex + (div * (i + 1))) and pIndex\n                        boxCount += 1\n                        for z = 0 to 4\n                            liquidation.TickVol.set(math.max(boxCount, 0), z, liquidation\n                            liquidation.TickOI .set(math.max(boxCount, 0), z, liquidation\n                        for x = 0 to 4\n                            grid.set(x, boxCount,\n                                     box.new(\n                                                     grid.get(x, boxCount - 1).get_right\n                                                     liquidation.Average.row(2).reduced\n                                                     math.round(index + div), \n                                                     liquidation.Average.row(2).reduced\n                                                     xloc         = div.floatGreatEqual\n                                                     border_color = gridCol, \n                                                     border_width = gridWidth, \n                                                     bgcolor      =  color.white\n                                                 ))\n                        break\n                                   if oicsum.elements_count().intGreatEqual(90001)\n                for i = 0 to 10000\n                    oicsum.remove_col(i)\n                else    \n            if filt < filt[1] - atr and not userDefinedTime or filt > filt[1] + atr\n                liquidation.TickVol.fill(0, 0, liquidation.TickVol.rows(), 0, liquidation\n                liquidation.TickOI .fill(0, 0, liquidation.TickOI .rows(), 0, liquidation\n                liquidation.Levels.clear()\n                                        for i = 0 to grid.rows() - 1\n                    for x = 0 to grid.columns() - 1\n                        grid.get(i, x).delete()\n                                if oicsum.columns().intGreatEqual(1) \n                    for i = 0 to oicsum.columns() - 1\n                        oicsum.remove_col()\n                                if oiclab.columns().intGreatEqual(1) \n                                        for i = 0 to oiclab.columns() - 1\n                        oiclab.get(0, i).delete()\n                        oiclab.get(1, i).delete()\n                                        for i = 0 to oiclab.columns() - 1\n                        oiclab.remove_col()\n                stime := time, sbar := bar_index, div := switch (last_bar_index -\n                                        false => (last_bar_index - sbar) / 20\n                    =>       (last_bar_time - stime) / 20\n                startIndex = div.floatGreatEqual(500).determine(time, bar_index)\n                for x = 0 to 4\n                                                                grid.set(x, 0,\n                             box.new(\n                                             startIndex,\n                                             liquidation.Average.row(2).reduced(100\n                                             math.round(startIndex + div), \n                                             liquidation.Average.row(2).reduced(100\n                                             xloc         = div.floatGreatEqual(500\n                                             border_color = gridCol, \n                                             border_width = gridWidth, \n                                             bgcolor      =  color.white\n                                         ))\n                    if liquidation.Average.columns().intGreatEqual(1) \n                    for i = 0 to liquidation.Average.columns() - 1\n                        liquidation.Average.remove_col()\n                                        liquidation.Average.add_col(0 ,  array.from(\n                                                     high, \n                                                     low, \n                                                     math.log(close), \n                                                     close > open ? volume : volume\n                                                     time\n                                                                                                          ))\n                for i = 0 to 499\n                                        liquidation.Levels.HeWhoSort(close * (1 + (i/1000)), 1)\n                    liquidation.Levels.HeWhoSort(close * (1 - (i/1000)), 1)\n                boxCount := 0\n    if barstate.islast and not userDefinedTime or time[1] < timtest2 and time >= \n        [endTime, endIndex] = switch userDefinedTime\n                        false => [last_bar_time, last_bar_index]\n            true  => [timtest2, bar_index          ]\n        if userDefinedTime  \n                        x = timeMat.Time.get(timeMat.Time.indexof(timtest) + 1)\n                        line.new(x, high, x, low,    xloc = xloc.bar_time,   extend = extend.both\n            line.new(timtest2, high, timtest2, low, xloc = xloc.bar_time, extend \n                    posSum = oicsum.row(0).sum()\n        negSum = oicsum.row(1).sum()\n                minlvlu = 50, minlvld = 50,  minlvl = 50, var corners = matrix.new<liqValues\n        if minlevl.notEqual(\"Auto\")\n                        minlvlu := int(str.tonumber(minlevl))\n            minlvld := int(str.tonumber(minlevl))\n                else \n                        for i = 50 to 20 by 10\n                                if liquidation.Average.row(0).max().floatGreatEqual(liquidation.Average\n                    minlvlu := i + 10\n                                if liquidation.Average.row(1).min().floatLessEqual (liquidation.Average\n                    minlvld := i - 10\n                minlvl    := math.min(minlvlu, minlvld)    \n        if syminfo.type.equal(\"crypto\")\n                        for i = 0 to liquidation.Average.columns() - 1\n                for x = 0 to 10\n                    if liquidation.Average.get(0, i).floatGreatEqual(liquidation.\n                        liquidation.Violations.set(0, x, nz(liquidation.Violations\n            for i = 0 to liquidation.Average.columns() - 1\n                for x = 0 to 10\n                    if liquidation.Average.get(1, i).floatLessEqual(liquidation.Average\n                        liquidation.Violations.set(1, x, nz(liquidation.Violations\n            if showcir\n                uCalc = liquidation.Average.row(2).reduced(100, \"P\")\n                lCalc = liquidation.Average.row(2).reduced(100, \"N\")\n                for i = liquidation.Average.columns() - 1 to 1\n                    if liquidation.Average.get(0, i - 1).floatGreatEqual(uCalc) \n                             and liquidation.Average.get(0, i) < uCalc\n                        oiclab.add_col(oiclab.columns())\n                        oiclab.set(0, oiclab.columns() - 1, label.new(math.round(\n                                                 liquidation.Average.get(0, i - 1\n                                     textcolor = color.new(gridUp, 50), \n                                     color     =  #000000,  \n                                     style     = label.style_text_outline, \n                                     xloc      = xloc.bar_time, \n                                     size      = size.tiny\n                                     ))\n                    if liquidation.Average.get(1, i - 1).floatLessEqual(lCalc) \n                             and liquidation.Average.get(1, i).floatGreatEqual(lCalc\n                        oiclab.add_col(oiclab.columns())\n                        oiclab.set(1, oiclab.columns() - 1, label.new(math.round(\n                                                 liquidation.Average.get(1, i - 1\n                                     textcolor = color.new(gridDn, 50), \n                                     color     =  #000000, \n                                     style     = label.style_text_outline, xloc =\n                                     size      = size.tiny\n                                     ))\n            for i = minlvl to 90 by 10 \n                transp = array.from(45, 50, 55, 60, 65, 70, 75, 80, 85, 90)\n                txt = switch i.intNotEqual(90)\n                    true => str.tostring(i, \"###x\")\n                    =>      box2Line ? \"90x\" : \"90 - 100x\" \n                switch box2Line\n                    false => \n                                         box.new(\n                             stime, liquidation.Average.row(2).expCalc().multiply\n                                                         xloc         = xloc.bar_time\n                                                         bgcolor      = color.new\n                                                         text_color   =  color.white\n                                                         text         = txt, \n                                                         border_color = color.new\n                                                         text_halign  = text.align_left\n                                                         text_size    = size.auto\n                                                         ),\n                     box.new(\n                             stime, liquidation.Average.row(2).expCalc().multiply\n                                                         xloc         = xloc.bar_time\n                                                         bgcolor      = color.new\n                                                         text_color   =  color.white\n                                                         text         = txt, \n                                                         border_color = color.new\n                                                         text_halign  = text.align_left\n                                                         text_size    = size.auto\n                                                         )\n                    =>\n                     line.new(\n                             stime, liquidation.Average.row(2).expCalc().multiply\n                                                         liquidation.Average.row(\n                                                         xloc         = xloc.bar_time\n                                                         color        = color.new\n                                                         ),\n                     line.new(\n                             stime, liquidation.Average.row(2).expCalc().multiply\n                                                         liquidation.Average.row(\n                                                         xloc          = xloc.bar_time\n                                                         color         = color.new\n                                                         )\n                                if box2Line\n                    label.new(bar_index + 7, liquidation.Average.row(2).expCalc()\n                                         style     = label.style_label_left, \n                                         textcolor = gridDn, \n                                         color =  #00000000,\n                                         text = txt\n                                         )\n                    label.new(bar_index + 7, liquidation.Average.row(2).expCalc()\n                                         style     = label.style_label_left,\n                                         textcolor = gridUp, \n                                         color =  #00000000,\n                                         text = txt\n                                         )\n                    if i.intEqual(90)\n                                             line.new(\n                                 stime, liquidation.Average.row(2).expCalc().multiply\n                                                             liquidation.Average.\n                                                             xloc         = xloc.bar_time\n                                                             color        = color.new\n                                                             )\n                        line.new(\n                                 stime, liquidation.Average.row(2).expCalc().multiply\n                                                             liquidation.Average.\n                                                             xloc          = xloc.bar_time\n                                                             color         = color.new\n                                                             )\n                                        label.new(bar_index + 7, liquidation.Average.row(2).expCalc\n                                             style     = label.style_label_left, \n                                             textcolor = gridDn, \n                                             text = str.tostring(i + 10, \"###x\"),\n                                             color =  #00000000\n                                             )\n                        label.new(bar_index + 7, liquidation.Average.row(2).expCalc\n                                             style     = label.style_label_left,\n                                             textcolor = gridUp, \n                                             text = str.tostring(i + 10, \"###x\"),\n                                             color =  #00000000\n                                             )\n                y1     = (liquidation.Average.row(2).divSubtract(minlvl, 100) / (\n                colarr = array.from(11, 11, 22, 22, 33, 33, 44, 44, 55, 66, 66)\n                txtc   = switch liquidation.Average.row(2).expCalc().multiply(\"+\"\n                    true =>  #ffffff50\n                    =>      color.new(gridDn, colarr.get((i - minlvl) / 10)) \n                if not box2Line\n                                        label.new(endIndex + 25, liquidation.Average.row(2).reduced(minlvl\n                                     \"\u25b0\", \n                                     textcolor = txtc,\n                                     size      = size.tiny, \n                                     color     =  #000000, \n                                     style     = label.style_text_outline\n                                     )\n                txtc2 = switch liquidation.Average.row(2).expCalc().multiply(\"-\",\n                    true =>  #ffffff50\n                    =>        color.new(gridUp, colarr.get((i - minlvl) / 10))\n                                if not box2Line\n                                        label.new(endIndex + 25, liquidation.Average.row(2).reduced(minlvl\n                                     \"\u25b0\", \n                                     textcolor = txtc2 ,\n                                     size      = size.tiny, \n                                     color     =  #000000, \n                                     style     = label.style_text_outline\n                                     )\n                                    [mult, mult2, mult3] = switch minlvl\n                       50 => [35  , 40, 30    ]\n            40 => [30  , 35, 25    ]\n            30 => [23  , 25.5, 20.5]\n            20 => [15  , 17, 13    ]\n            10 => [8   , 9 , 7     ]\n        liqd  = math.avg(liquidation.Average.row(2).reduced(100, \"N\"), liquidation\n        liqu  = math.avg(liquidation.Average.row(2).reduced(100, \"P\"), liquidation\n                liqd2 = liquidation.Average.row(2).reduced(mult, \"N\")\n        liqu2 = liquidation.Average.row(2).reduced(mult, \"P\")\n        sbartime = timeMat.Time.indexof(stime)\n        switchCond = syminfo.type.equal(\"crypto\")\n        [longText, shortText, totCalc] = switch switchCond\n                        true => [OIgrid.determine(\"\\nNet Longs In Range\",  \"\\nBuying Vol. In Range\"\n                     OIgrid.determine(\"\\nNet Shorts In Range\", \"\\nSelling Vol. In Range\"\n                     OIgrid.determine          (posSum+negSum, posSum-negSum)]\n                        =>      [\"\\nBuying Vol. In Range\", \"\\nSelling Vol. In Range\", posSum-\n        label.new(bar_index + 15, liquidation.Average.row(2).expCalc(), str.tostring\n                                         color     =  color.white, \n                                         textcolor =  color.rgb(0, 0, 0), \n                                         style     = label.style_text_outline, \n                                         size      = size.small\n                                         )\n        b = box.new(\n                                         int(\n                             math.avg(stime, stime, endTime)), \n                             liquidation.Average.row(2).reduced(mult2, \"N\"), \n                                                         int(\n                                             math.avg(stime, endTime, endTime)), \n                                             liquidation.Average.row(2).reduced(mult3\n                                             bgcolor      =  #00000050, \n                                             border_color =  #ffffff, \n                                             text         = str.tostring(posSum, \n                                                                                                                                text_color   =  color.white, \n                                             text_size    = size.auto, \n                                             xloc         = xloc.bar_time\n                                             )\n        o = box.new(\n                                         int(\n                             math.avg(stime, stime, endTime)), \n                             liquidation.Average.row(2).reduced(mult2, \"P\"), \n                                                         int(\n                                         math.avg(stime, endTime, endTime)), \n                                             liquidation.Average.row(2).reduced(mult3\n                                             bgcolor      =  #00000050, \n                                             border_color =  #ffffff, \n                                             text         = str.tostring(negSum, \n                                                                                                                                  text_color   =  color.white, \n                                             text_size    = size.auto, \n                                             xloc         = xloc.bar_time\n                                             )\n                if switchCond\n            liquidation.boxLines.push(line.new(timeMat.Time.get(sbartime), liqd, \n                                                     liqd, \n                                                     color = gridUp, \n                                                     style = line.style_dashed, \n                                                     xloc  = xloc.bar_time\n                                                     ))\n            corners.set(2, 0, \n                         liqValues.new(\n                                 leftUp = line.new(timeMat.Time.get(sbartime + 10\n                                                         liqd, \n                                                         color = gridUp, \n                                                         style = line.style_dashed\n                                                         xloc  = xloc.bar_time\n                                                         )))\n            liquidation.boxLines.push(line.new(timeMat.Time.get(sbartime + 10),  \n                                                 color = gridUp, \n                                                 style = line.style_dashed, \n                                                 xloc  = xloc.bar_time\n                                                 ))\n            corners.set(0, 0, \n                             liqValues.new(\n                                     rightUp = line.new(endIndex + 10,  liqd2, endIndex\n                                                 color = gridUp, \n                                                 style = line.style_dashed\n                                                 )))\n            liquidation.boxLines.push(line.new(int(math.avg(sbar, endIndex, endIndex\n                                                 color = gridUp, \n                                                 style = line.style_dashed\n                                                 ))\n            liquidation.boxLines.push(line.new(endIndex, liqd, endIndex + 10, \n                                                 liqd, \n                                                 color = gridUp, \n                                                 style = line.style_dashed\n                                                 ))\n            liquidation.boxLines.push(line.new(stime, liqu, timeMat.Time.get(sbartime\n                                                 liqu, \n                                                 color = gridDn, \n                                                 style = line.style_dashed, \n                                                 xloc  = xloc.bar_time\n                                                 ))\n            corners.set(3, 0, \n                         liqValues.new(\n                                 leftDn = line.new(timeMat.Time.get(sbartime + 10\n                                                 liqu2, \n                                                 color = gridDn, \n                                                 style = line.style_dashed, \n                                                 xloc  = xloc.bar_time\n                                                 )))\n            liquidation.boxLines.push(line.new(timeMat.Time.get(sbartime + 10),  \n                                                 color = gridDn, \n                                                 style = line.style_dashed, \n                                                 xloc  = xloc.bar_time\n                                                 ))\n            corners.set(1, 0, \n                         liqValues.new(\n                                 rightDn = line.new(endIndex + 10,  liqu, endIndex\n                                                 color = gridDn, \n                                                 style = line.style_dashed\n                                                 )))\n            liquidation.boxLines.push(line.new(\n                     int(\n                         math.avg(sbar, endIndex, endIndex)),  liqu2, endIndex + \n                                                 color = gridDn, \n                                                 style = line.style_dashed\n                                                 ))\n            liquidation.boxLines.push(line.new(endIndex, liqu, endIndex + 10, \n                                                 liqu, \n                                                 color = gridDn, \n                                                 style = line.style_dashed\n                                                 ))\n                var table liqtab = table.new(\n                                                 position.bottom_right, 20, 20, \n                                                 bgcolor      = na, \n                                                 frame_color  =  color.white, \n                                                 border_color =  color.white, \n                                                 frame_width  = 1, \n                                                 border_width = 1\n                                                 )\n            liqtab.cell(0, 0, \"Violations\", text_color =  color.white), liqtab.cell\n            liqtab.cell(2, 1, \"Negative\"  , text_color = gridUp), liqtab.merge_cells\n                        liqtab.merge_cells(0, 1, 1, 1)\n            liqtab.merge_cells(2, 1, 3, 1)\n            strArr  = array.from(\"100x: \", \"90x: \", \"80x: \", \"70x: \", \"60x: \", \"50x: \"\n            strArr2 = array.from(\"100x: \", \"90x: \", \"80x: \", \"70x: \", \"60x: \", \"50x: \"\n            intMat = matrix.new<int>(0, 10)\n            dnRow = liquidation.Violations.row(0), dnRow.reverse()    \n            upRow = liquidation.Violations.row(1), upRow.reverse()    \n            for i = 0 to strArr.size() - 1\n                strArr .set(i, strArr.get(i)  + str.tostring(dnRow.get(i)))\n                strArr2.set(i, strArr2.get(i) + str.tostring(upRow.get(i)))\n            intMat.add_row(0, array.from(0, 1, 0, 1, 0, 1, 0, 1, 0, 1))\n            intMat.add_row(1, array.from(2, 3, 2, 3, 2, 3, 2, 3, 2, 3))\n            intMat.add_row(2, array.from(2, 2, 3, 3, 4, 4, 5, 5, 6, 6))\n            for i = 0 to strArr.size() - 1\n                liqtab.cell(intMat.get(0, i), intMat.get(2, i), strArr.get (i), text_color\n                liqtab.cell(intMat.get(1, i), intMat.get(2, i), strArr2.get(i), text_color\n        if move \n            netLong  = oicsum.row(0), netShort = oicsum.row(1)\n            for i = bar_index - sbar to 0\n                                if timeMat.Close.get(i).floatGreatEqual(timeMat.Close.get(i + 1))\n                                        switch math.sign(timeMat.Difference.get(i)).floatEqual(1)\n                                                true =>  netLong .set(i, timeMat.Difference.get(i)), \n                                 netShort.set(i, 0)\n                                                =>       netLong .set(i, 0), \n                                 netShort.set(i, timeMat.Difference.get(i))\n                else \n                                        switch math.sign(timeMat.Difference.get(i)).floatEqual(1)\n                                                true =>  netLong .set(i, 0),\n                                 netShort.set(i, timeMat.Difference.get(i))\n                                                =>       netLong .set(i, timeMat.Difference.get(i)),\n                                 netShort.set(i, 0)\n                      netLong.netAdjust(), netShort.netAdjust()\n            b.set_top(liquidation.Average.row(2).reduced(mult, \"N\")) \n            o.set_top(liquidation.Average.row(2).reduced(mult, \"P\"))\n                        if switchCond\n                linefill.new(corners.get(2, 0).leftUp, corners.get(0, 0).rightUp,\n                linefill.new(corners.get(3, 0).leftDn, corners.get(1, 0).rightDn,\n                avgN = (math.avg(liquidation.Average.row(2).reduced(mult + 1, \"N\"\n                avgP = (math.avg(liquidation.Average.row(2).reduced(mult + 1, \"P\"\n                for i = 1 to math.min(bar_index - sbar, netLong.size() - 1)\n                    netCalc   = (liquidation.Average.row(2).reduced(mult + 1, \"N\"\n                                                         - (liquidation.Average.row\n                                                         * (netLong.get(i) - netLong\n                    snetCalc  = (liquidation.Average.row(2).reduced(minlvl - 1, \"P\"\n                                                         - (liquidation.Average.row\n                                                         * (netShort.get(i) - netShort\n                    netCalc2  =   (liquidation.Average.row(2) .reduced(mult + 1, \n                                                         - (liquidation.Average.row\n                                                         * (netLong.get(i - 1) - \n                    snetCalc2 =   (liquidation.Average.row(2).reduced(minlvl-1, \"P\"\n                                                         - (liquidation.Average.row\n                                                         * (netShort.get(i - 1) -\n                    line.new(timeMat.Time.get(i + 1), snetCalc, timeMat.Time.get(\n                                     snetCalc2,\n                                     color = gridDn,\n                                     xloc  = xloc.bar_time, \n                                     width = 2\n                                     )\n                    line.new(timeMat.Time.get(i + 1), netCalc, timeMat.Time.get(i\n                                     netCalc2, \n                                     color = gridUp,\n                                     xloc  = xloc.bar_time, \n                                     width = 2\n                                     )\n                                                   if not move and switchCond\n                        if liquidation.boxLines.size().intGreatEqual(1) \n                for i = 0 to liquidation.boxLines.size() - 1\n                    liquidation.boxLines.shift().delete()   \n                        for i = 0 to 3\n                                if not na(corners.get(i, 0))\n                                        switch i % 4\n                                                0 => corners.get(0, 0).rightUp.delete()\n                        1 => corners.get(1, 0).rightDn.delete()\n                        2 => corners.get(2, 0).leftUp .delete()\n                        3 => corners.get(3, 0).leftDn .delete()\n            if linefill.all.size().intGreatEqual(1) \n                for i = 0 to linefill.all.size() - 1\n                    linefill.all.shift().delete()\n                if heatmap\n                        count = 0\n            for i = 0 to grid.rows() - 1\n                for x = 0 to grid.columns() - 1\n                    grid.get(i, x).set_bottom(liquidation.Average.row(2).reduced(\n                    grid.get(i, x).set_top   (liquidation.Average.row(2).reduced(\n            for i = 0 to 4\n                orientation.set(0, i, grid.get(i, 0).get_top   ())\n                orientation.set(1, i, grid.get(i, 0).get_bottom())\n            [up1, dn1] = liquidation.Levels.double_binary_search_leftmost (0), [up2\n            [up3, dn3] = liquidation.Levels.double_binary_search_leftmost (2), [up4\n                                         [up5, dn5] = liquidation.Levels.double_binary_search_leftmost\n            var finTick = matrix.new<float>(5, 1, 0), var finTick2 = matrix.new<float\n            for i = 0 to 20\n                finTick .finSetVol(i, 0, dn1, up1), finTick .finSetVol(i, 1, dn2,\n                finTick2.finSetOI (i, 0, dn1, up1), finTick2.finSetOI (i, 1, dn2,\n                finTick .finSetVol(i, 2, dn3, up3), finTick .finSetVol(i, 3, dn4,\n                finTick2.finSetOI (i, 2, dn3, up3), finTick2.finSetOI (i, 3, dn4,\n                                     finTick .finSetVol(i, 4, dn5, up5),\n                                     finTick2.finSetOI (i, 4, dn5, up5)\n                finTick .add_col(finTick .columns(), finTick .col(finTick .columns\n                finTick2.add_col(finTick2.columns(), finTick2.col(finTick2.columns\n            for i = 0 to grid.rows() - 1\n                for x = 0 to grid.columns() - 1\n                    [datax, datamin, datamax] = switch OIgrid\n                        false                                    =>          [finTick\n                        true and syminfo.type.notEqual(\"crypto\") =>          [finTick\n                        =>                                                   [finTick2\n                    col = switch math.sign(datax)\n                        0  =>  color.new(color.gray, 80)\n                        1  =>   color.from_gradient(datax, 0, datamax, color.new(\n                        -1 =>   color.from_gradient(datax, datamin, 0, color.new(\n                    grid.get(i, x).set_bgcolor(col)\n                    if showValues\n                        oiTxt = switch switchCond\n                            true => \"\\n\\nOI: \" +\n                                             (finTick2.get(i, x).floatGreatEqual(\n                            =>      \"\"\n                        grid.get(i, x).set_text( \n                                                 \"VOL: \" + str.tostring(finTick.get\n                        grid.get(i, x).set_text_color( color.white)\n            if ext\n                for i = 0 to grid.rows() - 1\n                    for x = 1 to grid.columns() - 1\n                        [dataCur, dataPrev] = switch OIgrid\n                            false                                    => [finTick \n                            true and syminfo.type.notEqual(\"crypto\") => [finTick \n                            =>                                          [finTick2\n                        if dataCur.floatEqual(dataPrev)\n                            grid.get(i, x).set_left(grid.get(i, x - 1).get_left()\n                            grid.get(i, x - 1).delete()\n            if not switchCond\n                distanceTop = o.get_bottom() - o.get_top()\n                distanceBot = b.get_top() - b.get_bottom()\n                o.set_bottom(grid.get(4, 0) .get_top())   , o.set_top(o.get_bottom\n                b.set_top   (grid.get(0, 0) .get_bottom()), b.set_bottom(b.get_top\n        else \n                        for i = 0 to grid.rows() - 1\n                for x = 0 to grid.columns() - 1\n                    grid.get(i, x).delete()"}]}
{"messages": [{"role": "user", "content": "The Machine Learning Regression Trend tool uses random sample consensus (RANSAC) to fit and extrapolate a linear model by discarding potential outliers, resulting in a more robust fit. \ud83d\udd36 USAGE The proposed tool can be used like a regular linear regression, providing support/resistance as well as forecasting an estimated underlying trend. Using RANSAC allows filtering out outliers from the input data of our final fit, by outliers we are referring to values deviating from the underlying trend whose influence on a fitted model is undesired. For financial prices and under the assumptions of segmented linear trends, these outliers can be caused by volatile moves and/or periodic variations within an underlying trend. Adjusting the \"Allowed Error\" numerical setting will determine how sensitive the model is to outliers, with higher values returning a more sensitive model. The blue margin displayed shows the allowed error area. The number of outliers in the calculation window (represented by red dots) can also be indicative of the amount of noise added to an underlying linear trend in the price, with more outliers suggesting more noise. Compared to a regular linear regression which does not discriminate against any point in the calculation window, we see that the model using RANSAC is more conservative, giving more importance to detecting a higher number of inliners. \ud83d\udd36 DETAILS RANSAC is a general approach to fitting more robust models in the presence of outliers in a dataset and as such does not limit itself to a linear regression model. This iterative approach can be summarized as follow for the case of our script: Step 1: Obtain a subset of our dataset by randomly selecting 2 unique samples Step 2: Fit a linear regression to our subset Step 3: Get the error between the value within our dataset and the fitted model at time t, if the absolute error is lower than our tolerance threshold then that value is an inlier Step 4: If the amount of detected inliers is greater than a user-set amount save the model Repeat steps 1 to 4 until the set number of iterations is reached and use the model that maximizes the number of inliers  \ud83d\udd36 SETTINGS Length: Calculation window of the linear regression. Width: Linear regression channel width. Source: Input data for the linear regression calculation.  \ud83d\udd39RANSAC Minimum Inliers: Minimum number of inliers required to return an appropriate model. Allowed Error: Determine the tolerance threshold used to detect potential inliers. \"Auto\" will automatically determine the tolerance threshold and will allow the user to multiply it through the numerical input setting at the side. \"Fixed\" will use the user-set value as the tolerance threshold.  Maximum Iterations Steps: Maximum number of allowed iterations."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// \u00a9 LuxAlgo\n//@version=5\nindicator(\"Machine Learning Regression Trend [LuxAlgo]\", \"LuxAlgo - Machine Learning Regression Trend\"\n//------------------------------------------------------------------------------\n//Settings\n//-----------------------------------------------------------------------------{\nlength = input.int(100, minval = 5)\nwidthMult = input.float(2, 'Channel Width', minval = 0) \nsrc = input(close, 'Source')\n//RANSAC\ninlineN = input.int(10, 'Minimum Inliners', minval = 1, group = 'RANSAC')\nerrorType = input.string('Auto', 'Allowed Error', options = ['Auto', 'Fixed'], inline\nminError = input.float(1., '', minval = 0, step = 0.5, inline = 'error', group = 'RANSAC'\nmaxIter = input(10000, 'Maximum Iteration Steps', group = 'RANSAC')\n//Style\nlineCss = input( #2157f3, 'Line Color', group = 'Style')\nshowMargin = input(true, 'Show Margin', inline = 'margin', group = 'Style')\nmarginCss = input( color.new(#2157f3, 80), '', inline = 'margin', group = 'Style'\nshowChannel = input(true, 'Show Channel', inline = 'channel', group = 'Style')\nchannelCss = input( color.new(color.gray, 90), '', inline = 'channel', group = 'Style'\nshowInliners = input(true, 'Show Inliners', inline = 'inliners', group = 'Style')\ninlinersCss = input( #2157f3, '', inline = 'inliners', group = 'Style')\nshowOutliers = input(true, 'Show Outliers', inline = 'outliers', group = 'Style')\noutliersCss = input( #ff1100, '', inline = 'outliers', group = 'Style')\n//-----------------------------------------------------------------------------}\n//UDT\n//-----------------------------------------------------------------------------{\ntype LinearRegression\n    array<float> y\n    array<int> x\n    array<float> inliners_y\n    array<int> inliners_x\n    float a\n    float b\n//-----------------------------------------------------------------------------}\n//Methods\n//-----------------------------------------------------------------------------{\nmethod fit(LinearRegression id)=>\n    a = id.y.covariance(id.x) / id.x.variance()\n    b = id.y.avg() - a * id.x.avg()\n    id.a := a\n    id.b := b\nmethod predict(LinearRegression id, x)=>\n    predicted = id.a * x + id.b \nmethod rmse(LinearRegression id)=>\n    i = 0\n    rmse = 0.\n    for value in id.y\n        rmse += math.pow(value - id.predict(id.x.get(i)), 2)\n        i += 1\n        math.sqrt(rmse / i)\n//-----------------------------------------------------------------------------}\n//Get data\n//-----------------------------------------------------------------------------{\nvar y = array.new<float>(0)\nvar x = array.new<int>(0)\nn = bar_index\ny.unshift(src)\nx.unshift(n)\nif y.size() > length\n    y.pop()\n    x.pop()\n//Threshold\nthreshold = switch errorType\n    'Auto' => ta.cum(math.abs(close - open)) / (n+1) * minError\n    'Fixed' => minError\n//-----------------------------------------------------------------------------}\n//Display linear regression\n//-----------------------------------------------------------------------------{\nif barstate.islastconfirmedhistory\n    size = inlineN\n    LinearRegression final_model = na\n        for i = 0 to maxIter-1\n        //Possible inliners\n        inliners_y = array.new<float>(0) \n        inliners_x = array.new<int>(0)\n        //Determine random indices\n        for j = 0 to 1\n            idx = int(math.random(0, length-1))\n            inliners_y.unshift(y.get(idx))\n            inliners_x.unshift(x.get(idx))\n        //Get model\n        model = LinearRegression.new(inliners_y, inliners_x)\n        model.fit()\n        true_inliners_y = array.new<float>(0)\n        true_inliners_x = array.new<int>(0)\n        k = 0\n        for point in y\n            pred = model.predict(x.get(k))\n            if math.abs(point - pred) < threshold\n                true_inliners_y.unshift(point)\n                true_inliners_x.unshift(x.get(k))\n            k += 1\n        if true_inliners_y.size() >= size\n            final_model := LinearRegression.new(true_inliners_y, true_inliners_x\n              , inliners_y = true_inliners_y\n              , inliners_x = true_inliners_x)\n                        final_model.fit()\n            size := true_inliners_y.size()\n        //Tets for suitable model\n    if na(final_model)\n        runtime.error('A suitable model could not be obtained from the provided data/hyperparameters'\n        //Set line\n    y1 = final_model.predict(n-length+1)\n    y2 = final_model.predict(n)\n    line.new(n-length+1, y1, n, y2, color = lineCss, extend = extend.right)\n        //Error Margins\n    if showMargin\n        upper = line.new(n-length+1, y1 + threshold, n, y2 + threshold, color = na\n        lower = line.new(n-length+1, y1 - threshold, n, y2 - threshold, color = na\n        linefill.new(upper, lower, marginCss)\n        //Channel\n    final_model.y := y\n    final_model.x := x\n    width = final_model.rmse() * widthMult\n    if showChannel\n        upper = line.new(n-length+1, y1 + width, n, y2 + width, color = na, extend\n        lower = line.new(n-length+1, y1 - width, n, y2 - width, color = na, extend\n        linefill.new(upper, lower, channelCss)\n    //Show inliners/outliners\n    k = 0\n    for value in y\n        if final_model.inliners_x.includes(n-k)\n            if showInliners\n                label.new(n-k, value, '\u2022'\n                  , color = color(na)\n                  , textcolor = inlinersCss\n                  , style = label.style_label_center)\n        else if showOutliers\n            label.new(n-k, value, '\u2022'\n              , color = color(na)\n              , textcolor = outliersCss\n              , style = label.style_label_center)\n                k += 1\n//-----------------------------------------------------------------------------}"}]}
{"messages": [{"role": "user", "content": "The Dual Bollinger moving average (DBMA) consists of a moving average (MA) & two Bollinger Bands (BB), with the color of the bands representing the level of price compression. In its default settings, it is a 20-day simple moving average with 2 upper Bollinger Bands, having the standard deviation (SD) settings of 0.5 & 1, respectively.  How close the price is to the moving average? For a pullback trader, the entry point should be close to the moving average, preferably with price compression. How close should it be, is where the bands serve as a guide. The low of the pullback candle should be within the bands, that is, at least within the far band (1 SD of the MA), or even better if it's within the near band (0.5 SD). When the price is outside the bands, it should not be considered favourable for a pullback entry. For how long has the price been closer to the moving average? John Carter\u2019s TTM Squeeze indicator looked at the relationship between Bollinger Bands and Keltner's Channels to help identify period of volatility contractions. Bollinger Bands being completely enclosed within the Keltner Channels is indicative of a very low volatility. This is a state of volatility contraction known as squeeze. Using different ATR lengths (1.0, 1.5 and 2.0) for Keltner Channels, we can differentiate between levels of squeeze (High, Mid & Low compression, respectively). Greater the compression, higher the potential for explosive moves. The squeeze portion of the script is based on LazyBear's script (Squeeze Momentum Indicator)  The High, Mid & Low compression squeezes are depicted via the color of the bands being red, orange, or yellow, respectively. With the low of the pullback candle within the bands, & the squeeze color changing to red, it should be considered favourable for a pullback entry. Trailing the price with the lower bands The lower bands can be used for trailing with the moving average. While trailing, once the price closes below the moving average, the trailing stoploss (TSL) is said to be triggered, & the trade is exited. Here we use the bands to give it some cushion. Let the price close below the 1SD band for labelling the TSL as being triggered to exit the trade. If the price closes below the MA but is still within the bands, the signal is to keep holding the trade."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 finallynitin\n//@version=5\nindicator(title='Dual Bollinger Moving Average', shorttitle='DBMA', overlay=true)\nstring GRP1             = \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Moving Average \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\"\nMA_length = input.int(title='', minval=1, maxval=1000, defval=20, inline='line 1',\nMA_type = input.string(title='', options=['SMA', 'EMA', 'WMA'], defval='SMA', inline\nMA_source = input.source(title='', defval=close, inline='line 1', group=GRP1)\nMA_color = input.color(title='', defval= color.green, inline='line 1', group=GRP1\nMA_width = input.int(title='MA line width', defval=1, minval=1, maxval=4, inline='line 2'\nstring GRP2             = \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Bollinger Bands \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\"\nBB_show_upper = input.bool(title='Show Upper Bands', defval=true, inline='line 1',\nBB_show_lower = input.bool(title='Show Lower Bands', defval=false, inline='line 2'\nBB_stdev_near = input.float(title='Near Band', minval=0, maxval=3, defval=0.5, step\ncolorOrangeHalf = input.color( color.new(color.orange, 85), '', inline='line 3', \nBB_stdev_far = input.float(title='Far Band', minval=0, maxval=3, defval=1, step = \ncolorOrangeOne = input.color( color.new(color.orange, 90), '', inline='line 4', group\nstring GRP3             = \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Squeeze \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\"\ntoggleSQZColors = input.bool(title='Squeeze Colors', defval=true, inline='line 3',\ncolorRed = input.color( color.red, 'High-compression Squeeze', group=GRP3)\ncolorOrange = input.color( color.orange, 'Mid-compression Squeeze', group=GRP3)\ncolorYellow = input.color( color.yellow, 'Low-compression Squeeze', group=GRP3)\ncolorGreen = input.color( color.green, 'Fired Squeeze', group=GRP3)\ncolorBlue = input.color( color.blue, 'No Squeeze', group=GRP3)\n//--------BMA------\nBMA = 0.0\nBMA := MA_type == 'SMA' ? ta.sma(MA_source, MA_length) : MA_type == 'EMA' ? ta.ema\np1 = plot(BMA, title='Bollingerised Moving Average', color=MA_color, linewidth=MA_width\n//--------SQUEEZE------\n// original concept from John Carter's book \"Mastering the Trade\"\n// based on LazyBear's script (Squeeze Momentum Indicator) https://in.tradingview.com/script/nqQ1DT5a-Squeeze\ndevBB = BB_stdev_far * ta.stdev(MA_source, MA_length)\ndevKC = ta.sma(ta.tr, MA_length)\n//Bollinger 2x\nupBB = BMA + devBB * 2\nlowBB = BMA - devBB * 2\n//Keltner 2x\nupKCWide = BMA + devKC * 2\nlowKCWide = BMA - devKC * 2\n//Keltner 1.5x\nupKCNormal = BMA + devKC * 1.5\nlowKCNormal = BMA - devKC * 1.5\n//Keltner 1x\nupKCNarrow = BMA + devKC\nlowKCNarrow = BMA - devKC\nsqzOnWide = lowBB >= lowKCWide and upBB <= upKCWide  //Low-compression Squeeze: YELLOW\nsqzOnNormal = lowBB >= lowKCNormal and upBB <= upKCNormal  //Mid-compression Squeeze: ORANGE\nsqzOnNarrow = lowBB >= lowKCNarrow and upBB <= upKCNarrow  //High-compression Squeeze: RED\nsqzOffWide = lowBB < lowKCWide and upBB > upKCWide  //Fired Squeeze: GREEN\nnoSqz = sqzOnWide == false and sqzOffWide == false  //No Squeeze: BLUE\nsq_color = noSqz ? colorBlue : sqzOnNarrow ? colorRed : sqzOnNormal ? colorOrange \nbb_colorOne = toggleSQZColors ? color.new(sq_color, 80) : colorOrangeOne\nbb_colorHalf = toggleSQZColors ? color.new(sq_color, 80) : colorOrangeHalf\n//--------BOLLINGER BANDS------\nupper = BMA + devBB\nlower = BMA - devBB\np2 = plot(BB_show_upper ? upper : na, 'Upper Far Band', color= color.new(color.orange\np3 = plot(BB_show_lower ? lower : na, 'Lower Far Band', color= color.new(color.red\nfill(p1, p2, title='BB Background', color=bb_colorOne)\nfill(p1, p3, title='BB Background', color=bb_colorOne)\ndevhalf = BB_stdev_near * ta.stdev(close, 20)\nupperhalf = BMA + devhalf\nlowerhalf = BMA - devhalf\np4 = plot(BB_show_upper ? upperhalf : na, 'Upper Near Band', color= color.new(color.orange\np5 = plot(BB_show_lower ? lowerhalf : na, 'Lower Near Band', color= color.new(color.red\nfill(p1, p4, title='BB Background', color=bb_colorHalf)\nfill(p1, p5, title='BB Background', color=bb_colorHalf)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added POC option.                                                    Release Notes:                                                    Bar index fixed. Error messages no longer show."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 ChartPrime\n//@version=5\nindicator(\"Fibo Levels with Volume Profile [ChartPrime]\",shorttitle = \"FIVP [ChartPrime]\"\ncolor Offwhite                                  =  color.rgb(255, 255, 255, 71)\ncolor _offwhite                                 =  color.rgb(255, 255, 255, 50)\ncolor  Red1                                     =  color.rgb(255, 82, 82, 85)\ncolor  Red2                                     =  color.rgb(243, 6, 6, 60)\ncolor green                                     =  color.rgb(73, 241, 241, 85)\ncolor green2                                    =  color.rgb(73, 241, 241, 60)\ncolor Black                                     =  color.rgb(7, 7, 7)\ncolor Yellow                                    =  color.rgb(254, 229, 4)\nstring visual                                   =  \"\u279e Visuals Settings\ud83d\udd38\" \nstring core                                     =  \"\u279e Main Core Settings \ud83d\udd38\"\nstring TIME                                     = input.timeframe(\"D\",title = \"Fibo Timeframe\"\n     group = core,\n     options=[\"120\",\"240\",\"480\",\"720\",'D', 'W', 'M'],\n     tooltip = \"Choose a Higher Timeframe than Chart Timeframe\")\nstring Voldata                                  = input.string(\"All\",title = \"Volume Type\"\n     group = core,\n     options=[\"Bear\",\"Bull\",\"All\"],\n     tooltip = \"Choose Volume Type to Show in Boxes\") \nint levs                                        = input.int(12,\"Volume Levels\",tooltip\nbool ShowVolume                                 = input.bool(true,\"Show Volume \u2753\u2005\u2004\"\ncolor Bull                                      = input.color( color.new(#42f07f,\ncolor Bear                                      = input.color( color.new(#f37451,\nbool Showlevels                                 = input.bool(true,\"Show Levels \u2753\u2005\u2004\u2004\u2005\"\ncolor Bull1                                     = input.color(green,\"\",inline = \"02\"\ncolor Bear1                                     = input.color(Red1,\"\",inline = \"02\"\nbool ShowTarget                                 = input.bool(true,\"Show Target \u2753\u2005\u2004\u2004\u2005\"\ncolor Bull2                                     = input.color( color.lime,\"\",inline\ncolor Bear2                                     = input.color( color.rgb(230, 0, \nbool ShowPOC                                    = input.bool(true,\"Show POC \u2753\u2005\u2004\u2004\u2005\",inline\nint sync                                        = bar_index\nfloat scr                                       = close\nstring TF                                       = timeframe.isdwm ? \"M\" : \"W\"\nint atrLen                                      = 30\nfloat mult                                      = 0.3\nfloat per                                       = 10.0\nfloat perc                                      = close * (0.3/100)\nfloat srdatr                                    = ta.atr (atrLen) * mult\nfloat band                                      = math.min (srdatr, perc) [20] /2\nvar float [] Fibo                                   = array.new_float(6,0.0)\nvar line [] Lines                               = array.new_line()   \nvar label [] Labels                              = array.new_label()  \nvar box [] FiboBOX                              = array.new_box(6)\nfloat FH                                        = request.security(syminfo.tickerid\nfloat FL                                        = request.security(syminfo.tickerid\nfloat FC                                        = request.security(syminfo.tickerid\nfloat [] TotalVolume                            = array.new_float()\nfloat [] Greenvolume                            = array.new_float()\nfloat [] redvolume                              = array.new_float()\nvar int newWeekBarIndex                         = na\nvar int newWeekTIME                             = na\nweekChange                                      = timeframe.change(TF)\nif weekChange\n    newWeekBarIndex := bar_index\n    newWeekTIME := time\nTF2 = timeframe.multiplier < 60 ? \"1D\" : \"3D\"\nEXTIME = timeframe.in_seconds(TF2) * 1000\nanchorTime = time + EXTIME\nanchorBarIndex = (time - anchorTime) / (1000 * timeframe.in_seconds(timeframe.period\nanchorBarsBack = bar_index - anchorBarIndex \n// plot(anchorBarsBack)\n// plot(bar_index)\nBAR1 = math.floor(sync - newWeekBarIndex)\nVolume(GV,RV,TV,BC)=>\n    GR = GV / TV \n    RR = RV / TV\n    [GR , RR]\nPP = (FH + FL + FC) / 3\nif BAR1 > 5000\n    BAR1:=3500\narray.set(Fibo,0,PP + 0.382 * (FH - FL))\narray.set(Fibo,1,PP - 0.382 * (FH - FL))\narray.set(Fibo,2,PP + 0.618 * (FH - FL))\narray.set(Fibo,3,PP - 0.618 * (FH - FL))\narray.set(Fibo,4,PP + (FH - FL))\narray.set(Fibo,5,PP - (FH - FL))\n// int levs                    = array.size(Fibo) * 2\nfloat FT                    = array.get(Fibo,4)\nfloat FB                    = array.get(Fibo,5)\nfloat [] VPlevels           = array.new_float(levs+1)\nvar box [] VPboxes          = array.new_box(levs+3)\nif array.size(Fibo) > 6\n    for i = 0 to 5\n        array.shift(Fibo) \nstep = ( FT-FB ) / levs\nfor i=0 to levs by 1\n    array.set(VPlevels,i, FB + step * i)\nif barstate.islast\n    int [] Points       = array.new_int(levs,0)\n    float [] Volumes    = array.new_float(levs,0.0)\n    float [] SCR        = array.new_float()\n    float [] BUllV        = array.new_float(levs,0.0)\n    float [] BEARV        = array.new_float(levs,0.0)\n         for i = 0 to BAR1\n        array.push(SCR,close[i])\n    if Showlevels\n        for i = 0 to array.size(Fibo) - 1\n            C = i == 0 or i == 2 or i == 4  \n            array.push(FiboBOX,box.new(newWeekTIME,\n              array.get(Fibo,i) + (band/2),\n              time + EXTIME,\n              array.get(Fibo,i) - (band/2),\n              bgcolor = C ? Bear1 : Bull1,\n              border_color =C ? color.new(Bear1,60) : color.new(Bull1,60),\n              border_width = 1,\n              xloc = xloc.bar_time))\n    for i=0 to array.size(SCR) -1\n        for x=0 to array.size(VPlevels) - 2  by 1\n            if array.get(SCR,i)>array.get(VPlevels,x) \n                 and\n                 array.get(SCR,i)<array.get(VPlevels,x+1)\n                array.set(Points,x,array.get(Points,x)+1)\n                array.set(Volumes,x,array.get(Volumes,x)+volume[x])\n                if array.get(SCR,i) > open[i]\n                    array.set(BUllV,x,array.get(BUllV,x)+volume[x])\n                if array.get(SCR,i) < open[i]\n                    array.set(BEARV,x,array.get(BEARV,x)+volume[x])     \n                break\n        if array.get(SCR,i) > open[i]\n            array.push(Greenvolume,volume[i])\n        if array.get(SCR,i) < open[i]\n            array.push(redvolume,volume[i])\n        array.push(TotalVolume,volume[i])\n    [GR,RR] = Volume(array.sum(Greenvolume),\n         array.sum(redvolume),\n         array.sum(TotalVolume),\n         array.size(SCR) -1) \n            // label.new(bar_index,high,str.tostring(SCR.size()))\n    if ShowVolume \n                        for i = 0 to array.size(Points) -1\n            str = Voldata == \"All\" ? str.tostring(array.get(Volumes,i),format.volume\n                 : Voldata == \"Bear\" ? str.tostring(array.get(BEARV,i),format.volume\n                 str.tostring(array.get(BUllV,i),format.volume)\n            box.delete(array.get(VPboxes,i))\n            array.set(VPboxes,i,\n                 box.new(anchorBarsBack - array.get(Points,i),\n                 array.get(VPlevels,i+1) + (band/2),\n                 anchorBarsBack,\n                 array.get(VPlevels,i) + (band/2),\n             border_color = color.from_gradient(array.get(Points,i),0,\n             array.max(Points),\n             Bear,\n             Bull),\n             bgcolor=color.from_gradient(array.get(Points,i),0,\n             array.max(Points),\n             Bear,\n             Bull),\n             text=str,\n             text_color= color.white\n             ))\n    if ShowPOC\n        //get the max volume \n        // array.indexof(Volumes)\n        var box POC = na , box.delete(POC)\n        MaxVID = Volumes.indexof(Volumes.max())\n        POC:= box.new(newWeekTIME,VPlevels.get(MaxVID)+ (band/2),anchorTime,VPlevels\n               #e0f2e93a,border_style=line.style_solid,bgcolor= color.new(#586161\n              text=\"POC\",text_color=chart.fg_color,text_halign  = text.align_center\n    MID = (FB +FT ) / 2 \n    if (scr < FT) and (scr > FB) and ShowTarget\n        max_bars_back(scr,2000)\n        if GR > RR\n            if (scr > MID)\n                array.push(Lines,\n                     line.new(sync + 3,\n                      hl2[1],sync + 10,\n                      array.get(Fibo,2),\n                      color= Bull2,\n                      style = line.style_arrow_right,\n                      width = 1))\n                array.push(Labels,\n                     label.new(sync + 10,\n                     array.get(Fibo,2),\n                     \"Possible Target \",\n                     style=label.style_label_lower_left,\n                     color=color.new(Bull2, 70),\n                     textcolor =  color.white,\n                     size=size.small))\n            else if (scr < MID)\n                array.push(Lines,\n                     line.new(sync + 3,\n                     hl2[1],sync + 10,\n                     array.get(Fibo,0),\n                     color= Bull2,\n                     style = line.style_arrow_right,\n                     width = 1))\n                array.push(Labels,\n                     label.new(sync + 10,\n                     array.get(Fibo,0),\n                     \"Possible Target \",\n                     style=label.style_label_lower_left,\n                     color=color.new(Bull2, 70),\n                     textcolor =  color.white,\n                     size=size.small))    \n        else \n            if scr > MID \n                array.push(Lines,\n                     line.new(sync + 3,\n                     hl2[1],sync + 10,\n                     array.get(Fibo,1),\n                     color= Bear2,\n                     style = line.style_arrow_right,\n                     width = 1))\n                array.push(Labels,\n                     label.new(sync + 10,\n                     array.get(Fibo,1),\n                     \"Possible Target \",\n                     style=label.style_label_lower_left,\n                     color=color.new(Bear2, 70),\n                     textcolor =  color.white,\n                     size=size.small))\n            else if scr < MID\n                array.push(Lines,\n                     line.new(sync + 3,\n                     hl2[1],sync + 10,\n                     array.get(Fibo,3),\n                     color= Bear2,\n                     style = line.style_arrow_right,\n                     width = 1))\n                array.push(Labels,\n                     label.new(sync + 10,\n                     array.get(Fibo,3),\n                     \"Possible Target \",\n                     style=label.style_label_lower_left,\n                     color=color.new(Bear2, 70),\n                     textcolor =  color.white,\n                     size=size.small))\n    if array.size(Lines) > 1\n        line.delete(array.shift(Lines))\n    if array.size(Labels) > 1\n        label.delete(array.shift(Labels))\n    if array.size(FiboBOX) > 6\n        for i = 0 to 5\n            box.delete(array.shift(FiboBOX))"}]}
{"messages": [{"role": "user", "content": "Introduction and How It Is Different In the vast world of trading strategies, the TrendGuard Flag Finder stands out as a unique blend of traditional flag pattern detection and the renowned SuperTrend indicator.  - A significant portion of the Flag Pattern detection is inspired by the \"Flag Finder\" code by @Amphibiantrading, which serves as one of foundational element of this strategy.  - While many strategies focus on either trend-following or pattern recognition, this strategy harmoniously combines both, offering traders a more holistic view of the market.  - The integration of the SuperTrend indicator not only provides a clear direction of the prevailing trend but also offers potential stop-loss levels, enhancing the strategy's risk management capabilities. AAPL 1D chart ETHBTC 6hr chart Strategy: How It Works The TrendGuard Flag Finder is primarily built on two pillars: 1. Flag Pattern Detection: At its core, the strategy identifies flag patterns, which are continuation patterns suggesting that the prevailing trend will resume after a brief consolidation. The strategy meticulously detects both bullish and bearish flags, ensuring traders can capitalize on opportunities in both rising and falling markets. What is a Flag Pattern? A flag pattern consists of two main components: 1.1 The Pole: This is the initial strong price move, which can be either upwards (for bullish flags) or downwards (for bearish flags). The pole represents a strong surge in price in a particular direction, driven by significant buying or selling momentum. 1.2 The Flag: Following the pole, the price starts consolidating, moving against the initial trend. This consolidation forms a rectangular shape and is characterized by parallel trendlines. In a bullish flag, the consolidation will have a slight downward tilt, while in a bearish flag, it will have a slight upward tilt. How the Strategy Detects Flags: Identifying the Pole: The strategy first identifies a strong price movement over a user-defined number of bars. This movement should meet a certain percentage change to qualify as a pole. Spotting the Flag: After the pole is identified, the strategy looks for a consolidation phase. The consolidation should be counter to the prevailing trend and should be contained within parallel lines. The depth (for bullish flags) or rally (for bearish flags) of this consolidation is calculated to ensure it meets user-defined criteria. 2. SuperTrend Integration: The SuperTrend indicator, known for its simplicity and effectiveness, is integrated into the strategy. It provides a dynamic line on the chart, signaling the prevailing trend. When prices are above the SuperTrend line, it's an indication of an uptrend, and vice versa. This not only confirms the flag pattern's direction but also offers a potential stop-loss level for trades. When combined, these components allow traders to identify potential breakout (for bullish flags) or breakdown (for bearish flags) scenarios, backed by the momentum indicated by the SuperTrend. Usage To use the SuperTrend Enhanced Flag Finder: - Inputs: Begin by setting the desired parameters. The strategy offers a range of user-controlled settings, allowing for customization based on individual trading preferences and risk tolerance. - Visualization: Once the parameters are set, the strategy will identify and visually represent flag patterns on the chart. Bullish flags are represented in green, while bearish flags are in red. - Trade Execution: When a breakout or breakdown is identified, the strategy provides entry signals. It also offers exit signals based on the SuperTrend, ensuring that traders can capitalize on the momentum while managing risk.  Default Settings The strategy comes with a set of default settings optimized for general use: - SuperTrend Parameters: Length set to 10 and Factor set to 5.0. - Bull Flag Criteria: Max Flag Depth at 7, Max Flag Length at 10 bars, Min Flag Length at 3 bars, Prior Uptrend Minimum at 9%, and Flag Pole Length between 7 to 13 bars. - Bear Flag Criteria: Similar settings adjusted for bearish patterns. - Display Options: By default, both bullish and bearish flags are displayed, with breakout and breakdown points highlighted."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Amphibiantrading\n//@version=5\nstrategy(\"TrendGuard Flag Finder - Strategy [presentTrading]\", overlay = true, precision\n commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1, \n  currency=currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value\n//inputs\n//user controlled settings for the indicator, separated into 4 different groups \n// Add a button to choose the trading direction\ntradingDirection = input.string(\"Both\",\"Trading Direction\", options=[\"Long\", \"Short\"\n// Supertrend parameters\nSupertrendPeriod = input(10, \"Supertrend Length\",group ='SuperTrend Criteria')\nSupertrendFactor = input.float(4.0, \"Supertrend Factor\", step = 0.01,group ='SuperTrend Criteria'\n// Flag parameters\nvar g1 = 'Bull Flag Criteria'\nmax_depth = input.float(5, 'Max Flag Depth', step = .25, minval = 2.0, group = g1,\nmax_flag = input.int(7, 'Max Flag Length', group = g1, tooltip = 'The maximum number of bars the flag can last'\nmin_flag = input.int(3, 'Min Flag Length', group = g1, tooltip = 'The minimum number of bars required for the flag'\npoleMin = input.float(3.0, 'Prior Uptrend Minimum', group = g1, tooltip = 'The minimum percentage gain required before a fla\npoleMaxLen = input.int(13, 'Max Flag Pole Length', minval = 1, group = g1, tooltip\npoleMinLen = input.int(7, 'Min Flag Pole Length', minval = 1, group = g1, tooltip \nvar g2 = 'Bear Flag Criteria'\nmax_rally = input.float(5, 'Max Flag Rally', step = .25, minval = 2.0, group = g2,\nmax_flagBear = input.int(7, 'Max Flag Length', group = g2, tooltip = 'The maximum number of bars the flag can last'\nmin_flagBear = input.int(3, 'Min Flag Length', group = g2, tooltip = 'The minimum number of bars required for the flag'\npoleMinBear = input.float(3.0, 'Prior Downtrend Minimum', group = g2, tooltip = 'The minimum percentage loss required before a fla\npoleMaxLenBear = input.int(13, 'Max Flag Pole Length', minval = 1, group = g2, tooltip\npoleMinLenBear = input.int(7, 'Min Flag Pole Length', minval = 1, group = g2, tooltip\nvar g3 = 'Bull Flag Display Options'\nshowF = input.bool(true, 'Show Bull Flags', group = g3)\nshowBO = input.bool(true,'Show Bull Flag Breakouts', group = g3)\nlineColor = input.color( color.green, 'Bull Line Color', group = g3)\nlineWidth = input.int(2, 'Bull Line Width', minval = 1, maxval = 5, group = g3)\nvar g4 = 'Bear Flag Display Options'\nshowBF = input.bool(true, 'Show Bear Flags', group = g4)\nshowBD = input.bool(true,'Show Bear Flag Breakdowns', group = g4)\nlineColorBear = input.color( color.red, 'Bear Flag Line Color', group = g4)\nlineWidthBear = input.int(2, 'Bear Flag Line Width', minval = 1, maxval = 5, group\n//variables \n//declare starting variables used for identfying flags\nvar baseHigh = high, var startIndex = 0, var flagLength = 0, var baseLow = low \nvar lowIndex = 0, var flagBool = false, var poleLow = 0.0, var poleLowIndex = 0\nvar line flagHLine = na, var line flagLLine = na, var line flagPLine = na\n// bear flag variables\nvar flagLowBear = high, var startIndexBear = 0, var flagLengthBear = 0, var flagHigh\nvar highIndex = 0, var flagBoolBear = false, var poleHigh = 0.0, var polehighIndex\nvar line flagBearHLine = na, var line flagBearLLine = na, var line flagBearPLine =\n//find bull flag highs\n// check to see if the current bars price is higher than the previous base high or na and then sets \nif high > baseHigh or na(baseHigh)\n    baseHigh := high\n    startIndex := bar_index\n    flagLength := 0\n    baseLow := low\n    lowIndex := bar_index\n// check to see if the low of the current bar is lower than the base low, if it is set the base low \nif high <= baseHigh and low < baseLow\n    baseLow := low\n    lowIndex := bar_index\n// moves the base low from the base high bar_index to prevent the high and low being the same bar\nif high <= baseHigh and lowIndex == startIndex\n    baseLow := low\n    lowIndex := bar_index\n//find bear flag lows\n// check to see if the current bars price is lower than the previous flag low or na and then sets th\nif low < flagLowBear or na(flagLowBear)\n    flagLowBear := low\n    startIndexBear := bar_index\n    flagLengthBear := 0\n    flagHigh := high\n    highIndex := bar_index\n// check to see if the high of the current bar is higher than the flag high, if it is set the flag h\nif low >= flagLowBear and high > flagHigh\n    flagHigh := high\n    highIndex := bar_index\n// moves the flag high from the flag low bar_index to prevent the high and low being the same bar\nif low >= flagLowBear and highIndex == startIndexBear\n    flagHigh := high\n    highIndex := bar_index\n//calulations bullish\nfindDepth = math.abs(((baseLow / baseHigh) - 1) * 100)  //calculate the depth of the flag\npoleDepth = ((baseHigh / poleLow)- 1) * 100 // calculate the low of the flag pole to the base \nlower_close = close < close[1] // defines a lower close\n//calculations bearish\nfindRally = math.abs(((flagHigh / flagLowBear) - 1) * 100)   //calculate the rally of the flag\npoleDepthBear = ((flagLowBear / poleHigh)- 1) * 100 // calculate the high of the flag pole to the low \nhigher_close = close > close[1] // defines a higher close\n//start the counters\n// begins starting bars once a high is less than the flag high\nif high < baseHigh and findDepth <= max_depth or (high == baseHigh and lower_close\n    flagLength += 1\nelse   \n    flagLength := 0\n// begins starting bars once a low is higher than the flag low\nif low > flagLowBear and findRally <= max_rally or (low == flagLowBear and higher_close\n    flagLengthBear += 1\nelse   \n    flagLengthBear := 0\n// check for prior uptrend / downtrend to meet requirements\n// loops through all the bars from the minimum pole length to the maximum pole length to check if th\nif high == baseHigh \n    for i = poleMinLen to poleMaxLen\n        if ((high / low[i]) - 1) * 100 >= poleMin\n            flagBool := true\n            poleLow := low[i]\n            poleLowIndex := bar_index[i]\n            break\n// loops through all the bars from the minimum pole length to the maximum pole length to check if th\nif low == flagLowBear \n    for i = poleMinLenBear to poleMaxLenBear\n        if math.abs(((low / high[i]) - 1) * 100) >= poleMinBear\n            flagBoolBear := true\n            poleHigh := high[i]\n            polehighIndex := bar_index[i]\n            break\n// reset variables if criteria for a flag is broken\n// if the depth of the bull flag is greater than the maximum depth limit or the flag lasts longer th\nif findDepth >= max_depth or flagLength > max_flag\n    flagBool := false\n    flagLength := 0\n    baseHigh := na\n    startIndex := na\n    lowIndex := na\n    baseLow := na\n// if the rally of the bear flag is greater than the maximum rally limit or the flag lasts longer th\nif findRally >= max_rally or flagLengthBear > max_flagBear\n    flagBoolBear := false\n    flagLengthBear := 0\n    flagLowBear := na\n    startIndexBear := na\n    highIndex := na\n    flagHigh := na\n// reset the variables and begin looking for a new bull flag if price continues higher before the mi\nif high > baseHigh[1] and flagLength < min_flag\n    baseHigh := high\n    flagLength := 0\n    startIndex := bar_index\n    lowIndex := bar_index\n    baseLow := low\n// reset the variables and begin looking for a new bear flag if price continues lower before the min\nif low < flagLowBear[1] and flagLengthBear < min_flagBear\n    flagLowBear := low\n    flagLengthBear := 0\n    startIndexBear := bar_index\n    highIndex := bar_index\n    flagHigh := high\n//define the flags\n// if all requirements are met a bull flag is true, flagBool is true, flag length is less than maxim\nflag = flagBool == true and flagLength < max_flag and findDepth < max_depth and flagLength\n// if all requirements are met a bear flag is true, flagBoolBear is true, flag length is less than m\nbearFlag = flagBoolBear == true and flagLengthBear < max_flagBear and findRally < \n//define flags, breakouts, breadowns\n// a breakout is defined as the high going above the flag high and the length of the flag is greater\nbreakout = high > baseHigh[1] and flagLength >= min_flag and flagBool == true\n//a breakdown is defined as the depth of the flag being larger than user set parameter or the length\nbreakdown = findDepth >= max_depth or flagLength > max_flag\n// a separate variable to have breakouts only plot once using a plotshape\nplotBO = flag[1] and high > baseHigh[1] and flagLength[1] >= min_flag and flagBool\n// a bear flag breakout is defined as the low going below the flag low and the length of the flag is\nbreakoutBear = low < flagLowBear[1] and flagLengthBear >= min_flagBear and flagBoolBear\n//a breakdown is defined as the rally of the flag being larger than user set parameter or the length\nbreakdownBear = findRally >= max_rally or flagLengthBear > max_flagBear\n// a separate variable to have breakouts only plot once using a plotshape\nplotBD = bearFlag[1] and low < flagLowBear[1] and flagLengthBear[1] >= min_flagBear\n// if a bul flag is detected and the user has bull flags selected from the settings menu draw it on \nif flag and showF\n    //if a flag was detected on the previous bar, delete those lines and allow for new lines to be drawn\n    if flag[1]\n        line.delete(flagHLine[1]), line.delete(flagLLine[1]), line.delete(flagPLine\n    //draw new lines\n    flagHLine := line.new(startIndex, baseHigh, bar_index, baseHigh, color=lineColor\n    flagLLine := line.new(startIndex, baseLow, bar_index, baseLow, color=lineColor\n    flagPLine := line.new(poleLowIndex +1, poleLow, startIndex , baseLow, color=lineColor\n// if a bear flag is detected and the user has bear flags selected from the settings menu draw it on\nif bearFlag and showBF\n    //if a bear flag was detected on the previous bar, delete those lines and allow for new lines to be \n    if bearFlag[1]\n        line.delete(flagBearHLine[1]), line.delete(flagBearLLine[1]), line.delete(\n    //draw new lines\n    flagBearHLine := line.new(startIndexBear, flagHigh, bar_index, flagHigh, color\n    flagBearLLine := line.new(startIndexBear, flagLowBear, bar_index, flagLowBear,\n    flagBearPLine := line.new(polehighIndex + 1, poleHigh, startIndexBear , flagHigh\n//reset variables if a breakout occurs\nif breakout // bull flag - high gets above flag high\n    flagLength := 0\n    baseHigh := high\n    startIndex := bar_index\n    lowIndex := bar_index\n    baseLow := low\nif breakoutBear // bear flag - low gets below flag low\n    flagLengthBear := 0\n    flagLowBear := low\n    startIndexBear := bar_index\n    highIndex := bar_index\n    flagHigh := high\n//reset the variables and highs from a failed bull flag. This allows stocks below previous highs to \nhighest = ta.highest(high, 10) // built in variable that finds the highest high lookingback the past 10 bars\nif breakdown or flagLength == max_flag\n    flagBool := false\n    baseHigh := highest\n    startIndex := bar_index\n    lowIndex := bar_index\n    baseLow := low\n//reset the variables and lows from a failed bear flag. This allows stocks above previous lows to fi\nlowest = ta.lowest(low, 10) // built in variable that finds the lowest low lookingback the past 10 bars\nif breakdownBear or flagLengthBear == max_flagBear\n    flagBoolBear := false\n    flagLowBear := lowest\n    startIndexBear := bar_index\n    highIndex := bar_index\n    flagHigh := high\n// if a flag breakdowns remove the lines from the chart\nif (breakdown and flag[1])\n    line.delete(flagHLine)\n    line.delete(flagLLine)\n    line.delete(flagPLine)\nif (breakdownBear and bearFlag[1])\n    line.delete(flagBearHLine)\n    line.delete(flagBearLLine)\n    line.delete(flagBearPLine)\n//plot breakouts\n// use a plotshape to check if there is a breakout and the show breakout option is selected. If both\nplotshape(plotBO and showBO and showF, 'Breakout', shape.triangleup, location.belowbar\n// use a plotshape to check if there is a breakout and the show breakout option is selected. If both\nplotshape(plotBD and showBD and showBF, 'Breakout', shape.triangledown, location.abovebar\n// Define entry and exit conditions based on the indicator\nbullishEntryFlag = plotBO and showBO and showF\nbearishEntryFlag = plotBD and showBD and showBF\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(SupertrendFactor, SupertrendPeriod)\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color =  color.green,\ndownTrend = plot(direction < 0? na : supertrend, \"Down Trend\", color =  color.red\nfill(bodyMiddle, upTrend,  color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend,  color.new(color.red, 90), fillgaps=false)\n// Define entry and exit conditions based on the indicator\nbullishEntryST = direction < 0\nbearishEntryST = direction > 0 \n// Entry\nbullishEntry = bullishEntryFlag and bullishEntryST\nbearishEntry = bearishEntryFlag and bearishEntryST\n// Modify entry and exit conditions based on the selected trading direction\nif (bullishEntry and (tradingDirection == \"Long\" or tradingDirection == \"Both\"))\n    strategy.entry(\"Buy\", strategy.long)\n    strategy.exit(\"Sell\", \"Buy\", stop=supertrend)\nif (bearishEntry and (tradingDirection == \"Short\" or tradingDirection == \"Both\"))\n    strategy.entry(\"Sell\", strategy.short)\n    strategy.exit(\"Cover\", \"Sell\", stop=supertrend)\n// Exit conditions\nif (strategy.position_size > 0 and bearishEntry and (tradingDirection == \"Long\" or\n    strategy.close(\"Buy\")\nif (strategy.position_size < 0 and bullishEntry and (tradingDirection == \"Short\" or\n    strategy.close(\"Sell\")"}]}
{"messages": [{"role": "user", "content": "Trend Strategy #1  Indicators:  1. SMA 2. Pivot high/low functions derived from SMA  3. Step lines to plot support and resistance based on the pivot points  4. If the close is over the resistance line, green arrows plot above, and vice versa for red arrows below support.  Strategy: 1. Long Only 2. Mutable 2% TP/1.5% SL  3. 0.01% commission  4. When the close is greater than the pivot point of the sma pivot high, and the close is greater than the resistance step line, a long position is opened.  *At times, the 2% take profit may not trigger IF; the conditions for reentry are met at the time of candle closure + no exit conditions have been triggered.   5. If the position is in the green and the support step line crosses over the resistance step line, positions are exited.  How to use it and what makes it unique: Use this strategy to trade an up-trending market using a simple moving average to determine the trend. This strategy is meant to capture a good risk/reward in a bullish market while staying active in an appropriate fashion. This strategy is unique due to it's inclusion of the step line function with statistics derived from myself.  This description tells the indicators combined to create a new strategy, with commissions and take profit/stop loss conditions included, and the process of strategy execution with a description on how to use it. If you have any questions feel free to PM me and boost if you enjoyed it. Thank you, pineUSERS!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 CheatCode1\n//@version=5\nstrategy(\"Quantitative Trend Strategy- Uptrend long\", 'Steady Uptrend Strategy', overlay\nlength = input.int(20, minval=1)\nsrc = input(close, title=\"Source\")\nbasis = ta.sma(src, length)\noffset = input.int(0, \"Offset\", minval = -500, maxval = 500)\nplot(basis, \"Basis\", color= #FF6D00, offset = offset)\ninp1 = input.int(46, 'LookbackLeft')\ninp2 = input.int(32, 'LookbackRight')\nl1 = ta.pivothigh(close, inp1, inp2)\nS1 = ta.pivotlow(close, inp1, inp2)\n// plot(l1, 'Pivothigh', color.red, 1)\n// // plot(S1, 'Pivot Low', color.red)\nl1V = ta.valuewhen(l1, close, 0)\nS1V = ta.valuewhen(S1, close, 0)\nPlotl1 = not na(l1) ? l1V : na\nPlotS1 = not na(S1) ? S1V : na\nplot(Plotl1, 'Resistance',  color.green, 1, plot.style_stepline, true)\nplot(PlotS1, 'Support',  color.red, 1, plot.style_stepline, true)\nPriceforlong = close > l1V ? true : na\nPriceforshort = close < S1V ? true : na\nplotshape(Priceforlong ? high : na, 'p', shape.arrowup, location.abovebar,  color.green\nplotshape(Priceforshort ? low : na, 's', shape.arrowdown, location.belowbar,  color.red\nvol = volume\nvolma = ta.sma(vol, 20)\nPlotl1C = ta.valuewhen(na(Plotl1), l1V, 0)\nPlotS1C = ta.valuewhen(na(PlotS1), S1V, 0)\n//Strategy Execution\nvolc = volume > volma \nLc1 = Priceforlong \nSc1 = Priceforshort\nsL = Plotl1 < PlotS1 ? close : na\nsS = PlotS1 > Plotl1 ? close : na\nif Lc1 \n    strategy.entry('Long', strategy.long)\n// if Sc1 and C2\n//     strategy.entry('Short', strategy.short)\nif Priceforshort\n    strategy.cancel('Long')\nif Priceforlong   \n    strategy.cancel('Short')\n// Stp1 = ta.crossover(k, d)\n// Ltp1 = ta.crossunder(k, d)\n// Ltp = d > 70  ? Ltp1 : na\n// Stp = d < 30  ? Stp1 : na\nif strategy.openprofit >= 0 and sL\n    strategy.close('Long')\nif strategy.openprofit >= 0 and sS\n    strategy.close('Short')\ntakeP = input.float(2, title='Take Profit') / 100\nstopL = input.float(1.75, title='Stop Loss') / 100\n// // Pre Directionality\nStop_L = strategy.position_avg_price * (1 - stopL)\nStop_S = strategy.position_avg_price * (1 + stopL)\nTake_S= strategy.position_avg_price * (1 - takeP)\nTake_L = strategy.position_avg_price * (1 + takeP)\n     // sL = Plotl1 < PlotS1 ? close : na\n// sS = PlotS1 < Plotl1 ? close : na\n     // //Post Excecution\nif strategy.position_size > 0 and not (Lc1)\n    strategy.exit(\"Close Long\", stop = Stop_L, limit = Take_L)\nif strategy.position_size < 0 and not (Sc1)\n    strategy.exit(\"Close Short\", stop = Stop_S, limit = Take_S)"}]}
{"messages": [{"role": "user", "content": "The Golden Transform Oscillator contains multiple technical indicators and conditions for making buy and sell decisions. Here's a breakdown of its components and what it's trying to achieve: Strategy Setup: The GT is designed to be plotted on the chart without overlaying other indicators. Rate of Change (ROC) Calculation: The Rate of Change (ROC) indicator is calculated with a specified period (\"Rate of Change Length\"). The ROC measures the percentage change in price over the specified period. Hull Modified TRIX Calculation: The Hull Modified TRIX indicator is calculated with a specified period (\"Hull TRIX Length\"). The Hull MA (Moving Average) formula, a modified WMA, is used to calculate a modified TRIX indicator, which is a momentum oscillator. Hull MA Calculation: A Hull Moving Average (Hull MA) is calculated as an entry filter. Fisher Transform Calculation: The Fisher Transform indicator is calculated to serve as a preemptive exit filter. It involves mathematical transformations of price data to create an oscillator that can help identify potential reversals. The Fisher Transform is further smoothed using a Hull Moving Average (HMA). Conditions and Signals: Long conditions are determined based on crossovers between ROC and TRIX, as well as price relative the the MA. Short conditions are inversed. Exit Conditions: Exit conditions are defined for both long and short positions. For long positions, the strategy exits if ROC crosses under TRIX, or if the smoothed Fisher Transform crosses above a threshold and declines. Once again, short conditions are the inverse. Visualization and Plotting: The script uses background colors for entry and shapes for exits to highlight different levels and conditions for the ROC/TRIX correlation. It plots the Fisher Transform values and a lag trigger on the chart. Overall, this script is a complex algorithm that combines multiple technical indicators and conditions to generate trading signals and manage positions in the financial markets. It aims to identify potential entry and exit points based on the interplay of the mentioned indicators and conditions."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0\n// \u00a9 DraftVenture\n//@version=5\nstrategy(\"Golden Transform Strategy\", overlay=false)\n// ROC - to contrast Hull TRIX, no modifications\nroclength = input.int(50, title=\"Rate of Change Length\", minval=1)\nsource = input(close, \"ROC Source\")\nroc = 100 * (source - source[roclength])/source[roclength]\n// Hull modified TRIX - for greater weight\nlength = input.int(90, title=\"Hull TRIX Length\", minval=1)\nhullma(source, length) =>\n    wma1 = ta.wma(source, length / 2)\n    wma2 = ta.wma(source, length)\n    hull = ta.wma(2 * wma1 - wma2, math.floor(math.sqrt(length)))\n    hull\nhullmaValue = hullma(math.log(close), length)\ntrix = 10000 * ta.change(hullma(hullma(hullma(math.log(close), length), length), length\n// Hull MA - correlates Hull TRIX as an entry filter\nhlength = input.int(65, title= \"Hull MA Entry Length\", minval=1)\nsrc = input(close, title=\"Hull MA Source\")\nhullma2 = ta.wma(2*ta.wma(src, hlength/2)-ta.wma(src, hlength), math.floor(math.sqrt\n// Fisher Transform - as a preemptive exit filter\nlen = input.int(50, minval=1, title=\"Fisher Reversal Length\")\nhigh_ = ta.highest(hl2, len)\nlow_ = ta.lowest(hl2, len)\nround_(val) => val > .99 ? .999 : val < -.99 ? -.999 : val\nvalue = 0.0\nvalue := round_(.66 * ((hl2 - low_) / (high_ - low_) - .5) + .67 * nz(value[1]))\nfish0 = 0.0\nfish0 := .5 * math.log((1 + value) / (1 - value)) + .5 * nz(fish0[1])\nfish2 = fish0[1]\n// Smooth the Fisher with HMA to correlate with TRIX\nsmooth_length = input.int(5, title=\"Fisher Smoothing Length\", minval=1)\nfish1 = ta.hma(fish0, smooth_length)\n// Determine long and short conditions\nlongCondition = ta.crossover(roc, trix) and trix < 0 and open > hullma2\nshortCondition = ta.crossunder(roc, trix) and trix > 0 and open < hullma2\n// Exit conditions\nexitLongCondition = ta.crossunder(roc, trix) or fish1 > 1.5 and ta.crossunder(fish1\nexitShortCondition = ta.crossover(roc, trix) or fish1 < -1.5 and ta.crossover(fish1\n// Strategy entry and exit logic\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\nif exitLongCondition\n    strategy.close(\"Long\")\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\nif exitShortCondition\n    strategy.close(\"Short\")\n// Highlight periods for oscillater\nbgcolor(longCondition ?  color.new(color.yellow, 50) : na)\nbgcolor(shortCondition ?  color.new(color.white, 50) : na)\nhline(1.5, \"Overbought\", color= color.yellow)\nhline(0.75,\"Mid High\", color= color.gray)\nhline(0, \"Zero\", color= color.yellow)\nhline(-0.75, \"Mid Low\", color= color.gray)\nhline(-1.5, \"Oversold\", color= color.yellow)\nplot(fish1, color= color.yellow, title=\"Fisher Reversal\")\nplot(fish2, color= color.gray, title=\"Lag Trigger\")\nplotshape(series=ta.crossunder(roc, trix), style=shape.xcross, location=location.top\nplotshape(series=ta.crossover(roc, trix), style=shape.xcross, location=location.bottom\n// Strategy by KP"}]}
{"messages": [{"role": "user", "content": "Welcome to the \"Previous Day High Low Strategy only for Long\"!. This strategy aims to identify potential long trading opportunities based on the previous day's high and low prices, along with certain market strength conditions. Key Features: Entry Conditions: The strategy triggers a long position when the current day's closing price crosses above the previous day's high or low. Market Strength Filter: The strategy incorporates a market strength filter using the Average Directional Index (ADX). It only takes long positions when the ADX value is above a specific threshold and when there is a predominance of upward movement. Trade Timing: The strategy operates within a specified trade window, starting at 09:30 and ending at 15:10. Positions are closed at 15:15 if still active. Risk Management: The strategy employs dynamic stop-loss and profit-taking levels based on a user-defined Max Profit value. It has three profit targets (T1, T2, T3) and a stop-loss level to manage risk effectively. Rules: Ensure that the strategy idea is clearly understandable. Provide an easy-to-read title and a thoughtful description explaining the reasoning behind the strategy. All content should be ad-free. Avoid any form of promotion, advertising, or solicitation. No fundraising requests or money solicitation is allowed on TradingView. Publish in the same language as the TradingView subdomain you're on, except for script titles, which must be in English. Don't plagiarize. Create and share only unique content, and always give credit when using someone else's work. Be respectful, kind, and constructive when engaging with others. Zero tolerance for contentious political discourse, defamatory, threatening, or discriminatory remarks. Avoid sharing harmful, misleading, or inappropriate content. Respect the moderators' work and address complaints privately. Use only your original account and avoid creating duplicate or fake accounts. Do not attempt to manipulate the reputation system or engage in like-for-like schemes.  Explanation of how the strategy works 1. Previous Day's High and Low (HH, LL): In this strategy, we start by obtaining the high and low prices of the previous day (not the current day) using the request.security function. This function allows us to access historical data for a specific time frame. The high and low prices are stored in the variables HH and LL, respectively. 2. Entry Conditions: The strategy uses two conditions to trigger a long position: \t\tCondition 1 (Long Condition 1): If the closing price of the current day crosses above the previous day's high (HH), it generates a long signal. This is achieved using the ta.crossover function, which detects when a crossover occurs. Condition 2 (Long Condition 2): Similarly, if the closing price of the current day crosses above the previous day's low (LL), it also generates a long signal. Combined Condition: To take long positions, the strategy combines both long conditions using the logical OR operator (or). This means that if either of the two conditions is met, a long position will be initiated. 3. Market Strength Filter: The strategy also includes a filter based on the Average Directional Index (ADX) to gauge the market's strength before taking long positions. The ADX measures the strength of a trend in the market. The higher the ADX value, the stronger the trend. Calculation of ADX: The ADX is calculated using the adx function, which takes two parameters: LWdilength (DMI Length) and LWadxlength (ADX period). Strength Condition (strength_up): The strategy requires that the ADX value should be above a threshold (11 in this case) and that there is a predominance of upward movement (up > down) before initiating a long position. The LWADX value is multiplied by 2.5 and compared to the highest value of LWADX from the last 4 periods using ta.highest(LWADX, 4). If these conditions are met, the variable strength_up is set to true. Combined Condition: The strength_up condition is then combined with the long conditions using the logical AND operator (and). This means that the strategy will only take a long position if both the long conditions and the market strength condition are met. 4. Trade Timing: The strategy sets a specific trade window between 09:30 and 15:10. It will only execute trades within this time frame (TradeTime). 5. Risk Management: The strategy implements dynamic stop-loss (SL) and profit-taking levels (T1, T2, T3) based on a user-defined Max Profit value. The stop-loss is set as a percentage of the Max Profit value. As the position moves in favor of the trader, the profit targets are adjusted accordingly. 6. Position Management: The strategy uses the strategy.entry function to enter long positions based on the combined entry conditions. Once a position is open, the script uses strategy.exit to define the exit condition when either the profit target or stop-loss level is hit. The strategy.close function is used to close any open position at the end of the trade window (15:15). 7. Plotting: The strategy uses the plot function to visualize the previous day's high and low prices, as well as the stop-loss (SL) and profit-taking (T1, T2, T3) levels on the chart. Overall, the \"Previous Day High Low Strategy only for Long\" aims to identify potential long trading opportunities based on the previous day's price action and market strength conditions. However, as with any trading strategy, it's essential to thoroughly test it and consider risk management before applying it to real-world trading scenarios. Disclaimer: The information presented by this strategy is for educational purposes only and should not be considered as investment advice. The strategy is not designed for qualified investors. Always conduct your own research and consult with a financial advisor before making any trading decisions. Remember, the success of any trading strategy depends on various factors, including market conditions, risk management, and individual trading skills. Past performance is not indicative of future results."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 mangeshabhang19\n//@version=5\nstrategy(\"Previous Day High Low Strategy only for Long\", overlay=true, margin_long\n[HH, LL] = request.security(syminfo.tickerid, '1D', [high, low], barmerge.gaps_off\nOpenTime = timestamp(year, month, dayofmonth , 09, 30)   \nCloseTime = timestamp(year, month, dayofmonth, 15, 10)  \nExitTime = timestamp(year, month, dayofmonth, 15, 15)  \nTradeTime = time >= OpenTime and time <= CloseTime\nUW = open > close ? high - open : high - close\nLW = open > close ? close - low : open - low\nBody = open > close ? open - close : close - open\nUWP = (UW / (LW + UW)) * 100\nLWP = (LW / (LW + UW)) * 100\nlongCondition = ta.crossover(close, HH)\nlongCondition := longCondition or ta.crossover(close, LL)\nlongCondition := longCondition //and  high == close\nplot(HH, color= color.red,linewidth = 1)\nplot(LL, color= color.red,linewidth = 1) \n//============================================= Market Strength ============================\nLWadxlength = input(9, title='ADX period')\nLWdilength = input(11, title='DMI Length')\ndirmov(len) =>\n    up = ta.change(high)\n    down = -ta.change(low)\n    truerange = ta.rma(ta.tr, len)\n    plus = fixnan(100 * ta.rma(up > down and up > 0 ? up : 0, len) / truerange)\n    minus = fixnan(100 * ta.rma(down > up and down > 0 ? down : 0, len) / truerange\n    [plus, minus]\nadx(LWdilength, LWadxlength) =>\n    [plus, minus] = dirmov(LWdilength)\n    sum = plus + minus\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), LWadxlength)\n    [adx, plus, minus]\n[ADX, up, down] = adx(LWdilength, LWadxlength)\nLWADX = (ADX - 15) * 2.5\nadxcolor = up > down ?  color.green :  color.red\nstrength_up = LWADX > 11 and  up > down and LWADX > ta.highest(LWADX[1],4)\nlongCondition := longCondition and strength_up // and close>= high-input(15,'LW Size') \nplotshape(longCondition, title=\"Buy Signal\", location=location.belowbar, color= color.green\n//========================== POSITIONS ================================\nfloat MaxProfit = input(150.00,\"Max Profit\")\nfloat T1 = MaxProfit * 0.3\nfloat T2 = MaxProfit * 0.5\nfloat T3 = MaxProfit * 0.8\nfloat SL =  na\nfloat CP = na\nfloat EP = na\nif not na(EP[1]) \n    EP := EP[1]\nif not na(CP[1]) \n    CP := CP[1]\nif not na(SL[1]) \n    SL := SL[1]\n// Execute strategy on tick\nif (barstate.isconfirmed)\n    if (strategy.position_size == 0)\n        EP := na\n        CP := na\n        SL := na\n    if (longCondition and TradeTime)\n        strategy.entry(\"Long\", strategy.long)\nif (strategy.position_size > 0)\n    if na(EP[1]) \n        EP := strategy.position_avg_price\n        CP := EP\n        SL := math.min(input(15,\"Max SL\"), MaxProfit * 0.4)\n    if (high >= EP + T1) and CP <  EP + T1\n        CP := EP + T1\n        SL := CP-EP//SL * 0.8\n    if (high >= EP + T2) and CP < EP + T2\n        CP := EP + T2\n        SL := CP-EP-T1//SL * 0.8\n    if (high >= EP + T3) and CP < EP + T3\n        CP := EP + MaxProfit\n        SL := CP-EP-T2//SL * 0.8\n    strategy.exit(\"Exit Long\", \"Long\", limit = EP + MaxProfit, stop =CP-SL)\nif (strategy.position_size > 0 and time > CloseTime)\n    strategy.close(\"Long\")\n//PLOT\nplot(CP, title=\"Stop Loss\", color= color.yellow, linewidth=1, style = plot.style_linebr\nplot(EP, title=\"Stop Loss\", color= color.white, linewidth=1, style = plot.style_linebr\nplot(CP - SL, title=\"Stop Loss\", color= color.red, linewidth=1, style = plot.style_linebr\nplot(EP + T1, title=\"Target 1\", color= color.blue, linewidth=1, style = plot.style_linebr\nplot(EP + T2, title=\"Target 2\", color= color.blue, linewidth=1, style = plot.style_linebr\nplot(EP + T3, title=\"Target 3\", color= color.blue, linewidth=1, style = plot.style_linebr\nplot(EP + MaxProfit, title=\"Max Profit\", color= color.green, linewidth=1, style ="}]}
{"messages": [{"role": "user", "content": "This is a combination of two popular systematic trading strategies - in the trend following category.  The strategy is designed for use on the daily timeframe. Specific features of this system are outlined below: 1. Two different strategies to choose from, \"Trend\" which is a volatility adjusted Exponential Moving Average (EMA) crossover strategy and \"Breakout\" which is my adaptation of the well documented \"Turtle Strategy\" 2. Uses advanced position sizing and risk management, usually reserved for institutional portfolio management, a proven technique utilised by Commodity Trading Advisors and Managed Futures funds (Algo/Quant funds). \"Trend\" uses a fast (user defined) and slow EMA crossover, where the slow length is 5 times the fast length. The resulting signal is adjusted for the volatility of returns over a 252 lookback period, which helps to normalise the signal across different assets. The system goes long or short when it detects a new trend has formed. \"Break\" uses the highest high or lowest low over a user defined lookback period to define the recent range. This is converted into a price normalised signal to allow the system to detect when a breakout occurs. The system goes long or short based off the breakout signal. Position sizing is based on recent price volatility and the user defined annualised risk target. In essence positions are inverse volatility weighted, so larger size is opened during lower volatility and smaller size during increased volatility. Recent volatility is calculated as the standard deviation of returns with 14 period lookback, then extrapolated into an annualised volatility of expected returns. Annualised recent volatility is then referenced to the risk target set by the user to adjust the position size. The default settings are a conservative 15% annual risk target/volatility. Initial capital should be set as the maximum risk capital per trade (ie if $10,000 total capital and 10% risk per trade, initial capital should be $1000). Maximum leverage per position can be set independently, to facilitate hitting risk targets that are greater than the natural volatility of the traded asset, and to accommodate low volatility conditions, whilst maintaining overall risk controls. Direction (long or short) is at the user's discretion. Hard stop losses are based on multiples of the average true range of recent price (14 period lookback), user configurable. Strategy trailing stops are based off recent highest highs or lowest lows (user defined lookback) to cut the position if the trend or momentum is lost. Although both strategies can be run simultaneously, optimal diversification will be achieved if ran separately/individually to avoid masking of entries."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Crunchster1\n//@version=5\nstrategy(title=\"Crunchster's Turtle and Trend System\", shorttitle=\"Turtle Trend\", \n// Inputs and Parameters\nsrc = input(close, 'Source', group='Strategy Settings')\nlength = input.int(title=\"Lookback period for fast EMA\", defval=10, minval=2, group\nblength = input.int(title=\"Lookback period for Breakout\", defval=20, minval=5, step\nlong = input(true, 'Long', inline='08', group='Strategy toggle')\nshort = input(true, 'Short', inline='08', group='Strategy toggle', tooltip='Toggle long/short strategy on/off'\nEMAwt = input(false, 'Trend', inline='01', group='Strategy toggle')\nbreakwt = input(true, 'Breakout', inline='01', group='Strategy toggle', tooltip='Toggle trend/breakout strategy on/off'\nstopMultiple = input.float(2, 'Stop multiple', step=0.5, group='Risk Management Settings'\ntrail = input.int(10, 'Trail lookback', step=5, group='Risk Management Settings', \nlev = input.float(1, 'Max Leverage', step=0.5, group='Risk Management Settings', tooltip\nriskT = input.float(15, maxval=75, title='Annualised Volatility Target %', group='Risk Management Settings'\ncomp = input(true, 'Compounding', inline='09', group='Risk Management Settings')\nComppct = input.float(50, '%', step=5, inline='09', group='Risk Management Settings'\n// Backtesting period\nFromDay = input.int(defval=1, title='From Day', minval=1, maxval=31, inline='04', \nFromMonth = input.int(defval=1, title='From Mon', minval=1, maxval=12, inline='04'\nFromYear = input.int(defval=2018, title='From Yr', minval=1900, inline='04', group\nToDay = input.int(defval=1, title='To Day', minval=1, maxval=31, inline='05', group\nToMonth = input.int(defval=1, title='To Mon', minval=1, maxval=12, inline='05', group\nToYear = input.int(defval=9999, title='To Yr', minval=1900, inline='05', group='Backtest range'\nstart = timestamp(FromYear, FromMonth, FromDay, 00, 00)\nfinish = timestamp(ToYear, ToMonth, ToDay, 23, 59)\nwindow = time >= start and time <= finish\n// Breakout strategy\nlower = ta.lowest(low[1], blength)\nupper = ta.highest(high[1], blength)\nbasis = math.avg(upper, lower)\nsignal = 20*(close - basis) / (upper - lower)\n// Trend strategy\nfEMA = ta.ema(close[1], length)\nsEMA = ta.ema(close[1], length*5)\nemadiff = fEMA - sEMA\nnemadiff = 5*emadiff/(ta.stdev(close - close[1], 252))\n//Risk Management formulae\ntr = math.max(high - low, math.abs(high - close), math.abs(low - close)) //True range\nstopL = ta.sma(tr, 14) //Average true range\nstdev = ta.stdev(close-close[1], 14) //volatility of recent returns\nmaxcapital = strategy.initial_capital+strategy.netprofit //Maximum capital available to invest - initial ca\nannvol = 100*math.sqrt(365)*stdev/close //converts recent volatility of returns into annua\nrisk = 1.1\nif comp\n    risk := (strategy.initial_capital+(Comppct*strategy.netprofit/100))//adjust investment capital to include compounding\nelse\n    risk := strategy.initial_capital\nshares = (risk * (riskT/annvol)) / close //calculates volatility adjusted position size, de\nif ((shares*close) > lev*maxcapital) //ensures position size does not exceed available \n    shares := lev*maxcapital/close\n//To set the price at the entry point of trade\nPosopen() =>\n    math.abs(strategy.position_size[1]) <= 0 and math.abs(strategy.position_size) \nvar float openN = na\nif Posopen()\n    openN := stopL\n// Trailing stop\ntlower = ta.lowest(low[1], trail)\ntupper = ta.highest(high[1], trail)\ntbasis = math.avg(tupper, tlower)\ntsignal = 20*(close - tbasis) / (tupper - tlower)\n// Strategy Rules\nif EMAwt\n    if long\n        longCondition2 = (nemadiff >2 and nemadiff[1] <2) and window\n        exitlong = tsignal <= -10\n        if (longCondition2)\n            strategy.entry('Trend Long!', strategy.long, qty=shares)\n        if strategy.position_size > 0    \n            strategy.exit('Stop Long', from_entry = 'Trend Long!', stop=(strategy.opentrades.entry_price\n        if (exitlong)\n            strategy.close('Trend Long!', immediately = true)\n    if short\n        shortCondition2 = (nemadiff <-1 and nemadiff[1] >-1) and window\n        exitshort = tsignal >= 10\n        if (shortCondition2)\n            strategy.entry('Trend Short!', strategy.short, qty=shares)\n        if strategy.position_size < 0   \n            strategy.exit('Stop Short', from_entry = 'Trend Short!', stop=(strategy.opentrades.entry_price\n        if (exitshort)\n            strategy.close('Trend Short!', immediately = true)\nif breakwt\n    if long\n        longCondition1 = (signal >= 10) and window\n        exitlong = tsignal <= -10\n        if (longCondition1)\n            strategy.entry('Break Long!', strategy.long, qty=shares)\n        if strategy.position_size > 0    \n            strategy.exit('Stop Long', from_entry = 'Break Long!', stop=(strategy.opentrades.entry_price\n        if (exitlong)\n            strategy.close('Break Long!', immediately = true)\n    if short\n        shortCondition1 = (signal <= -10) and window\n        exitshort = tsignal >= 10\n        if (shortCondition1)\n            strategy.entry('Break Short!', strategy.short, qty=shares)\n        if strategy.position_size < 0   \n            strategy.exit('Stop Short', from_entry = 'Break Short!', stop=(strategy.opentrades.entry_price\n        if (exitshort)\n            strategy.close('Break Short!', immediately = true)\n// Visuals of trend and direction\nplot(nemadiff, title='EMA Forecast', color= color.black, display=display.none)\nplot(ta.sma(ta.median(math.sqrt(math.pow(nemadiff,2)), 700), 350), 'Forecast mean'\nMAColor = fEMA > sEMA ?  #00ff00 :  #ff0000\nMA1 = plot(fEMA, title='Fast EMA', color=MAColor)\nMA2 = plot(sEMA, title='Slow EMA', color=MAColor)\nfill(MA1, MA2, title='Band Filler', color=MAColor)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Improve readability, and enhance the plotting so that it's easier to spot the trend.                                                    Release Notes:                                                    update the chart to show new area based plotting."}, {"role": "assistant", "content": "//@version=5\nstrategy(title='[tradinghook] - Renko Trend Reversal Strategy', shorttitle='[tradinghook] - Renko TRS'\n// INPUTS\nrenkoATRLength = input.int(10, minval=1, title='ATR Length')\nstopLossPct = input.float(3, title='Stop Loss Percentage', step=0.1)\ntakeProfitPct = input.float(20, title='Take Profit Percentage', step=0.1)\nstartDate = input.time(timestamp(\"01 July 2023 00:00\"), title=\"Start Date\")\nendDate = input.time(timestamp(\"31 Dec 2025 23:59\"), title=\"End Date\")\nenableShorts = input.bool(true, title=\"Enable Shorts\")\nenableSignals = input.bool(true, title=\"Enable Buy/Sell Signals\")\nvar float stopLossPrice = na\nvar float takeProfitPrice = na\natr = ta.atr(renkoATRLength)\n// thanks to https://www.tradingview.com/script/2vKhpfVH-Renko-XZ/ for manually calculating renkoClose and renkoOpen\ngetRenkoClose() =>\n    p1 = 0.0\n    p1 := close > nz(p1[1]) + atr ? nz(p1[1]) + atr : close < nz(p1[1]) - atr ? nz(\n    p1\ncalculateRenkoOpen() =>\n    p3 = 0.0\n    p3 := open > nz(p3[1]) + atr ? nz(p3[1]) + atr : open < nz(p3[1]) - atr ? nz(p3\n    p3\ngetRenkoOpen() =>\n    open_v = 0.0\n    Br_2 = calculateRenkoOpen()\n    open_v := calculateRenkoOpen() != calculateRenkoOpen()[1] ? Br_2[1] : nz(open_v\n    open_v\n    // Calculate Renko open and close values\nrenkoOpen = getRenkoOpen()\nrenkoClose = getRenkoClose()\n// PLOTS\nplotOpen = plot(renkoOpen, title=\"Renko Open\", color= color.new(color.green, 100),\nplotClose = plot(renkoClose, title=\"Renko Close\", color= color.new(color.red, 100)\nfill(plotOpen, plotClose, title=\"Area Fill\", color=renkoClose < renkoOpen ?  color.new\n// SIGNALS\nif (enableSignals) \n    isWithinTimeRange = time >= startDate and time <= endDate\n    buySignal = ta.crossunder(renkoOpen, renkoClose) and isWithinTimeRange\n    sellSignal = ta.crossover(renkoOpen, renkoClose) and isWithinTimeRange and enableShorts\n    if (buySignal)\n        stopLossPrice := renkoOpen * (1 - stopLossPct / 100)\n        takeProfitPrice := renkoOpen * (1 + takeProfitPct / 100)\n        strategy.entry(\"Long\", strategy.long)\n        strategy.exit(\"ExitLong\", \"Long\", stop = stopLossPrice, limit = takeProfitPrice\n    if (sellSignal)\n        stopLossPrice := renkoOpen * (1 + stopLossPct / 100)\n        takeProfitPrice := renkoOpen * (1 - takeProfitPct / 100)\n        strategy.entry(\"Short\", strategy.short)\n        strategy.exit(\"ExitShort\", \"Short\", stop = stopLossPrice, limit = takeProfitPrice"}]}
{"messages": [{"role": "user", "content": "First I would like to give the original credit and thanks to @ceyhun for his amazing volume script. The way I decided to convert it into a strategy is divided into multiple types. First, I decided in order to smooth out the values and make it more accurate to adapt the values to multiple timeframes. After that I took the initial values from the buyers and sellers , and made a rest operation between them to have a flat difference between the power of both sides. WIth that later on I decided to to apply a volatility filter,in this case bollinger bands, in order to find out potential leading trends. At the same time in order to filter even more, I decided to make use as well for weekly VWAP values of the asset used. Lastly I added a dynamic risk management into it , based on the ATR Daily values of the asset values. As for the rules used, for example for long, I am looking that the price of the asset is above the weekly VWAP, after that I am checking that the MTF volume rest operation is both bullish and above the upper side of the bollinger. For short we would want the asset to be below the weekly VWAP, and the volume to be bearish and above the upper side of bollinger. The exit is either based on daily ATR values multipliers, or if we have a reverse condition. If you have any questions, please let me know !"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 original author ceyhun\n//@ exlux99 update\n//@version=5\nstrategy('Buying Selling Volume Strategy', format=format.volume, precision=0, overlay\nweekly_vwap = request.security(syminfo.tickerid, \"W\", ta.vwap(hlc3))\nvi = false\ncustomTimeframe = input.timeframe(\"60\", group=\"Entry Settings\")\nallow_long = input.bool(true, group=\"Entry Settings\")\nallow_short = input.bool(false, group=\"Entry Settings\")\nxVolume = request.security(syminfo.tickerid, customTimeframe, volume)\nxHigh = request.security(syminfo.tickerid, customTimeframe, high)\nxLow = request.security(syminfo.tickerid, customTimeframe, low)\nxClose = request.security(syminfo.tickerid, customTimeframe, close)\nBV = xHigh == xLow ? 0 : xVolume * (xClose - xLow) / (xHigh - xLow)\nSV = xHigh == xLow ? 0 : xVolume * (xHigh - xClose) / (xHigh - xLow)\nvol = xVolume > 0 ? xVolume : 1\nTP = BV + SV\nBPV = BV / TP * vol\nSPV = SV / TP * vol\nTPV = BPV + SPV\ntavol20 = request.security(syminfo.tickerid, customTimeframe, ta.ema(vol, 20))\ntabv20= request.security(syminfo.tickerid, customTimeframe, ta.ema(BV, 20))\ntasv20= request.security(syminfo.tickerid, customTimeframe, ta.ema(SV, 20))\nVN = vol / tavol20\nBPN = BV / tabv20 * VN * 100\nSPN = SV / tasv20 * VN * 100\nTPN = BPN + SPN\nxbvp = request.security(syminfo.tickerid, customTimeframe,-math.abs(BPV))\nxbpn = request.security(syminfo.tickerid, customTimeframe,-math.abs(BPN))\nxspv = request.security(syminfo.tickerid, customTimeframe,-math.abs(SPV))\nxspn = request.security(syminfo.tickerid, customTimeframe,-math.abs(SPN))\nBPc1 = BPV > SPV ? BPV : xbvp\nBPc2 = BPN > SPN ? BPN : xbpn\nSPc1 = SPV > BPV ? SPV : xspv\nSPc2 = SPN > BPN ? SPN : xspn\nBPcon = vi ? BPc2 : BPc1\nSPcon = vi ? SPc2 : SPc1\nminus = BPcon + SPcon\nplot(minus, color = BPcon > SPcon  ?  color.green :  color.red , style=plot.style_columns\nlength = input.int(20, minval=1, group=\"Volatility Settings\")\nsrc = minus//input(close, title=\"Source\")\nmult = input.float(2.0, minval=0.001, maxval=50, title=\"StdDev\", group=\"Volatility Settings\"\nxtasma = request.security(syminfo.tickerid, customTimeframe, ta.sma(src, length))\nxstdev = request.security(syminfo.tickerid, customTimeframe, ta.stdev(src, length)\nbasis = xtasma\ndev = mult * xstdev\nupper = basis + dev\nlower = basis - dev\nplot(basis, \"Basis\", color= #FF6D00, offset = 0)\np1 = plot(upper, \"Upper\", color= #2962FF, offset = 0)\np2 = plot(lower, \"Lower\", color= #2962FF, offset = 0)\nfill(p1, p2, title = \"Background\", color= color.rgb(33, 150, 243, 95))\n// Original a\nlongOriginal = minus > upper and BPcon > SPcon and close > weekly_vwap\nshortOriginal = minus > upper and BPcon < SPcon and close< weekly_vwap\nhigh_daily = request.security(syminfo.tickerid, \"D\", high)\nlow_daily  = request.security(syminfo.tickerid, \"D\", low)\nclose_daily = request.security(syminfo.tickerid, \"D\", close)\ntrue_range = math.max(high_daily - low_daily, math.abs(high_daily - close_daily[1]\natr_range = ta.sma(true_range*100/request.security(syminfo.tickerid, \"D\", close), \nProfitTarget_Percent_long = input.float(100.0, title='TP Multiplier for Long entries '\nProfit_Ticks_long = close + (close * (atr_range * ProfitTarget_Percent_long))/100\nLossTarget_Percent_long = input.float(1.0, title='SL Multiplier for Long entries',\nLoss_Ticks_long = close - (close * (atr_range * LossTarget_Percent_long ))/100\nProfitTarget_Percent_short = input.float(100.0, title='TP Multiplier for Short entries '\nProfit_Ticks_short = close - (close * (atr_range*ProfitTarget_Percent_short))/100\nLossTarget_Percent_short = input.float(5.0, title='SL Multiplier for Short entries'\nLoss_Ticks_short = close + (close * (atr_range*LossTarget_Percent_short))/100\nvar longOpened_original = false\nvar int timeOfBuyLong = na\nvar float tpLong_long_original = na\nvar float slLong_long_original = na\nlong_entryx = longOriginal\nlongEntry_original = long_entryx and not longOpened_original \nif longEntry_original\n    longOpened_original := true\n    tpLong_long_original := Profit_Ticks_long\n    slLong_long_original := Loss_Ticks_long\n    timeOfBuyLong := time\n    //lowest_low_var_sl := lowest_low\n     tpLong_trigger = longOpened_original[1] and ((close > tpLong_long_original) or (high\nslLong_Trigger = longOpened_original[1] and ((close < slLong_long_original) or (low\nlongExitSignal_original =   shortOriginal or tpLong_trigger or slLong_Trigger \nif(longExitSignal_original)\n    longOpened_original := false\n    tpLong_long_original := na\n    slLong_long_original := na\nif(allow_long)\n    strategy.entry(\"long\", strategy.long, when=longOriginal) \n    strategy.close(\"long\", when= longExitSignal_original) //or shortNew\nif(allow_short)\n    strategy.entry(\"short\", strategy.short, when=shortOriginal ) \n    strategy.close(\"short\", when= longOriginal) //or shortNew"}]}
{"messages": [{"role": "user", "content": "- Introduction and how it is different The PresentTrend strategy is a unique custom trend-following strategy. This combination allows the strategy to take advantage of both short-term and long-term market trends, making it suitable for various market conditions. BTCUSDT 4hr chart (700.hk/) 3D chart - Strategy, How it Works RSI or MFI: The first part uses a custom indicator based on either the Relative Strength Index (RSI) or the Money Flow Index (MFI). The indicator calculates a PresentTrend value, which generates buy and sell signals based on its crossover and crossunder, indicating potential trend reversals. ATR: The second part is a popular trend-following indicator that uses the Average True Range (ATR).  The strategy enters a long position when all buy signals from both strategies are true, and a short position when all sell signals are true. This ensures trades are entered when both short-term and long-term trends align, potentially increasing the strategy's reliability. - Trade direction The strategy also includes a trade direction parameter, allowing the user to choose whether to enter long trades, short trades, or both. This makes the strategy adaptable to different market conditions and trading styles. - Usage 1. Set the input parameters for the custom trend-following strategy. 2. Choose whether to use the RSI or MFI for the custom strategy. 3. Choose the trade direction: long, short, or both. 4. The strategy will generate buy and sell signals based on the conditions of both strategies. 5. Enter a trade when a buy or sell signal is generated, depending on the chosen trade direction. Please note that this strategy is meant to be a tool to aid in your trading decisions and not a standalone trading system. Always use proper risk management and make sure to test the strategy thoroughly before using it in live trading. - Default settings 1. Source: 'hlc3', a balanced price level for calculations. 2. Length: 14, a common setting for many technical indicators. 3. Multiplier: 1.618 (the golden ratio), used in calculating the upper and lower thresholds. 4. RSI or MFI: Set to use MFI by default, both are momentum indicators. 5. Trade Direction: 'Both', allowing for both long and short trades. The default settings are designed to provide a balanced approach to trend detection. However, these can be adjusted based on the user's preferences and the specific characteristics of the market being traded. - Strategy's default Properties 1. Default Quantity Type: 'strategy.percent_of_equity'  2. commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1: These parameters set the commission and slippage for the strategy. The commission is set to 0.1% of the trade value, and the slippage (the difference between the expected price of a trade and the price at which the trade is executed) is set to 1. 3. default_qty_type = strategy.percent_of_equity, default_qty_value = 10: These parameters set the default quantity for trades. The default_qty_type is set to strategy.percent_of_equity, which means that the size of each trade will be a percentage of the account equity. The default_qty_value is set to 10, which means that each trade will be 10% of the account equity. 4. initial_capital= 10000: This parameter sets the initial capital for the strategy to $10,000."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 PresentTrading\n//@version=5\n// Define the strategy settings\nstrategy('PresentTrend - Strategy [presentTrading]' , overlay=true, precision=3, default_qty_type\n commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1, \n  currency=currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value\n// Define the input parameters\npriceSource  = input.source(title='Source', defval=hlc3, group='PresentTrend') // The price source to use\nlengthParam  = input.int(title='Length', defval=14, group='PresentTrend') // The length of the moving average\nmultiplier = input.float(title='Multiplier', defval=1.618, step=0.1, group='PresentTrend'\nindicatorChoice  = input.bool(title='Whether to use RSI or MFI', defval=false, group\n// Add a parameter for choosing Long or Short\ntradeDirection = input.string(title=\"Trade Direction\", defval=\"Both\", options=[\"Long\"\n// Calculate the ATR and the upT and downT values\nATR = ta.sma(ta.tr, lengthParam)\nupperThreshold = low - ATR * multiplier \nlowerThreshold  = high + ATR * multiplier \n// Initialize the PresentTrend indicator\nPresentTrend = 0.0\n// Calculate the PresentTrend indicator\nPresentTrend := (indicatorChoice ? ta.rsi(priceSource, lengthParam) >= 50 : ta.mfi(\n// Calculate the buy and sell signals\nlongSignal  = ta.crossover(PresentTrend, PresentTrend[2])\nshortSignal  = ta.crossunder(PresentTrend, PresentTrend[2])\n// Calculate the number of bars since the last buy and sell signals\nbarsSinceBuy = ta.barssince(longSignal)\nbarsSinceSell = ta.barssince(shortSignal)\npreviousBuy = ta.barssince(longSignal[1])\npreviousSell = ta.barssince(shortSignal[1])\n// Initialize the direction variable\ntrendDirection = 0\n// Calculate the direction of the trend\ntrendDirection := longSignal and previousBuy > barsSinceSell ? 1 : shortSignal and \n// Check the trade direction parameter before entering a trade\nif (trendDirection == 1 and (tradeDirection == \"Long\" or tradeDirection == \"Both\"))\n    strategy.entry(\"Buy\", strategy.long) \nif (trendDirection == -1 and (tradeDirection == \"Short\" or tradeDirection == \"Both\"\n    strategy.entry(\"Sell\", strategy.short) \n// Add a stop mechanism when the tradeDirection is one-sided\nif (tradeDirection == \"Long\" and trendDirection == -1)\n    strategy.close(\"Buy\")\nif (tradeDirection == \"Short\" and trendDirection == 1)\n    strategy.close(\"Sell\")\n// Visualization\nplot(PresentTrend, color= color.blue, title=\"PresentTrend\")\nplotshape(series=longSignal, location=location.belowbar, color= color.green, style\nplotshape(series=shortSignal, location=location.abovebar, color= color.red, style="}]}
{"messages": [{"role": "user", "content": "This is a conceptual strategy intended for E-mini S&P 500 futures with hourly bars. It uses three signals, going long or short when two or more change in the same direction. First is MACD. A positive oscillator is considered a bullish signal and a falling oscillator is interpreted bearishly. Next, stochastics are used as an overbought/oversold indicator. Overbought conditions are considered bearish and oversold readings are viewed as bullish. Third is a custom indicator based on our Moving Average Speed script. It takes the rate of change of the 50-hour simple moving average (SMA), and then smooths it using a 10-period average. This provides a directional signal. Traders may want to experiment with different settings for moving average speed.  Note: This is intended for use with stock index futures, which have round-the clock price data to populate the data in the indicators. It may not yield good results with stocks or ETFs. TradeStation has, for decades, advanced the trading industry, providing access to stocks, options, futures and cryptocurrencies. See our Overview for more. Important Information TradeStation Securities, Inc., TradeStation Crypto, Inc., and TradeStation Technologies, Inc. are each wholly owned subsidiaries of TradeStation Group, Inc., all operating, and providing products and services, under the TradeStation brand and trademark. TradeStation Crypto, Inc. offers to self-directed investors and traders cryptocurrency brokerage services.  It is neither licensed with the SEC or the CFTC nor is it a Member of NFA. When applying for, or purchasing, accounts, subscriptions, products, and services, it is important that you know which company you will be dealing with. Please click here for further important information explaining what this means. This content is for informational and educational purposes only. This is not a recommendation regarding any investment or investment strategy.  Any opinions expressed herein are those of the author and do not represent the views or opinions of TradeStation or any of its affiliates.  Investing involves risks. Past performance, whether actual or indicated by historical tests of strategies, is no guarantee of future performance or success. There is a possibility that you may sustain a loss equal to or greater than your entire investment regardless of which asset class you trade (equities, options, futures, or digital assets); therefore, you should not invest or risk money that you cannot afford to lose. Before trading any asset class, first read the relevant risk disclosure statements on the Important Documents page, found here: www.tradestation.com/important-information."}, {"role": "assistant", "content": "// By TradeStation\n//@version=5\nstrategy(\"Mov Avg Speed Strategy\", overlay=true)\nsrc = input(close, title=\"Source\")\n// MA Speed  \navg_len = input.int(50, minval=1, title=\"Avg Length\", group=\"MA Speed\")\nroc_len = input.int(1, minval=1, title=\"Rate of Change Length\", group=\"MA Speed\")\navg_roc_len = input.int(10, minval=1, title=\"Avg Rate of Change Length\", group=\"MA Speed\"\n// Stochastic\nstoch_len = input.int(14, minval=1, title=\"Stochastic Length\", group=\"Stochastic\")\nsmooth_k = input.int(3, minval=1, title=\"Stochastic Smooth K\", group=\"Stochastic\")\noverbought = input.float(80, title=\"Stochastic Overbought\", group=\"Stochastic\")\noversold = input.float(20, title=\"Stochastic Oversold\", group=\"Stochastic\")\n// MACD\nfast_length = input(12, title=\"Fast Length\", group=\"MACD\")\nslow_length = input(26, title=\"Slow Length\", group=\"MACD\")\nmacd_avg_length = input.int(9, title=\"MACD Avg Length\",  minval=1, group=\"MACD\")\n// MA Speed\navg = ta.sma(src, avg_len)\nroc = ta.roc(avg, roc_len)\navg_roc = ta.sma(roc, avg_roc_len)\navg_roc_signal = avg_roc > 0 ? 1 : avg_roc < 0 ? -1 : 0 \n// Stochastic k\nk = ta.sma(ta.stoch(close, high, low, stoch_len), smooth_k)\nstochastic_signal = k <= oversold ? 1 : k >= overbought ? -1 : 0\n// MACD\nfast_ma = ta.ema(src, fast_length)\nslow_ma = ta.ema(src, slow_length)\nmacd = fast_ma - slow_ma\nmacd_avg = ta.ema(macd, macd_avg_length)\nmacd_signal = macd_avg > macd_avg[1] ? 1 : macd_avg < macd_avg[1] ? -1 : 0\n// set the signal couint\nlong_count = 0\nshort_count = 0\nif macd_signal == 1\n    long_count += 1\nelse if macd_signal == -1\n    short_count += 1\n if stochastic_signal == 1\n    long_count += 1\nelse if stochastic_signal == -1\n    short_count += 1\n if avg_roc_signal == 1\n    long_count += 1\nelse if avg_roc_signal == -1\n    short_count += 1\nif (long_count >= 2)\n    strategy.entry(\"Long\", strategy.long)\nif (short_count >= 2)\n    strategy.entry(\"Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "Introduction:  In the ever-evolving world of Forex trading, strategies that provide a competitive edge are highly sought after. The Moving Average (MA) crossover technique is a popular long-term approach, but its vulnerability to false signals can lead to potential losses. To overcome this challenge, we introduce a game-changing MA crossover filter designed to weed out false signals and unlock the full potential of this strategy. In this article, we delve into the mechanics of this filter, providing a comprehensive analysis of its components and how it enhances the accuracy of buy and sell signals. The Power of the MA Crossover Filter: The essence of our MA crossover filter lies in the integration of a specialized indicator that operates on a scale of 0 to 100. This ingenious indicator dynamically measures the distance between the middle Bollinger band and either the upper or lower Bollinger band. By analyzing the values of the last 504 candlesticks, it maps the range from 50 to 100 for the largest and smallest distances between the middle and upper Bollinger bands. Similarly, for values ranging from 0 to 50, it measures the distance between the middle and lower Bollinger bands. Unveiling the Signal Execution Process:  The brilliance of this filter is revealed in its meticulous execution of buy and sell signals, which significantly reduces false crossovers. Let's explore the process step-by-step: Buy Signal Precision:  To initiate a buy signal, the price must be positioned above the 200-period Simple Moving Average (SMA). The filter validates the crossover by checking the indicator's value, ensuring it falls below the threshold of 25. Sell Signal Accuracy:  For a sell signal, the price must be below the 200-period Simple Moving Average (SMA). The filter confirms the crossover by verifying the indicator's value, which should exceed the threshold of 75. This selective approach ensures that only high-confidence crossovers are considered, maximizing the potential for profitable trades. Fine-Tuning the Filter for Optimal Performance:  While the MA crossover filter exhibits its prowess in GBPUSD and EURUSD currency pairs, it may require adjustments for other pairs. Currency pairs possess unique characteristics, and adapting the filter to specific behavior is crucial for its success. To fine-tune the filter for alternative currency pairs, traders should conduct rigorous backtesting and analyze historical price data. By experimenting with indicator threshold values, traders can calibrate the filter to accurately match the dynamics of the target currency pair. This iterative process allows for customization, ultimately resulting in a finely-tuned filter that aligns with the unique behavior of the selected market. Conclusion:  The MA crossover filter represents a paradigm shift in long-term Forex trading strategies. By intelligently filtering false signals, this precision tool unleashes the true potential of the MA crossover technique, elevating its profitability and enhancing overall trading performance. While no strategy guarantees absolute success, incorporating this filter empowers traders with a heightened level of confidence in their buy and sell signals. Embracing the power of this innovative filter can be a transformative step towards mastering Forex profits and staying ahead in the dynamic world of currency trading."}, {"role": "assistant", "content": "//@version=4\nstrategy(title=\"EMA Difference Mapping with Trades\", shorttitle=\"EMA Diff Map\", overlay\n// Inputs\nemaLength = input(20, \"EMA Length\")\nstdDevLength = input(2, \"Standard Deviation Length\")\npriceSource = close\ntakeProfitPoints = input(1000, title=\"Take Profit (in Points)\")\nstopLossPoints = input(2500, title=\"Stop Loss (in Points)\")\n// Calculate EMA\nema = ema(priceSource, emaLength)\n// Calculate Standard Deviation\nstdDev = stdev(priceSource, stdDevLength)\n// Calculate differences\ndiff1 = (ema + stdDev) - ema\ndiff2 = ema - (ema - stdDev)\n// Calculate min and max differences from last year\nlookbackPeriod = 504 // Number of trading days in a year\nminDiff1 = lowest(diff1, lookbackPeriod)\nmaxDiff1 = highest(diff1, lookbackPeriod)\nminDiff2 = lowest(diff2, lookbackPeriod)\nmaxDiff2 = highest(diff2, lookbackPeriod)\n// Map differences based on requirements\nmappedDiff1 = 50 + 50 * ((diff1 - minDiff1) / (maxDiff1 - minDiff1))\nmappedDiff2 = 50 - 50 * ((diff2 - minDiff2) / (maxDiff2 - minDiff2))\n// Combine mapped differences into a single line\nmappedLine = if close > ema\n    mappedDiff1\nelse\n    mappedDiff2\n// Plot 'mappedLine' in the main chart area conditionally\nplot(mappedLine, title=\"EMA Difference Mapping\", color=(close > ema ?  color.blue \n// Calculate the 50EMA and 200SMA\nema50 = ema(close, 50)\nsma200 = sma(close, 200)\n// Plot the 50EMA and 200SMA on the main chart\nplot(ema50, color= color.blue, title=\"50 SMA\", linewidth=2)\nplot(sma200, color= color.red, title=\"200 SMA\", linewidth=2)\n// Initialize trade variables\nvar bool waitingForBuy = na\nvar bool waitingForSell = na\nvar bool buyConditionMet = false\nvar bool sellConditionMet = false\nif not sellConditionMet and crossunder(ema50, sma200)\n    sellConditionMet := true\n    waitingForBuy := false\nif sellConditionMet \n    waitingForSell := true\n    sellConditionMet := false\nif waitingForSell and close < sma200 and mappedLine > 75\n    strategy.entry(\"Sell\", strategy.short)\n    strategy.exit(\"Sell Exit\", \"Sell\", profit=takeProfitPoints, loss=stopLossPoints\n    waitingForSell := false\n// Define the strategy conditions and execute trades\nif not buyConditionMet  and crossover(ema50, sma200)\n    buyConditionMet := true\n    waitingForSell := false\nif buyConditionMet \n    waitingForBuy := true\n    buyConditionMet := false\nif waitingForBuy and close > sma200 and mappedLine < 25\n    strategy.entry(\"Buy\", strategy.long)\n    strategy.exit(\"Buy Exit\", \"Buy\", profit=takeProfitPoints, loss=stopLossPoints)\n    waitingForBuy := false"}]}
{"messages": [{"role": "user", "content": "What are financial ratios? Financial ratios are basic calculations using quantitative data from a company\u2019s financial statements. They are used to get insights and important information on the company\u2019s performance, profitability, and financial health. Common financial ratios come from a company\u2019s balance sheet, income statement, and cash flow statement. Businesses use financial ratios to determine liquidity, debt concentration, growth, profitability, and market value. The common financial ratios every business should track are 1) liquidity ratios 2) leverage ratios 3)efficiency ratio 4) profitability ratios 5) market value ratios. Initially I had a big list of 20 different ratios for testing, but in the end I decided to stick for the strategy with these ones : Current ratio: Current Assets / Current Liabilities The current ratio measures how a business\u2019s current assets, such as cash, cash equivalents, accounts receivable, and inventories, are used to settle current liabilities such as accounts payable. Interest coverage ratio: EBIT / Interest expenses Companies generally pay interest on corporate debt. The interest coverage ratio shows if a company\u2019s revenue after operating expenses can cover interest liabilities. Payables turnover ratio: Cost of Goods sold (or net credit purchases) / Average Accounts Payable The payables turnover ratio calculates how quickly a business pays its suppliers and creditors. Gross margin: Gross profit / Net sales The gross margin ratio measures how much profit a business makes after the cost of goods and services compared to net sales. With this data, I have created the long and long exit strategy: For long, if any of the 4 listed ratios,such as current ratio or interest coverage ratio or payable turn ratio or gross margin ratio  is ascending after a quarter, its a potential long entry. For example in january the gross margin ratio is at 10% and in april is at 15%, this is an increase from a quarter to another, so it will get a long entry trigger.  The same could happen if any of the 4 listed ratios follow the ascending condition since they are all treated equally as important For exit, if any of the 4 listed ratios are descending after a quarter, such as current ratio or interest coverage ratio or payable turn ratio or gross margin ratio  is descending after a quarter,  its a potential long exit. For example in april we entered a long trade, and in july data from gross margin comes as 12% .  In this case it fell down from 15% to 12%, triggering an exit for our trade. However there is a special case with this strategy, in order to make it more re active and make use of the compound effect: So lets say on july 1 when the data came in, the gross margin data came descending (indicating an exit for the long trade), however at the same the interest coverage ratio came as positive, or any of the other 3 left ratios left . In that case the next day after the trade closed, it will enter a new long position and wait again until a new quarter data for the financial is being published. Regarding the guidelines of tradingview, they recommend to have more than 100 trades.  With this type of strategy, using Daily timeframe and data from financials coming each quarter(4 times a year), we only have the financial data available since 2016, so that makes 28 quarters of data, making a maximum potential of 28 trades. This can however be \"bypassed\" to check the integrity of the strategy and its edge, by taking for example multiple stocks and test them in a row, for example, appl, msft, goog, brk and so on, and you can see the correlation between them all. At the same time I have to say that this strategy is more as an educational one since it miss a risk management and other additional filters to make it more adapted for real live trading, and instead serves as a guiding tool for those that want to make use of fundamentals in their trades If you have any questions, please let me know !"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n//@version=5\n//exlux99\nstrategy('Financial Ratios', overlay=true,initial_capital = 1000000, default_qty_type\n//Current ratio: Current Assets / Current Liabilities\nTOTAL_CURRENT_ASSETS = request.financial(syminfo.tickerid, \"TOTAL_CURRENT_ASSETS\",\nTOTAL_CURRENT_LIABILITIES = request.financial(syminfo.tickerid, \"TOTAL_CURRENT_LIABILITIES\"\ncurrent_ratio =  TOTAL_CURRENT_ASSETS/ TOTAL_CURRENT_LIABILITIES\n// plot(current_ratio)\n//Quick ratio (Acid-test ratio): (Current Assets \u2013 Inventories \u2013 Prepaid Expenses) / Current \nPREPAID_EXPENSES = request.financial(syminfo.tickerid, \"PREPAID_EXPENSES\", \"FQ\")\nINVENTORY_FINISHED_GOODS = request.financial(syminfo.tickerid, \"INVENTORY_FINISHED_GOODS\"\nquick_ratio = (TOTAL_CURRENT_ASSETS - INVENTORY_FINISHED_GOODS - PREPAID_EXPENSES)\n// plot(quick_ratio, color=color.white)\n//Cash ratio: Cash and cash equivalents / Current Liabilities\nCASH_N_EQUIVALENTS = request.financial(syminfo.tickerid, \"CASH_N_EQUIVALENTS\", \"FQ\"\ncash_ratio = CASH_N_EQUIVALENTS / TOTAL_CURRENT_LIABILITIES\n// plot(cash_ratio, color=color.orange)\nlong_liquidity =  current_ratio > current_ratio[1] and quick_ratio > quick_ratio[1\nlong_exit_liquidity =  current_ratio < current_ratio[1] and quick_ratio < quick_ratio\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//Leverage ratios\n//Debt ratio: Total Debt / Total Assets\nTOTAL_DEBT= request.financial(syminfo.tickerid, \"TOTAL_DEBT\", \"FQ\")\nTOTAL_ASSETS = request.financial(syminfo.tickerid, \"TOTAL_ASSETS\", \"FQ\")\ndebt_ratio = TOTAL_DEBT / TOTAL_ASSETS\n//plot(debt_ratio)\n//Debt to equity ratio: Total Debt / Total Equity\nTOTAL_EQUITY= request.financial(syminfo.tickerid, \"TOTAL_EQUITY\", \"FQ\")\ndebt_equity_ratio = TOTAL_DEBT / TOTAL_EQUITY\n//plot(debt_equity_ratio,color=color.white)\n//Interest coverage ratio: EBIT / Interest expenses\nEBIT = request.financial(syminfo.tickerid, \"EBIT\", \"FQ\")\nINTEREST_EXPENSE_ON_DEBT = request.financial(syminfo.tickerid, \"INTEREST_EXPENSE_ON_DEBT\"\ninterest_ratio = EBIT / INTEREST_EXPENSE_ON_DEBT\n//plot(interest_ratio, color=color.orange)\nlong_leverage =  debt_ratio < debt_ratio[1] and debt_equity_ratio< debt_equity_ratio\nlong_exit_leverage =  debt_ratio > debt_ratio[1] and debt_equity_ratio > debt_equity_ratio\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Efficiency ratios\n//Asset turnover ratio: Net sales / Average total assets\nSALES_OF_BUSINESS =request.financial(syminfo.tickerid, \"TOTAL_REVENUE\", \"FQ\")\nasset_turnover_ratio = SALES_OF_BUSINESS / TOTAL_ASSETS\n// plot(asset_turnover_ratio)\n//Inventory turnover: Cost of goods sold / Average value of inventory\n// COST_OF_GOODS= request.financial(syminfo.tickerid, \"COST_OF_GOODS\", \"FQ\")\n// TOTAL_INVENTORY = request.financial(syminfo.tickerid, \"TOTAL_INVENTORY\", \"FQ\")\n// inventory_turnover = COST_OF_GOODS/ TOTAL_INVENTORY\nINVENT_TO_REVENUE = request.financial(syminfo.tickerid, \"INVENT_TO_REVENUE\", \"FQ\")\n// plot(INVENT_TO_REVENUE,color=color.white)\n//Payables turnover ratio: Cost of Goods sold (or net credit purchases) / Average Accounts Payable\nCOST_OF_GOODS = request.financial(syminfo.tickerid, \"COST_OF_GOODS\", \"FQ\")\nACCOUNTS_PAYABLE= request.financial(syminfo.tickerid, \"ACCOUNTS_PAYABLE\", \"FQ\")\npayable_turnover = COST_OF_GOODS / ACCOUNTS_PAYABLE\n// plot(payable_turnover,color=color.orange)\n//Receivables turnover ratio: Net credit sales / Average accounts receivable\nlong_Efficiency  = asset_turnover_ratio > asset_turnover_ratio[1]  and payable_turnover\nlong_exit_Efficiency = asset_turnover_ratio < asset_turnover_ratio[1] and payable_turnover\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Profitability  ratios\n//Gross margin: Gross profit / Net sales\nGROSS_PROFIT = request.financial(syminfo.tickerid, \"GROSS_PROFIT\", \"FQ\")\nSALES          = request.financial(syminfo.tickerid, \"TOTAL_REVENUE\", \"FQ\")\ngross_margin =  GROSS_PROFIT / SALES\n// plot(gross_margin)\n//Operating margin: Operating income / Net sales\nOPER_INCOME = request.financial(syminfo.tickerid, \"OPER_INCOME\", \"FQ\")\noperating_margin = OPER_INCOME/ SALES\n// plot(operating_margin, color=color.white)\n//Return on assets (ROA): Net income / Total assets\nNET_INCOME= request.financial(syminfo.tickerid, \"NET_INCOME\", \"FQ\")\nroa = NET_INCOME/TOTAL_ASSETS\n//plot(roa, color=color.orange)\n //Return on equity (ROE): Net income / Total equity\nroe = NET_INCOME / TOTAL_EQUITY\n//plot(roe, color=color.purple)\nlong_profitability =  (gross_margin > gross_margin[1] and operating_margin>operating_margin\nlong_exit_profitability =  (gross_margin < gross_margin[1] and operating_margin<operating_margin\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//5)   Market Value ratios\n//Earnings per share ratio (EPS): (Net Income \u2013 Preferred Dividends) / End-of-Period Common Shares \nPREFERRED_DIVIDENDS = request.financial(syminfo.tickerid, \"PREFERRED_DIVIDENDS\", \"FQ\"\nTOTAL_SHARES_OUTSTANDING = request.financial(syminfo.tickerid, \"TOTAL_SHARES_OUTSTANDING\"\neps_ratio = (NET_INCOME - PREFERRED_DIVIDENDS)/TOTAL_SHARES_OUTSTANDING\n// plot(eps_ratio)\n// //Price earnings ratio (P/E): Share price / Earnings per share\n// EPS = request.financial(syminfo.tickerid, \"EARNINGS_PER_SHARE\", \"FQ\")\n// closex = request.security(syminfo.tickerid, \"M\", close)\n// PE_RATIO = closex / eps_ratio\n// plot(PE_RATIO,color=color.white) \n//Book value per share ratio: (Total Equity \u2013 Preferred Equity) / Total shares outstanding\nCOMMON_EQUITY_TOTAL = request.financial(syminfo.tickerid, \"COMMON_EQUITY_TOTAL\", \"FQ\"\npreferred_equity = TOTAL_EQUITY - COMMON_EQUITY_TOTAL\nTSO = request.financial(syminfo.tickerid, \"TOTAL_SHARES_OUTSTANDING\", \"FQ\")\nbook_value = (TOTAL_EQUITY - preferred_equity)/TSO\n// plot(book_value, color=color.white)\n//Dividend yield ratio: Dividend per share / Share price\nDIVIDENDS_YIELD = request.financial(syminfo.tickerid, \"DIVIDENDS_YIELD\", \"FQ\")\n// plot(DIVIDENDS_YIELD,color=color.orange)\nlong_market = DIVIDENDS_YIELD > DIVIDENDS_YIELD[1] and eps_ratio > eps_ratio[1] and\nlong_exit_market =   DIVIDENDS_YIELD < DIVIDENDS_YIELD[1] and eps_ratio < eps_ratio\n//and (current_ratio > current_ratio[1] )\n//and interest_ratio < interest_ratio[1]\n//and payable_turnover > payable_turnover[1]\n//and gross_margin > gross_margin[1]\n//long_tot = (long_liquidity or long_leverage or long_Efficiency or long_profitability )   // or lon\nlong_tot = current_ratio > current_ratio[1] or interest_ratio < interest_ratio[1] \nlong_tot_exit =  current_ratio < current_ratio[1] or interest_ratio > interest_ratio\n// plot(current_ratio)\n// plot(interest_ratio, color=color.white)\n// plot(payable_turnover, color=color.orange)\n// plot(gross_margin, color=color.purple)\n// DEBT_TO_REVENUE = request.financial(syminfo.tickerid, \"SPRINGATE_SCORE\", \"FQ\")\n// plot(DEBT_TO_REVENUE)\nstrategy.entry(\"long\",strategy.long,when= ( long_tot or long_tot[1]  ))\nstrategy.close(\"long\",when= long_tot_exit )"}]}
{"messages": [{"role": "user", "content": "Trend Strategy #2 Indicators: 1. EMA(s) 2. Fibonacci retracement with a mutable lookback period  Strategy: 1. Short Only 2. No preset Stop Loss/Take Profit 3. 0.01% commission 4. When in a profit and a closure above the 200ema, the position takes a profit. 5. The position is stopped When a closure over the (0.764) Fibonacci ratio occurs. * NO IMMEDIATE RE-ENTRIES EVER!* How to use it and what makes it unique: This strategy will enter often and stop quickly. The goal with this strategy is to take losses often but catch the big move to the downside when it occurs through the Silvercross/Fibonacci combination. This is a unique strategy because it uses a programmed Fibonacci ratio that can be used within the strategy and on any program. You can manipulate the stats by changing the lookback period of the Fibonacci retracement and looking at different assets/timeframes.  This description tells the indicators combined to create a new strategy, with commissions and take profit/stop loss conditions included, and the process of strategy execution with a description of how to use it. If you have any questions feel free to PM me and boost if you found it helpful. Thank you, pineUSERS! CHEATCODE1"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 CheatCode1\n//@version=5\nstrategy(\"CC-Trend strategy 2\", overlay=true, initial_capital = 10000, commission_type\nema9 = ta.ema(close, 9)\nema21 = ta.ema(close, 21)\nema55 = ta.ema(close, 55)\nema200 = ta.ema(close, 200)\nplot(ema200, '22',  color.blue, 2)\nFibL = input.int(100, 'Fibonacci Length', 1, 500, group = 'Automatic Fibonacci Retracement'\nlen1 = input.int(1, 'Show Last', 0, 1000, group = 'Automatic Fibonacci Retracement'\nlen2 = input.int(5, 'Offset Length', 0, 1000, group = 'Automatic Fibonacci Retracement'\nhighF = ta.highest(ema55 >= ema9 ? ema55:ema9, FibL)\nlowF = ta.lowest(ema55 >= ema9 ? ema9:ema55, FibL)\nAvgFib = highF - lowF\n//Fibonacci Executions\nLL2 = highF + .618 * AvgFib\nLL1 = highF + .272 * AvgFib\nL1 = highF\nL236 = highF - 0.236 * AvgFib\nL382 = highF - 0.382 * AvgFib\nMid =  highF - 0.50 * AvgFib\nS382 = lowF + 0.382 * AvgFib\nS236 = lowF + 0.236 * AvgFib\nS1 = lowF\nSS1 = lowF - .272 * AvgFib\nSS2 = lowF - .618 * AvgFib\n//Fibonacci Plot's\nhigh2FP = plot(LL2, 'Highe2',  color.red,offset = len2, show_last = len1, trackprice\nhigh1FP = plot(LL1, 'Highe1',  color.red,offset = len2, show_last = len1, trackprice\nhighFP = plot(highF, 'High',  color.red,offset = len2, show_last = len1, trackprice\nL236P = plot(L236, \"0.764\",  #ED381C, offset = len2, show_last = len1, trackprice \nL382P = plot(L382, \"0.618\",  color.white,offset = len2, show_last = len1, trackprice\nMidP = plot(Mid, \"0.5\",  color.orange,offset = len2, show_last = len1, trackprice \nS382P = plot(S382, \"0.382\",  color.yellow ,offset = len2, show_last = len1, trackprice\nS236P = plot(S236, \"0.236\",  color.lime ,offset = len2, show_last = len1, trackprice\nlowFP = plot(lowF, 'Low',  color.green,offset = len2, show_last = len1, trackprice\nlow1FP = plot(SS1, 'Lowe1',  color.green,offset = len2, show_last = len1, trackprice\nlow2FP = plot(SS2, 'Lowe2',  color.green,offset = len2, show_last = len1, trackprice\nplot(ema9, '22',  color.yellow, 2)\nplot(ema55, '55',  color.aqua, 2)\nplot(ema200, '200',  color.maroon, 2)\nshortCondition = close[1] < highF and ema21 < ema55\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\nshorttp = ta.crossover(close, ema200) and strategy.openprofit >= 0\nif (shorttp)\n    strategy.close('Short', 'Short TP', qty_percent = 100)\nshortclose2 = close[1] > L236 and not (shortCondition) \nif(shortclose2)\n    strategy.close('Short', 'Short RM', qty_percent = 100)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    BUGFIX: \"License ID\" field would not let 13 digit integers to be added in the field due to its default maxval limit being lower. 13 digit integers can now be added."}, {"role": "assistant", "content": "// @version=5\n// @strategy_alert_message {{strategy.order.comment}}\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 TradeSmart22\nstrategy(default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding\n// PLOT SETTINGS\nplot_signals = input.bool(true, title=\"Plot Signals\", group=\"Plot Settings\", tooltip\nplot_sl_tp = input.bool(true, title=\"Plot SL/TP Lines\", group=\"Plot Settings\")\n// STRATEGY SETTINGS\n// Supertrend 1\nplot_st_1 = input.bool(false, title=\"Plot Supertrend 1\", group=\"Supertrend 1\")\ncan_be_entry_signal_st_1 = input.bool(true, title=\"Supertrend 1 can be entry signal\"\nlong_trend_st_1 = input.string(\"uptrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nshort_trend_st_1 = input.string(\"downtrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nper_st_1 = input.int(20, title=\"ATR Period 1\", group=\"Supertrend 1\")\nsrc_st_1 = input(hl2, title=\"Source 1\", group=\"Supertrend 1\")\nmult_st_1 = input.float(2.0, title=\"ATR Multiplier 1\", step=0.1, group=\"Supertrend 1\"\natr_st_1 = ta.atr(per_st_1)\nup_st_1 = src_st_1 - (mult_st_1 * atr_st_1)\nup1_st_1 = nz(up_st_1[1], up_st_1)\nup_st_1 := close[1] > up1_st_1 ? math.max(up_st_1, up1_st_1) : up_st_1\ndn_st_1 = src_st_1 + (mult_st_1 * atr_st_1)\ndn1_st_1 = nz(dn_st_1[1], dn_st_1)\ndn_st_1 := close[1] < dn1_st_1 ? math.min(dn_st_1, dn1_st_1) : dn_st_1\ntrend_st_1 = 1\ntrend_st_1 := nz(trend_st_1[1], trend_st_1)\ntrend_st_1 := trend_st_1 == -1 and close > dn1_st_1 ? 1 : trend_st_1 == 1 and close\nbuySignal_st_1 = trend_st_1 == 1 and trend_st_1[1] == -1\nsellSignal_st_1 = trend_st_1 == -1 and trend_st_1[1] == 1\nupPlot_st_1 = plot(trend_st_1 == 1 ? up_st_1 : na, title=\"Up Trend 1\", style=plot.style_linebr\nplotshape(buySignal_st_1 and plot_st_1 ? up_st_1 : na, title=\"Start Up Trend 1\", location\nplotshape(buySignal_st_1 and plot_st_1 ? up_st_1 : na, title=\"Buy 1\", text=\"Buy 1\"\ndnPlot_st_1 = plot(trend_st_1 == 1 ? na : dn_st_1, title=\"Down Trend 1\", style=plot.style_linebr\nplotshape(sellSignal_st_1 and plot_st_1 ? dn_st_1 : na, title=\"Start Down Trend 1\"\nplotshape(sellSignal_st_1 and plot_st_1 ? dn_st_1 : na, title=\"Sell 1\", text=\"Sell 1\"\n// Supertrend 2\nplot_st_2 = input.bool(false, title=\"Plot Supertrend 2\", group=\"Supertrend 2\")\ncan_be_entry_signal_st_2 = input.bool(false, title=\"Supertrend 2 can be entry signal\"\nlong_trend_st_2 = input.string(\"uptrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nshort_trend_st_2 = input.string(\"downtrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nper_st_2 = input.int(5, title=\"ATR Period 2\", group=\"Supertrend 2\")\nsrc_st_2 = input(hlcc4, title=\"Source 2\", group=\"Supertrend 2\")\nmult_st_2 = input.float(15, title=\"ATR Multiplier 2\", step=0.1, group=\"Supertrend 2\"\natr_st_2 = ta.atr(per_st_2)\nup_st_2 = src_st_2 - (mult_st_2 * atr_st_2)\nup1_st_2 = nz(up_st_2[1], up_st_2)\nup_st_2 := close[1] > up1_st_2 ? math.max(up_st_2, up1_st_2) : up_st_2\ndn_st_2 = src_st_2 + (mult_st_2 * atr_st_2)\ndn1_st_2 = nz(dn_st_2[1], dn_st_2)\ndn_st_2 := close[1] < dn1_st_2 ? math.min(dn_st_2, dn1_st_2) : dn_st_2\ntrend_st_2 = 1\ntrend_st_2 := nz(trend_st_2[1], trend_st_2)\ntrend_st_2 := trend_st_2 == -1 and close > dn1_st_2 ? 1 : trend_st_2 == 1 and close\nbuySignal_st_2 = trend_st_2 == 1 and trend_st_2[1] == -1\nsellSignal_st_2 = trend_st_2 == -1 and trend_st_2[1] == 1\nupPlot_st_2 = plot(trend_st_2 == 1 ? up_st_2 : na, title=\"Up Trend 2\", style=plot.style_linebr\nplotshape(buySignal_st_2 and plot_st_2 ? up_st_2 : na, title=\"Start Up Trend 2\", location\nplotshape(buySignal_st_2 and plot_st_2 ? up_st_2 : na, title=\"Buy 2\", text=\"Buy 2\"\ndnPlot_st_2 = plot(trend_st_2 == 1 ? na : dn_st_2, title=\"Down Trend 2\", style=plot.style_linebr\nplotshape(sellSignal_st_2 and plot_st_2 ? dn_st_2 : na, title=\"Start Down Trend 2\"\nplotshape(sellSignal_st_2 and plot_st_2 ? dn_st_2 : na, title=\"Sell 2\", text=\"Sell 2\"\n// Supertrend 3\nplot_st_3 = input.bool(false, title=\"Plot Supertrend 3\", group=\"Supertrend 3\")\ncan_be_entry_signal_st_3 = input.bool(true, title=\"Supertrend 3 can be entry signal\"\nlong_trend_st_3 = input.string(\"uptrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nshort_trend_st_3 = input.string(\"downtrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nper_st_3 = input.int(10, title=\"ATR Period 3\", group=\"Supertrend 3\")\nsrc_st_3 = input(hl2, title=\"Source 3\", group=\"Supertrend 3\")\nmult_st_3 = input.float(3.0, title=\"ATR Multiplier 3\", step=0.1, group=\"Supertrend 3\"\natr_st_3 = ta.atr(per_st_3)\nup_st_3 = src_st_3 - (mult_st_3 * atr_st_3)\nup1_st_3 = nz(up_st_3[1], up_st_3)\nup_st_3 := close[1] > up1_st_3 ? math.max(up_st_3, up1_st_3) : up_st_3\ndn_st_3 = src_st_3 + (mult_st_3 * atr_st_3)\ndn1_st_3 = nz(dn_st_3[1], dn_st_3)\ndn_st_3 := close[1] < dn1_st_3 ? math.min(dn_st_3, dn1_st_3) : dn_st_3\ntrend_st_3 = 1\ntrend_st_3 := nz(trend_st_3[1], trend_st_3)\ntrend_st_3 := trend_st_3 == -1 and close > dn1_st_3 ? 1 : trend_st_3 == 1 and close\nbuySignal_st_3 = trend_st_3 == 1 and trend_st_3[1] == -1\nsellSignal_st_3 = trend_st_3 == -1 and trend_st_3[1] == 1\nupPlot_st_3 = plot(trend_st_3 == 1 ? up_st_3 : na, title=\"Up Trend 3\", style=plot.style_linebr\nplotshape(buySignal_st_3 and plot_st_3 ? up_st_3 : na, title=\"Start Up Trend 3\", location\nplotshape(buySignal_st_3 and plot_st_3 ? up_st_3 : na, title=\"Buy 3\", text=\"Buy 3\"\ndnPlot_st_3 = plot(trend_st_3 == 1 ? na : dn_st_3, title=\"Down Trend 3\", style=plot.style_linebr\nplotshape(sellSignal_st_3 and plot_st_3 ? dn_st_3 : na, title=\"Start Down Trend 3\"\nplotshape(sellSignal_st_3 and plot_st_3 ? dn_st_3 : na, title=\"Sell 3\", text=\"Sell 3\"\n// Supertrend 4\nplot_st_4 = input.bool(false, title=\"Plot Supertrend 4\", group=\"Supertrend 4\")\ncan_be_entry_signal_st_4 = input.bool(true, title=\"Supertrend 4 can be entry signal\"\nlong_trend_st_4 = input.string(\"uptrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nshort_trend_st_4 = input.string(\"downtrend\", options=[\"uptrend\", \"downtrend\", \"unspecified\"\nper_st_4 = input.int(20, title=\"ATR Period 4\", group=\"Supertrend 4\")\nsrc_st_4 = input(hl2, title=\"Source 4\", group=\"Supertrend 4\")\nmult_st_4 = input.float(10.0, title=\"ATR Multiplier 4\", step=0.1, group=\"Supertrend 4\"\natr_st_4 = ta.atr(per_st_4)\nup_st_4 = src_st_4 - (mult_st_4 * atr_st_4)\nup1_st_4 = nz(up_st_4[1], up_st_4)\nup_st_4 := close[1] > up1_st_4 ? math.max(up_st_4, up1_st_4) : up_st_4\ndn_st_4 = src_st_4 + (mult_st_4 * atr_st_4)\ndn1_st_4 = nz(dn_st_4[1], dn_st_4)\ndn_st_4 := close[1] < dn1_st_4 ? math.min(dn_st_4, dn1_st_4) : dn_st_4\ntrend_st_4 = 1\ntrend_st_4 := nz(trend_st_4[1], trend_st_4)\ntrend_st_4 := trend_st_4 == -1 and close > dn1_st_4 ? 1 : trend_st_4 == 1 and close\nbuySignal_st_4 = trend_st_4 == 1 and trend_st_4[1] == -1\nsellSignal_st_4 = trend_st_4 == -1 and trend_st_4[1] == 1\nupPlot_st_4 = plot(trend_st_4 == 1 ? up_st_4 : na, title=\"Up Trend 4\", style=plot.style_linebr\nplotshape(buySignal_st_4 and plot_st_4 ? up_st_4 : na, title=\"Start Up Trend 4\", location\nplotshape(buySignal_st_4 and plot_st_4 ? up_st_4 : na, title=\"Buy 4\", text=\"Buy 4\"\ndnPlot_st_4 = plot(trend_st_4 == 1 ? na : dn_st_4, title=\"Down Trend 4\", style=plot.style_linebr\nplotshape(sellSignal_st_4 and plot_st_4 ? dn_st_4 : na, title=\"Start Down Trend 4\"\nplotshape(sellSignal_st_4 and plot_st_4 ? dn_st_4 : na, title=\"Sell 4\", text=\"Sell 4\"\n// Exit Strategy\nfunction(source, length, smoothing) => \n    if smoothing == \"RMA/SMMA\"\n        ta.rma(source, length)\n    else\n        if smoothing == \"SMA\"\n            ta.sma(source, length)\n        else\n            if smoothing == \"EMA\"\n                ta.ema(source, length)\n            else\n                ta.wma(source, length)\nformula(number, decimals) =>\n    factor = math.pow(10, decimals)\n    int(number * factor) / factor\n    use_atr_based_sl = input.bool(true, \"ATR Based Stop Loss\", group=\"Exit Strategy\", \nnnatr_length = input.int(100, title = \"ATR Length\", group=\"Exit Strategy\")\nsmoothing = input.string(\"RMA/SMMA\", title=\"ATR Smoothing\", options=[\"RMA/SMMA\", \"SMA\"\nuse_low_high_based_sl = input.bool(false, \"Candle Low/High Based Stop Loss\", group\ncandle_lookback_sl = input.int(50, title=\"Candle Lookback\", group=\"Exit Strategy\")\nuse_percentage_based_sl = input.bool(false, \"Percentage Based Stop Loss\", group=\"Exit Strategy\"\npercentage_sl = input.float(0.3, title=\"Percentage\", group=\"Exit Strategy\")\nuse_pip_based_sl = input.bool(false, \"Pip Based Stop Loss\", group=\"Exit Strategy\",\npip_sl = input.int(10, title = \"Pip\", group=\"Exit Strategy\")\nnnatr_loss = input.float(4.5, title=\"Base Risk Multiplier\", minval = 0.1, step = 0.1\nrr_ratio = input.float(1.5, title=\"Risk to Reward Ratio\", minval = 0.1, step = 0.1\nnnatr_profit = nnatr_loss * rr_ratio\n    nnatr = formula(function(ta.tr(true), nnatr_length, smoothing), 5)\nlowest_point_sl = ta.lowest(candle_lookback_sl)\nhighest_point_sl = ta.highest(candle_lookback_sl)\npercentage_val = percentage_sl * 0.01\npercentage_long_sl = close - (close * percentage_val * nnatr_loss)\npercentage_short_sl = close + (close * percentage_val * nnatr_loss)\npip_long_sl = close - pip_sl * syminfo.mintick\npip_short_sl = close + pip_sl * syminfo.mintick\nb_atr_buy  = use_atr_based_sl ? close + nnatr * nnatr_profit : use_low_high_based_sl\nb_atr_sell = use_atr_based_sl ? close - nnatr * nnatr_loss : use_low_high_based_sl\ns_atr_buy  = use_atr_based_sl ? close - nnatr * nnatr_profit : use_low_high_based_sl\ns_atr_sell = use_atr_based_sl ? close + nnatr * nnatr_loss : use_low_high_based_sl\n// FORCE EXITING\nuse_force_exit_exact_time_1 = input.bool(false, title=\"1 - Force exit on custom session close\"\nforce_exit_exact_time_1 = input.session(\"0930-1630:1234567\", title=\"\", group=\"Force Exiting\"\ncustom_session_1 = time(\"30S\", force_exit_exact_time_1)\nuse_force_exit_exact_time_2 = input.bool(false, title=\"2 - Force exit on custom session close\"\nforce_exit_exact_time_2 = input.session(\"0930-1630:1234567\", title=\"\", group=\"Force Exiting\"\ncustom_session_2 = time(\"30S\", force_exit_exact_time_2)\nuse_force_exit_exact_time_3 = input.bool(false, title=\"3 - Force exit on custom session close\"\nforce_exit_exact_time_3 = input.session(\"0930-1630:1234567\", title=\"\", group=\"Force Exiting\"\ncustom_session_3 = time(\"30S\", force_exit_exact_time_3)\nuse_force_exit_exact_time_4 = input.bool(false, title=\"4 - Force exit on custom session close\"\nforce_exit_exact_time_4 = input.session(\"0930-1630:1234567\", title=\"\", group=\"Force Exiting\"\ncustom_session_4 = time(\"30S\", force_exit_exact_time_4)\n// BASE SETUPS\nallow_long = input.bool(true, title=\"Allow Long Entries\", group=\"Base Setups\")\nallow_short = input.bool(true, title=\"Allow Short Entries\", group=\"Base Setups\")\norder_size_value = input.float(1000, title='Order Size', minval=0, inline=\"ordersize\"\norder_size_type = input.string(\"Cash\", title=\"\", inline=\"ordersize\", options=[\"Cash\"\n// ATR Filter\nswitch_ma(maType, maSrc, maLen) =>\n    float maOut = switch maType\n        \"SMA\" => ta.sma(maSrc, maLen)\n        \"EMA\" => ta.ema(maSrc, maLen)\n        \"WMA\" => ta.wma(maSrc, maLen)\n        \"VWMA\" => ta.vwma(maSrc, maLen)\n        \"RMA/SMMA\" => ta.rma(maSrc, maLen)\n        \"SWMA\" => ta.swma(maSrc)\n        \"HMA\" => ta.hma(maSrc, maLen)\nuse_atr_limiter = input.bool(true, title=\"Use ATR Limiter\", group=\"ATR Limiter\", tooltip\natrlim_len = input(50, title=\"ATR Limiter Length\", group=\"ATR Limiter\")\natrlim_smoothing = input.string(\"RMA/SMMA\", title=\"ATR Limiter Smoothing\", options\natrlim_boundary_high = input.float(1000, title=\"High Boundary\", group=\"ATR Limiter\"\natrlim_boundary_low = input.float(0.0003, title=\"Low Boundary\", group=\"ATR Limiter\"\natrlim_val = formula(function(ta.tr(true), atrlim_len, atrlim_smoothing), 5)\nplot(atrlim_val, title='atrlim_val', color= color.yellow)\natrlim_calc_by_ma = input.string(\"ATR value under MA\", options=[\"ATR value over MA\"\natrlim_ema_type = input.string(\"RMA/SMMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\natrlim_ema_len = input.int(400, title=\"MA Length\", minval=1, group=\"ATR Limiter\")\natrlim_ema = switch_ma(atrlim_ema_type, atrlim_val, atrlim_ema_len)\ncheck_atr_lim_long() =>\n    use_atr_limiter ? atrlim_calc_by_ma == \"ATR value over MA\" ? atrlim_val > atrlim_ema\n    check_atr_lim_short() =>\n    use_atr_limiter ? atrlim_calc_by_ma == \"ATR value over MA\" ? atrlim_val > atrlim_ema\n// Entry Logic\ngreen_1 = trend_st_1 == 1\ngreen_2 = trend_st_2 == 1 \ngreen_3 = trend_st_3 == 1 \ngreen_4 = trend_st_4 == 1 \nred_1 = trend_st_1 != 1 \nred_2 = trend_st_2 != 1\nred_3 = trend_st_3 != 1\nred_4 = trend_st_4 != 1\nst_uptrend_bool_arr = array.from(green_1, green_2, green_3, green_4)\nst_downtrend_bool_arr = array.from(red_1, red_2, red_3, red_4)\nst_buy_signal_arr = array.from(buySignal_st_1, buySignal_st_2, buySignal_st_3, buySignal_st_4\nlast_st_buy_signal_arr = array.from(buySignal_st_1[1], buySignal_st_2[1], buySignal_st_3\nst_sell_signal_arr = array.from(sellSignal_st_1, sellSignal_st_2, sellSignal_st_3,\nlast_st_sell_signal_arr = array.from(sellSignal_st_1[1], sellSignal_st_2[1], sellSignal_st_3\nlong_trend_arr = array.from(long_trend_st_1, long_trend_st_2, long_trend_st_3, long_trend_st_4\nshort_trend_arr = array.from(short_trend_st_1, short_trend_st_2, short_trend_st_3,\nlong_trends_ok = true\nshort_trends_ok = true\nfor [index, value] in st_uptrend_bool_arr\n    if value \n        if array.get(long_trend_arr, index) == \"downtrend\"\n            long_trends_ok := false\n        if array.get(short_trend_arr, index) == \"downtrend\"\n            short_trends_ok := false\nfor [index, value] in st_downtrend_bool_arr\n    if value \n        if array.get(long_trend_arr, index) == \"uptrend\"\n            long_trends_ok := false\n        if array.get(short_trend_arr, index) == \"uptrend\"\n            short_trends_ok := false\ncan_be_entry_signal_arr = array.from(can_be_entry_signal_st_1, can_be_entry_signal_st_2\nlong_trigger = false\nshort_trigger = false\nfor [index, value] in st_buy_signal_arr\n    if array.get(st_buy_signal_arr, index) and not array.get(last_st_buy_signal_arr\n        long_trigger := true\n    if array.get(st_sell_signal_arr, index) and not array.get(last_st_sell_signal_arr\n        short_trigger := true\ncheck_entry_long() => long_trigger and long_trends_ok\ncheck_entry_short() => short_trigger and short_trends_ok\n// WADDAH ATTAR FILTER\nwafilt_calc_macd(source, fast_length, fast_type, slow_length, slow_type) =>\n    fast_ma = switch_ma(fast_type, source, fast_length)\n    slow_ma = switch_ma(slow_type, source, slow_length)\n    fast_ma - slow_ma\nwafilt_calc_BBUpper(ma_type, source, length, mult) =>\n    basis = switch_ma(ma_type, source, length)\n    dev = mult * ta.stdev(source, length)\n    basis + dev\nwafilt_calc_BBLower(ma_type, source, length, mult) => \n    basis = switch_ma(ma_type, source, length)\n    dev = mult * ta.stdev(source, length)\n    basis - dev\n    wa_entry_logic = input.string(\"Not specified\", options=[\"Explosion over Deadzone\",\nwafilt_only_trade_when_trend = input.string(\"Not specified\", options=[\"Strong Trends\"\nwa_over_e_dz = input.string(\"Not specified\", options=[\"Over Explosion and Deadzone\"\nwafilt_sensitivity = input(150, title=\"Sensitivity\", group=\"Waddah Attar Filter\")\nwafilt_fast_type = input.string(\"SMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nwafilt_fast_length=input(10, title=\"Fast MA Length\", inline=\"wa_1\", group=\"Waddah Attar Filter\"\nwafilt_slow_type = input.string(\"SMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nwafilt_slow_length=input(20, title=\"Slow MA Length\", inline=\"wa_2\", group=\"Waddah Attar Filter\"\nwafilt_channel_type = input.string(\"EMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nwafilt_channel_length=input(20, title=\"BB Channel Length\", inline=\"wa_3\", group=\"Waddah Attar Filter\"\nwafilt_mult=input(2.0, title=\"BB Stdev Multiplier\", inline=\"wa_3\", group=\"Waddah Attar Filter\"\nwafilt_dead_zone = nz(ta.rma(ta.tr(true),100)) * 3.7\nwafilt_t1 = (wafilt_calc_macd(close, wafilt_fast_length, wafilt_fast_type, wafilt_slow_length\nwafilt_e1 = (wafilt_calc_BBUpper(wafilt_channel_type, close, wafilt_channel_length\nwafilt_trend_up = (wafilt_t1 >= 0) ? wafilt_t1 : 0\nwafilt_trend_down = (wafilt_t1 < 0) ? (-1 * wafilt_t1) : 0\nwafilt_trend_up_color = wafilt_trend_up < wafilt_trend_up[1] ?  color.lime :  color.green\nwafilt_trend_down_color = wafilt_trend_down < wafilt_trend_down[1] ?  color.orange\nwafilt_trend_val = wafilt_trend_up != 0 ? wafilt_trend_up : wafilt_trend_down\nwafilt_trend_color = wafilt_trend_up != 0 ? wafilt_trend_up_color : wafilt_trend_down_color\ncheck_waddah_attar_long() =>\n    logic = wa_entry_logic == \"Explosion over Deadzone\" ? wafilt_e1 > wafilt_dead_zone\n    trend = wafilt_only_trade_when_trend == \"All Trends\" ? wafilt_trend_color ==  \n    wa_bar_value = wa_over_e_dz == \"Over Explosion and Deadzone\" ? wafilt_trend_val\n    logic and trend and wa_bar_value\ncheck_waddah_attar_short() =>\n    logic = wa_entry_logic == \"Explosion over Deadzone\" ? wafilt_e1 > wafilt_dead_zone\n    trend = wafilt_only_trade_when_trend == \"All Trends\" ? wafilt_trend_color ==  \n    wa_bar_value = wa_over_e_dz == \"Over Explosion and Deadzone\" ? wafilt_trend_val\n    logic and trend and wa_bar_value\n// TREND FILTER\nuse_long_trend_filter_1 = input.bool(false, title=\"Use long trend filter 1\", group\nshow_long_trend_filter_1 = input.bool(false, title=\"Show long trend filter 1\", group\nlong_ma_type_1 = input.string(\"EMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nlong_ma_len_1 = input.int(120, title=\"TF1 - MA Length\", inline=\"lTF1\", group=\"Trend Filter\"\nlong_ma_source_1 = input(close, title=\"TF1 - MA Source\", inline=\"lTF1\", group=\"Trend Filter\"\nfloat long_ma_tf_1 = switch_ma(long_ma_type_1, long_ma_source_1, long_ma_len_1)\nuse_short_trend_filter_1 = input.bool(false, title=\"Use short trend filter 1\", group\nshow_short_trend_filter_1 = input.bool(false, title=\"Show short trend filter 1\", group\nshort_ma_type_1 = input.string(\"EMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nshort_ma_len_1 = input.int(120, title=\"TF2 - MA Length\", inline=\"sTF1\", group=\"Trend Filter\"\nshort_ma_source_1 = input(close, title=\"TF2 - MA Source\", inline=\"sTF1\", group=\"Trend Filter\"\nfloat short_ma_tf_1 = switch_ma(short_ma_type_1, short_ma_source_1, short_ma_len_1\nplot(long_ma_tf_1, color= color.blue, display=show_long_trend_filter_1 ? display.all\nplot(short_ma_tf_1, color= color.teal, display=show_short_trend_filter_1 ? display.all\ncheck_trend_filter_long() =>\n    long_filter_1 = use_long_trend_filter_1 ? close > long_ma_tf_1 : true\n    long_filter_1\ncheck_trend_filter_short() =>    \n    short_filter_1 = use_short_trend_filter_1 ? close < short_ma_tf_1 : true\n    short_filter_1\n// VOLUME FILTER\nuse_volume_filter = input.bool(true, title=\"Only enter trades where volume is higher then the\nvol_ma_type = input.string(\"RMA/SMMA\", options=[\"SMA\", \"EMA\", \"WMA\", \"VWMA\", \"RMA/SMMA\"\nvol_ma_len = input.int(200, title=\"Volume-based MA Length\", group=\"Volume Filter\")\nvol_ma = switch_ma(vol_ma_type, volume, vol_ma_len)\ncheck_volume_filter() =>\n    use_volume_filter ? volume > vol_ma : true\n// DATE RANGE SETTINGS\nlimit_dates = input.bool(false, title=\"Limit Between Dates\", group=\"Date Range Limiter\"\nstart_date = input.time(timestamp(\"Jan 01 2023 00:00:00\"), title=\"Start Date\", group\nend_date = input.time(timestamp(\"Jun 24 2023 00:00:00\"), title=\"End Date\", group=\"Date Range Limiter\"\n// SESSION LIMITER\nshow_session_plots = input.bool(false, title=\"Show session plots\", group=\"Session Limiter\"\nuse_session_limit = input.bool(false, title=\"Use session limiter\", group=\"Session Limiter\"\nlimit_session1 = input.bool(false, title=\"Sidney session\", group=\"Session Limiter\"\nlimit_session2 = input.bool(false, title=\"Tokyo session\", group=\"Session Limiter\",\nlimit_session3 = input.bool(false, title=\"London session\", group=\"Session Limiter\"\nlimit_session4 = input.bool(false, title=\"New York session\", group=\"Session Limiter\"\nsession1 = time(timeframe.period, \"1500-0000:1234567\", \"America/New_York\") //Sydney Session\nsession2 = time(timeframe.period, \"1900-0400:1234567\", \"America/New_York\") //Tokyo Session\nsession3 = time(timeframe.period, \"0300-1100:1234567\", \"America/New_York\") //London Session\nsession4 = time(timeframe.period, \"0800-1700:1234567\", \"America/New_York\") //New York Session\nbgcolor(session1 and show_session_plots ?  color.new(color.red, 60) : na, title=\"Sydney Session\"\nbgcolor(session2 and show_session_plots ?  color.new(color.orange, 60) : na, title\nbgcolor(session3 and show_session_plots ?  color.new(color.yellow, 60) : na, title\nbgcolor(session4 and show_session_plots ?  color.new(color.green, 60) : na, title\n// TRADING TIME\nlimit_trading_time = input.bool(true, title=\"Limit Trading Time\", group=\"Trading Time Limiter\"\ndays_to_trade_on = input.string(\"123567\", title=\"Valid Trading Days Global\", tooltip\nlimit_day1 = input.bool(false, title=\"\", group=\"Trading Time Limiter\", inline=\"day1\"\ndays_to_trade_on1 = input.string(\"23456\", title=\"(1) Valid Trading Days\", inline=\"day1\"\nvalid_hours1 = input.bool(false, title=\"\", inline=\"inline1\", group=\"Trading Time Limiter\"\nhours_to_trade_on1 = input.session(\"1800-2000\", title=\"(1) Valid Trading Hours Between\"\nlimit_day2 = input.bool(false, title=\"\", group=\"Trading Time Limiter\", inline=\"day2\"\ndays_to_trade_on2 = input.string(\"1234567\", title=\"(2) Valid Trading Days\", inline\nvalid_hours2 = input.bool(false, title=\"\", inline=\"inline2\", group=\"Trading Time Limiter\"\nhours_to_trade_on2 = input.session(\"0930-1600\", title=\"(2) Valid Trading Hours Between\"\nlimit_day3 = input.bool(false, title=\"\", group=\"Trading Time Limiter\", inline=\"day3\"\ndays_to_trade_on3 = input.string(\"1234567\", title=\"(3) Valid Trading Days\", inline\nvalid_hours3 = input.bool(false, title=\"\", inline=\"inline3\", group=\"Trading Time Limiter\"\nhours_to_trade_on3 = input.session(\"0930-1600\", title=\"(3) Valid Trading Hours Between\"\n// PineConnector Automation\nuse_pc_automation = input.bool(false, title=\"Use PineConnector Automation | PLEASE READ TOOLTI\npc_licence_id = input.int(60123456789, title=\"License ID\", maxval=9999999999999, group\npc_risk = input.float(1, title=\"Risk (trading volume)\", group=\"PineConnector Automation\"\npc_long_entry_alert = str.tostring(pc_licence_id) + ',buy,' + syminfo.ticker + ',risk='\npc_short_entry_alert = str.tostring(pc_licence_id) + ',sell,' + syminfo.ticker + ',risk='\npc_long_exit_alert = str.tostring(pc_licence_id) + ',closelong,' + syminfo.ticker \npc_short_exit_alert = str.tostring(pc_licence_id) + ',closeshort,' + syminfo.ticker\n// LIMITERS\nin_date() => \n    time > start_date and time < end_date\n    check_valid_session() =>\n    s1 = limit_session1 ? session1 : na\n    s2 = limit_session2 ? session2 : na\n    s3 = limit_session3 ? session3 : na\n    s4 = limit_session4 ? session4 : na\n    use_session_limit ? na(s1) and na(s2) and na(s3) and na(s4) ? false : true : true\ncheck_valid_time() =>\n    t = (limit_day1 == false and limit_day2 == false and limit_day3 == false) ? time\n    t7 = valid_hours1 and limit_day1 == false ? time(timeframe.period, hours_to_trade_on1\n    t8 = valid_hours2 and limit_day2 == false ? time(timeframe.period, hours_to_trade_on2\n    t9 = valid_hours3 and limit_day3 == false ? time(timeframe.period, hours_to_trade_on3\n    t1 = valid_hours1 and limit_day1 ? time(timeframe.period, hours_to_trade_on1 +\n    t2 = valid_hours2 and limit_day2 ? time(timeframe.period, hours_to_trade_on2 +\n    t3 = valid_hours3 and limit_day3 ? time(timeframe.period, hours_to_trade_on3 +\n    na(t) and na(t1) and na(t2) and na(t3) and na(t7) and na(t8) and na(t9) ? false\n check_filters_long() => check_volume_filter() and check_waddah_attar_long() and check_valid_session\ncheck_filters_short() => check_volume_filter() and check_waddah_attar_short() and \ncheckLong() => check_entry_long() and check_filters_long() \ncheckShort() => check_entry_short() and check_filters_short() \nshould_long_limit_dates = limit_dates ? (in_date() and checkLong()) : checkLong()\nshould_short_limit_dates = limit_dates ? (in_date() and checkShort()) : checkShort\nshould_long_limit_day_trades = limit_trading_time ? (check_valid_time() and checkLong\nshould_short_limit_day_trades = limit_trading_time ? (check_valid_time() and checkShort\nlong = should_long_limit_dates and should_long_limit_day_trades and allow_long\nshort = should_short_limit_dates and should_short_limit_day_trades and allow_short\n// CALCULATE EXIT PRICES AND STOP LOSSES\nlong_exit_price = float(na)\nlong_stop_price = float(na)\nshort_exit_price = float(na)\nshort_stop_price = float(na)\nlong_exit_price := (long and strategy.position_size <= 0) ? b_atr_buy : long_exit_price\nlong_stop_price := (long and strategy.position_size <= 0) ? b_atr_sell : long_stop_price\nshort_exit_price := (short and strategy.position_size >= 0) ? s_atr_buy : short_exit_price\nshort_stop_price := (short and strategy.position_size >= 0) ? s_atr_sell : short_stop_price\nplot(strategy.position_size > 0 and plot_sl_tp ? long_exit_price : na, color= color.green\nplot(strategy.position_size > 0 and plot_sl_tp ? long_stop_price : na, color= color.red\nplot(strategy.position_size < 0 and plot_sl_tp ? short_exit_price : na, color= color.purple\nplot(strategy.position_size < 0 and plot_sl_tp ? short_stop_price : na, color= color.aqua\n// QUANTITY CALCULATION\nourQty = switch order_size_type\n    \"Capital Percentage\" => (strategy.initial_capital + strategy.netprofit) * 0.01\n    \"Cash\" => order_size_value / close \n    \"Contract(s)\" => order_size_value \n    => 0\n// TEST\n// ENTER/EXIT ORDERS\ncheckForceExit(usage_trigger, exit_trigger, order_comment) =>\n    if strategy.position_size != 0 and usage_trigger\n        if exit_trigger\n            strategy.cancel_all()\n            if use_pc_automation\n                strategy.close_all(comment=strategy.position_size > 0 ? pc_long_exit_alert\n            else\n                strategy.close_all(comment=order_comment, immediately=true)\nplotshape(plot_signals and strategy.position_size == 0 ? long : na, style=shape.labelup\nplotshape(plot_signals and strategy.position_size == 0 ? short : na, style=shape.labeldown\nvalid_values = true\nif (na(nnatr) and use_atr_based_sl) or (na(lowest_point_sl) and use_low_high_based_sl\n    valid_values := false\nif valid_values\n    if allow_long\n        if long and strategy.position_size == 0\n            strategy.order(\"Long Entry\", direction=strategy.long, qty=ourQty, oca_type\n        if strategy.position_size > 0\n            strategy.cancel(\"Long Entry\")\n            strategy.order(\"Long Exit\", direction=strategy.short, qty=strategy.position_size\n            strategy.order(\"Long Stop\", direction=strategy.short, qty=strategy.position_size\n    if allow_short\n        if short and strategy.position_size == 0\n            strategy.order(\"Short Entry\", direction=strategy.short, qty=ourQty, oca_type\n        if strategy.position_size < 0\n            strategy.cancel(\"Short Entry\")\n            strategy.order(\"Short Exit\", direction=strategy.long, qty=-1*strategy.position_size\n            strategy.order(\"Short Stop\", direction=strategy.long, qty=-1*strategy.position_size\n    checkForceExit(use_force_exit_exact_time_1, custom_session_1[1] and not custom_session_1\n    checkForceExit(use_force_exit_exact_time_2, custom_session_2[1] and not custom_session_2\n    checkForceExit(use_force_exit_exact_time_3, custom_session_3[1] and not custom_session_3\n    checkForceExit(use_force_exit_exact_time_4, custom_session_4[1] and not custom_session_4"}]}
{"messages": [{"role": "user", "content": "The \"Merovinh - Mean Reversion Lowest Low\" strategy is a mean reversion trading approach that aims to identify potential reversal points based on the updated lowest low of the specified number of bars. This strategy focuses on the detection of bullish price movements. Works well on Tech giant's shares. Strategy Overview:  The strategy detects the lowest low and highest high over a specified number of bars.  It uses a mean reversion concept where it expects the price to revert back towards the updated lowest low.  The strategy enters a long position when the current lowest low breaks the previous lowest low (based on the specified number of broken lows).  It closes the long position when the highest high breaks the previous highest high.  The strategy aims to capitalize on potential reversals in the market by buying at lower price levels and selling at higher price levels.  Strategy Parameters:  Minimum number of bars: Specifies the minimum number of bars considered for calculating the lowest low and highest high.  Number of broken lows: Determines the number of previous lows that need to be broken for entering a long position.  How It Works:  The strategy calculates the lowest low and highest high based on the specified number of bars.  It compares the current lowest low with the previous lowest low.  If the current lowest low breaks the previous lowest low (based on the specified number of broken lows), a long position is entered.  The strategy continuously updates the previous lows and highs.  It closes the long position if the highest high breaks the previous highest high."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 merovinh\n//@version=5\nstrategy(title=\"Merovinh - Mean Reversion Lowest low\",\n     overlay = true,\n     default_qty_type = strategy.percent_of_equity,\n     initial_capital = 10000,\n     default_qty_value = 10,\n     commission_type = strategy.commission.percent,\n     slippage = 1,\n     commission_value = 0.04)\nGR_TIME = 'Time Period'\nbars = input(9, title = \"Minimum number of bars\", tooltip = \"The minimum number of bars before updating lowest\nnumberOfLows  = input.string(defval='One', title='Number of broken lows', options=[\n//Period\nstartTime = input.time(timestamp(\"27 Jul 2021 00:00 +0000\"), \"Start date\", inline =\nfinalTime = input.time(timestamp(\"31 Dec 2030 23:59 +0000\"), \"Final date\", inline =\nvar prevLow = .0\nvar prevHigh = .0\nvar prevLow2 = .0\nvar prevLow3 = .0\nvar prevLow4 = .0\ntruetime = time > startTime and time < finalTime\nhighestHigh = ta.highest(high, bars)\nlowestLow = ta.lowest(low, bars)\nif numberOfLows == 'One'\n    if truetime and prevLow > 0 and lowestLow < prevLow\n        strategy.entry('long', strategy.long)\nif numberOfLows == 'Two'\n    if truetime and prevLow > 0 and lowestLow < prevLow and prevLow < prevLow2\n        strategy.entry('long', strategy.long)\nif numberOfLows == 'Three'\n    if truetime and prevLow > 0 and lowestLow < prevLow and prevLow < prevLow2 and \n        strategy.entry('long', strategy.long)\nif numberOfLows == 'Four'\n    if truetime and prevLow > 0 and lowestLow < prevLow and prevLow < prevLow2 and \n        strategy.entry('long', strategy.long)\nif truetime and prevHigh > 0 and highestHigh > prevHigh\n    strategy.close('long')\nif prevLow != lowestLow\n    prevLow4 := prevLow3\n    prevLow3 := prevLow2\n    prevLow2 := prevLow\n    prevLow := lowestLow\nprevHigh := highestHigh\nplot(lowestLow, color= color.green, linewidth=1, title=\"Lowest Low Line\")\nplot(highestHigh, color= color.green, linewidth=1, title=\"Highest High Line\")"}]}
{"messages": [{"role": "user", "content": "In this script, the \"TRAX\" (TRIX) indicator is calculated using the Volume Weighted Moving Average (VWMA) instead of Exponential Moving Average (EMA) like the standard TRIX. The Detrended Price is used to identify short term cycles with a rate of change verses the rate of change from a triple smoothed TRAX VWMA . The strategy is intended for counter-trend trading, meaning it tries to capture potential reversals. 1. Indicators Used: TRAX is calculated using the Volume Weighted Moving Average (VWMA) of the logarithm of the closing price. DPO (Detrended Price Oscillator) is calculated by taking the closing price and subtracting a simple moving average (SMA) of the closing price shifted back. 2. Crossover Conditions: Longs occur when DPO crosses above the TRAX, with the TRAX trending below 0, and the stock is trading above an adjustable simple moving average. Shorts occur due to the inverse conditions. 3. Visualization: This script plots the SMA and the TRAX-DPO Combined Oscillator. It highlights the periods of zero-line crossover using a green background for potential long positions and a red background for potential short positions. However, it will trigger verified entries/exits in accordance with the SMA. In conclusion, this fun prototype underwent a unique alteration using the Volume Weighted Moving Average and focuses on capturing shorter counter-trend cycles. You have the freedom to fine-tune the strategy by adjusting parameters and incorporating other analysis methods that resonate with your trading style and risk tolerance."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 DraftVenture\n//@version=5\nstrategy(\"TRAX DPO\", overlay=true)\n// TRAX Calculation\ntraxlength = input.int(12, title = \"TRAX Length\", minval=1)\ntrax = 10000 * ta.change(ta.vwma(ta.vwma(ta.vwma(math.log(close), traxlength), traxlength\n// DPO Calculation\nperiod_ = input.int(19, title=\"DPO Length\", minval=1)\nbarsback = period_/2 + 1\nma = ta.sma(close, period_)\ndpo = close[barsback] - ma\n// MA Confirmation Calculation\nlen = input.int(3, minval=1, title=\"SMA Confirmation Length\")\nsrc = input(close, title=\"SMA Source\")\noffset = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nout = ta.sma(src, len)\nplot(out, color= color.white, title=\"MA\", offset=offset)\n// DPO-TRAX Oscillator\ndpotrax = dpo - trax\nplot(dpotrax, color= color.blue, title=\"DPO-TRAX Oscillator\", offset=offset)\n// Crossover Conditions\nlongCondition = ta.crossover(dpo, trax) and trax < 0 and close > out\nshortCondition = ta.crossunder(dpo, trax) and trax > 0 and close < out\n// Strategy Logic\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n// Highlight periods of zero-line crossover\nbgcolor(longCondition ?  color.new(color.green, 80) : na)\nbgcolor(shortCondition ?  color.new(color.red, 80) : na)\n// Strategy by KP"}]}
{"messages": [{"role": "user", "content": "Hello  I would like to introduce a very simple strategy that uses a combination of 3 simple moving averages ( SMA 4 , SMA 9 , SMA 18 )  this is a classic combination showing the most probable trend directions Crosses were marked on the basis of the color of the candles (bulish cross - blue / bearish cross - maroon) ma 100 was used to determine the main trend, which is one of the most popular 4-hour candles We define main trend while price crosses SMA100 ( for bullish trend I use green candle color ) The long position strategy was created in combination of 3 moving averages with Kaufman's adaptive moving average by  alexgrover   The strategy is very accurate and is easy to use indicators the strategy uses only Buy (Long) signals in a combination of crossovers of the SMA 4, SMA 9, SMA 18 and the Kaufman Adaptive Moving Average. As a signal to close a long position, only the opposite signal of the intersection of 3 different moving averages is used the current strategy is recommended for higher time zones (4h +) due to the strength of the closing candles, which translates into signal strength works fascinatingly well for long-term bullish market assets (for example 4h Apple, Tesla charts) Enjoy and trade safe ;)"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Wielkieef\n//@version=5\nstrategy(title='twisted SMA strategy [4h] ', overlay=true, pyramiding=1, initial_capital\nsrc = close\nLength1 = input.int(4, title='\u2003\u20031-SMA Lenght', minval=1, group='SMA')\nLength2 = input.int(9, title='\u2003\u20032-SMA Lenght', minval=1, group='SMA')\nLength3 = input.int(18, title='\u2003\u20033-SMA Lenght', minval=1, group='SMA')\nSMA1 = ta.sma(close, Length1)\nSMA2 = ta.sma(close, Length2)\nSMA3 = ta.sma(close, Length3)\nLong_ma = SMA1 > SMA2 and SMA2 > SMA3\nShort_ma = SMA1 < SMA2 and SMA2 < SMA3\nLengthMainSMA = input.int(100, title='\u2003\u2003SMA Lenght', minval=1)\nSMAas = ta.sma(src, LengthMainSMA)\n//  Powered Kaufman Adaptive Moving Average by alexgrover (modificated by Wielkieef)\nlengthas = input.int(25, title='\u2003\u2003  Lenght')\nsp = input.bool(true, title='\u2003\u2003Self Powered')\ner = math.abs(ta.change(close, lengthas)) / math.sum(math.abs(ta.change(close)), lengthas\npow = sp ? 1 / er : 2\nper = math.pow(math.abs(ta.change(close, lengthas)) / math.sum(math.abs(ta.change(close\na = 0.\na := per * src + (1 - per) * nz(a[1], src)\nmad4h = 0.\na_f = a / a[1] > .999 and a / a[1] < 1.001\n///.\nBar_color = close > SMAas ?  color.green : Long_ma ?  color.blue : Short_ma ?  color.maroon\nbarcolor(color=Bar_color)\nlong_cond = Long_ma and SMAas < close and not a_f\n  long_stop = Short_ma \nif  long_cond\n    strategy.entry('BUY', strategy.long)\nstrategy.close_all(when=long_stop)\n//by wielkieef"}]}
{"messages": [{"role": "user", "content": "Moving Average Period:** This is the period of the moving average that will be used to identify the trend. A good starting point is 10 days. * **Candlestick Patterns:** The candlestick patterns that will be used to identify potential reversals in the trend. Some of the most common candlestick patterns include the bullish engulfing pattern, the bearish engulfing pattern, the hammer pattern, and the inverted hammer pattern. * **Support and Resistance Levels:** The support and resistance levels that will be used to manage risk. These levels can be identified using a variety of technical indicators, such as the moving average, the Bollinger bands, and the Fibonacci retracement levels. Here is how the strategy will work: 1. The moving average will be used to identify the trend. When the price is above the moving average, it is considered to be in an uptrend. When the price is below the moving average, it is considered to be in a downtrend. 2. Candlestick patterns will be used to identify potential reversals in the trend. If a bullish candlestick pattern appears in an uptrend, it could be a sign that the trend is about to continue. If a bearish candlestick pattern appears in a downtrend, it could be a sign that the trend is about to reverse."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Trend Following Strategy with Candlestick Patterns\", overlay=true)\n// Moving Average\nma_period = input(10, title=\"Moving Average Period\")\nmoving_average = ta.sma(close, ma_period)\n// Candlestick Patterns\n// Custom Function\nabs(x) => x >= 0 ? x : -x\n// Candlestick Patterns\nisDoji() =>\n    (close - open) <= (high - low) * 0.1\nisMarubozuWhite() =>\n    close == high and open == low and close > open\nisHammer() =>\n    (high - low) >= 3 * abs(open - close) and (close - low) / (0.001 + high - low)\nisInvertedHammer() =>\n    (high - low) >= 3 * abs(open - close) and (high - close) / (0.001 + high - low\nisLongLowerShadow() =>\n    (low - close) > 2 * abs(open - close) and (low - open) / (0.001 + high - low) \nisUpsideTasukiGap() =>\n    close[1] < open[1] and open > close and open > close[1] and close < open[1]\nisRisingWindow() =>\n    high[1] < low and close > open\nisPiercing() =>\n    close[1] < open[1] and close > open and close > ((open + low) / 2) and close <\nisBullishEngulfing() =>\n    close[1] < open[1] and close > open and high > high[1] and low < low[1]\nisTweezerBottom() =>\n    low == ta.valuewhen(low == ta.lowest(low, 10), low, 0) and low == ta.valuewhen\nisBullishAbandonedBaby() =>\n    close[2] < open[2] and close[1] > open[1] and low[1] > ta.valuewhen(high == ta.highest\nisMorningStar() =>\n    close[2] < open[2] and close[1] < open[1] and close > open[1] and open < close\nisMorningDojiStar() =>\n    close[2] < open[2] and close[1] < open[1] and isDoji() and close > open[1] and\nisDragonflyDoji() =>\n    isDoji() and (high - close) / (0.001 + high - low) < 0.1 and (open - low) / (0.001\nisThreeWhiteSoldiers() =>\n    close[2] < open[2] and close[1] < open[1] and close > open and open < close[2]\nisRisingThreeMethods() =>\n    close[4] < open[4] and close[1] < open[1] and close > open and open < close[4]\nisMarubozuBlack() =>\n    close == low and open == high and open > close\nisGravestoneDoji() =>\n    isDoji() and (close - low) / (0.001 + high - low) < 0.1 and (high - open) / (0.001\nisHangingMan() =>\n    (high - low) >= 4 * abs(open - close) and (open - close) / (0.001 + high - low\nisLongUpperShadow() =>\n    (high - open) > 2 * abs(open - close) and (high - close) / (0.001 + high - low\nisDownsideTasukiGap() =>\n    close[1] > open[1] and open < close and open < close[1] and close > open[1]\nisFallingWindow() =>\n    low[1] > high and close < open\nisDarkCloudCover() =>\n    close[1] > open[1] and close < open and close < ((open + high) / 2) and close \nisBearishEngulfing() =>\n    close[1] > open[1] and close < open and high > high[1] and low < low[1]\nisTweezerTop() =>\n    high == ta.valuewhen(high == ta.highest(high, 10), high, 0) and high == ta.valuewhen\nisAbandonedBaby() =>\n    close[2] > open[2] and close[1] < open[1] and high[1] < ta.valuewhen(low == ta.lowest\nisEveningDojiStar() =>\n    close[2] > open[2] and close[1] > open[1] and isDoji() and close < open[1] and\nisEveningStar() =>\n    close[2] > open[2] and close[1] > open[1] and close < open[1] and open > close\nisThreeBlackCrows() =>\n    close[2] > open[2] and close[1] > open[1] and close < open and open > close[2]\nisFallingThreeMethods() =>\n    close[4] > open[4] and close[1] > open\nisShootingStar() =>\n    (high - low) >= 3 * abs(open - close) and (high - close) / (0.001 + high - low\ndoji = isDoji()\nmarubozuWhite = isMarubozuWhite()\nhammer = isHammer()\ninvertedHammer = isInvertedHammer()\nlongLowerShadow = isLongLowerShadow()\nupsideTasukiGap = isUpsideTasukiGap()\nrisingWindow = isRisingWindow()\npiercing = isPiercing()\nbullishEngulfing = isBullishEngulfing()\ntweezerBottom = isTweezerBottom()\nbullishAbandonedBaby = isBullishAbandonedBaby()\nmorningStar = isMorningStar()\nmorningDojiStar = isMorningDojiStar()\ndragonflyDoji = isDragonflyDoji()\nthreeWhiteSoldiers = isThreeWhiteSoldiers()\nrisingThreeMethods = isRisingThreeMethods()\nmarubozuBlack = isMarubozuBlack()\ngravestoneDoji = isGravestoneDoji()\nhangingMan = isHangingMan()\nlongUpperShadow = isLongUpperShadow()\ndownsideTasukiGap = isDownsideTasukiGap()\nfallingWindow = isFallingWindow()\ndarkCloudCover = isDarkCloudCover()\nbearishEngulfing = isBearishEngulfing()\ntweezerTop = isTweezerTop()\nabandonedBaby = isAbandonedBaby()\neveningDojiStar = isEveningDojiStar()\neveningStar = isEveningStar()\nthreeBlackCrows = isThreeBlackCrows()\nfallingThreeMethods = isFallingThreeMethods()\nshootingStar = isShootingStar()\nisBullishPattern() =>\n    (isMarubozuWhite() or isHammer() or isInvertedHammer() or isDoji() or isMorningStar\nisBearishPattern() =>\n    (isMarubozuBlack() or isInvertedHammer() or isLongUpperShadow() or isTweezerTop\nisBullishCandle = isBullishPattern()\nisBearishCandle = isBearishPattern()\n// Calculate Pivot Points\npivotPoint(high, low, close) =>\n    (high + low + close) / 3\nr1 = pivotPoint(high[1], low[1], close[1]) * 2 - low[1]\ns1 = pivotPoint(high[1], low[1], close[1]) * 2 - high[1]\nr2 = pivotPoint(high[1], low[1], close[1]) + (high[1] - low[1])\ns2 = pivotPoint(high[1], low[1], close[1]) - (high[1] - low[1])\nr3 = high[1] + 2 * (pivotPoint(high[1], low[1], close[1]) - low[1])\ns3 = low[1] - 2 * (high[1] - pivotPoint(high[1], low[1], close[1]))\n// Trend Identification\nis_uptrend = close > moving_average\nis_downtrend = close < moving_average\n// Entry and Exit Conditions with Trend Identification\nenterLong = is_uptrend and isBullishCandle and close > r1\nexitLong = is_uptrend and (bearishEngulfing or doji or close < s1)\nenterShort = is_downtrend and isBearishCandle and close < s1\nexitShort = is_downtrend and (bullishEngulfing or doji or close > r1)\n// Strategy Execution\nif enterLong and strategy.position_size == 0 and strategy.position_size[1] == 0 and\n    strategy.entry(\"Buy\", strategy.long, qty=40)\nif exitLong and strategy.position_size > 0\n    strategy.close(\"Buy\")\nif enterShort and strategy.position_size == 0 and close < s1\n    strategy.entry(\"Sell\", strategy.short, qty=40)\nif exitShort and strategy.position_size < 0\n    strategy.close(\"Sell\")\n// Stop-Loss and Trailing Stop-Loss\nstop_loss_pct = input(2.0, title=\"Stop Loss Percentage\")\ntrailing_stop_loss_pct = input(1.0, title=\"Trailing Stop Loss Percentage\")\ntrailing_stop_loss_active = input(true, title=\"Trailing Stop Loss Active\")\n// Stop-Loss\nstop_loss_level = strategy.position_avg_price * (1 - stop_loss_pct / 100)\nstrategy.exit(\"Stop Loss\", \"Buy\", loss=stop_loss_level)\n// Trailing Stop-Loss\n// Plotting Moving Average\nplot(moving_average, color= color.blue, title=\"Moving Average\", linewidth=2)\n// Plotting Candlestick Patterns\nplotshape(isBullishCandle, title=\"Bullish Candle\", location=location.belowbar, color\nplotshape(isBearishCandle, title=\"Bearish Candle\", location=location.abovebar, color\n// Plotting Support and Resistance Levels\n//hline(r1, \"Resistance Level 1\", color=color.red, linestyle=hline.style_dotted)\n//hline(s1, \"Support Level 1\", color=color.green, linestyle=hline.style_dotted)"}]}
{"messages": [{"role": "user", "content": "0. Preface Hello traders, This is a strategy script that allows you to utilize a Grid Strategy using moving averages. It is very simple, but I decided to post it because it was hard to find such shared open-source codes in Pine Script. 1. Main This is a very simple trading method.  Based on the moving average line you set, if the price drops by a certain ATR (or percent) below it, you buy, and when it goes back up, you sell. In basic settings, you choose the moving average line and its length, and decide how much to set the distance between each grid through the 'Band Multiplier/Percent' item. I believe that it is advantageous to widen the bandwidth for stocks with strong upward momentum. 2. Conclusion I have confirmed that this works better in the stock market than in the crypto market,  and that it is suitable for use on index stocks like NASDAQ because it follows trends. In addition, through backtesting, I have confirmed that this grid strategy is more suitable for buying strategies than selling strategies, so I uploaded it as a strategy focused on buying strategies. Personally, I have developed my own strategy by adjusting buying and selling strategies according to trends and managing risks. I hope you can use this to create a script that suits you. Thank you."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Seungdori_\n//@version=5\nstrategy(\"Grid Strategy with MA\", overlay=true, initial_capital = 100000, default_qty_type\n//Inputs//\nlength = input.int(defval = 100, title = 'MA Length', group = 'MA')\nMA_Type = input.string(\"SMA\", title=\"MA Type\", options=['EMA', 'HMA', 'LSMA', 'RMA'\nlogic = input.string(defval='ATR', title ='Grid Logic', options = ['ATR', 'Percent'\nband_mult = input.float(2.5, step = 0.1, title = 'Band Multiplier/Percent', group \natr_len = input.int(defval=100, title = 'ATR Length', group ='parameter')\n//Var//\nvar int order_cond = 0\nvar bool order_1 = false\nvar bool order_2 = false\nvar bool order_3 = false\nvar bool order_4 = false\nvar bool order_5 = false\nvar bool order_6 = false\nvar bool order_7 = false\nvar bool order_8 = false\nvar bool order_9 = false\nvar bool order_10 = false\nvar bool order_11 = false\nvar bool order_12 = false\nvar bool order_13 = false\nvar bool order_14 = false\nvar bool order_15 = false\n/////////////////////\n//Region : Function//\n/////////////////////\ngetMA(source ,ma_type, length) =>\n    maPrice = ta.ema(source, length)\n    ema = ta.ema(source, length)\n    sma = ta.sma(source, length)\n    if ma_type == 'SMA'\n        maPrice := ta.sma(source, length)\n        maPrice\n    if ma_type == 'HMA'\n        maPrice := ta.hma(source, length)\n        maPrice\n    if ma_type == 'WMA'\n        maPrice := ta.wma(source, length)\n        maPrice\n    if ma_type == \"RMA\"\n        maPrice := ta.rma(source, length)\n    if ma_type == \"LSMA\"\n        maPrice := ta.linreg(source, length, 0)\n    maPrice\nmain_plot = getMA(ohlc4, MA_Type, length)\natr = ta.atr(length)\npremium_zone_1 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*1), 5) : ta.ema\npremium_zone_2 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*2), 5) : ta.ema\npremium_zone_3 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*3), 5) : ta.ema\npremium_zone_4 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*4), 5) : ta.ema\npremium_zone_5 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*5), 5) : ta.ema\npremium_zone_6 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*6), 5) : ta.ema\npremium_zone_7 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*7), 5) : ta.ema\npremium_zone_8 = logic == 'ATR' ? ta.ema(main_plot + atr*(band_mult*8), 5) : ta.ema\n//premium_zone_9 = ta.rma(main_plot + atr*(band_mult*9), 5)\n//premium_zone_10 = ta.rma(main_plot + atr*(band_mult*10), 5)\ndiscount_zone_1 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*1), 5) : ta.ema\ndiscount_zone_2 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*2), 5) : ta.ema\ndiscount_zone_3 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*3), 5) : ta.ema\ndiscount_zone_4 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*4), 5) : ta.ema\ndiscount_zone_5 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*5), 5) : ta.ema\ndiscount_zone_6 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*6), 5) : ta.ema\ndiscount_zone_7 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*7), 5) : ta.ema\ndiscount_zone_8 = logic == 'ATR' ? ta.ema(main_plot - atr*(band_mult*8), 5) : ta.ema\n//discount_zon_9 = ta.sma(main_plot - atr*(band_mult*9), 5)\n//discount_zone_10 =ta.sma( main_plot - atr*(band_mult*10), 5)\n//Region End//\n////////////////////\n// Region : Plots//\n///////////////////\ndis_low1 = plot(discount_zone_1, color= color.new(color.green, 80))\ndis_low2 = plot(discount_zone_2, color= color.new(color.green, 70))\ndis_low3 = plot(discount_zone_3, color= color.new(color.green, 60))\ndis_low4 = plot(discount_zone_4, color= color.new(color.green, 50))\ndis_low5 = plot(discount_zone_5, color= color.new(color.green, 40))\ndis_low6 = plot(discount_zone_6, color= color.new(color.green, 30))\ndis_low7 = plot(discount_zone_7, color= color.new(color.green, 20))\ndis_low8 = plot(discount_zone_8, color= color.new(color.green, 10))\n//dis_low9 = plot(discount_zone_9, color=color.new(color.green, 0))\n//dis_low10 = plot(discount_zone_10, color=color.new(color.green, 0))\nplot(main_plot, color = color.new(color.gray, 10))\npre_up1 = plot(premium_zone_1, color= color.new(color.red, 80))\npre_up2 = plot(premium_zone_2, color= color.new(color.red, 70))\npre_up3 = plot(premium_zone_3, color= color.new(color.red, 60))\npre_up4 = plot(premium_zone_4, color= color.new(color.red, 50))\npre_up5 = plot(premium_zone_5, color= color.new(color.red, 40))\npre_up6 = plot(premium_zone_6, color= color.new(color.red, 30))\npre_up7 = plot(premium_zone_7, color= color.new(color.red, 20))\npre_up8 = plot(premium_zone_8, color= color.new(color.red, 10))\n//pre_up9 = plot(premium_zone_9, color=color.new(color.red, 0))\n//pre_up10 = plot(premium_zone_10, color=color.new(color.red, 0))\nfill(dis_low1, dis_low2, color= color.new(color.green, 95))\nfill(dis_low2, dis_low3, color= color.new(color.green, 90))\nfill(dis_low3, dis_low4, color= color.new(color.green, 85))\nfill(dis_low4, dis_low5, color= color.new(color.green, 80))\nfill(dis_low5, dis_low6, color= color.new(color.green, 75))\nfill(dis_low6, dis_low7, color= color.new(color.green, 70))\nfill(dis_low7, dis_low8, color= color.new(color.green, 65))\n//fill(dis_low8, dis_low9, color=color.new(color.green, 60))\n//fill(dis_low9, dis_low10, color=color.new(color.green, 55))\nfill(pre_up1, pre_up2, color= color.new(color.red, 95))\nfill(pre_up2, pre_up3, color= color.new(color.red, 90))\nfill(pre_up3, pre_up4, color= color.new(color.red, 85))\nfill(pre_up4, pre_up5, color= color.new(color.red, 80))\nfill(pre_up5, pre_up6, color= color.new(color.red, 75))\nfill(pre_up6, pre_up7, color= color.new(color.red, 70))\nfill(pre_up7, pre_up8, color= color.new(color.red, 65))\n//fill(pre_up8, pre_up9, color=color.new(color.red, 60))\n//fill(pre_up9, pre_up10, color=color.new(color.red, 55))\n//Region End//\n///////////////////////\n//Region : Strategies//\n///////////////////////\n//Longs//\nlongCondition1 = ta.crossunder(low, discount_zone_7)\nlongCondition2 = ta.crossunder(low, discount_zone_6)\nlongCondition3 = ta.crossunder(low, discount_zone_5)\nlongCondition4 = ta.crossunder(low, discount_zone_4)\nlongCondition5 = ta.crossunder(low, discount_zone_3)\nlongCondition6 = ta.crossunder(low, discount_zone_2)\nlongCondition7 = ta.crossunder(low, discount_zone_1)\nlongCondition8 = ta.crossunder(low, main_plot)\nlongCondition9 = ta.crossunder(low, premium_zone_1)\nlongCondition10 = ta.crossunder(low, premium_zone_2)\nlongCondition11 = ta.crossunder(low, premium_zone_3)\nlongCondition12 = ta.crossunder(low, premium_zone_4)\nlongCondition13 = ta.crossunder(low, premium_zone_5)\nlongCondition14 = ta.crossunder(low, premium_zone_6)\nlongCondition15 = ta.crossunder(low, premium_zone_7)\nif (longCondition1) and order_1 == false\n    strategy.entry(\"Long1\", strategy.long)\n    order_1 := true\nif (longCondition2) and order_2 == false\n    strategy.entry(\"Long2\", strategy.long)\n    order_2 := true\nif (longCondition3) and order_3 == false\n    strategy.entry(\"Long3\", strategy.long)\n    order_3 := true\nif (longCondition4) and order_4 == false\n    strategy.entry(\"Long4\", strategy.long)\n    order_4 := true\nif (longCondition5) and order_5 == false\n    strategy.entry(\"Long5\", strategy.long)\n    order_5 := true\nif (longCondition6) and order_6 == false\n    strategy.entry(\"Long6\", strategy.long)\n    order_6 := true\nif (longCondition7) and order_7 == false\n    strategy.entry(\"Long7\", strategy.long)\n    order_7 := true\nif (longCondition8) and order_8 == false\n    strategy.entry(\"Long8\", strategy.long)\n    order_8 := true\nif (longCondition9) and order_9 == false\n    strategy.entry(\"Long9\", strategy.long)\n    order_9 := true\nif (longCondition10) and order_10 == false\n    strategy.entry(\"Long10\", strategy.long)\n    order_10 := true\nif (longCondition11) and order_11 == false\n    strategy.entry(\"Long11\", strategy.long)\n    order_11 := true\nif (longCondition12) and order_12 == false\n    strategy.entry(\"Long12\", strategy.long)\n    order_12 := true\nif (longCondition13) and order_13 == false\n    strategy.entry(\"Long13\", strategy.long)\n    order_13 := true\nif (longCondition14) and order_14 == false\n    strategy.entry(\"Long14\", strategy.long)\n    order_14 := true\nif (longCondition15) and order_15 == false\n    strategy.entry(\"Long14\", strategy.long)\n    order_15 := true\n//Close//\nshortCondition1 = ta.crossover(high, discount_zone_6)\nshortCondition2 = ta.crossover(high, discount_zone_5)\nshortCondition3 = ta.crossover(high, discount_zone_4)\nshortCondition4 = ta.crossover(high, discount_zone_3)\nshortCondition5 = ta.crossover(high, discount_zone_2)\nshortCondition6 = ta.crossover(high, discount_zone_1)\nshortCondition7 = ta.crossover(high, main_plot)\nshortCondition8 = ta.crossover(high, premium_zone_1)\nshortCondition9 = ta.crossover(high, premium_zone_2)\nshortCondition10 = ta.crossover(high, premium_zone_3)\nshortCondition11 = ta.crossover(high, premium_zone_4)\nshortCondition12 = ta.crossover(high, premium_zone_5)\nshortCondition13 = ta.crossover(high, premium_zone_6)\nshortCondition14 = ta.crossover(high, premium_zone_7)\nshortCondition15 = ta.crossover(high, premium_zone_8)\nif (shortCondition1) and order_1 == true\n    strategy.close(\"Long1\")\n    order_1 := false\nif (shortCondition2) and order_2 == true\n    strategy.close(\"Long2\")\n    order_2 := false\nif (shortCondition3) and order_3 == true\n    strategy.close(\"Long3\")\n    order_3 := false\nif (shortCondition4) and order_4 == true\n    strategy.close(\"Long4\")\n    order_4 := false\nif (shortCondition5) and order_5 == true\n    strategy.close(\"Long5\")\n    order_5 := false\nif (shortCondition6) and order_6 == true\n    strategy.close(\"Long6\")\n    order_6 := false\nif (shortCondition7) and order_7 == true\n    strategy.close(\"Long7\")\n    order_7 := false\nif (shortCondition8) and order_8 == true\n    strategy.close(\"Long8\")\n    order_8 := false\nif (shortCondition9) and order_9 == true\n    strategy.close(\"Long9\")\n    order_9 := false\nif (shortCondition10) and order_10 == true\n    strategy.close(\"Long10\")\n    order_10 := false\nif (shortCondition11) and order_11 == true\n    strategy.close(\"Long11\")\n    order_11 := false\nif (shortCondition12) and order_12 == true\n    strategy.close(\"Long12\")\n    order_12 := false\nif (shortCondition13) and order_13 == true\n    strategy.close(\"Long13\")\n    order_13 := false\nif (shortCondition14) and order_14 == true\n    strategy.close(\"Long14\")\n    order_14 := false\nif (shortCondition15) and order_15 == true\n    strategy.close(\"Long15\")\n    order_15 := false"}]}
{"messages": [{"role": "user", "content": "- Introduction and how it is different The 'Volatility Capture RSI-Bollinger - Strategy ' is a trading strategy that combines the concepts of Bollinger Bands (BB), Relative Strength Index (RSI), and Simple Moving Average (SMA) to generate trading signals. The uniqueness of this strategy is it calculates which is a dynamic level between the upper and lower Bollinger Bands based on the closing price. This unique feature allows the strategy to adapt to market volatility and price movements. The market in Crypto and Stock are highly volatile, making them suitable for a strategy that uses Bollinger Bands. The RSI can help identify overbought or oversold conditions in this often speculative market. BTCUSD 4hr chart (700.hk/) 3hr chart Remember, the effectiveness of a trading strategy also depends on other factors such as the timeframe used, the specific settings of the indicators, and the overall market conditions. It's always recommended to backtest and paper trade a strategy before using it in live trading. - Strategy, How it Works Dynamic Bollinger Band: The strategy works by first calculating the upper and lower Bollinger Bands based on the user-defined length and multiplier. It then uses the Bollinger Bands and the closing price to dynamically adjust the presentBollingBand value. In the end, it generates a long signal when the price crosses over the present Bolling Band and a short signal when the price crosses under the present Bolling Band. RSI: If the user has chosen to use RSI for signals, the strategy also calculates the RSI and its SMA, and uses these to generate additional long and short signals. The RSI-based signals are only used if the 'Use RSI for signals' option is set to true. The strategy then checks the chosen trading direction and enters a long or short position accordingly. If the trading direction is set to 'Both', the strategy can enter both long and short positions. Finally, the strategy exits a position when the close price crosses under the present Bolling Band for a long position, or crosses over the present Bolling Band for a short position. - Trade direction The strategy also includes a trade direction parameter, allowing the user to choose whether to enter long trades, short trades, or both. This makes the strategy adaptable to different market conditions and trading styles. - Usage 1. Set the input parameters as per your trading preferences. You can choose the price source, the length of the moving average, the multiplier for the ATR, whether to use RSI for signals, the RSI and SMA periods, the bought and sold range levels, and the trading direction. 2. The strategy will then generate buy and sell signals based on these parameters. You can use these signals to enter and exit trades. - Default settings 1. Source: hlc3 2. Length: 50 3. Multiplier: 2.7183 4. Use RSI for signals: True 5. RSI Period: 10 6. SMA Period: 5 7. Bought Range Level: 55 8. Sold Range Level: 50 9. Trade Direction: Both - Strategy's default Properties 1. Default Quantity Type: 'strategy.percent_of_equity' 2. commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1: These parameters set the commission and slippage for the strategy. The commission is set to 0.1% of the trade value, and the slippage (the difference between the expected price of a trade and the price at which the trade is executed) is set to 1. 3. default_qty_type = strategy.percent_of_equity, default_qty_value = 15: These parameters set the default quantity for trades. The default_qty_type is set to strategy.percent_of_equity, which means that the size of each trade will be a percentage of the account equity. The default_qty_value is set to 15, which means that each trade will be 15% of the account equity. 4. initial_capital= 10000: This parameter sets the initial capital for the strategy to $10,000."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 PresentTrading\n//@version=5\n// Define the strategy settings\nstrategy('Volatility Capture RSI-Bollinger - Strategy [presentTrading]', overlay=true\n commission_value= 0.1, commission_type=strategy.commission.percent, slippage=1, \n  currency=currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value\n// Define the input parameters for the indicator\npriceSource  = input.source(title='Source', defval=hlc3, group='presentBollingBand'\nlengthParam   = input.int(50, 'lengthParam', minval=1, group='presentBollingBand') \nmultiplier = input.float(2.7183, 'Multiplier', minval=0.1, step=.1, group='presentBollingBand'\nuseRSI = input.bool(true, 'Use RSI for signals', group='presentBollingBand') // Boolean input to decide whether to use RSI for \nrsiPeriod = input.int(10, 'RSI Period', minval=1, group='presentBollingBand') // The period for the RSI calculation\nsmaPeriod = input.int(5, 'SMA Period', minval=1, group='presentBollingBand') // The period for the SMA calculation\nboughtRange = input.float(55, 'Bought Range Level', minval=1, group='presentBollingBand'\nsoldRange = input.float(50, 'Sold Range Level', minval=1, group='presentBollingBand'\n// Add a parameter for choosing Long or Short\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long\", \"Short\", \n// Calculate the bollingerBand\nbarIndex = bar_index // The current bar index\nupperBollingerBand = ta.sma(high, lengthParam) + ta.stdev(high, lengthParam) * multiplier\nlowerBollingerBand = ta.sma(low, lengthParam) - ta.stdev(low, lengthParam) * multiplier\nvar float presentBollingBand = na // Initialize the presentBollingBand variable\ncrossCount = 0 // Initialize the crossCount variable\n// Calculate the buy and sell signals\nlongSignal1 = ta.crossover(priceSource, presentBollingBand) // Calculate the long signal\nshortSignal1 = ta.crossunder(priceSource, presentBollingBand) // Calculate the short signal\n// Calculate the RSI\nrsiValue = ta.rsi(priceSource, rsiPeriod) // Calculate the RSI value\nrsiSmaValue = ta.sma(rsiValue, smaPeriod) // Calculate the SMA of the RSI value\n// Calculate the buy and sell signals\nlongSignal2 = rsiSmaValue > boughtRange // Calculate the long signal based on the RSI SMA\nshortSignal2 = rsiSmaValue < soldRange // Calculate the short signal based on the RSI SMA\npresentBollingBand := na(lowerBollingerBand) or na(upperBollingerBand)?0.0 : close>\nif (tradeDirection == \"Long\" or tradeDirection == \"Both\") and longSignal1 and (useRSI\n    presentBollingBand := lowerBollingerBand // If the trade direction is \"Long\" or \"Both\", and\n    strategy.entry(\"Long\", strategy.long) // Enter a long position.\nif (tradeDirection == \"Short\" or tradeDirection == \"Both\") and shortSignal1 and (useRSI\n    presentBollingBand := upperBollingerBand // If the trade direction is \"Short\" or \"Both\", an\n    strategy.entry(\"Short\", strategy.short) // Enter a short position.\n// Exit condition\nif (strategy.position_size > 0 and ta.crossunder(close, presentBollingBand)) // If the strategy has a long position and the clo\n    strategy.close(\"Long\")\nif (strategy.position_size < 0 and ta.crossover(close, presentBollingBand)) // If the strategy has a short position and the cl\n    strategy.close(\"Short\")\n//~~ Plot\nplot(presentBollingBand,\"presentBollingBand\", color= color.blue) // Plot the presentBollingBand on the chart."}]}
{"messages": [{"role": "user", "content": "Indicator which shows candles which have open or close in top or bottom 20% of the range."}, {"role": "assistant", "content": "//@version=5\n//FxLowe - NR4 & NR7.\nstrategy(title = \"80-20\", overlay = true)\ntwenty = 0.2 * ( high - low)\ntriggerGreen = ((close >= high-twenty)) and ((open <= low+twenty))\ntriggerRed = (open >= high-twenty) and (close <= low+twenty)\n//barcolor( trigger ? blue : na, offset = 0, editable = true, title = \"trigger\")\nplotshape(triggerGreen, title= \"triggerGreen\", location=location.abovebar, color= \nplotshape(triggerRed, title= \"triggerRed\", location=location.abovebar, color= color.red"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Chart appearance improved"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Crunchster1\n//@version=5\nstrategy(title=\"Crunchster's Normalised Trend Strategy\", shorttitle=\"Normalised Trend Strategy\"\n// Inputs and Parameters\nsrc = input(close, 'Source', group='Strategy Settings')\nlength = input.int(title=\"Lookback period for price normalisation filter\", defval=14\nhlength = input.int(title=\"Lookback period for Hull Moving Average\", defval=100, minval\noffset = input.int(title=\"HMA Offset\", defval=0, minval=0, group='Strategy Settings'\nlong = input(true, 'Long', inline='08', group='Strategy Settings')\nshort = input(true, 'Short', inline='08', group='Strategy Settings', tooltip='Toggle long/short strategy on/off'\nstopMultiple = input.float(1, 'Stop multiple', step=0.25, group='Risk Management Settings'\nlev = input.float(1, 'Max Leverage', step=0.5, group='Risk Management Settings', tooltip\nriskT = input.float(10, maxval=75, title='Annualised Volatility Target %', group='Risk Management Settings'\ncomp = input(false, 'Compounding', inline='09', group='Risk Management Settings')\nComppct = input.float(50, '%', step=5, inline='09', group='Risk Management Settings'\n// Backtesting period\nFromDay = input.int(defval=1, title='From Day', minval=1, maxval=31, inline='04', group\nFromMonth = input.int(defval=1, title='From Mon', minval=1, maxval=12, inline='04',\nFromYear = input.int(defval=2018, title='From Yr', minval=1900, inline='04', group=\nToDay = input.int(defval=1, title='To Day', minval=1, maxval=31, inline='05', group\nToMonth = input.int(defval=1, title='To Mon', minval=1, maxval=12, inline='05', group\nToYear = input.int(defval=9999, title='To Yr', minval=1900, inline='05', group='Backtest range'\nstart = timestamp(FromYear, FromMonth, FromDay, 00, 00)\nfinish = timestamp(ToYear, ToMonth, ToDay, 23, 59)\nwindow = time >= start and time <= finish\n// Normalised returns calculation\nnRet = (src - src[1]) / ta.stdev((src - src[1]), length)\nnPrice = ta.cum(nRet)\n//Hull Moving Average - using normalised price series\nfHMA = ta.wma(2 * ta.wma(nPrice[offset], hlength / 2) - ta.wma(nPrice[offset], hlength\n//Risk Management formulae\ntr = math.max(high - low, math.abs(high - close), math.abs(low - close)) //True range\nstopL = ta.sma(tr, 14) //Average true range\nstdev = ta.stdev(close-close[1], 14) //volatility of recent returns\nmaxcapital = strategy.initial_capital+strategy.netprofit //Maximum capital available to invest - initial ca\nannvol = 100*math.sqrt(365)*stdev/close //converts recent volatility of returns into annua\nrisk = 1.1\nif comp\n    risk := (strategy.initial_capital+(Comppct*strategy.netprofit/100))//adjust investment capital to include compounding\nelse\n    risk := strategy.initial_capital\nshares = (risk * (riskT/annvol)) / close //calculates volatility adjusted position size, de\nif ((shares*close) > lev*maxcapital) //ensures position size does not exceed available \n    shares := lev*maxcapital/close\n//To set the price at the entry point of trade\nPosopen() =>\n    math.abs(strategy.position_size[1]) <= 0 and math.abs(strategy.position_size) >\nvar float openN = na\nif Posopen()\n    openN := stopL\n// Strategy Rules\nif long\n    longCondition = ta.crossover(nPrice, fHMA) and window\n    exitlong = ta.crossunder(nPrice, fHMA)\n    if (longCondition)\n        strategy.entry('Go Long!', strategy.long, qty=shares)\n    if strategy.position_size > 0    \n        strategy.exit('Stop Long', from_entry = 'Go Long!', stop=(strategy.opentrades.entry_price\n    if (exitlong)\n        strategy.close('Go Long!', immediately = true)\nif short\n    shortCondition = ta.crossunder(nPrice, fHMA) and window\n    exitshort = ta.crossover(nPrice, fHMA)\n    if (shortCondition)\n        strategy.entry('Go Short!', strategy.short, qty=shares)\n    if strategy.position_size < 0   \n        strategy.exit('Stop Short', from_entry = 'Go Short!', stop=(strategy.opentrades.entry_price\n    if (exitshort)\n        strategy.close('Go Short!', immediately = true)\n// Visuals of trend and direction\nplot(nPrice, title='Real Price', color= color.black)\nMAColor = fHMA > fHMA[3] ?  #00ff00 :  #ff0000\nMA1 = plot(fHMA, title='Hull MA', color=MAColor)\nMA2 = plot(fHMA[3], title='Hull MA Offset', color=MAColor)\nfill(MA1, MA2, title='Band Filler', color=MAColor)"}]}
{"messages": [{"role": "user", "content": "\ud83c\uddfa\ud83c\uddf8 GENERAL OVERVIEW Buy&Sell Bullish Engulfing - The Quant Science It is a Buy&Sell strategy based on the 'Bullish Engulfing' candlestick pattern. The main goal of the strategy is to achieve a consistent and sustainable return over time, with a manageable level of risk. Bullish Engulfing The template was developed at the top of the Indicator provided by TradingView called 'Engulfing - Bullish'. ENTRY AND EXIT CRITERIA Entry: A single long order is opened when the candlestick pattern is formed, and the percentage size of the order (%) is fixed by the trader through the user interface. Exit: The long trade is closed on a percentage equity take profit-stop loss. ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \ud83c\uddee\ud83c\uddf9 PANORAMICA GENERALE Buy&Sell Bullish Engulfing - The Quant Science \u00e8 una strategia Buy&Sell basata sul candlestick pattern 'Bullish Engulfing'. L'obiettivo principale della strategia \u00e8 ottenere un ritorno costante e sostenibile nel tempo, con un livello gestibile di rischio. Bullish Engulfing Il template \u00e8 stato sviluppato al top dell' Indicatore fornito da Trading View chiamato 'Engulfing - Bullish'. CRITERI DI ENTRATA E USCITA Entrata: viene aperto un singolo ordine long quando si forma il candlestick pattern, la size percentuale dell'ordine (%) viene selezionato tramite l'interfaccia utente dal trader. Uscita: la chiusura della posizione avviene unicamente tramite un take profit-stop loss percentuale calcolato sul capitale."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2557     \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557    \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551    \n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2551 \n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \n                                                                                                    //@version=5\nstrategy(\n     \"Buy&Sell Bullish Engulfing - The Quant Science\",\n     overlay = true,\n     default_qty_type = strategy.percent_of_equity, \n     default_qty_value = 100,\n     pyramiding = 1,\n     currency = currency.EUR,\n     initial_capital = 10000,\n     commission_type = strategy.commission.percent,\n     commission_value = 0.07,\n     process_orders_on_close = true, \n     close_entries_rule = \"ANY\"\n     )\nstartDate  = input.int(title=\"D: \", defval=1,    minval=1,    maxval=31,   inline \nstartMonth = input.int(title=\"M: \", defval=1,    minval=1,    maxval=12,   inline \nstartYear  = input.int(title=\"Y: \", defval=2022, minval=1800, maxval=2100, inline \nendDate    = input.int(title=\"D: \", defval=31,   minval=1,    maxval=31,   inline \nendMonth   = input.int(title=\"M: \", defval=12,   minval=1,    maxval=12,   inline \nendYear    = input.int(title=\"Y: \", defval=2023, minval=1800, maxval=2100, inline \ninDateRange = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\nPROFIT   = input.float(defval = 1, minval = 0, title = \"Target profit (%): \", step\nSTOPLOSS = input.float(defval = 1, minval = 0, title = \"Stop Loss (%): \",     step\nvar float equity_trades = 0\nequity_trades := strategy.initial_capital\nvar float equity   = 0\nvar float qty_order   = 0\nt_ordersize = \"Percentage size of each new order. With 'Reinvestment Profit' activate, the size will be calculate \norders_size = input.float(defval = 2, title = \"Orders size (%): \", minval = 0.10, \nqty_order := ((equity_trades * orders_size) / 100 ) / close \nC_DownTrend = true\nC_UpTrend   = true\nvar trendRule1 = \"SMA50\"\nvar trendRule2 = \"SMA50, SMA200\"\nvar trendRule = input.string(trendRule1, \"Detect Trend Based On\", options=[trendRule1\nif trendRule == trendRule1\n    priceAvg = ta.sma(close, 50)\n    C_DownTrend := close < priceAvg\n    C_UpTrend := close > priceAvg\nif trendRule == trendRule2\n    sma200 = ta.sma(close, 200)\n    sma50  = ta.sma(close, 50)\n    C_DownTrend := close < sma50 and sma50 < sma200\n    C_UpTrend := close > sma50 and sma50 > sma200\nC_Len = 14\nC_ShadowPercent = 5.0 \nC_ShadowEqualsPercent = 100.0\nC_DojiBodyPercent = 5.0\nC_Factor = 2.0 \nC_BodyHi = math.max(close, open)\nC_BodyLo = math.min(close, open)\nC_Body = C_BodyHi - C_BodyLo\nC_BodyAvg = ta.ema(C_Body, C_Len)\nC_SmallBody = C_Body < C_BodyAvg\nC_LongBody = C_Body > C_BodyAvg\nC_UpShadow = high - C_BodyHi\nC_DnShadow = C_BodyLo - low\nC_HasUpShadow = C_UpShadow > C_ShadowPercent / 100 * C_Body\nC_HasDnShadow = C_DnShadow > C_ShadowPercent / 100 * C_Body\nC_WhiteBody = open < close\nC_BlackBody = open > close\nC_Range = high-low\nC_IsInsideBar = C_BodyHi[1] > C_BodyHi and C_BodyLo[1] < C_BodyLo\nC_BodyMiddle = C_Body / 2 + C_BodyLo\nC_ShadowEquals = C_UpShadow == C_DnShadow or (math.abs(C_UpShadow - C_DnShadow) / \nC_IsDojiBody = C_Range > 0 and C_Body <= C_Range * C_DojiBodyPercent / 100\nC_Doji = C_IsDojiBody and C_ShadowEquals\npatternLabelPosLow  = low  - (ta.atr(30) * 0.6)\npatternLabelPosHigh = high + (ta.atr(30) * 0.6)\nlabel_color_bullish = input.color( color.rgb(43, 255, 0), title = \"Label Color Bullish\"\nC_EngulfingBullishNumberOfCandles = 2\nC_EngulfingBullish = C_DownTrend and C_WhiteBody and C_LongBody and C_BlackBody[1]\nif C_EngulfingBullish\n    var ttBullishEngulfing = \"Engulfing\\nAt the end of a given downward trend, there will most likely be a reversal pattern. To \n    label.new(bar_index, patternLabelPosLow, text=\"BE\", style=label.style_label_up\nbgcolor(ta.highest(C_EngulfingBullish?1:0, C_EngulfingBullishNumberOfCandles)!=0 ?\nvar float c       = 0\nvar float o       = 0\nvar float c_exit  = 0\nvar float c_stopl = 0\nif C_EngulfingBullish and strategy.opentrades==0 and inDateRange \n    c := strategy.equity\n    o := close\n    c_exit  := c + (c * PROFIT / 100)\n    c_stopl := c - (c * STOPLOSS / 100)\n    strategy.entry(id = \"LONG\", direction = strategy.long, qty = qty_order, limit \nif ta.crossover(strategy.equity, c_exit)\n    strategy.exit(id = \"CLOSE-LONG\", from_entry = \"LONG\", limit = close)\nif ta.crossunder(strategy.equity, c_stopl)\n    strategy.exit(id = \"CLOSE-LONG\", from_entry = \"LONG\", limit = close)"}]}
{"messages": [{"role": "user", "content": "This script is a trading strategy that combines the Vortex Indicator and a Moving Average (MA) to generate potential entry signals for long and short positions. 1. Vortex Indicator: The Vortex Indicator consists of two lines: Vortex Positive (VIP) and Vortex Negative (VIM). It is designed to identify trend direction and measure the strength of a trend. 2. Moving Average (MA): The script uses a chosen type of Moving Average (SMA, EMA, SMMA, WMA, or VWMA) to smooth the price data. The smoothed line is referred to as the \"Smoothing Line.\" 3. Determine Long and Short Conditions: The script looks for potential long entry signals when VIP crosses above VIM, highlighting each crossover on the chart, and the closing price is above the Smoothing Line. It searches for short entry signals when VIM crosses above VIP, with the closing price is below the Smoothing Line. When the long or short conditions are met, the strategy enters either a long or short position accordingly. Potential Usage: The strategy can be utilized in trending markets, where the Vortex Indicator helps identify trend direction and strength, and the Moving Average smooths the price data to filter out some noise. It aims to capture trends and ride them while avoiding false signals during choppy or sideways markets."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 DraftVenture\n//@version=5\nstrategy(\"Vortex + Moving Average Strategy\", overlay=true)\n//Vortex settings\nperiod_ = input.int(14, title=\"Vortex Length\", minval=2)\nVMP = math.sum( math.abs( high - low[1]), period_ )\nVMM = math.sum( math.abs( low - high[1]), period_ )\nSTR = math.sum( ta.atr(1), period_ )\nVIP = VMP / STR\nVIM = VMM / STR\nplot(VIP, title=\"VI +\", color= color.white)\nplot(VIM, title=\"VI -\", color= color.white)\nlen = input.int(9, minval=1, title=\"MA Length\")\nsrc = input(close, title=\"Source\")\noffset = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nout = ta.sma(src, len)\nplot(out, color= color.blue, title=\"MA\", offset=offset)\nma(source, length, type) =>\n    switch type\n        \"SMA\" => ta.sma(source, length)\n        \"EMA\" => ta.ema(source, length)\n        \"SMMA (RMA)\" => ta.rma(source, length)\n        \"WMA\" => ta.wma(source, length)\n        \"VWMA\" => ta.vwma(source, length)\ntypeMA = input.string(title = \"Method\", defval = \"SMA\", options=[\"SMA\", \"EMA\", \"SMMA (RMA)\"\nsmoothingLength = input.int(title = \"Length\", defval = 5, minval = 1, maxval = 100,\nsmoothingLine = ma(out, smoothingLength, typeMA)\nplot(smoothingLine, title=\"Smoothing Line\", color= #f37f20, offset=offset, display\n// Determine long and short conditions\nlongCondition = ta.crossover(VIP, VIM) and close > smoothingLine\nshortCondition = ta.crossunder(VIP, VIM) and close < smoothingLine\ncrossCondition = ta.crossunder(VIP, VIM) or ta.crossunder(VIM, VIP)\n// Strategy entry and exit logic\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\nbgcolor(crossCondition ?  color.new(color.white, 80) : na)\n// Strategy by KP"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added alerts."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 wbburgin\n//@version=5\nstrategy(\"Powertrend - Volume Range Filter [wbburgin]\",overlay=true,initial_capital\n default_qty_value=10, commission_value=0.00, slippage = 0, shorttitle=\"Powertrend [wbburgin]\"\nimport wbburgin/wbburgin_utils/2 as utils\nrngfilt_volumeadj(float source1, float tethersource, float smoothrng)=>\n    rngfilt = source1\n    if tethersource > nz(tethersource[1])\n        rngfilt := (source1 - smoothrng) < nz(rngfilt[1]) ? nz(rngfilt[1]) : (source1\n    else\n        rngfilt := (source1 + smoothrng) > nz(rngfilt[1]) ? nz(rngfilt[1]) : (source1\n    rngfilt\nl = input.int(200,\"Length\",group=\"General\")\nuseadx = input.bool(false,\"ADX Filter\",group=\"Filters\",inline=\"ADX\")\nlengthadx = input.int(14,title=\"\",group=\"Filters\",inline=\"ADX\")\nusehl = input.bool(false,\"Range Supertrend\",group=\"Filters\",inline=\"HL\")\nlengthhl = input.int(14,title=\"\",group=\"Filters\",inline=\"HL\")\nshowhl = input.bool(false,\"Plot\",group=\"Filters\",inline=\"HL\")\nusevwma = input.bool(false,\"VWMA Filter\",group=\"Filters\",inline=\"VWMA\")\nlengthvwma = input.int(200,title=\"\",group=\"Filters\",inline=\"VWMA\")\nshowvwma = input.bool(false,\"Plot\",group=\"Filters\",inline=\"VWMA\")\nhighlighting = input.bool(true,\"Highlighting\",group=\"Display\")\nbarcolors = input.bool(true,\"Bar Colors\",group=\"Display\")\nbuyselllabels = input.bool(true,\"Entry-Exit Labels\",group=\"Display\")\nvolrng = rngfilt_volumeadj(close,volume,utils.smoothrng(close,l,3))\nsmoothrng = utils.smoothrng(close,l,3)\nbasetype = volrng\nhband = basetype + smoothrng\nlowband = basetype - smoothrng\n// Filters\n    // -- Built-in\nuprng = utils.trendUp(basetype)\n    // -- ADX\n[x,y,adx] = ta.dmi(lengthadx,lengthadx)\nadx_vwma = ta.vwma(adx,lengthadx)\nadx_filter = not useadx ? true : adx > adx_vwma ? true : false\n    // -- High/Low\nlowband_trendfollow = ta.lowest(lowband,lengthhl)\nhighband_trendfollow = ta.highest(hband,lengthhl)\nin_general_uptrend = ta.barssince(ta.crossover(close,highband_trendfollow[1])) < ta.barssince\nigu_filter_positive = not usehl ? true : in_general_uptrend ? true : false\nigu_filter_negative = not usehl ? true : not in_general_uptrend ? true : false\n    // -- VWMA\nvwma = ta.vwma(volrng,lengthvwma)\nvwma_filter_positive = not usevwma ? true : volrng > vwma ? true : false\n//No negative needed\nb = uprng and ta.crossover(close,hband) and igu_filter_positive and adx_filter and\ns = not uprng and ta.crossunder(close,lowband) and igu_filter_negative and adx_filter\nin_b = ta.barssince(b)[1] < ta.barssince(s)[1]\nin_s = ta.barssince(s)[1] < ta.barssince(b)[1]\nif b\n    strategy.entry(\"Long\",strategy.long)\n    alert(\"Powertrend Entry\",freq=alert.freq_once_per_bar)\nif s\n    strategy.close(\"Long\")\n    alert(\"Powertrend Exit\",freq=alert.freq_once_per_bar)\nmp=plot(basetype,color= color.white,title=\"Volume Range\")\nhp=plot(hband,color=na,title=\"High Range\")\nlp=plot(lowband,color=na, title=\"Low Range\")\nbb=plot(not showhl ? na : in_general_uptrend ? lowband_trendfollow : na, color= color.lime\nuu=plot(not showhl ? na : not in_general_uptrend ? highband_trendfollow : na,color\nplot(not showvwma ? na : vwma, color =  color.orange,title=\"VWMA\")\nfill(hp,mp,color=not highlighting ? na :  color.new(color.lime,88))\nfill(mp,lp,color=not highlighting ? na :  color.new(color.yellow,88))\nfill(uu,hp,color=not highlighting ? na : in_general_uptrend ? na :  color.new(color.red\nfill(bb,lp,color=not highlighting ? na : not in_general_uptrend ? na :  color.new\nplotshape(b and not in_b and buyselllabels ? lowband : na,\"Buy Label\",style=shape.labelup\n color= color.green,textcolor= color.white,text = \"Buy\", size=size.tiny)\nplotshape(s and not in_s and buyselllabels ? hband : na,\"Sell Label\",style=shape.labeldown\n color= color.red,textcolor= color.white,text = \"Sell\", size=size.tiny)\nbarcolor(barcolors ? uprng ?  color.lime :  color.yellow : na)\n//alertcondition(b,\"PT Buy\")\n//alertcondition(s,\"PT Sell\")"}]}
{"messages": [{"role": "user", "content": "Unlocking the Magic of Linear Regression in TradingView In the ever-evolving world of financial markets, traders and investors seek effective tools to gauge price movements, make informed decisions, and achieve their financial goals. One such tool that has proven its worth over time is linear regression, a mathematical concept that has found its way into technical analysis and trading strategies. In this blog post, we will explore the magic behind linear regression, delve into its history, and understand how it's widely used as a technical indicator. The Birth of Linear Regression: From Mathematics to Trading Linear regression is a statistical method that aims to model the relationship between two variables by fitting a linear equation to observed data. The formula for a linear regression line is typically expressed as y = a + bx, where y is the dependent variable, x is the independent variable, a is the intercept, and b is the slope. While the roots of linear regression trace back to the field of statistics, it didn't take long for traders and investors to recognize its potential in the financial world. By applying linear regression to historical price data, traders can identify trends, assess the relationship between variables, and even predict potential future price levels. The Linear On MACD Strategy Let's take a closer look at a powerful example of how linear regression is employed in a trading strategy right within TradingView. The \"Linear On MACD\" strategy harnesses the potential of linear regression in conjunction with the Moving Average Convergence Divergence (MACD) indicator. The goal of this strategy is to generate buy and sell signals based on the interactions between the predicted stock price and the MACD indicator. Here's a breakdown of the strategy's components:     Calculation of Linear Regression: The strategy begins by calculating linear regression coefficients for the historical stock price based on volume. This helps predict potential future price levels.     Predicted Stock Price: The linear regression results are then used to plot the predicted stock price on the chart. This provides a visual representation of where the price could trend based on historical data.     Buy and Sell Signals: The strategy generates buy signals when certain conditions are met. These conditions include the predicted stock price being between the open and close prices, a rising MACD, and other factors that suggest a potential bullish trend. On the other hand, sell signals are generated based on MACD trends and predicted price levels.     Risk Management: The strategy also incorporates risk tolerance levels to determine entry and exit points. This ensures that traders take into account their risk appetite when making trading decisions. Embracing the Magic of Linear Regression As we explore the \"Linear On MACD\" strategy, we uncover the power of linear regression in aiding traders and investors. Linear regression, a mathematical marvel, seamlessly merges with technical analysis to provide insights into potential price movements. Its historical significance in statistics blends perfectly with the demands of modern financial markets. Whether you're a seasoned trader or a curious investor, the Linear On MACD strategy exemplifies how a robust mathematical concept can be harnessed to make informed trading decisions. By embracing the magic of linear regression, you're tapping into a tool that continues to evolve alongside the financial world it empowers. Disclaimer: The information provided in this blog post is for educational purposes only and does not constitute financial advice. Trading and investing carry risks, and it's important to conduct thorough research and consider seeking professional advice before making any trading decisions."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 stocktechbot\n//@version=5\nstrategy(\"Linear On MACD\", overlay=true, margin_long=100, margin_short=100)\nfast_length = input(title=\"Fast Length\", defval=12)\nslow_length = input(title=\"Slow Length\", defval=26)\ntolerance = input.string(title=\"Risk tolerance\", defval = \"LOW\", options=[\"LOW\", \"HIGH\"\nchng = 0\nobv = ta.cum(math.sign(ta.change(close)) * volume)\nif close < close[1] and (open < close)\n    chng := 1\nelse if close > close[1]\n    chng := 1\nelse\n    chng := -1\nobvalt = ta.cum(math.sign(chng) * volume)\n//src = input(title=\"Source\", defval=close)\nsrc = obvalt\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nsma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\"SMA\"\nsma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\n// Calculating\nfast_ma = sma_source == \"SMA\" ? ta.sma(src, fast_length) : ta.ema(src, fast_length\nslow_ma = sma_source == \"SMA\" ? ta.sma(src, slow_length) : ta.ema(src, slow_length\nmacd = fast_ma - slow_ma\nsignal = sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\nhist = macd - signal\n//hline(0, \"Zero Line\", color=color.new(#787B86, 50))\n//plot(hist, title=\"Histogram\", style=plot.style_columns, color=(hist>=0 ? (hist[1] < hist ? col_gro\n//plot(macd, title=\"MACD\", color=col_macd)\n//plot(signal, title=\"Signal\", color=col_signal)\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\n//Linear Regression\nvol = volume\n// Function to calculate linear regression\nlinregs(y, x, len) =>\n    ybar = math.sum(y, len)/len\n    xbar = math.sum(x, len)/len\n    b = math.sum((x - xbar)*(y - ybar),len)/math.sum((x - xbar)*(x - xbar),len)\n    a = ybar - b*xbar\n    [a, b]\n// Historical stock price data\nprice = close\n// Length of linear regression\nlen = input(defval = 21, title = 'Lookback')\n// Calculate linear regression for stock price based on volume\n[a, b] = linregs(price, vol, len)\n// Predicted stock price based on volume\npredicted_price = a + b*vol\n// Check if predicted price is between open and close\nis_between = open < predicted_price and predicted_price < close\n// Plot predicted stock price\nplot(predicted_price, color= color.rgb(218, 27, 132), linewidth=2, title=\"Predicted Stock Price\"\nplot(ta.vwma(predicted_price,len), color= color.rgb(199, 43, 64), linewidth=2, title\n//BUY Signal\nlincrossunder = close > predicted_price\nmacdrise = ta.rising(macd,2)\n//macdvollong = ta.crossover(macd, signal)\n//macdlong = ta.crossover(macdLine, signalLine)\nmacdvollong = macd > signal\nmacdlong = macdLine > signalLine\nlongCondition=false\nif macdlong and macdvollong and is_between and ta.rising(predicted_price,1)\n    longCondition := true\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\n//Sell Signal\nlincrossover = close < predicted_price\nmacdfall = ta.falling(macd,1)\nmacdsell = macd < signal\nshortCondition = false\nrisklevel = predicted_price\nif (tolerance == \"HIGH\")\n    risklevel := ta.vwma(predicted_price,len)\nif macdfall and macdsell and (macdLine < signalLine) and (close < risklevel)\n    shortCondition := true\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "This strategy is based and shown by trader and investor Alexandre Wolwacz \"Stormer\". Overview The strategy uses two indicators Bollinger Bands and EMA (optional for EMA). Calculates Bollinger Bands, EMA, highest high, and lowest low values based on the input parameters, evaluating the conditions to determine potential long and short entry signals. The conditions include checks for crossovers and crossunders of the price with the upper and lower Bollinger Bands, as well as the position of the price relative to the EMA. The script also incorporates the option to add an inside bar pattern check for additional information. Entry Position Long Position: Price cross over the superior band of bollinger bands. The EMA is used to add support for trend analysis, it is an optional input, when used, it checks if price is above EMA. Short Position: Price cross under the inferior band of bollinger bands. The EMA is used to add support for trend analysis, it is an optional input, when used, it checks if price is under EMA.  Risk Management Stop Loss: The stop loss is calculated based on the input highest high (for short position) and lowest low (for long position). It gets the length based on the input from the last candles to set which is the highest high and which is the lowest low. Take Profit: According to the author, the profit target should be at least 1:1.6 the risk, so to have the strategy mathematically positive. The profit target is configured input, can be increased or decreased. It calculates the take profit based on the price of the stop loss with the profit target input."}, {"role": "assistant", "content": "// This close code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 AugustoErni\n//@version=5\nstrategy('Bollinger Bands Modified (Stormer)', overlay=true, process_orders_on_close\nbbL                   = input.int(20, title='BB Length/Comprimento da Banda de Bollinger'\nmult                  = input.float(0.38, title='BB Standard Deviation/Desvio Padr\u00e3o da Banda de \nemaL                  = input.int(80, title='EMA Length/Comprimento da M\u00e9dia M\u00f3vel \nhighestHighL          = input.int(7, title='Highest High Length/Comprimento da Alta Maior'\nlowestLowL            = input.int(7, title='Lowest Low Length/Comprimento da Baixa Menor'\ntargetFactor          = input.float(1.6, title='Target Take Profit/Objetivo de Lucro Alvo'\nemaTrend              = input.bool(true, title='Check Trend EMA/Verificar Tend\u00eancia da M\u00e9dia \ncrossoverCheck        = input.bool(false, title='Add Another Crossover Check/Adicionar Mais uma \ncrossunderCheck       = input.bool(false, title='Add Another Crossunder Check/Adicionar Mais uma \ninsideBarPatternCheck = input.bool(true, title='Show Inside Bar Pattern/Mostrar Padr\u00e3o de Inside \n[middle, upper, lower] = ta.bb(close, bbL, mult)\nema                    = ta.ema(close, emaL)\nhighestHigh            = ta.highest(high, highestHighL)\nlowestLow              = ta.lowest(low, lowestLowL)\nisCrossover            = ta.crossover(close, upper) ? 1 : 0\nisCrossunder           = ta.crossunder(close, lower) ? 1 : 0\nisPrevBarHighGreaterCurBarHigh = high[1] > high ? 1 : 0\nisPrevBarLowLesserCurBarLow    = low[1] < low ? 1 : 0\nisInsideBar                    = isPrevBarHighGreaterCurBarHigh and isPrevBarLowLesserCurBarLow\nisBarLong  = ((close - open) > 0) ? 1 : 0\nisBarShort = ((close - open) < 0) ? 1 : 0\nisLongCross  = crossoverCheck ? ((isBarLong and not isBarShort) and (open < upper \nisShortCross = crossunderCheck ? ((isBarShort and not isBarLong) and (close < lower\nisCandleAboveEma = close > ema ? 1 : 0\nisCandleBelowEma = close < ema ? 1 : 0\nisLongCondition  = emaTrend ? isLongCross and isCandleAboveEma ? 1 : 0 : isLongCross\nisShortCondition = emaTrend ? isShortCross and isCandleBelowEma ? 1 : 0 : isShortCross\nisPositionNone  = strategy.position_size == 0 ? 1 : 0\nisPositionLong  = strategy.position_size > 0 ? 1 : 0\nisPositionShort = strategy.position_size < 0 ? 1 : 0\nvar float enterLong     = 0.0\nvar float stopLossLong  = 0.0\nvar float targetLong    = 0.0\nvar float enterShort    = 0.0\nvar float stopLossShort = 0.0\nvar float targetShort   = 0.0\nvar bool isLongEntry    = false\nvar bool isShortEntry   = false\nif (isPositionNone)\n    isLongEntry   := false\n    isShortEntry  := false\n    enterLong     := 0.0\n    stopLossLong  := 0.0\n    targetLong    := 0.0\n    enterShort    := 0.0\n    stopLossShort := 0.0\n    targetShort   := 0.0\nif (isPositionShort or isPositionNone)\n    isLongEntry  := false\n    enterLong    := 0.0\n    stopLossLong := 0.0\n    targetLong   := 0.0\nif (isPositionLong or isPositionNone)\n    isShortEntry  := false\n    enterShort    := 0.0\n    stopLossShort := 0.0\n    targetShort   := 0.0\nif (isPositionLong and isLongEntry)\n    isLongEntry   := true\n    isShortEntry  := false\n    enterShort    := 0.0\n    stopLossShort := 0.0\n    targetShort   := 0.0\nif (isPositionShort and isShortEntry)\n    isShortEntry := true\n    isLongEntry  := false\n    enterLong    := 0.0\n    stopLossLong := 0.0\n    targetLong   := 0.0\nif (isLongCondition and not isLongEntry)\n    isLongEntry  := true\n    enterLong    := close\n    stopLossLong := lowestLow\n    targetLong   := (enterLong + (math.abs(enterLong - stopLossLong) * targetFactor\n    alertMessage = '{ \"side/lado\": \"buy\", \"entry/entrada\": ' + str.tostring(enterLong\n    alert(alertMessage)\n    strategy.entry('Long', strategy.long)\n    strategy.exit('Exit Long', 'Long', stop=stopLossLong, limit=targetLong)\nif (isShortCondition and not isShortEntry)\n    isShortEntry  := true\n    enterShort    := close\n    stopLossShort := highestHigh\n    targetShort   := (enterShort - (math.abs(enterShort - stopLossShort) * targetFactor\n    alertMessage = '{ \"side/lado\": \"sell\", \"entry/entrada\": ' + str.tostring(enterShort\n    alert(alertMessage)\n    strategy.entry('Short', strategy.short)\n    strategy.exit('Exit Short', 'Short', stop=stopLossShort, limit=targetShort)\nplot(upper, title='Upper Band', color= color.blue)\nplot(middle, title='Middle Band', color= color.gray)\nplot(lower, title='Lower Band', color= color.blue)\nplot(ema, title='EMA', color= color.white)\nbarcolor(insideBarPatternCheck and isInsideBar and isBarLong ?  color.lime : insideBarPatternCheck\ntablePosition    = position.bottom_right\ntableColumns     = 2\ntableRows        = 5\ntableFrameWidth  = 1\ntableBorderColor =  color.gray\ntableBorderWidth = 1\ntableInfoTrade = table.new(position=tablePosition, columns=tableColumns, rows=tableRows\ntable.cell(table_id=tableInfoTrade, column=0, row=0)\ntable.cell(table_id=tableInfoTrade, column=1, row=0)\ntable.cell(table_id=tableInfoTrade, column=0, row=1, text='Entry Side/Lado da Entrada'\ntable.cell(table_id=tableInfoTrade, column=0, row=2, text=isLongEntry ? 'LONG' : isShortEntry\ntable.cell(table_id=tableInfoTrade, column=1, row=1, text='Entry Price/Pre\u00e7o da Entrada'\ntable.cell(table_id=tableInfoTrade, column=1, row=2, text=isLongEntry ? str.tostring\ntable.cell(table_id=tableInfoTrade, column=0, row=3, text='Take Profit Price/Pre\u00e7o Alvo Lucro'\ntable.cell(table_id=tableInfoTrade, column=0, row=4, text=isLongEntry ? str.tostring\ntable.cell(table_id=tableInfoTrade, column=1, row=3, text='Stop Loss Price/Pre\u00e7o Stop Loss'\ntable.cell(table_id=tableInfoTrade, column=1, row=4, text=isLongEntry ? str.tostring"}]}
{"messages": [{"role": "user", "content": "The profitability and uniqueness of a trading strategy depend on various factors including market conditions, risk management, and the strategy's ability to capitalize on price movements. I'll describe the strategy provided and highlight its potential benefits and differences compared to other strategies: Strategy Overview: The provided strategy combines three technical indicators: Supertrend, MACD, and VWAP. It aims to identify potential entry and exit points by confirming trend direction and considering the proximity to the VWAP level. The strategy also incorporates stop-loss and take-profit mechanisms, as well as a trailing stop. Unique Aspects and Potential Benefits: Trend Confirmation: The strategy uses both Supertrend and MACD to confirm the trend direction. This dual confirmation can increase the likelihood of accurate trend identification and filter out false signals. VWAP Confirmation: The strategy considers the proximity of the price to the VWAP level. This dynamic level can act as a support or resistance and provide additional context for entry decisions. Adaptive Stop Loss: The strategy sets a stop-loss range, which helps provide some tolerance for minor price fluctuations. This adaptive approach considers market volatility and helps prevent premature stop-loss triggers. Trailing Stop: The strategy incorporates a trailing stop mechanism to lock in profits as the trade moves in the desired direction. This can potentially enhance profitability during strong trends. Partial Profit Booking: While not explicitly implemented in the provided code, you could consider booking partial profits when the MACD shows a crossover in the opposite direction. This aspect could help secure gains while still keeping exposure to potential further price movements. Key Differences from Other Strategies: Dual Indicator Confirmation: The combination of Supertrend and MACD for trend confirmation is a unique aspect of this strategy. It adds an extra layer of filtering to enhance the accuracy of entry signals. Dynamic VWAP: Incorporating the VWAP level into the decision-making process adds a dynamic element to the strategy. VWAP is often used by institutional traders, and its inclusion can provide insights into the market sentiment. Adaptive Stop Loss and Trailing: The strategy's use of an adaptive stop-loss range and a trailing stop can help manage risk and protect profits more effectively during changing market conditions. Partial Profit Booking: The suggestion to consider partial profit booking upon MACD crossovers in the opposite direction is a practical approach to secure gains while staying in the trade. Caution and Considerations: Backtesting: Before deploying any strategy in real trading, it's crucial to thoroughly backtest it on historical data to understand its performance under various market conditions. Risk Management: While the strategy has built-in risk management mechanisms, it's essential to carefully manage position sizes and overall portfolio risk. Market Conditions: No strategy works well in all market conditions. It's important to be flexible and adjust the strategy or refrain from trading during particularly volatile or unpredictable periods. Continuous Monitoring: Even though the strategy includes automated components, continuous monitoring of the trades and market conditions is necessary. Adaptability: Markets can change over time. Traders need to be prepared to adapt the strategy as necessary to stay aligned with evolving market dynamics."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Trend Confirmation Strategy\", overlay=true)\n// Supertrend Indicator\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step = 0.01)\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n// MACD Indicator\nfast_length = input(title=\"Fast Length\", defval=12)\nslow_length = input(title=\"Slow Length\", defval=26)\nmacd_src = input(title=\"Source\", defval=close)\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nmacd_sma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\nmacd_sma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\nfast_ma = macd_sma_source == \"SMA\" ? ta.sma(macd_src, fast_length) : ta.ema(macd_src\nslow_ma = macd_sma_source == \"SMA\" ? ta.sma(macd_src, slow_length) : ta.ema(macd_src\nmacd = fast_ma - slow_ma\nsignal = macd_sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\n// VWAP Indicator\nvwap_hideonDWM = input(false, title=\"Hide VWAP on 1D or Above\")\nvwap_src = input(title=\"VWAP Source\", defval=hlc3)\nvwap_value = ta.vwap(vwap_src)\nvwap_value_long = vwap_value\nvwap_value_short = vwap_value\n// Entry Criteria\nconfirm_up_trend = direction > 0 and macd > signal\nconfirm_down_trend = direction < 0 and macd < signal\n// VWAP Confirmation\nprice_above_vwap = close > vwap_value_long\nprice_below_vwap = close < vwap_value_short\n// Stop Loss and Take Profit\nstop_loss_range = input(2, title=\"Stop Loss Range\")\ntrail_offset = input(0.5, title=\"Trailing Stop Offset\")\nstop_loss_long = close - stop_loss_range\nstop_loss_short = close + stop_loss_range\n// Strategy Entry\nif not (vwap_hideonDWM and timeframe.isdwm)\n    if confirm_up_trend and price_above_vwap\n        strategy.entry(\"Buy\", strategy.long)\n    if confirm_down_trend and price_below_vwap\n        strategy.entry(\"Sell\", strategy.short)\n// Strategy Exit\nif macd < signal and macd[1] >= signal[1]\n    strategy.close(\"Buy\", comment=\"MACD Crossover\")\nif macd > signal and macd[1] <= signal[1]\n    strategy.close(\"Sell\", comment=\"MACD Crossover\")\n// Plot Supertrend and VWAP\nplot(supertrend, color=direction > 0 ?  color.green :  color.red, title=\"Supertrend\"\nplot(vwap_value_long, color= color.blue, title=\"VWAP Long\")\nplot(vwap_value_short, color= color.orange, title=\"VWAP Short\")\n// Plot MACD Histogram\nhist = macd - signal\nhist_color = hist >= 0 ?  color.green :  color.red\nplot(hist, style=plot.style_histogram, color=hist_color, title=\"MACD Histogram\")"}]}
{"messages": [{"role": "user", "content": "The strategy aims to create a simple buy-only trading system based on moving average crossovers and the Weekly Commodity Channel Index (CCI) or Weekly Average Directional Index (ADX). It generates buy signals when the fast-moving average crosses above the slow-moving average and when the Weekly CCI and or Weekly ADX meet the specified conditions.  The strategy also allows for dynamic re-entry, which means it can open new long positions if the price goes above the three moving averages after an exit. However, the strategy will exit the long position if the price closes below the third moving average. ENTRY CONDITIONS  The script defines the conditions for generating buy signals. It checks for two conditions for a valid buy signal: \u2022\tIf the fast-moving average crosses above the slow-moving average -THERE IS  Dynamic Re-Entry also \u2022\tIf the user chooses  HE OR SHE CAN FILTER TRADES BY USING  CCI   OR ADX   Dynamic Re-Entry:   the script allows for dynamic re-entry. If there is no active long position and the price is above all three moving averages a new long position is opened. Exit Conditions   The script defines the exit condition for closing a long position. If the price closes below the third moving average, the script closes the long position. IMPORTANT NOTICE ONLY DAILY TIME FRAME THERE WOULD BE WHIPSAW USE YOUR OWN ACCUMEN TO MINIMISE THEM  ITS ONLY BUY STRATEGY EXIT CAN BE STRATEGY BASED OR SET PROFIT AND TARGETS AS PER RISK APETITE /RISK MANAGEMENT DONT TRADE OPTIONS ON THIS SUITABLE FOR STOCKS OF USA AND INDIAN MARKETS ALWAYS REMEMBER TO DO YOUR OWN RESEARCH BEFORE TRADING AND INVESTING"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Buy Only Strategy with Dynamic Re-Entry and Exit\", overlay=true)\n// Input Parameters\nfast_length = input(20, title=\"Fast Moving Average Length\")\nslow_length = input(30, title=\"Slow Moving Average Length\")\nthird_ma_length = input(100, title=\"Third Moving Average Length\")\ncci_period = input(14, title=\"CCI Period for Weekly CCI\")\nuse_cci = input(true, title=\"Use CCI for Entry\")\nuse_adx = input(true, title=\"Use ADX for Entry\")\nadx_length = input(14, title=\"ADX Length\")\nadx_threshold = input(25, title=\"ADX Threshold\")\n// Calculate Moving Averages\nfast_ma = ta.sma(close, fast_length)\nslow_ma = ta.sma(close, slow_length)\nthird_ma = ta.sma(close, third_ma_length)\n// Weekly Commodity Channel Index (CCI) with user-defined period\nweekly_cci = request.security(syminfo.tickerid, \"W\", ta.cci(close,  cci_period))\n// Weekly Average Directional Index (ADX)\ndirmov = hlc3\nplus = ta.change(dirmov) > 0 ? ta.change(dirmov) : 0\nminus = ta.change(dirmov) < 0 ? -ta.change(dirmov) : 0\ntrur = ta.rma(ta.tr, adx_length)\nplusDI = ta.rma(plus, adx_length) / trur * 100\nminusDI = ta.rma(minus, adx_length) / trur * 100\nsum = plusDI + minusDI\nDX = sum == 0 ? 0 : math.abs(plusDI - minusDI) / sum * 100\nADX = ta.rma(DX, adx_length)\n// Entry Conditions (Buy Only and Weekly CCI > 100 and/or Weekly ADX > 25)\ncci_condition = use_cci ? (weekly_cci > 100) : false\nadx_condition = use_adx ? (ADX > adx_threshold) : false\nlong_condition = ta.crossover(fast_ma, slow_ma) and (cci_condition or adx_condition\n// Exit Condition and Dynamic Re-Entry\nexit_condition = close < third_ma\nre_entry_condition = close > fast_ma and close > slow_ma and close > third_ma and weekly_cci\n// Entry and Exit Signals\nstrategy.entry(\"Long\", strategy.long, when=long_condition)\nstrategy.close(\"Long\", when=exit_condition)\n// Dynamic Re-Entry and Exit\nif strategy.position_size == 0 and re_entry_condition\n    strategy.entry(\"Long\", strategy.long)\nif strategy.position_size > 0 and close < third_ma\n    strategy.close(\"Long\")\n// Plot Weekly CCI and ADX for reference\nplot(weekly_cci, title=\"Weekly CCI\", color= color.orange)\nplot(ADX, title=\"Weekly ADX\", color= color.blue)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added some debugging labels and corrected some minor typos."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 BigJasTrades https://linktr.ee/bigjastrades \n// READ THIS BEFORE USE:\n// This code is provided as an example strategy for educational purposes only.  It comes with NO war\n// It should be used as a basis for your own learning and development and to create your own strateg\n// It is NOT provided to enable you to profitably trade. \n// If you use this code or any part of it you agree that you have thoroughly tested it and determine\n// If you use this code or any part of it you agree that you accept all risk and you are responsibil\n//@version=5\nstrategy(title = \"Strategy Template\", shorttitle = \"ST v1.0\", overlay = true, pyramiding\n//INPUTS\n//indicator values\nshortSMAlength              = input.int(defval = 14, title = \"Short SMA Length\", tooltip\nlongSMAlength               = input.int(defval = 28, title = \"Long SMA Length\", tooltip\n//compounding\ncompoundingSelected         = input.bool(defval = true, title = \"Compounding\", tooltip\n//take profit and stop loss\ntakeProfitSelected          = input.bool(defval = true, title = \"Use Take Profit\",\ntakeProfitPercent           = input.float(defval = 1.0, title = \"Take Profit %\", tooltip\nstopLossSelected            = input.bool(defval = true, title = \"Use Stop Loss\", tooltip\nstopLossPercent             = input.float(defval = 1.0, title = \"Stop Loss %\", tooltip\n//trading window\nstartDate                   = input.time(defval = timestamp(\"1 Jan 2023 00:00:00\")\nendDate                     = input.time(defval = timestamp(\"1 Jan 2030 00:00:00\")\n//VARIABLES\nvar float tradingCapital    = na //trading capital is used to calculate position si\nvar float positionSize      = na //position size is used to set the quantity of the\nvar float takeProfitPrice   = na //this is used for take profit targets if selected\nvar float stopLossPrice     = na //this is used for stop loss if selected\ninTradeWindow               = (time >= startDate) and (time < endDate) //calculate the trading/backtesting window\n//COMPOUNDING\nif compoundingSelected // set the tradingCapital available to the strategy based on wither Compounding has been selected or\n    tradingCapital := strategy.initial_capital + strategy.netprofit\nelse\n    tradingCapital := strategy.initial_capital\n//ENTRY CONDITIONS\n//replace these with your own conditions\nlongCondition = ta.crossover(source1 = ta.sma(source = close, length = shortSMAlength\nshortCondition = ta.crossunder(source1 = ta.sma(source = close, length = shortSMAlength\n//EXIT CONDITIONS\n//Exit conditions are based on stop loss, take profit and the opposite entry condition being present\n//ENTRY ORDERS\n//Enter Long\nif longCondition and inTradeWindow\n    //close any prior short positions\n    if strategy.position_size < 0 //if in a short position\n        strategy.close_all(comment = \"Buy to Close\")\n    //set position size\n    positionSize := tradingCapital / close\n    //enter long position\n    strategy.entry(id = \"Buy to Open\", direction =  strategy.long, qty = positionSize\n//Enter Short\nif shortCondition and inTradeWindow\n    //close any prior long positions\n    if strategy.position_size > 0 //if in a long position\n        strategy.close_all(comment = \"Sell to Close\")\n    //set position size\n    positionSize := tradingCapital / close\n    //enter short position\n    strategy.entry(id = \"Sell to Open\", direction =  strategy.short, qty = positionSize\n//IN-ORDER MANAGEMENT\n//placeholder - none used in this template\n//EXIT ORDERS\n//Stop Loss and Take Profit for Long Positions\nif strategy.opentrades > 0 and strategy.position_size > 0 and (takeProfitSelected \n    if takeProfitSelected\n        takeProfitPrice := strategy.position_avg_price * (1 + (takeProfitPercent /\n    else\n        takeProfitPrice := na\n    if stopLossSelected\n        stopLossPrice := strategy.position_avg_price * (1 - (stopLossPercent / 100\n    else\n        stopLossPrice := na\n    strategy.exit(id = \"Exit\", from_entry = \"Buy to Open\", qty_percent = 100, limit\n//Stop Loss and Take Profit for Short Positions\nif strategy.opentrades > 0 and strategy.position_size < 0 and (takeProfitSelected \n    if takeProfitSelected\n        takeProfitPrice := strategy.position_avg_price * (1 - (takeProfitPercent /\n    else\n        takeProfitPrice := na\n    if stopLossSelected\n        stopLossPrice := strategy.position_avg_price * (1 + (stopLossPercent / 100\n    else\n        stopLossPrice := na\n    strategy.exit(id = \"Exit\", from_entry = \"Sell to Open\", qty_percent = 100, limit\n//DEBUGGING LABELS\n//un-comment these lables to use for your debugging.  Replace the text inside the str.tostring() fun\n//label.new(x=bar_index, y=high, text=str.tostring(takeProfitPrice), yloc=yloc.abovebar, color=color\n//label.new(x=bar_index, y=high, text=str.tostring(stopLossPrice), yloc=yloc.belowbar, color=color.n\n//VISUALISATIONS\nplot(series = ta.sma(source = close, length = shortSMAlength), title = \"Short SMA\"\nplot(series = ta.sma(source = close, length = longSMAlength), title = \"Long SMA\", \nbgcolor(color = longCondition ? color.new(color =  color.green, transp = 95) : na\nbgcolor(color = shortCondition ? color.new(color =  color.red, transp = 95) : na,"}]}
{"messages": [{"role": "user", "content": "My exit strategy to reduce risk via tracking price and ATR. Sets new STOP price based on how many ATR is current price above from the entry price. I only check 5 and 20 EMAs for entry strategy. I intentionally used a simple entry strategy to further test the impact of this exit strategy. First sets STOP at 1.5 ATR below the entry price. If there is a 2 ATR increase, pulls STOP to the entry point to eliminate the possibility of loss. If there is a 3 ATR increase, takes a 50% profit and moves STOP to 1 ATR above the entry price. If there is a 4 ATR increase, moves STOP to 2 ATR above the entry price. If there is a 5 ATR increase, moves STOP to 3 ATR above the entry price. . . . This is my first strategy attempt so I am open to any recommendations. I am planning to update this strategy overtime when I get better at pinescript and trading in general"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 ekinbasarkomur\n//@version=5\nstrategy(\"[EKIN] ATR Exit Strategy\", overlay=true, initial_capital = 1000, default_qty_value\n// Simple EMA tracking\nfastEMA = ta.ema(close, 5)\nslowEMA = ta.ema (close, 20)\natr = ta.atr(14)\n// We define entry price for future reference\nvar float entry_price = na\n// We define stop and take profit for future calculations\nvar float stop_price = na\nvar float take_profit_price = na\n// We define atr limtim its here\nvar float atr_down = na\nvar float atr_up = na\nvar float atr_current = na\nvar float atr_ref = na\navg = (low + high) / 2\n// Conditions\nenterCondition = ta.crossover(fastEMA, slowEMA)\nvar bool tookProfit = false\ntimePeriod = time >= timestamp(syminfo.timezone, 2021, 12, 15, 0, 0)\nInTrade = strategy.position_size > 0\n// Go long if conditions are met\nif (enterCondition and timePeriod and not InTrade)\n    // Calculate and update variables\n    entry_price := avg\n    atr_ref := atr\n    atr_div = int((avg - entry_price) / atr_ref)\n    atr_down := entry_price + (atr_ref * (atr_div - 1.5))\n    atr_up := entry_price + (atr_ref * (atr_div + 1))\n    atr_current := entry_price + (atr_ref * atr_div) \n    stop_price := (entry_price - (atr_ref * 1.5))\n    take_profit_price := (entry_price + (atr_ref * 3))\n    strategy.order(\"buy\", strategy.long, qty = 2)\n// Enter here if in position\nif InTrade or tookProfit\n    stopCondition = avg < stop_price\n    takeProfitCondition = avg > take_profit_price\n    if avg < atr_down\n        stopCondition := true\n    // Move stop price and exit price if price for each atr price increase\n    if avg > atr_up\n        if tookProfit\n            atr_ref := atr\n        atr_div = int((avg - entry_price) / atr_ref)\n        atr_down := entry_price + (atr_ref * (atr_div - 1))\n        atr_up := entry_price + (atr_ref * (atr_div + 1))\n        atr_current := entry_price + (atr_ref * atr_div) \n    // Take half of the investment if current price is 3 atr higher than entry price\n    if (takeProfitCondition and timePeriod and InTrade and not tookProfit)\n        strategy.order(\"take_half_profit\", strategy.short, qty = 1)\n        tookProfit := true\n    // Exit position if conditions are met and reset the variables\n    if (stopCondition and timePeriod and InTrade)\n        if tookProfit\n            strategy.order(\"exit\", strategy.short, qty = 1)\n        else\n            strategy.order(\"stop_loss\", strategy.short, qty = 2)\n        tookProfit := false\n// Plot EMA's\nplot(fastEMA, color =  color.blue)\nplot(slowEMA, color =  color.yellow)\n// Plot ATR Limit/Stop positions\nprofit_plot = plot(series = InTrade?atr_up:na, title = \"profit\", color =  color.green\nclose_plot = plot(series = InTrade?atr_current:na, title = \"close\", color =  color.white\nstop_plot = plot(series = InTrade?atr_down:na, title = \"stop_loss\", color =  color.red\nfill(profit_plot, close_plot, color =  color.new(color.green, 80))\nfill(close_plot, stop_plot, color = color.new(color.red,80))"}]}
{"messages": [{"role": "user", "content": "Grid Trading Strategy Overview Introduction: Grid trading is a popular and time-tested trading methodology that seeks to capitalize on market volatility. By placing buy and sell orders at predetermined price levels, traders can potentially profit from price fluctuations within a specific range. This version is a spot grid trading strategy, with no leverage. How it works Grid Creation: The strategy divides the price range between a specified lower and upper price into several levels or \"grids\". Order Placement: Buy orders are placed from the top of the grid (actually from the second highest price). If any buy orders filled, a sell order will be placed at the higher level of that buy order. Profit Generation: As the price moves and hits these levels, the strategy aims to buy low and sell high, profiting from the price differences between the grids. Key Features: Adaptive to Volatility: This strategy performs best in volatile markets where prices fluctuate within a defined range. Automated Trading: Once set up, the strategy automates the buying and selling process, reducing the need for constant market monitoring. Risk Management: By diversifying orders across multiple price levels, the strategy can potentially reduce the impact of adverse price movements. Parameters: Lower Price: The bottom price of your grid. No buy orders will be placed below this price. Upper Price: The top price of your grid. No sell orders will be placed above this price. Number of Grids: Determines how many buy and sell levels are created within the specified price range. Start Date: Determines the start time of the strategy, start time affects the price of the initial position. End Date: Determines the end time of the strategy. The strategy will close all position at the end date. Default Parameters and Backtesting Results: I'm using BTC/USDT as the backtesting target. And the default parameters are like this: Lower Price: 10,000 Upper Price: 100,000 Number of Grids: 50 Start Date: 19 Nov 2020 End Date: 22 Dec 2022 commission_value: 0.1% - binance's spot trading fee The start price and end price are both around 17,000. With little price change in this 2 year's range, the strategy achieve's ~45% gain. Note: Like all trading methods, grid-based trading carries risks and doesn't assure profits. It's vital to test the approach, grasp its workings, and employ risk management techniques. Trade with caution."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Grid Trading Strategy - Spot Version\", overlay=true, process_orders_on_close\n// this strategy basically reprodue the logic of binnace spot grid trading\n// Parameters\nlower_price = input.float(10000, title=\"Lower Price\")\nupper_price = input.float(100000, title=\"Upper Price\")\nnum_grids = input(50, title=\"Number of Grids\")\nstart_date = input.time(timestamp(\"19 Nov 2020 00:00 +0800\"), \"Start Date\", confirm\nend_date = input.time(timestamp(\"22 Dec 2022 00:00 +0800\"), \"End Date\", confirm=true\ngrid_size = (upper_price - lower_price) / num_grids\nintime = time >= start_date and time < end_date and barstate.isconfirmed\nbgcolor(intime ?  color.new(color.green, 70) : na)\n// save 0.5% as trading fee\nuseable_capital = strategy.initial_capital * 0.95\nvar inited = false\nvar finished = false\n// if current price is higher than the upper price, use the default avg price as all buy orders\navg_price = (upper_price + lower_price) / 2\n// we have to save our capital for the total potential qty that this grid can use, qty_each_level * \nvar qty_each_level = useable_capital / (avg_price * num_grids)\n// Calculate all the prices at different level of the grid, from lower price to upper price\nvar float[] price_levels = array.new<float>(num_grids + 1)\n// Binance Spot Grid Trading uses normal grids. Orders are placed from the top grid to the bottom gr\n// current_level_index indicates where we are, +1 is a sell order and -1 is a buy order. At first, w\nvar current_level_index = num_grids\n// var trade_levels = -1\nif not inited and intime\n    inited := true\n    // set the highest grid price, this is not inside the loop because the highest price will not be a b\n    price_levels.set(num_grids, upper_price)\n    // iterate the grid form second highest price to the bottom\n    for i = num_grids - 1 to 0\n        price = lower_price + i * grid_size\n        price_levels.set(i, price)\n        // if current price is lower than the grid price, buy order fills\n        if close <= price\n            current_level_index := i\n    // how many buy orders filled at the opening time\n    filled_buy_orders = num_grids - current_level_index\n    if filled_buy_orders > 0\n        // calculate the total prices of all possible buy orders\n        total_prices = filled_buy_orders * close\n        for j = 0 to current_level_index\n            total_prices := total_prices + array.get(price_levels, j)\n        // the qty is fixed for each level\n        avg_price := total_prices / num_grids\n        qty_each_level := useable_capital / total_prices\n        // label.new(bar_index, avg_price, \"avg price: \" + str.tostring(avg_price))\n        // label.new(bar_index, close, \"close price: \" + str.tostring(close))\n        // label.new(bar_index, filled_buy_orders, \"filled_buy_orders: \" + str.tostring(filled_buy_orders))\n        strategy.order(\"Buy\", strategy.long, qty = filled_buy_orders * qty_each_level\n// if we are not at the bottom, next lower price will be next_buy_price\nnext_buy_price = current_level_index > 0 ? array.get(price_levels, current_level_index\nif intime and not na(next_buy_price) and close < next_buy_price\n    // if price drop too much at this bar, it's possible to trade more than 1 level at once\n    filled_buy_orders = math.floor((next_buy_price - close) / grid_size) + 1\n    // prevent from buying out of the grid\n    filled_buy_orders := math.min(filled_buy_orders, current_level_index)\n    strategy.order(\"Buy\", strategy.long, qty = filled_buy_orders * qty_each_level)\n    current_level_index := current_level_index - filled_buy_orders\n// if we are not at the top, next higher price will be next_sell_price\nnext_sell_price = current_level_index < num_grids ? array.get(price_levels, current_level_index\nif intime and not na(next_sell_price) and close > next_sell_price\n    // if price raise too much at this bar, it's possible to trade more than 1 level at once\n    filled_sell_orders = math.floor((close - next_sell_price) / grid_size) + 1\n    // prevent from selling out of the grid\n    filled_sell_orders := math.min(filled_sell_orders, num_grids - current_level_index\n    strategy.order(\"Sell\", strategy.short, qty = filled_sell_orders * qty_each_level\n    current_level_index := current_level_index + filled_sell_orders\n//close at the finish time\nif not finished and time >= end_date\n    finished := true\n    strategy.close_all(\"close\")\n    // strategy.order(\"Sell\", strategy.short, qty = (num_grids - current_level_index) * qty_each_level)"}]}
{"messages": [{"role": "user", "content": "This strategy is based and shown by trader and investor Alexandre Wolwacz \"Stormer\". Overview The strategy uses 12 moving averages (default EMA) to identify trends and generate trading signals opening positions. Allowing to select the type of moving average and length to be used. The conditions includes relationship between moving averages, the position of the current price relative to the moving averages, and the occurrence of certain price patterns. Calculation The mean moving averages is calculated by adding all the 12 moving averages and dividing by 12, the value is used to help to identify trend and possible condition to open position. The 12 moving averages is spliced by 3 ranges, initial range (moving average lines 1 to 4), middle range (moving average lines 5 to 8) and end range (moving average lines 9 to 12). These ranges helps to identify potential trend and market turn over. The moving average touch price is a relationship between the low price (uptrend) or high price (downtrend) with the moving average lines, it identifies where the price (low/high) has reached the the moving average line. Fetching the value to help for opening position, set stop loss and take profit. Since the stop loss is based and set from the previous moving average touch price value, when position is about to be open and setting the stop loss value, there is a verification to check both current and previous moving average touch price to recalculate the stop loss value. The turnover trend checks for a possible market turnover event, setting up a new profit target, this setting when enabled is to be helpful when a turnover occurs against the position to exit position with some profit based on highest high price if long or lowest low price if short. The turnover signal is similar to turnover trend. The difference is that when this setting is enabled and it triggers, it simply exit the current position and opens up a reverse position, long goes short and short goes long. And there is an complement optional that checks current price exit profitable.  Entry Position Long Position: Price is higher than the mean moving averages. Meaning possible uptrend. The lines of the middle range from the moving averages are in increasing order. Meaning possible uptrend. The current high pierced up previous high. Fetch the previous value of the moving average touch price. Meaning the low price has touched one of the moving average lines, which that value is conditioning to open position.  Short Position: Price is lower than the mean moving averages. Meaning possible downtrend. The lines of the middle range from the moving averages are in decreasing order. Meaning possible downtrend. The current low pierced down previous low. Fetch the previous value of the moving average touch price. Meaning the high price has touched one of the moving average lines, which that value is conditioning to open position.  Risk Management Stop Loss: The stop loss is based from the previous moving average touch price value, high price for short and low price for long or occurs an verification to check for both current and previous moving average touch price value and a recalculation is done to set the stop loss.  Take Profit: According to the author, the profit target should be at least 1:1.6 the risk, so to have the strategy mathematically positive. The profit target is configured input, can be increased or decreased. It calculates the take profit based on the price of the stop loss with the profit target input.  Turnover Trend Long Position: The moving averages initial range lines signals a possible market turnover. Meaning long might be going short. Fetches the highest high hit since the opening of the position, setting that value to the new profit target.  Short Position: The moving averages initial range lines signals a possible market turnover. Meaning short might be going long. Fetches the lowest low hit since the opening of the position, setting that value to the new profit target."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 AugustoErni\n//@version=5\nstrategy('Moving Average Rainbow (Stormer)', overlay=true, process_orders_on_close\nmaType                        = input.string('EMA', title='Moving Average Type/Tipo de M\u00e9dia M\u00f3vel'\nmaLengthFirst                 = input.int(3, title='MA #1', minval=1, step=1, tooltip\nmaLengthSecond                = input.int(5, title='MA #2', minval=1, step=1, tooltip\nmaLengthThird                 = input.int(8, title='MA #3', minval=1, step=1, tooltip\nmaLengthFourth                = input.int(13, title='MA #4', minval=1, step=1, tooltip\nmaLengthFifth                 = input.int(20, title='MA #5', minval=1, step=1, tooltip\nmaLengthSixth                 = input.int(25, title='MA #6', minval=1, step=1, tooltip\nmaLengthSeventh               = input.int(30, title='MA #7', minval=1, step=1, tooltip\nmaLengthEighth                = input.int(35, title='MA #8', minval=1, step=1, tooltip\nmaLengthNineth                = input.int(40, title='MA #9', minval=1, step=1, tooltip\nmaLengthTenth                 = input.int(45, title='MA #10', minval=1, step=1, tooltip\nmaLengthEleventh              = input.int(50, title='MA #11', minval=1, step=1, tooltip\nmaLengthTwelveth              = input.int(55, title='MA #12', minval=1, step=1, tooltip\ntargetFactor                  = input.float(1.6, title='Target Take Profit/Objetivo de Lucro Alvo'\nverifyTurnoverTrend           = input.bool(true, title='Verify Turnover Trend/Verificar Tend\u00eancia de \nverifyTurnoverSignal          = input.bool(false, title='Verify Turnover Signal/Verificar Sinal de \nverifyTurnoverSignalPriceExit = input.bool(false, title='Verify Price Exit Turnover Signal/Verificar Sa\u00edda \nmas(maType, maLengthFirst, maLengthSecond, maLengthThird, maLengthFourth, maLengthFifth\n    if (maType == 'SMA')\n        [ta.sma(close, maLengthFirst), ta.sma(close, maLengthSecond), ta.sma(close\n    else if (maType == 'RMA')\n        [ta.rma(close, maLengthFirst), ta.rma(close, maLengthSecond), ta.rma(close\n    else if (maType == 'WMA')\n        [ta.wma(close, maLengthFirst), ta.wma(close, maLengthSecond), ta.wma(close\n    else if (maType == 'HMA')\n        [ta.hma(close, maLengthFirst), ta.hma(close, maLengthSecond), ta.hma(close\n    else if (maType == 'VWMA')\n        [ta.vwma(close, maLengthFirst), ta.vwma(close, maLengthSecond), ta.vwma(close\n    else\n        [ta.ema(close, maLengthFirst), ta.ema(close, maLengthSecond), ta.ema(close\n[ma1, ma2, ma3, ma4, ma5, ma6, ma7, ma8, ma9, ma10, ma11, ma12] = mas(maType, maLengthFirst\nmaTouchPriceTrend(ma1, ma2, ma3, ma4, ma5, ma6, ma7, ma8, ma9, ma10, ma11, ma12, trend\n    var float touchPrice = na\n    if (trend == 'UPTREND')\n        if (low <= ma1 and low >= ma2)\n            touchPrice := ma2\n        else if (low <= ma2 and low >= ma3)\n            touchPrice := ma3\n        else if (low <= ma3 and low >= ma4)\n            touchPrice := ma4\n        else if (low <= ma4 and low >= ma5)\n            touchPrice := ma5\n        else if (low <= ma5 and low >= ma6)\n            touchPrice := ma6\n        else if (low <= ma6 and low >= ma7)\n            touchPrice := ma7\n        else if (low <= ma7 and low >= ma8)\n            touchPrice := ma8\n        else if (low <= ma8 and low >= ma9)\n            touchPrice := ma9\n        else if (low <= ma9 and low >= ma10)\n            touchPrice := ma10\n        else if (low <= ma10 and low >= ma11)\n            touchPrice := ma11\n        else if (low <= ma11 and low >= ma12)\n            touchPrice := ma12\n        else\n            touchPrice := na\n    else if (trend == 'DOWNTREND')\n        if (high >= ma1 and high <= ma2)\n            touchPrice := ma2\n        else if (high >= ma2 and high <= ma3)\n            touchPrice := ma3\n        else if (high >= ma3 and high <= ma4)\n            touchPrice := ma4\n        else if (high >= ma4 and high <= ma5)\n            touchPrice := ma5\n        else if (high >= ma5 and high <= ma6)\n            touchPrice := ma6\n        else if (high >= ma6 and high <= ma7)\n            touchPrice := ma7\n        else if (high >= ma7 and high <= ma8)\n            touchPrice := ma8\n        else if (high >= ma8 and high <= ma9)\n            touchPrice := ma9\n        else if (high >= ma9 and high <= ma10)\n            touchPrice := ma10\n        else if (high >= ma10 and high <= ma11)\n            touchPrice := ma11\n        else if (high >= ma11 and high <= ma12)\n            touchPrice := ma12\n        else\n            touchPrice := na\nmaMean = ((ma1 + ma2 + ma3 + ma4 + ma5 + ma6 + ma7 + ma8 + ma9 + ma10 + ma11 + ma12\nisMa1To4Above            = ma1 > ma2 and ma2 > ma3 and ma3 > ma4 ? 1 : 0\nisMa1To4Below            = ma1 < ma2 and ma2 < ma3 and ma3 < ma4 ? 1 : 0\nisMa5To8Above            = ma5 > ma6 and ma6 > ma7 and ma7 > ma8 ? 1 : 0\nisMa5To8Below            = ma5 < ma6 and ma6 < ma7 and ma7 < ma8 ? 1 : 0\nisCloseGreaterMaMean     = close > maMean ? 1 : 0\nisCloseLesserMaMean      = close < maMean ? 1 : 0\nisCurHighGreaterPrevHigh = high > high[1] ? 1 : 0\nisCurLowLesserPrevLow    = low < low[1] ? 1 : 0\nisMaUptrend              = isCloseGreaterMaMean and isMa5To8Above ? 1 : 0\nisMaDowntrend            = isCloseLesserMaMean and isMa5To8Below ? 1 : 0\nisUptrend                = isMaUptrend ? 'UPTREND' : na\nisDowntrend              = isMaDowntrend ? 'DOWNTREND' : na\ncurTouchPriceUptrend    = maTouchPriceTrend(ma1, ma2, ma3, ma4, ma5, ma6, ma7, ma8\nprevTouchPriceUptrend   = curTouchPriceUptrend[1]\ncurTouchPriceDowntrend  = maTouchPriceTrend(ma1, ma2, ma3, ma4, ma5, ma6, ma7, ma8\nprevTouchPriceDowntrend = curTouchPriceDowntrend[1]\nisPrevTouchPriceUptrendTouched   = prevTouchPriceUptrend > 0.0 or not na(prevTouchPriceUptrend\nisPrevTouchPriceDowntrendTouched = prevTouchPriceDowntrend > 0.0 or not na(prevTouchPriceDowntrend\nisPrevTouchedPriceUptrend        = isPrevTouchPriceUptrendTouched and isMaUptrend \nisPrevTouchedPriceDowntrend      = isPrevTouchPriceDowntrendTouched and isMaDowntrend\nisPositionFlat  = strategy.position_size == 0 ? 1 : 0\nvar float positionEntryPrice         = na\nvar bool positionIsEntryLong         = false\nvar bool positionIsEntryShort        = false\nvar float longPositionHighestHigh    = na\nvar float shortPositionLowestLow     = na\nvar float stopLossLong               = na\nvar float stopLossShort              = na\nvar float targetLong                 = na\nvar float targetShort                = na\nvar bool isTurnoverTrendLongTrigger  = na\nvar bool isTurnoverTrendShortTrigger = na\nisPositionLongClose  = na(positionEntryPrice) and not positionIsEntryLong ? 1 : 0\nisPositionShortClose = na(positionEntryPrice) and not positionIsEntryShort ? 1 : 0\nisLongCondition      = isMaUptrend and isCurHighGreaterPrevHigh and isPrevTouchedPriceUptrend\nisShortCondition     = isMaDowntrend and isCurLowLesserPrevLow and isPrevTouchedPriceDowntrend\nlongTurnoverExit     = verifyTurnoverSignal and verifyTurnoverSignalPriceExit ? (verifyTurnoverSignal\nshortTurnoverExit    = verifyTurnoverSignal and verifyTurnoverSignalPriceExit ? (verifyTurnoverSignal\nif (isPositionFlat)\n    positionEntryPrice          := na\n    positionIsEntryLong         := false\n    positionIsEntryShort        := false\n    stopLossLong                := na\n    targetLong                  := na\n    stopLossShort               := na\n    targetShort                 := na\n    isTurnoverTrendLongTrigger  := na\n    isTurnoverTrendShortTrigger := na\nif ((isLongCondition and isPositionLongClose) or longTurnoverExit)\n    positionEntryPrice          := close\n    positionIsEntryLong         := true\n    positionIsEntryShort        := false\n    longPositionHighestHigh     := na\n    shortPositionLowestLow      := na\n    isTurnoverTrendLongTrigger  := na\n    isTurnoverTrendShortTrigger := na\n    stopLossLong                := prevTouchPriceUptrend\n    if (isCurLowLesserPrevLow)\n        curLowToucedPrice = na(curTouchPriceUptrend) ? low : curTouchPriceUptrend\n        stopLossLong      := na(curTouchPriceUptrend) ? ((stopLossLong + curLowToucedPrice\n    targetLong := (positionEntryPrice + (math.abs(positionEntryPrice - stopLossLong\n    if (targetLong > 0 and stopLossLong > 0)\n        alertMessage = '{ \"side/lado\": \"buy\", \"entry/entrada\": ' + str.tostring(positionEntryPrice\n        alert(alertMessage)\n        strategy.entry('Long', strategy.long)\n        strategy.exit('Exit Long', 'Long', stop=stopLossLong, limit=targetLong)\nif ((isShortCondition and isPositionShortClose) or shortTurnoverExit)\n    positionEntryPrice          := close\n    positionIsEntryLong         := false\n    positionIsEntryShort        := true\n    longPositionHighestHigh     := na\n    shortPositionLowestLow      := na\n    isTurnoverTrendLongTrigger  := na\n    isTurnoverTrendShortTrigger := na\n    stopLossShort               := prevTouchPriceDowntrend\n    if (isCurHighGreaterPrevHigh)\n        curHighToucedPrice = na(curTouchPriceDowntrend) ? high : curTouchPriceDowntrend\n        stopLossShort      := na(curTouchPriceDowntrend) ? ((stopLossShort + curHighToucedPrice\n    targetShort := (positionEntryPrice - (math.abs(positionEntryPrice - stopLossShort\n    if (targetShort > 0 and stopLossShort > 0)\n        alertMessage = '{ \"side/lado\": \"sell\", \"entry/entrada\": ' + str.tostring(positionEntryPrice\n        alert(alertMessage)\n        strategy.entry('Short', strategy.short)\n        strategy.exit('Exit Short', 'Short', stop=stopLossShort, limit=targetShort\nif (verifyTurnoverTrend and positionIsEntryLong)\n    curHighestHigh = high\n    if (curHighestHigh > longPositionHighestHigh or na(longPositionHighestHigh))\n        longPositionHighestHigh := curHighestHigh\n    if (isMa1To4Below and isCloseLesserMaMean and longPositionHighestHigh > positionEntryPrice\n        isTurnoverTrendLongTrigger := true\n        alertMessage = '{ \"side/lado\": \"buy\", \"stop\": ' + str.tostring(stopLossLong\n        alert(alertMessage)\n        strategy.exit('Exit Long', 'Long', stop=stopLossLong, limit=longPositionHighestHigh\nif (verifyTurnoverTrend and positionIsEntryShort)\n    curLowestLow = low\n    if (curLowestLow < shortPositionLowestLow or na(shortPositionLowestLow))\n        shortPositionLowestLow := curLowestLow\n    if (isMa1To4Above and isCloseGreaterMaMean and shortPositionLowestLow < positionEntryPrice\n        isTurnoverTrendShortTrigger := true\n        alertMessage = '{ \"side/lado\": \"sell\", \"stop\": ' + str.tostring(stopLossShort\n        alert(alertMessage)\n        strategy.exit('Exit Short', 'Short', stop=stopLossShort, limit=shortPositionLowestLow\nplot(ma1, title='1st Moving Average', color= color.rgb(240, 240, 240))\nplot(ma2, title='2nd Moving Average', color= color.rgb(220, 220, 220))\nplot(ma3, title='3rd Moving Average', color= color.rgb(200, 200, 200))\nplot(ma4, title='4th Moving Average', color= color.rgb(180, 180, 180))\nplot(ma5, title='5th Moving Average', color= color.rgb(160, 160, 160))\nplot(ma6, title='6th Moving Average', color= color.rgb(140, 140, 140))\nplot(ma7, title='7th Moving Average', color= color.rgb(120, 120, 120))\nplot(ma8, title='8th Moving Average', color= color.rgb(100, 120, 120))\nplot(ma9, title='9th Moving Average', color= color.rgb(80, 120, 120))\nplot(ma10, title='10th Moving Average', color= color.rgb(60, 120, 120))\nplot(ma11, title='11th Moving Average', color= color.rgb(40, 120, 120))\nplot(ma12, title='12th Moving Average', color= color.rgb(20, 120, 120))\ntablePosition    = position.bottom_right\ntableColumns     = 2\ntableRows        = 7\ntableFrameWidth  = 1\ntableBorderColor =  color.gray\ntableBorderWidth = 1\ntableInfoTrade   = table.new(position=tablePosition, columns=tableColumns, rows=tableRows\ntable.cell(table_id=tableInfoTrade, column=0, row=0)\ntable.cell(table_id=tableInfoTrade, column=1, row=0)\ntable.cell(table_id=tableInfoTrade, column=0, row=1, text='Entry Side/Lado da Entrada'\ntable.cell(table_id=tableInfoTrade, column=0, row=2, text=positionIsEntryLong ? 'LONG'\ntable.cell(table_id=tableInfoTrade, column=1, row=1, text='Entry Price/Pre\u00e7o da Entrada'\ntable.cell(table_id=tableInfoTrade, column=1, row=2, text=not na(positionEntryPrice\ntable.cell(table_id=tableInfoTrade, column=0, row=3, text='Take Profit Price/Pre\u00e7o Alvo Lucro'\ntable.cell(table_id=tableInfoTrade, column=0, row=4, text=positionIsEntryLong ? str.tostring\ntable.cell(table_id=tableInfoTrade, column=1, row=3, text='Stop Loss Price/Pre\u00e7o Stop Loss'\ntable.cell(table_id=tableInfoTrade, column=1, row=4, text=positionIsEntryLong ? str.tostring\ntable.cell(table_id=tableInfoTrade, column=0, row=5, text='New Target/Novo Alvo', \ntable.cell(table_id=tableInfoTrade, column=0, row=6, text=verifyTurnoverTrend and \ntable.cell(table_id=tableInfoTrade, column=1, row=5, text='Possible Market Turnover/Poss\u00edvel Virada do \ntable.cell(table_id=tableInfoTrade, column=1, row=6, text=verifyTurnoverTrend and"}]}
{"messages": [{"role": "user", "content": "//@version=4 strategy(title = \"Supply System Strategy\", shorttitle = \"SSS\", overlay = true) // Strategy Inputs var startTime = input(defval = 930, title = \"Start Time\") var endTime = input(defval = 1700, title = \"End Time\") var tradeLong = input(defval = true, title = \"Trade Long\") var tradeShort = input(defval = true, title = \"Trade Short\") var stopLossTicks = input(defval = 20, title = \"Stop Loss In Ticks\") var profitTargetTicks = input(defval = 20, title = \"Profit Target In Ticks\") // Functions to detect supply and demand zones isSupplyZone(low, high) =>     not na(low) and not na(high) and high > high and low > low isDemandZone(low, high) =>     not na(low) and not na(high) and high < high and low < low // Calculate supply and demand zones supplyZone = isSupplyZone(low, high) demandZone = isDemandZone(low, high) // Entry conditions longCondition = tradeLong and supplyZone shortCondition = tradeShort and demandZone // Strategy orders strategy.entry(\"Long\", strategy.long, when = longCondition) strategy.entry(\"Short\", strategy.short, when = shortCondition) strategy.exit(\"Exit\", from_entry = \"Long\", loss = stopLossTicks, profit = profitTargetTicks) strategy.exit(\"Exit\", from_entry = \"Short\", loss = stopLossTicks, profit = profitTargetTicks)"}, {"role": "assistant", "content": "//@version=4\nstrategy(title = \"Supply System Strategy\", shorttitle = \"SSS\", overlay = true)\n// Strategy Inputs\nvar startTime = input(defval = 930, title = \"Start Time\")\nvar endTime = input(defval = 1700, title = \"End Time\")\nvar tradeLong = input(defval = true, title = \"Trade Long\")\nvar tradeShort = input(defval = true, title = \"Trade Short\")\nvar stopLossTicks = input(defval = 20, title = \"Stop Loss In Ticks\")\nvar profitTargetTicks = input(defval = 20, title = \"Profit Target In Ticks\")\n// Functions to detect supply and demand zones\nisSupplyZone(low, high) =>\n    not na(low) and not na(high) and high[1] > high and low[1] > low\nisDemandZone(low, high) =>\n    not na(low) and not na(high) and high[1] < high and low[1] < low\n// Calculate supply and demand zones\nsupplyZone = isSupplyZone(low[1], high[1])\ndemandZone = isDemandZone(low[1], high[1])\n// Entry conditions\nlongCondition = tradeLong and supplyZone\nshortCondition = tradeShort and demandZone\n// Strategy orders\nstrategy.entry(\"Long\", strategy.long, when = longCondition)\nstrategy.entry(\"Short\", strategy.short, when = shortCondition)\nstrategy.exit(\"Exit\", from_entry = \"Long\", loss = stopLossTicks, profit = profitTargetTicks\nstrategy.exit(\"Exit\", from_entry = \"Short\", loss = stopLossTicks, profit = profitTargetTicks"}]}
{"messages": [{"role": "user", "content": "This script includes the condition you specified, ensuring that no buy or sell signals are generated unless the current close price is above the last two closes (for longs) or below the last two closes (for shorts). It uses a simple moving average (SMA) of the close price for the last two candles as a reference. User replace EMA 10 with 9 ChatGPT To replace the EMA length of 10 with 9 in your script, you can make the following modification: pinescript Copy code //@version=4 strategy(\"Improved EMA Crossover Strategy with Support/Resistance and EMA Exit\", shorttitle=\"EMA CC\", overlay=true) // Input parameters fast_length = input(9, title=\"Fast EMA Length\") slow_length = input(9, title=\"Slow EMA Length\")  // Change the EMA length to 9 trail_length = input(5, title=\"Trailing Stop Length\") stop_loss_percent = input(2.0, title=\"Stop Loss (%)\", minval=0.1, maxval=5.0) take_profit_percent = input(4.0, title=\"Take Profit (%)\", minval=1.0, maxval=10.0) // Calculate EMAs ema_fast = ema(close, fast_length) ema_slow = ema(close, slow_length)  // Use the same length (9) for the slow EMA // Calculate SMA of the close price for the last two candles last_two_close_sma = sma(close, 2) // Buy and sell conditions buy_condition = crossover(ema_fast, ema_slow) and close > open and close > last_two_close_sma sell_condition = crossunder(ema_fast, ema_slow) and close < open and close < last_two_close_sma // Calculate trailing stop levels var float trail_stop_level = na if (high > trail_stop_level)     trail_stop_level := high - (high * stop_loss_percent / 100) else     trail_stop_level := max(trail_stop_level, high - (high * stop_loss_percent / 100)) // Calculate take profit level take_profit_level = close + (close * take_profit_percent / 100) // Calculate exit conditions exit_buy_condition = close < ema_fast or low < last_two_close_sma exit_sell_condition = close > ema_fast or high > last_two_close_sma // Plot buy and sell signals plotshape(buy_condition, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small) plotshape(sell_condition, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small) // Entry and exit conditions strategy.entry(\"Buy\", strategy.long, when = buy_condition) strategy.entry(\"Sell\", strategy.short, when = sell_condition) // Exit conditions: Close below 5 EMA or below last two close SMA for buy and close above 5 EMA or above last two close SMA for sell strategy.exit(\"Exit Buy\", from_entry = \"Buy\", when = exit_buy_condition) strategy.exit(\"Exit Sell\", from_entry = \"Sell\", when = exit_sell_condition) // Plot EMAs plot(ema_fast, color=color.blue, title=\"Fast EMA\") plot(ema_slow, color=color.orange, title=\"Slow EMA\") I've changed the EMA length from 10 to 9 for both the fast and slow EMAs as per your request. User EMA 5 to 3 ChatGPT To replace the EMA length of 5 with 3 in your script, you can make the following modification: pinescript Copy code //@version=4 strategy(\"Improved EMA Crossover Strategy with Support/Resistance and EMA Exit\", shorttitle=\"EMA CC\", overlay=true) // Input parameters fast_length = input(3, title=\"Fast EMA Length\")  // Change the fast EMA length to 3 slow_length = input(9, title=\"Slow EMA Length\")  // Change the slow EMA length to 9 trail_length = input(5, title=\"Trailing Stop Length\") stop_loss_percent = input(2.0, title=\"Stop Loss (%)\", minval=0.1, maxval=5.0) take_profit_percent = input(4.0, title=\"Take Profit (%)\", minval=1.0, maxval=10.0) // Calculate EMAs ema_fast = ema(close, fast_length) ema_slow = ema(close, slow_length) // Calculate SMA of the close price for the last two candles last_two_close_sma = sma(close, 2) // Buy and sell conditions buy_condition = crossover(ema_fast, ema_slow) and close > open and close > last_two_close_sma sell_condition = crossunder(ema_fast, ema_slow) and close < open and close < last_two_close_sma // Calculate trailing stop levels var float trail_stop_level = na if (high > trail_stop_level)     trail_stop_level := high - (high * stop_loss_percent / 100) else     trail_stop_level := max(trail_stop_level, high - (high * stop_loss_percent / 100)) // Calculate take profit level take_profit_level = close + (close * take_profit_percent / 100) // Calculate exit conditions exit_buy_condition = close < ema_fast or low < last_two_close_sma exit_sell_condition = close > ema_fast or high > last_two_close_sma // Plot buy and sell signals plotshape(buy_condition, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small) plotshape(sell_condition, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small) // Entry and exit conditions strategy.entry(\"Buy\", strategy.long, when = buy_condition) strategy.entry(\"Sell\", strategy.short, when = sell_condition) // Exit conditions: Close below 3 EMA or below last two close SMA for buy and close above 3 EMA or above last two close SMA for sell strategy.exit(\"Exit Buy\", from_entry = \"Buy\", when = exit_buy_condition) strategy.exit(\"Exit Sell\", from_entry = \"Sell\", when = exit_sell_condition) // Plot EMAs plot(ema_fast, color=color.blue, title=\"Fast EMA\") plot(ema_slow, color=color.orange, title=\"Slow EMA\") I've changed the fast EMA length from 5 to 3 as per your request. The slow EMA length remains at 9. User Also Auto plot support and resistance area in the chart and Trend lines ChatGPT To automatically plot support and resistance areas and trendlines on the chart, you can use Pine Script to detect significant price levels and draw trendlines based on historical data. Here's an updated version of your script that includes support and resistance area plotting and trendline drawing: pinescript Copy code //@version=4 strategy(\"Improved EMA Crossover Strategy with Support/Resistance and EMA Exit\", shorttitle=\"EMA CC\", overlay=true) // Input parameters fast_length = input(3, title=\"Fast EMA Length\") slow_length = input(9, title=\"Slow EMA Length\") trail_length = input(5, title=\"Trailing Stop Length\") stop_loss_percent = input(2.0, title=\"Stop Loss (%)\", minval=0.1, maxval=5.0) take_profit_percent = input(4.0, title=\"Take Profit (%)\", minval=1.0, maxval=10.0) // Calculate EMAs ema_fast = ema(close, fast_length) ema_slow = ema(close, slow_length) // Calculate SMA of the close price for the last two candles last_two_close_sma = sma(close, 2) // Buy and sell conditions buy_condition = crossover(ema_fast, ema_slow) and close > open and close > last_two_close_sma sell_condition = crossunder(ema_fast, ema_slow) and close < open and close < last_two_close_sma // Calculate trailing stop levels var float trail_stop_level = na if (high > trail_stop_level)     trail_stop_level := high - (high * stop_loss_percent / 100) else     trail_stop_level := max(trail_stop_level, high - (high * stop_loss_percent / 100)) // Calculate take profit level take_profit_level = close + (close * take_profit_percent / 100) // Calculate exit conditions exit_buy_condition = close < ema_fast or low < last_two_close_sma exit_sell_condition = close > ema_fast or high > last_two_close_sma // Plot buy and sell signals plotshape(buy_condition, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small) plotshape(sell_condition, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small) // Entry and exit conditions strategy.entry(\"Buy\", strategy.long, when = buy_condition) strategy.entry(\"Sell\", strategy.short, when = sell_condition) // Exit conditions: Close below 3 EMA or below last two close SMA for buy and close above 3 EMA or above last two close SMA for sell strategy.exit(\"Exit Buy\", from_entry = \"Buy\", when = exit_buy_condition) strategy.exit(\"Exit Sell\", from_entry = \"Sell\", when = exit_sell_condition) // Plot EMAs plot(ema_fast, color=color.blue, title=\"Fast EMA\") plot(ema_slow, color=color.orange, title=\"Slow EMA\") // Auto plot support and resistance areas supportLevel = security(syminfo.tickerid, \"D\", lowest(low, 50)) resistanceLevel = security(syminfo.tickerid, \"D\", highest(high, 50)) plot(supportLevel, title=\"Support\", color=color.green, linewidth=1, style=plot.style_area, transp=80) plot(resistanceLevel, title=\"Resistance\", color=color.red, linewidth=1, style=plot.style_area, transp=80) // Auto plot trendlines var line supportLine = na var line resistanceLine = na if (bar_index % 10 == 0)     supportLine := line.new(x1=bar_index, y1=supportLevel, x2=bar_index - 50, y2=supportLevel, color=color.green, width=1)     resistanceLine := line.new(x1=bar_index, y1=resistanceLevel, x2=bar_index - 50, y2=resistanceLevel, color=color.red, width=1) line.set_x1(supportLine, x1=bar_index) line.set_x2(supportLine, x2=bar_index - 50) line.set_y1(supportLine, y1=supportLevel) line.set_y2(supportLine, y2=supportLevel) line.set_x1(resistanceLine, x1=bar_index) line.set_x2(resistanceLine, x2=bar_index - 50) line.set_y1(resistanceLine, y1=resistanceLevel) line.set_y2(resistanceLine, y2=resistanceLevel) This updated script includes automatic plotting of support and resistance areas and trendlines on the chart. It calculates support and resistance levels based on historical data and draws trendlines using the line.new function. The support areas are plotted in green, and the resistance areas are plotted in red. The script also continuously updates the trendlines as new bars form. User 11:58:09 AM\tError at 67:0 Unknown argument 'x1' of type 'series' 11:58:09 AM\tUnassigned argument x; 11:58:09 AM\tError at 68:0 Unknown argument 'x2' of type 'series' 11:58:09 AM\tUnassigned argument x; 11:58:09 AM\tError at 69:0 Unknown argument 'y1' of type 'series' 11:58:09 AM\tUnassigned argument y; 11:58:09 AM\tError at 70:0 Unknown argument 'y2' of type 'series' 11:58:09 AM\tUnassigned argument y; 11:58:09 AM\tError at 72:0 Unknown argument 'x1' of type 'series' 11:58:09 AM\tUnassigned argument x; 11:58:09 AM\tError at 73:0 Unknown argument 'x2' of type 'series' 11:58:09 AM\tUnassigned argument x; 11:58:09 AM\tError at 74:0 Unknown argument 'y1' of type 'series' 11:58:09 AM\tUnassigned argument y; 11:58:09 AM\tError at 75:0 Unknown argument 'y2' of type 'series' 11:58:09 AM\tUnassigned argument y ChatGPT I apologize for the errors in the previous script. It seems there was an issue with the trendline drawing code. To resolve these errors and correctly draw trendlines, you can use the line.new function as follows: pinescript Copy code //@version=4 strategy(\"Improved EMA Crossover Strategy with Support/Resistance and EMA Exit\", shorttitle=\"EMA CC\", overlay=true) // Input parameters fast_length = input(3, title=\"Fast EMA Length\") slow_length = input(9, title=\"Slow EMA Length\") trail_length = input(5, title=\"Trailing Stop Length\") stop_loss_percent = input(2.0, title=\"Stop Loss (%)\", minval=0.1, maxval=5.0) take_profit_percent = input(4.0, title=\"Take Profit (%)\", minval=1.0, maxval=10.0) // Calculate EMAs ema_fast = ema(close, fast_length) ema_slow = ema(close, slow_length) // Calculate SMA of the close price for the last two candles last_two_close_sma = sma(close, 2) // Buy and sell conditions buy_condition = crossover(ema_fast, ema_slow) and close > open and close > last_two_close_sma sell_condition = crossunder(ema_fast, ema_slow) and close < open and close < last_two_close_sma // Calculate trailing stop levels var float trail_stop_level = na if (high > trail_stop_level)     trail_stop_level := high - (high * stop_loss_percent / 100) else     trail_stop_level := max(trail_stop_level, high - (high * stop_loss_percent / 100)) // Calculate take profit level take_profit_level = close + (close * take_profit_percent / 100) // Calculate exit conditions exit_buy_condition = close < ema_fast or low < last_two_close_sma exit_sell_condition = close > ema_fast or high > last_two_close_sma // Plot buy and sell signals plotshape(buy_condition, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small) plotshape(sell_condition, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small) // Entry and exit conditions strategy.entry(\"Buy\", strategy.long, when = buy_condition) strategy.entry(\"Sell\", strategy.short, when = sell_condition) // Exit conditions: Close below 3 EMA or below last two close SMA for buy and close above 3 EMA or above last two close SMA for sell strategy.exit(\"Exit Buy\", from_entry = \"Buy\", when = exit_buy_condition) strategy.exit(\"Exit Sell\", from_entry = \"Sell\", when = exit_sell_condition) // Plot EMAs plot(ema_fast, color=color.blue, title=\"Fast EMA\") plot(ema_slow, color=color.orange, title=\"Slow EMA\") // Auto plot support and resistance areas supportLevel = security(syminfo.tickerid, \"D\", lowest(low, 50)) resistanceLevel = security(syminfo.tickerid, \"D\", highest(high, 50)) plot(supportLevel, title=\"Support\", color=color.green, linewidth=1, style=plot.style_histogram, transp=80) plot(resistanceLevel, title=\"Resistance\", color=color.red, linewidth=1, style=plot.style_histogram, transp=80) // Auto plot trendlines var line supportLine = na var line resistanceLine = na if (bar_index % 10 == 0)     line.delete(supportLine)     line.delete(resistanceLine)     supportLine := line.new(x1=bar_index - 50, y1=supportLevel, x2=bar_index, y2=supportLevel, color=color.green, width=1)     resistanceLine := line.new(x1=bar_index - 50, y1=resistanceLevel, x2=bar_index, y2=resistanceLevel, color=color.red, width=1) This code includes modifications to correctly draw the support and resistance areas as well as the trendlines using the line.new and line.delete functions. User Make me new pine script for Auto drawing of trend lines and support and resistance area based on price action ChatGPT Creating a Pine Script strategy that automatically draws trendlines, support, and resistance areas based on price action is a complex task. However, I can provide you with a simplified Pine Script example that demonstrates how to draw support and resistance lines based on recent swing highs and swing lows. Please note that this is a basic example, and a more sophisticated solution would require advanced logic and analysis. pinescript Copy code //@version=4 study(\"Auto Trendlines and Support/Resistance\", shorttitle=\"ATSR\", overlay=true) // Calculate swing highs and swing lows var float highSwing = na var float lowSwing = na var float support = na var float resistance = na isHighSwing = high > high and high > high isLowSwing = low < low and low < low if (isHighSwing)     highSwing := high if (isLowSwing)     lowSwing := low // Plot swing highs and lows plotshape(isHighSwing, style=shape.triangleup, location=location.abovebar, color=color.green, size=size.small) plotshape(isLowSwing, style=shape.triangledown, location=location.belowbar, color=color.red, size=size.small) // Calculate support and resistance levels if (isHighSwing)     resistance := highSwing if (isLowSwing)     support := lowSwing // Plot support and resistance lines plot(resistance, title=\"Resistance\", color=color.red) plot(support, title=\"Support\", color=color.green) In this script: We identify swing highs and swing lows based on recent price action. When a new high swing is detected, we set the highSwing variable to the previous high. When a new low swing is detected, we set the lowSwing variable to the previous low. We plot green triangles above bars for high swings and red triangles below bars for low swings. Based on the swings, we calculate support and resistance levels. We plot red lines at resistance levels and green lines at support levels. This script provides a basic illustration of how you can automatically draw support and resistance lines based on recent swing highs and lows. Depending on your specific requirements and trading strategy, you may need to implement more advanced logic and analysis to improve the accuracy and usefulness of these levels."}, {"role": "assistant", "content": "//@version=4\nstrategy(\"Improved EMA Crossover Strategy with Support/Resistance and EMA Exit\", shorttitle\n// Input parameters\nfast_length = input(3, title=\"Fast EMA Length\")  // Change the fast EMA length to 3\nslow_length = input(9, title=\"Slow EMA Length\")  // Change the slow EMA length to 9\ntrail_length = input(5, title=\"Trailing Stop Length\")\nstop_loss_percent = input(2.0, title=\"Stop Loss (%)\", minval=0.1, maxval=5.0)\ntake_profit_percent = input(4.0, title=\"Take Profit (%)\", minval=1.0, maxval=10.0)\n// Calculate EMAs\nema_fast = ema(close, fast_length)\nema_slow = ema(close, slow_length)\n// Calculate SMA of the close price for the last two candles\nlast_two_close_sma = sma(close, 2)\n// Buy and sell conditions\nbuy_condition = crossover(ema_fast, ema_slow) and close > open and close > last_two_close_sma\nsell_condition = crossunder(ema_fast, ema_slow) and close < open and close < last_two_close_sma\n// Calculate trailing stop levels\nvar float trail_stop_level = na\nif (high > trail_stop_level[1])\n    trail_stop_level := high - (high * stop_loss_percent / 100)\nelse\n    trail_stop_level := max(trail_stop_level[1], high - (high * stop_loss_percent /\n// Calculate take profit level\ntake_profit_level = close + (close * take_profit_percent / 100)\n// Calculate exit conditions\nexit_buy_condition = close < ema_fast or low < last_two_close_sma\nexit_sell_condition = close > ema_fast or high > last_two_close_sma\n// Plot buy and sell signals\nplotshape(buy_condition, title=\"Buy Signal\", location=location.belowbar, color= color.green\nplotshape(sell_condition, title=\"Sell Signal\", location=location.abovebar, color= \n// Entry and exit conditions\nstrategy.entry(\"Buy\", strategy.long, when = buy_condition)\nstrategy.entry(\"Sell\", strategy.short, when = sell_condition)\n// Exit conditions: Close below 3 EMA or below last two close SMA for buy and close above 3 EMA or a\nstrategy.exit(\"Exit Buy\", from_entry = \"Buy\", when = exit_buy_condition)\nstrategy.exit(\"Exit Sell\", from_entry = \"Sell\", when = exit_sell_condition)\n// Plot EMAs\nplot(ema_fast, color= color.blue, title=\"Fast EMA\")\nplot(ema_slow, color= color.orange, title=\"Slow EMA\")"}]}
{"messages": [{"role": "user", "content": "The Strategy use RSI 2 Period. If RSI (N) > RSI (N-1), open a call order at the opening of a new candle. Conversely, if RSI (N) < RSI (N-1) then open a PUT order at the opening of a new candle"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"RSI Strategy\", overlay=true)\nrsiPeriod = input.int(2, \"RSI Period\")\npreviousRSI = ta.rsi(close, rsiPeriod)[1]\nif ta.rsi(close, rsiPeriod) > previousRSI\n    strategy.entry(\"Buy\", strategy.long)\nif ta.rsi(close, rsiPeriod) < previousRSI\n    strategy.entry(\"Sell\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "The Blue arrow should appear one candle prior to the entry candle. The strategy entries are triggered at the beginning of the next candle."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 PipJones\n//@version=5\nstrategy('We Get Pips with Alerts', overlay=true)\n[supertrend, direction] = ta.supertrend(3, 10)\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, 'Up Trend', color= color.new(color.green\ndownTrend = plot(direction < 0 ? na : supertrend, 'Down Trend', color= color.new(color.red\nfill(bodyMiddle, upTrend,  color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend,  color.new(color.red, 90), fillgaps=false)\nif ta.change(direction) < 0\n    strategy.entry('Long Entry', strategy.long)\n    alert('', alert.freq_once_per_bar_close)\nif ta.change(direction) > 0\n    strategy.entry('Short Entry', strategy.short)\n    alert('', alert.freq_once_per_bar_close)\nplotshape(ta.change(direction) < 0, style=shape.labelup, location=location.belowbar\nplotshape(ta.change(direction) > 0, style=shape.labeldown, location=location.abovebar"}]}
{"messages": [{"role": "user", "content": "First, we identify the trend, the trend will be determined by the daily candles, whenever the daily candle closes above the high of a previous candle the trend becomes positive and the trend remains positive till the time a candle closes below the lowest price of this candle, however, if the cost of any future candle closes above the high of this candle then the bottom of this candle becomes the SL/ trend change point. And vice versa for the opposing side.  Once we have identified the trend we will trade only on the side of the trend in the 15mins candles  If the trend is positive then only positive trades will be initiated when the conditions are fulfilled I.e  Whenever a 15min candle closes above the high of a previous 15min candle then we enter the trade and if any 15min candle closes below the lowest price of this candle then we SL our trade, once any candle closes above the highest price of this candle then the lowest price of that candle becomes our trailing SL"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Anand's Strategy\", overlay=true)\n// Get the high and low of the previous day's candle\nprev_high = request.security(syminfo.tickerid, \"D\", high[2])\nprev_low = request.security(syminfo.tickerid, \"D\", low[2])\n// var float prev_high = na\n// var float prev_low = na\nprev_close = request.security(syminfo.tickerid, \"D\", close[1])\ngetDayIndexedHighLow(_bar) =>\n    _indexed_high = request.security(syminfo.tickerid, \"D\", high[_bar])\n    _indexed_low = request.security(syminfo.tickerid, \"D\", low[_bar])\n    [_indexed_high, _indexed_low]\nvar index = 2\nwhile index >= 0\n    [indexed_high_D, indexed_low_D] =  getDayIndexedHighLow(index)\n      if prev_close > indexed_high_D or prev_close < indexed_low_D\n        prev_high := indexed_high_D\n        prev_low := indexed_low_D\n        break\n    // Decrease the index to move to the previous 15-minute candle\n    index := index - 1\n// Determine the trade direction based on the candle criterion\ntrade_direction = prev_close > prev_high ? 1 : (prev_close < prev_low ? -1 : 0)\n// Get the current close from 15-minute timeframe\ncurrent_close = request.security(syminfo.tickerid, \"15\", close[1])\nprev_high_15m = request.security(syminfo.tickerid, \"15\", high[2])\nprev_low_15m = request.security(syminfo.tickerid, \"15\", low[2])\n// var float prev_high_15m = na\n// var float prev_low_15m = na\ngetIndexedHighLow(_bar) =>\n    _indexed_high = request.security(syminfo.tickerid, \"15\", high[_bar])\n    _indexed_low = request.security(syminfo.tickerid, \"15\", low[_bar])\n    [_indexed_high, _indexed_low]\n// Loop through previous 15-minute candles until the condition is met\nvar  i = 2\nwhile i >= 2\n    [indexed_high_15m, indexed_low_15m] =  getIndexedHighLow(i)\n      if current_close > indexed_high_15m or current_close < indexed_low_15m\n        prev_high_15m := indexed_high_15m\n        prev_low_15m := indexed_low_15m\n        break\n    // Decrease the index to move to the previous 15-minute candle\n    i := i - 1\nbuy_condition = trade_direction == 1 and current_close > prev_high_15m\nstop_loss_buy = prev_low_15m\n// Sell Trade Criteria in Negative Trend\nsell_condition = trade_direction == -1 and current_close < prev_low_15m\nstop_loss_sell = prev_high_15m\n// Trailing Stop Loss for Buy Trade\n// Custom Trailing Stop Function for Buy Trade\nvar float trail_stop_buy = na\ntrailing_buy_condition = buy_condition and current_close > trail_stop_buy\nif trailing_buy_condition\n    trail_stop_buy := current_close\n// Custom Trailing Stop Function for Sell Trade\nvar float trail_stop_sell = na\ntrailing_sell_condition = sell_condition and current_close < trail_stop_sell\nif trailing_sell_condition\n    trail_stop_sell := current_close\n// Take Buy Trade with Stop Loss\nif (buy_condition)\n    strategy.entry(\"Buy\", strategy.long)\n    strategy.exit(\"Buy Stop Loss\", \"Buy\", stop=stop_loss_buy)\n// Take Sell Trade with Stop Loss\nif (sell_condition)\n    strategy.entry(\"Sell\", strategy.short)\n    strategy.exit(\"Sell Stop Loss\", \"Sell\", stop=stop_loss_sell)\n// Set the background color based on the trade direction\nbgcolor(trade_direction == 1 ?  color.new(color.green, 90) : trade_direction == -1"}]}
{"messages": [{"role": "user", "content": "ADX and ADX-R corss We need to be very careful about how we read and interpret the ADX indicator. It is not a bullish and bearish indicator. ADX\u2019s moving average only measures the strength of the trend. So, if the price is going UP, and the ADX indicator is also going UP, then we have the case for a strong bullish case. The same is true if the price is going DOWN and the ADX indicator is going UP. Then we have the case for a strong bearish case."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"ADX-R Strategy\", overlay=false)\nadx_length = input(14, title=\"ADX Length\")\nadx_smooth_length = input(14, title=\"ADX Smoothing Length\")\nadx_threshold = input(20, title=\"ADX Threshold\")\nTrueRange = math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low \nPlusDMChange = ta.change(high)\nMinusDMChange = ta.change(low)\nPlusDM = PlusDMChange > 0 and PlusDMChange > (-1) * MinusDMChange ? PlusDMChange : \nMinusDM = MinusDMChange < 0 and (-1) * MinusDMChange > PlusDMChange ? (-1) * MinusDMChange\nATR = ta.rma(TrueRange, adx_length)\nPlusDI = 100 * ta.rma(PlusDM, adx_length) / ATR\nMinusDI = 100 * ta.rma(MinusDM, adx_length) / ATR\nSumDI = PlusDI + MinusDI\nDX = math.abs(PlusDI - MinusDI) / SumDI * 100\nADX = ta.rma(DX, adx_smooth_length)\nADXR = ta.rma(ADX, adx_smooth_length)\nadx_cross_up = ta.crossover(ADX, ADXR) and ADX > adx_threshold\nadx_cross_down = ta.crossunder(ADX, ADXR)\nstrategy.entry(\"Buy\", strategy.long, when=adx_cross_up)\nstrategy.close(\"Buy\", when=adx_cross_down)\nplot(ADX, color= color.blue, title=\"ADX\")\nplot(ADXR, color= color.red, title=\"ADXR\")"}]}
{"messages": [{"role": "user", "content": "Rsi and Bollinger Band Breakout  With Buy and Sell signal"}, {"role": "assistant", "content": "//@version=5\nstrategy('RSI AND BOLLINGER BAND BREAKOUTS', overlay=true)\n// input controls\nlengthsma = input.int(title='LSMA', defval=10, minval=1, maxval=30, step=1) \nLmulti = input.float(title='multiplier', defval=1, minval=1, maxval=3, step=0.5) \nRSIL = input.int(title='RSIL', defval=5, minval=1, maxval=21, step=1) \nOverbought = input.int(title='OB', defval=60, minval=1, maxval=100, step=1)\nOversold = input.int(title='OS', defval=40, minval=1, maxval=100, step=1) \nEXITEMA = input.int(title='EXITEMA', defval=20, minval=1, maxval=100, step=1) \n//Bollinger bands and sma \nSMA = ta.sma(close, lengthsma) \nstdev = ta.stdev(close, 20) \nupperband = SMA + stdev * Lmulti \nlowerband = SMA - stdev * Lmulti \nEMA = ta.ema(close, EXITEMA) \n// RELATIVE STRNGTH INDEX \nRSI = ta.rsi(close, RSIL)\n// Buy and sell \nBUY = ta.crossover(close, upperband) and ta.crossover(RSI, Overbought) \nSELL = ta.crossunder(close, lowerband) and ta.crossunder(RSI, Oversold) \n// BUY AND SELL EXIT \nbuyexit = ta.crossunder(close, EMA) \nsellexit = ta.crossover(close, EMA) \nstrategy.entry('LONG', strategy.long, when=BUY, comment='B') \nstrategy.entry('SHORT', strategy.short, when=SELL, comment='S') \nstrategy.close('LONG', when=buyexit, comment='S') \nstrategy.close('SHORT', when=sellexit, comment='B')"}]}
{"messages": [{"role": "user", "content": "Bollinger Bands and RSI Strategy, Stratagy that combine bolinger and Rsi if rsi lowerd than boli then it would sign sell signal"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Bollinger Bands and RSI Strategy sumit\", overlay = true)\n// Parameters\nlength = input(20, title = \"Bollinger Bands Length\")\nsrc = input(close, title = \"Source\")\nmult = input(2.0, title = \"Bollinger Bands Multiplier\")\nrsiLength = input(14, title = \"RSI Length\")\nrsiOverbought = input(70, title = \"RSI Overbought Level\")\nrsiOversold = input(30, title = \"RSI Oversold Level\")\n// Calculate Bollinger Bands\nbasis = ta.sma(src, length)\ndev = mult * ta.stdev(src, length)\nupper = basis + dev\nlower = basis - dev\n// Calculate RSI\nrsiValue = ta.rsi(src, rsiLength)\n// Entry conditions\nbuyCondition = ta.crossover(src, upper) and rsiValue < rsiOversold\nsellCondition = ta.crossunder(src, lower) and rsiValue > rsiOverbought\nif (buyCondition)\n    strategy.entry(\"Buy\", strategy.long)\nif (sellCondition)\n    strategy.entry(\"Sell\", strategy.short)\n// Plot Bollinger Bands and RSI on the chart\nplot(upper, color =  color.blue, title = \"Upper Bollinger Band\")\nplot(lower, color =  color.red, title = \"Lower Bollinger Band\")\nplot(rsiValue, color =  color.green, title = \"RSI\")\nhline(rsiOverbought, \"Overbought\", color= color.red)\nhline(rsiOversold, \"Oversold\", color= color.green)"}]}
{"messages": [{"role": "user", "content": "Certainly! The \"RSI with SuperTrend\" strategy combines the Relative Strength Index (RSI) and the SuperTrend indicators to identify potential trade opportunities. This strategy aims to capture price movements by considering both overbought/oversold conditions (RSI) and trend direction (SuperTrend). Here's a breakdown of how the strategy works: 1. **Relative Strength Index (RSI):**    - RSI is a momentum oscillator that measures the speed and change of price movements.    - It ranges from 0 to 100 and is typically used to identify overbought (70 or higher) and oversold (30 or lower) conditions.    - In this strategy, the RSI is calculated based on the closing prices over a user-defined length.    - Buy signals occur when the RSI crosses below the oversold level, suggesting a potential price reversal to the upside.    - Sell signals occur when the RSI crosses above the overbought level, suggesting a potential price reversal to the downside. 2. **SuperTrend Indicator:**    - The SuperTrend indicator is used to identify the current trend direction.    - It provides potential support and resistance levels that can help traders understand where a trend might reverse.    - The SuperTrend is calculated based on the Average True Range (ATR) and a user-defined multiplier.    - Buy signals occur when the price crosses above the SuperTrend line, suggesting a potential uptrend.    - Sell signals occur when the price crosses below the SuperTrend line, suggesting a potential downtrend. 3. **Strategy Conditions:**    - The strategy conditions are based on a combination of RSI and SuperTrend signals.    - A \"long\" condition is triggered when the RSI crosses below the oversold level and the SuperTrend indicates an uptrend.    - A \"short\" condition is triggered when the RSI crosses above the overbought level and the SuperTrend indicates a downtrend. 4. **Execution of Orders:**    - When a \"long\" condition is met, the strategy enters a long position (buy).    - When a \"short\" condition is met, the strategy enters a short position (sell). 5. **Visualization:**    - The SuperTrend line is plotted on the chart to provide a visual representation of the trend direction.    - Up and down arrows are plotted above or below bars where the strategy conditions are met. Please note that this is a simplified version of the strategy, and actual trading involves careful consideration of risk management, position sizing, and thorough backtesting. Traders should adapt and customize the strategy to their trading preferences and risk tolerance."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"RSI with SuperTrend\", overlay=true)\n// Input parameters\nrsi_length = input.int(14, title=\"RSI Length\")\nrsi_overbought = input.int(70, title=\"RSI Overbought Level\")\nrsi_oversold = input.int(30, title=\"RSI Oversold Level\")\nsupertrend_period = input.int(10, title=\"SuperTrend Period\")\nsupertrend_multiplier = input.float(1.5, title=\"SuperTrend Multiplier\")\n// Declare and initialize Supertrend variable\nvar float supertrend = na\n// Calculate RSI\nrsi_value = ta.rsi(close, rsi_length)\n// Calculate SuperTrend\natr_value = ta.atr(supertrend_period)\nhl2_value = (high + low) / 2\nupper_band = hl2_value + (supertrend_multiplier * atr_value)\nlower_band = hl2_value - (supertrend_multiplier * atr_value)\ntrend_up = ta.highest(upper_band, 2)\ntrend_down = ta.lowest(lower_band, 2)\nsupertrend := hl2_value > trend_down ? 1 : hl2_value < trend_up ? -1 : supertrend[1\n// Strategy conditions\nrsi_cross_overbought = ta.crossover(rsi_value, rsi_overbought)\nrsi_cross_oversold = ta.crossunder(rsi_value, rsi_oversold)\nsupertrend_cross_up = ta.crossover(supertrend, 0)\nsupertrend_cross_down = ta.crossunder(supertrend, 0)\nlong_condition = rsi_cross_oversold and supertrend_cross_up\nshort_condition = rsi_cross_overbought and supertrend_cross_down\n// Plot SuperTrend on the chart\nplot(supertrend, color= color.blue, title=\"SuperTrend\")\n// Execute strategy orders\nif (long_condition)\n    strategy.entry(\"Long\", strategy.long)\nif (short_condition)\n    strategy.entry(\"Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "Best Strategy on Forex & Crypto chart should be Heiken Ashi...  Thank You so much for use this strategy an comment me to how get profit in Global Market"}, {"role": "assistant", "content": "//@version=5\nstrategy(title = 'AI Pipel', overlay=true)\n//Heiken\nlen=input(10)\no=ta.ema(open,len)\nc=ta.ema(close,len)\nh=ta.ema(high,len)\nl=ta.ema(low,len)\nhaopen=0.0\nhaclose = (o+h+l+c)/4\nhaopen := na(haopen[1]) ? (o + c)/2 : (haopen[1] + haclose[1]) / 2\nhahigh = math.max (h, math.max(haopen,haclose))\nhalow = math.min (l, math.min(haopen,haclose))\nlen2=input(10)\no2=ta.ema(haopen, len2)\nc2=ta.ema(haclose, len2)\nh2=ta.ema(hahigh, len2)\nl2=ta.ema(halow, len2)\ncol=o2>c2 ?  color.red :  color.lime\nplotcandle(o2, h2, l2, c2, title=\"heikin smoothed\", color=col)\n//Ichi\nconversionPeriods = input.int(9, minval=1, title=\"Conversion Line Length\")\nbasePeriods = input.int(26, minval=1, title=\"Base Line Length\")\nlaggingSpan2Periods = input.int(52, minval=1, title=\"Leading Span B Length\")\ndisplacement = input.int(26, minval=1, title=\"Lagging Span\")\ndonchian(len) => math.avg(ta.lowest(len), ta.highest(len))\nconversionLine = donchian(conversionPeriods)\nbaseLine = donchian(basePeriods)\nleadLine1 = math.avg(conversionLine, baseLine)\nleadLine2 = donchian(laggingSpan2Periods)\n//plot(conversionLine, color=#2962FF, title=\"Conversion Line\")\n//plot(baseLine, color=#B71C1C, title=\"Base Line\")\n//plot(close, offset = -displacement + 1, color=#43A047, title=\"Lagging Span\")\n//p1 = plot(leadLine1, offset = displacement - 1, color=#A5D6A7,\n//   title=\"Leading Span A\")\n//p2 = plot(leadLine2, offset = displacement - 1, color=#EF9A9A,\n//   title=\"Leading Span B\")\n//plot(leadLine1 > leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = \"Kumo Cloud\n//plot(leadLine1 < leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = \"Kumo Cloud\n//fill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 9\n//rsi\nma(source, length, type) =>\n    switch type\n        \"SMA\" => ta.sma(source, length)\n        \"Bollinger Bands\" => ta.sma(source, length)\n        \"EMA\" => ta.ema(source, length)\n        \"SMMA (RMA)\" => ta.rma(source, length)\n        \"WMA\" => ta.wma(source, length)\n        \"VWMA\" => ta.vwma(source, length)\nrsiLengthInput = input.int(14, minval=1, title=\"RSI Length\", group=\"RSI Settings\")\nrsiSourceInput = input.source(close, \"Source\", group=\"RSI Settings\")\nmaTypeInput = input.string(\"SMA\", title=\"MA Type\", options=[\"SMA\", \"Bollinger Bands\"\nmaLengthInput = input.int(14, title=\"MA Length\", group=\"MA Settings\")\nbbMultInput = input.float(2.0, minval=0.001, maxval=50, title=\"BB StdDev\", group=\"MA Settings\"\nup = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)\ndown = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)\nrsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\nrsiMA = ma(rsi, maLengthInput, maTypeInput)\n//buy\nif ta.crossover(close,conversionLine) and ta.crossover(rsi,rsiMA) // and o2<c2 and o2[1]>c2[1]\n    //label.new(bar_index,low,'Buy', style =label.style_label_up,color=color.green )\n    strategy.entry(\"Long\",strategy.long,comment = \"Long\")\n//\n////sell\nif ta.crossunder(close,conversionLine) and ta.crossunder(rsi,rsiMA) // and o2>c2 and o2[1]<c2[1]\n    //label.new(bar_index,high,'Sell', style =label.style_label_down,color = color.red )\n    strategy.entry(\"Short\",strategy.short,comment = \"Short\")"}]}
{"messages": [{"role": "user", "content": "Advanced High Accuracy BTCUSDT Strategy by Abdul Wahid Overview This strategy is designed to provide traders with high-accuracy entry and exit signals for trading BTCUSDT. It combines multiple indicators like RSI, MACD, Bollinger Bands, and moving averages to create a comprehensive trading strategy. The script also includes risk management features to ensure that you're not overexposed in the market. Features High-Accuracy Signals: Utilizes a combination of RSI, MACD, Bollinger Bands, and moving averages. Risk Management: Automatically calculates the lot size based on your capital and the current ATR value. Visual Indicators: Clear \"Buy\" and \"Sell\" signals plotted directly on the chart. Market Condition: Displays whether the market is \"Bullish\" or \"Bearish\" at the bottom of the chart. How to Use Apply the script to a BTCUSDT chart. Look for \"Buy\" and \"Sell\" signals plotted on the chart. Use the lot size calculated by the script for your trades. Risk Disclaimer Trading involves risks and is not suitable for everyone. You should only trade with money that you can afford to lose. This script is for educational purposes only and should not be considered as financial advice. Connect with Me For more updates and trading insights, follow me on Instagram: @abdul_wahid1337"}, {"role": "assistant", "content": "//@version=4\nstrategy(\"Advanced High Accuracy BTCUSDT Strategy by Abdul Wahid\", overlay=true, pyramiding\n// Parameters\nrsiPeriod = 14\nmacdShort = 12\nmacdLong = 26\nmacdSignal = 9\nlengthBB = 20\nmultBB = 2.0\nma200Length = 200\nma50Length = 50\natrLength = 14\nriskPerTrade = 0.01\n// Indicators\nrsiValue = rsi(close, rsiPeriod)\n[macdLine, signalLine, _] = macd(close, macdShort, macdLong, macdSignal)\nbasisBB = sma(close, lengthBB)\nupperBB = basisBB + multBB * stdev(close, lengthBB)\nlowerBB = basisBB - multBB * stdev(close, lengthBB)\nma200 = sma(close, ma200Length)\nma50 = sma(close, ma50Length)\natrValue = atr(atrLength)\n// Risk Management\ncapital = strategy.equity\nlotSize = (capital * riskPerTrade) / atrValue\n// Additional Conditions\naboveMa50 = close > ma50\nbelowMa50 = close < ma50\n// Entry and Exit Conditions\nlongCondition = crossover(macdLine, signalLine) and (rsiValue < 70) and (close > upperBB\nshortCondition = crossunder(macdLine, signalLine) and (rsiValue > 30) and (close < \n// Strategy Orders\nif (longCondition)\n    strategy.close(\"Sell\")\n    strategy.entry(\"Buy\", strategy.long, qty=lotSize)\nif (shortCondition)\n    strategy.close(\"Buy\")\n    strategy.entry(\"Sell\", strategy.short, qty=lotSize)\n// Market Condition\nmarketCondition = close > ma200 ? \"Bullish\" : \"Bearish\"\n// Plotting\nplotshape(series=longCondition, title=\"Buy Signal\", location=location.belowbar, color\nplotshape(series=shortCondition, title=\"Sell Signal\", location=location.abovebar, color\n// Watermark and Market Condition\nlabel.new(x=bar_index[1], y=na, text=marketCondition, xloc=xloc.bar_index, yloc=yloc.belowbar\nlabel.new(x=bar_index[1], y=na, text=\"Made by Abdul Wahid\", xloc=xloc.bar_index, yloc"}]}
{"messages": [{"role": "user", "content": "Description: This script implements the renowned Turtle Trading Strategy, a trend-following system based on breakout trading. The strategy aims to capture big market movements by entering a trade when the price breaks through a historical high or low and then adding to the position as the trend continues. Features: Entry and Exit Days: Users can define the number of days for breakout entry and exit. Stop Loss: The strategy uses the Average True Range (ATR) to set a dynamic stop loss. Users can adjust the multiplier for the ATR to determine the stop loss distance. Position Sizing: The strategy calculates position size based on a percentage of equity and the ATR. Time Filter: Users can set a start and end date for the strategy to run. The chart will highlight the period during which the strategy is active. Position Scaling: The strategy scales into a position by adding more contracts/shares as the trend continues in the desired direction. Parameters: break through days of entrance: Number of days to determine the breakout level for entry. break through days of exit: Number of days to determine the breakout level for exit. stop loss ATR multiplier: Multiplier for the ATR to set the stop loss. strategy start time: The date and time when the strategy starts. strategy end time: The date and time when the strategy ends. How it Works: The strategy checks if the current price has broken above the highest price of the past 'entry days' or below the lowest price of the past 'entry days'. If a breakout is detected, the strategy enters a long or short position based on the direction of the breakout. The strategy then scales into the position by adding more contracts/shares if the price continues to move in the direction of the trend. The strategy exits the position if the price breaks through the opposite breakout level of the past 'exit days' or if the stop loss is hit. The strategy also closes all positions at the end date defined by the user. Note: This strategy is for educational purposes."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 bot_researcher\n//@version=5\nstrategy(\"Turtle Trading Strategy\", overlay=true, process_orders_on_close=true, margin_long\nentry_days = input.int(10, \"break through days of entrance\")\nexit_days = input.int(20, \"break through days of exit\")\nsl_atr_multipler = input.float(1, \"stop loss ATR multipler\")\nstart_date = input.time(timestamp(\"01 Nov 2021 00:00 +0000\"), \"strategy start time\"\nend_date = input.time(timestamp(\"01 Nov 2023 00:00 +0000\"), \"strategy end time\", confirm\nintime = time >= start_date and time < end_date and barstate.isconfirmed\nbgcolor(intime ?  color.new(color.green, 70) : na)\natr = ta.atr(20)\nvar inited = false\nvar finished = false\nvar float long_positions = 0\nvar float short_positions = 0\nvar float entry_atr = 0\nvar float qty = 0\nvar float long_entry_price = 0\nvar float short_entry_price = 0\nentry_highest = ta.highest(high[1], entry_days)\nentry_lowest = ta.lowest(low[1], entry_days)\nexit_highest = ta.highest(high[1], exit_days)\nexit_lowest = ta.lowest(low[1], exit_days)\n// plot(entry_highest, 'highest 20')\n// plot(entry_lowest, 'lowest 20')\nif intime and not inited\n    if close > entry_highest\n        entry_atr := atr\n        long_entry_price := close\n        float diff = int((close - entry_highest) / (0.5 * entry_atr)) + 1\n        long_positions := math.min(diff, 4)\n        qty := strategy.equity * 0.01 / entry_atr\n        strategy.order(\"long\", strategy.long, qty * long_positions)\n        inited := true\n    else if close < entry_lowest\n        entry_atr := atr\n        short_entry_price := close\n        float diff = int((entry_lowest - close) / (0.5 * entry_atr)) + 1\n        short_positions := math.min(diff, 4)\n        qty := strategy.equity * 0.01 / entry_atr\n        strategy.order(\"short\", strategy.short, qty * short_positions)\n        inited := true\nlong_price_diff = close - (long_entry_price + long_positions * 0.5 * entry_atr)\nif long_price_diff > 0 and long_positions > 0 and long_positions < 4\n    float step = int(long_price_diff / (0.5 * entry_atr)) + 1\n    float maxStep = math.min(step, 4 - long_positions)\n    long_positions := long_positions + maxStep\n    strategy.order(\"long+\", strategy.long, qty * maxStep)\nshort_price_diff = (short_entry_price - short_positions * 0.5 * entry_atr) - close\nif short_price_diff > 0 and short_positions > 0 and short_positions < 4 \n    float step = int(short_price_diff / (0.5 * entry_atr)) + 1\n    float maxStep = math.min(step, 4 - short_positions)\n    short_positions := short_positions + maxStep\n    strategy.order(\"short+\", strategy.short, qty * maxStep)\nif long_positions > 0 and close < exit_lowest\n    long_positions := 0\n    inited := false\n    strategy.close_all(comment = 'exit long')\nif short_positions > 0 and close > exit_highest\n    short_positions := 0\n    inited := false\n    strategy.close_all(comment = 'exit short')\nsl_range = sl_atr_multipler * entry_atr\nif long_positions > 0 and close < strategy.position_avg_price - sl_range\n    inited := false\n    long_positions := 0\n    strategy.close_all(comment = 'long stop loss')\nif short_positions > 0 and close > strategy.position_avg_price + sl_range\n    short_positions := 0\n    inited := false\n    strategy.close_all(comment = 'short stop loss')\nif not finished and time >= end_date\n    finished := true\n    long_positions := 0\n    short_positions := 0\n    strategy.close_all(\"close\")"}]}
{"messages": [{"role": "user", "content": "uses macd and rsi to give u signal. to enter a trade wait for the red or green triangle to pop out  green is for long and red is for short"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"BAO JIAK INDICATOR\", overlay=true)\n// MACD Settings\nfastLength = input.int(12, title=\"Fast Length\")\nslowLength = input.int(26, title=\"Slow Length\")\nsignalSMA = input.int(9, title=\"Signal Length\")\n[macdLine, signalLine, _] = ta.macd(close, fastLength, slowLength, signalSMA)\nmacdHist = macdLine - signalLine\n// RSI Settings\nrsiLength = input.int(14, title=\"RSI Length\")\nrsiOverbought = input.int(65, title=\"RSI Overbought\")\nrsiOversold = input.int(35, title=\"RSI Oversold\")\nrsi = ta.rsi(close, rsiLength)\n// Price Change Condition\nmaxPriceChange = input.float(10, title=\"Max Price Change\")\n// Calculate EMAs\nema12 = ta.ema(close, 12)\nema26 = ta.ema(close, 26)\n// Track previous MACD histogram value\nvar float prevMacdHist = na\n// Entry Conditions\nlongCondition = (macdHist > 0) and (macdHist >= 0.01 and macdHist <= 0.4) and (close\nshortCondition = (macdHist < 0) and (macdHist >= -0.4 and macdHist <= -0.01) and (close\n// Buy and Sell Shapes\nplotshape(longCondition, style=shape.triangleup, location=location.belowbar, color=\nplotshape(shortCondition, style=shape.triangledown, location=location.abovebar, color\n// Update previous MACD histogram value\nprevMacdHist := macdHist\n// Plot EMAs on the chart\nplot(ema12, title=\"EMA 12\", color= color.blue)\nplot(ema26, title=\"EMA 26\", color= color.red)"}]}
{"messages": [{"role": "user", "content": "It's show when you must buy and when you must  sell"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// https://t.me/yek_trader\n//@version=4\nstrategy(\"[Order] Paraboic SAR + Regression Channels + Supertrend\", shorttitle=\"PRCS\"\n// -- INPUT --\ntakeProfitPercent = input(title=\"TakeProfit(%)\", type=input.float, defval=1, step=\nstopLossPercent = input(title=\"StopLoss(%)\", type=input.float, defval=1, step=0.1,\n// Parabolic SAR\nshowPSAR = input(title=\"Show Parabolic SAR\", type=input.bool, defval=true, group=\"Parabolic SAR\"\nstart = input(title=\"Start\", type=input.float, step=0.001, defval=0.02, group=\"Parabolic SAR\"\nincrement = input(title=\"Increment\", type=input.float, step=0.001, defval=0.02, group\nmaximum = input(title=\"Maximum\", type=input.float, step=0.01, defval=0.2, group=\"Parabolic SAR\"\nwidth = input(title=\"Point Width\", type=input.integer, minval=1, defval=2, group=\"Parabolic SAR\"\nhighlightStartPoints = input(title=\"Highlight Start Points ?\", type=input.bool, defval\nshowLabels = input(title=\"Show Buy/Sell Labels ?\", type=input.bool, defval=true, group\nhighlightState = input(title=\"Highlight State ?\", type=input.bool, defval=true, group\n// Regression channels\n// showRegressionChannels = input(title=\"Show Regression channels\", type=input.bool, defval=true, gr\nsrc = input(title = \"Source\", type = input.source, defval = close, group=\"Regression channels\"\nlen = input(title = \"Length\", defval = 100, minval = 3, group=\"Regression channels\"\nmult = input(title = \"Channel Multiplier\", type = input.float, defval = 2, minval \nshowinterval = input(title = \"Show Channel\", defval = true, group=\"Regression channels\"\nshowhist = input(title = \"Show Historical Broken Channels\", defval = true, group=\"Regression channels\"\nshowresult = input(title = \"Print Slope\", defval = true, group=\"Regression channels\"\nlw = input(title = \"Line Width\", defval = 2, group=\"Regression channels\")\ncolup = input( title = \"Color When Up\", defval =  color.green, group=\"Regression channels\"\ncoldw = input( title = \"Color When Down\", defval =  color.red, group=\"Regression channels\"\ncolbr = input( title = \"Color Of Broken Channel\", defval =  color.silver, group=\"Regression channels\"\nextendln = input(title = \"Extend Line\", defval = true, group=\"Regression channels\"\n// Supertrend\nshowSuperTrend = input(title=\"Show\", type=input.bool, defval=false, group=\"Supertrend\"\natrPeriod = input(10, \"ATR Length\", group=\"Supertrend\")\nfactor = input(3, \"Factor\", group=\"Supertrend\")\n// -- INPUT END --\n// -- Parabolic SAR --\nvar float takeProfit = na\nvar float stopLoss = na\npsar = sar(start, increment, maximum)\ndir = psar < close ? 1 : -1\npsarColor = dir == 1 ?  #3388bb :  #fdcc02\npsarPlot = plot(showPSAR ? psar : na, title=\"PSAR\", style=plot.style_circles, linewidth\nvar color longColor =  color.green\nvar color shortColor =  color.red\nbuySignal = dir == 1 and dir[1] == -1\nsellSignal = dir == -1 and dir[1] == 1\n// plotshape(buySignal and highlightStartPoints and showPSAR ? psar : na, title=\"Long Start\", locati\nplotshape(buySignal and showLabels and showPSAR ? psar : na, title=\"Buy Label\", text\n    // plotshape(sellSignal and highlightStartPoints and showPSAR ? psar : na, title=\"Short Start\", loca\nplotshape(sellSignal and showLabels and showPSAR ? psar : na, title=\"Sell Label\", \nmidPricePlot = plot(ohlc4, title=\"\", display=display.none)\nfillColor = highlightState ? (dir == 1 ? longColor : shortColor) : na\nfill(midPricePlot, psarPlot, title=\"Trade State Filling\", color=fillColor)\nchangeCond = dir != dir[1]\nalertcondition(changeCond, title=\"Alert: PSAR Direction Change\", message=\"PSAR has changed direction!\"\nalertcondition(buySignal, title=\"Alert: PSAR Long\", message=\"PSAR Long\")\nalertcondition(sellSignal, title=\"Alert: PSAR Short\", message=\"PSAR Sell\")\n// Close by takeprofit\ntakeProfitLong_Condition = takeProfitPercent != 0 and strategy.position_size > 0 and\ntakeProfitShort_Condition = takeProfitPercent != 0 and strategy.position_size < 0 \nplotshape(takeProfitLong_Condition, title=\"Long TakeProfit\", style=shape.circle, location\nplotshape(takeProfitShort_Condition, title=\"Short TakeProfit\", style=shape.circle,\nif takeProfitLong_Condition\n    takeProfit := na\n    strategy.close_all(comment=\"TakeProfit\")\nif takeProfitShort_Condition\n    takeProfit := na\n    strategy.close_all(comment=\"TakeProfit\")\n// Close by stoploss\nif stopLossPercent != 0 and strategy.position_size > 0 and crossunder(close, stopLoss\n    stopLoss := na\n    strategy.close_all(comment=\"StopLoss\")\nif stopLossPercent != 0 and strategy.position_size < 0 and crossover(close, stopLoss\n    stopLoss := na\n    strategy.close_all(comment=\"StopLoss\")\n// Open orders\nif buySignal\n    strategy.entry(\"Long\", strategy.long)\n    if takeProfitPercent > 0\n        takeProfit := close * (1 + takeProfitPercent)\n            if stopLossPercent > 0\n        stopLoss := close * (1 - stopLossPercent)\nif sellSignal\n    strategy.entry(\"Short\", strategy.short)\n    if takeProfitPercent >  0\n        takeProfit := close * (1 - takeProfitPercent)\n        if stopLossPercent > 0\n        stopLoss :=  close * (1 + stopLossPercent)\n// -- Parabolic SAR end --\n//-- Regression Channels --\ngetmedianslopes(_n, _y) =>\n    // For each point, get slopes with other data points, and then calculate median \n    // _n :: number of pointstheil\n    // _y :: source time series, e.g. close\n    _S = array.new_float(0)\n    _S1 = array.new_float(0)\n    float _m = 0.0\n    int _ntmp = _n\n    if _n > 2\n        for i = 0 to _n-1\n            _S1 := array.new_float(0)\n            for j = 0 to _n-1\n                if i != j\n                    array.push(_S1,(_y[i]-_y[j])/(j-i))\n            _m := array.median(_S1)\n            array.push(_S,_m)\n    _S\nintercepts(_src,_n,_mslope) =>\n    // Get all intercepts (Y - mslope*X) \n    // _n :: number of data points\n    // _mslope :: median slope determined by means of TS model\n    _I = array.new_float(0)\n    if _n > 2\n        for i = 0 to _n-1\n            array.push(_I,_src[_n-1-i] - _mslope*i)\n    _I\ntruncate(_value, _decimals) =>\n    // For output: Truncates a given float to a certain number of decimals\n    _factor = pow(10, _decimals)\n    int(_value * _factor) / _factor\nrmsd(_src,_x,_a,_b,_n) =>\n    float _rmsd = 0.0\n    for i = 0 to _n-1\n        _rmsd := _rmsd + pow(_src[i] -_a -_b*(_x-i),2)/_n\n    sqrt(_rmsd)\n// --- MAIN ---\n// get estimate only for the last barstate\nif (not showhist) and (not barstate.islast)\n    len:=0\nS = getmedianslopes(len, src)\nmslope = array.median(S)\nI = intercepts(src,len,mslope)\nminter = array.median(I)\n// apply estimator\nint x1 = bar_index-len\nint x2 = bar_index\nfloat y1 = minter\nfloat y2 = minter+mslope*(len-1)\n//estimate prediction interval (as \\pm mult*RMSD)\nfloat rmse = 0.0\nif showhist or barstate.islast \n    for j = 0 to len-1\n        rmse := rmse + pow(src[j] - (minter + mslope*(len - j)), 2)/len\nfloat dev = mult*sqrt(rmse)\n// check if prediction interval is broken\nbool isbroken = (src > y2 + dev) or (src < y2 - dev)\n// plot results\nline a = line.new(x1, y1, x2, y2, xloc.bar_index, \n                  extend = extendln?extend.right:extend.none, \n                  color=mslope>0?colup:coldw, width=lw)\nline.delete(a[1])\nif showinterval\n    line ap = line.new(x1, y1+dev, x2, y2+dev, xloc.bar_index, \n                      extend = extendln?extend.right:extend.none, \n                      color=isbroken?colbr:mslope>0?colup:coldw, \n                      width=lw, style=line.style_dashed)\n    line am = line.new(x1, y1-dev, x2, y2-dev, xloc.bar_index, \n                      extend = extendln?extend.right:extend.none, \n                      color=isbroken?colbr:mslope>0?colup:coldw, \n                      width=lw, style=line.style_dashed)\n    line.delete(ap[1])\n    line.delete(am[1])\nif showresult and barstate.islast\n    label b = label.new(bar_index-(len-1), mslope>0?y1-dev:y1+dev, \n                       style = mslope>0?label.style_label_up:label.style_label_down\n                       text = \"Slope \"+tostring(truncate(mslope,2)), \n                       color = mslope>0?colup:coldw)\n    label.delete(b[1])\n// handle the historical breaks\nvar int lastsavedbreakbar = 0\nbool iscrossing = false\nif cross(src, y2 + dev)\n    iscrossing := true\nbool histplotcondition = bar_index-int(len*0.5) > lastsavedbreakbar[1]\nif iscrossing and showhist and histplotcondition\n    line ap_broken = line.new(x1, y1+dev[1], x2, y2+dev[1], xloc.bar_index, \n                              extend = extend.none, \n                              color=colbr, width=1, style=line.style_dashed)\n    line am_broken = line.new(x1, y1-dev[1], x2, y2-dev[1], xloc.bar_index, \n                              extend = extend.none, \n                              color=colbr, width=1, style=line.style_dashed)\n    lastsavedbreakbar := bar_index\n// -- SuperTrend --\n[supertrend, direction] = supertrend(factor, atrPeriod)\nbodyMiddle = plot(showSuperTrend ? (open + close) / 2 : na, display=display.none)\nupTrend = plot(showSuperTrend and direction < 0 ? supertrend : na, \"Up Trend\", color\ndownTrend = plot(showSuperTrend and direction > 0 ? supertrend : na, \"Down Trend\",\n// fill(bodyMiddle, upTrend, supertrend ? color.new(color.green, 90) : color.new(color.green, 100), \n// fill(bodyM1ddle, downTrend, supertrend ? color.new(color.red, 90) : color.new(color.red, 100), fi"}]}
{"messages": [{"role": "user", "content": "Linear Cross Trading Strategy The Linear Cross trading strategy is a technical analysis strategy that uses linear regression to predict the future price of a stock. The strategy is based on the following principles:     The price of a stock tends to follow a linear trend over time.     The slope of the linear trend can be used to predict the future price of the stock.     The strategy enters a long position when the predicted price crosses above the current price, and exits the position when the predicted price crosses below the current price. The Linear Cross trading strategy is implemented in the TradingView Pine script below. The script first calculates the linear regression of the stock price over a specified period of time. The script then plots the predicted price and the current price on the chart. The script also defines two signals:     Long signal: The long signal is triggered when the predicted price crosses above the current price.     Short signal: The short signal is triggered when the predicted price crosses below the current price. The script enters a long position when the long signal is triggered and exits the position when the short signal is triggered. Here is a more detailed explanation of the steps involved in the Linear Cross trading strategy:     Calculate the linear regression of the stock price over a specified period of time.     Plot the predicted price and the current price on the chart.     Define two signals: the long signal and the short signal.     Enter a long position when the long signal is triggered.     Exit the long position when the short signal is triggered. The Linear Cross trading strategy is a simple and effective way to trade stocks. However, it is important to note that no trading strategy is guaranteed to be profitable. It is always important to do your own research and backtest the strategy before using it to trade real money. Here are some additional things to keep in mind when using the Linear Cross trading strategy:     The length of the linear regression period is a key parameter that affects the performance of the strategy. A longer period will smooth out the noise in the price data, but it will also make the strategy less responsive to changes in the price.     The strategy is more likely to generate profitable trades when the stock price is trending. However, the strategy can also generate profitable trades in ranging markets.     The strategy is not immune to losses. It is important to use risk management techniques to protect your capital when using the strategy. I hope this blog post helps you understand the Linear Cross trading strategy better. Booost and share with your friend, if you like."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 stocktechbot\n//@version=5\nstrategy(\"Linear Cross\", overlay=true, margin_long=100, margin_short=0)\n//Linear Regression\nvol = volume\n// Function to calculate linear regression\nlinregs(y, x, len) =>\n    ybar = math.sum(y, len)/len\n    xbar = math.sum(x, len)/len\n    b = math.sum((x - xbar)*(y - ybar),len)/math.sum((x - xbar)*(x - xbar),len)\n    a = ybar - b*xbar\n    [a, b]\n// Historical stock price data\nprice = close\n// Length of linear regression\nlen = input(defval = 21, title = 'Strategy Length')\nlinearlen=input(defval = 9, title = 'Linear Lookback')\n[a, b] = linregs(price, vol, len)\n// Calculate linear regression for stock price based on volume\n//eps = request.earnings(syminfo.ticker, earnings.actual)\n//MA For double confirmation\nout = ta.sma(close, 200)\noutf = ta.sma(close, 50)\noutn = ta.sma(close, 90)\noutt = ta.sma(close, 21)\noutthree = ta.sma(close, 9)\n// Predicted stock price based on volume\npredicted_price = a + b*vol\n// Check if predicted price is between open and close\nis_between = open < predicted_price and predicted_price < close\n//MACD\n//[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\n// Plot predicted stock price\nplot(predicted_price, color= color.rgb(65, 59, 150), linewidth=2, title=\"Predicted Price\"\nplot(ta.sma(predicted_price,linearlen), color= color.rgb(199, 43, 64), linewidth=2\n//offset = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nplot(out, color= color.blue, title=\"MA200\")\n[macdLine, signalLine, histLine] = ta.macd(predicted_price, 12, 26, 9)\n//BUY Signal\nlongCondition=false\nmafentry =ta.sma(close, 50) > ta.sma(close, 90)\n//matentry = ta.sma(close, 21) > ta.sma(close, 50)\nmatwohun = close > ta.sma(close, 200)\ntwohunraise = ta.rising(out, 2)\ntwentyrise = ta.rising(outt, 2)\nmacdrise = ta.rising(macdLine,2)\nmacdlong = ta.crossover(predicted_price, ta.wma(predicted_price,linearlen))  and (signalLine\nif macdlong and macdrise\n    longCondition := true\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\n//Sell Signal\nlastEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\ndaysSinceEntry = len\ndaysSinceEntry := int((time - strategy.opentrades.entry_time(strategy.opentrades - \npercentageChange = (close - lastEntryPrice) / lastEntryPrice * 100\n//trailChange = (ta.highest(close,daysSinceEntry) - close) / close * 100\n//label.new(bar_index, high, color=color.black, textcolor=color.white,text=str.tostring(int(trailCha\nshortCondition=false\nmafexit =ta.sma(close, 50) < ta.sma(close, 90)\nmatexit = ta.sma(close, 21) < ta.sma(close, 50)\nmatwohund = close < ta.sma(close, 200)\ntwohunfall = ta.falling(out, 3)\ntwentyfall = ta.falling(outt, 2)\nshortmafall = ta.falling(outthree, 1)\nmacdfall = ta.falling(macdLine,1)\nmacdsell = macdLine < signalLine\nif macdfall and macdsell and (macdLine < signalLine) and ta.falling(low,2)\n    shortCondition := true\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "Hello guys This script follows traditional technical indicators MACD, ADX, RSI and pivot points If the price is above the resistance and the MACD has crossover ,and the RSI 14 is above 50 ADX is higher than 20, and DI+ is higher than DI-. This is a buy signal and vice versa for a sell signal The script moves the stop loss to the entry price after the first target is reached You can specify the quantity you want to sell when the price reaches the first target There are also options like if you want the script to entry long or short, or both you can reverse the strategy if it does not work well If you want to inquire about any details, please let me know in the comments"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 AHMEDABDELAZIZZIZO\n//@version=5\nstrategy(\"Ta Strategy\", overlay=true,initial_capital = 1000 ,default_qty_type = strategy.percent_of_equity\n// inputs\ninversestrategy = input.bool(false, title = \"Inverse Strategy\",tooltip = \"This option makes you reverse the strategy so tha\ndirection = input.string(defval = \"Both\" , options = [\"Both\" , \"Short\" , \"Long\"] )\nleftbars= input(6,title = \" Left Bars\" , group = \"Support and resistance\")\nrightbars = input(6, title = \" Right Bars\", group = \"Support and resistance\")\nmacdfast = input(12, title = \"MACD Fast\", group = \"MACD\")\nmacdslow = input(26, title = \"MACD Slow\",group = \"MACD\")\nmacdsignal = input(7, \"MACD Signal\",group = \"MACD\")\nsellqty = input(50, title = \"QTY to sell at TP 1\")\nlen = input(14, title=\"ADX Length\" , group = \"ADX\")\n// sup and res\nres = fixnan(ta.pivothigh(high,leftbars,rightbars))\nsup = fixnan(ta.pivotlow(low , leftbars,rightbars))\n// macd\nmacd =ta.ema(close,macdfast) - ta.ema(close,macdslow)\nsignal=ta.ema(macd,macdsignal)\n//adx\nup = ta.change(high)\ndown = -ta.change(low)\nplusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\nminusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\ntruerange = ta.rma(ta.tr,len)\nplusDI = 100 * ta.rma(plusDM, len) / truerange\nminusDI = 100 * ta.rma(minusDM, len) / truerange\ndx = 100 * ta.rma(math.abs(plusDI - minusDI) / (plusDI + minusDI), len)\nadx = ta.sma(dx, len)\n// start deal condition\nlongcondition =  ta.crossover(macd,signal) and close > res and ta.rsi(close,14) > \nshortcondition = ta.crossunder(macd,signal) and close < sup and ta.rsi(close,14) <\n//tp\nlongtp1   = input.float(6, \"Long TP 1\", minval = 0.0, step = 0.25, group = \"Exit LONG Orders\"\nlongtp2   = input.float(12, \"Long TP 2\", minval = 0.0, step = 0.25, group = \"Exit LONG Orders\"\nlongsl1 = input.float(3.0, \"Long SL\",  minval = 0.0, step = 0.25, group = \"Exit LONG Orders\"\nlongtakeprofit1 = (strategy.position_avg_price * (1 + longtp1)) \nlongstoploss1 = (strategy.position_avg_price * (1 - longsl1)) \nlongtakeprofit2 = (strategy.position_avg_price * (1 + longtp2)) \n//sl\nshorttp1   = input.float(6.0, \"Short TP 1 \", minval = 0.0, step = 0.25, group = \"Exit SHORT Orders\"\nshorttp2   = input.float(12.0, \"Short TP 2\", minval = 0.0, step = 0.25, group = \"Exit SHORT Orders\"\nshortsl1 = input.float(3.0, \"Short SL\",  minval = 0.0, step = 0.25, group = \"Exit SHORT Orders\"\nshorttakeprofit1 = (strategy.position_avg_price * (1- shorttp1))\nshortstoploss1 = (strategy.position_avg_price * (1 + shortsl1))\nshorttakeprofit2 = (strategy.position_avg_price * (1- shorttp2))\n//placeorders\nif inversestrategy == false\n    if direction == \"Both\"\n        if longcondition and strategy.opentrades == 0\n            strategy.entry(\"long\" , strategy.long )\n        strategy.exit(\"exit long 1\",\"long\",qty_percent = sellqty ,limit = longtakeprofit1\n        strategy.exit(\"exit long 2\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if high >= longtakeprofit1\n            strategy.cancel(\"exit long 2\")\n            strategy.exit(\"exit long 3\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if shortcondition and strategy.opentrades == 0\n            strategy.entry(\"short\",strategy.short)\n        strategy.exit(\"exit short 1\",\"short\",qty_percent = sellqty ,limit = shorttakeprofit1\n        strategy.exit(\"exit short 2\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n        if low <= shorttakeprofit1\n            strategy.cancel(\"exit short 2\")\n        strategy.exit(\"exit short 3\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n    else if direction == \"Long\"\n        if longcondition and strategy.opentrades == 0\n            strategy.entry(\"long\" , strategy.long )\n        strategy.exit(\"exit long 1\",\"long\",qty_percent = sellqty ,limit = longtakeprofit1\n        strategy.exit(\"exit long 2\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if high >= longtakeprofit1\n            strategy.cancel(\"exit long 2\")\n            strategy.exit(\"exit long 3\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n    else if direction == \"Short\"\n        if shortcondition and strategy.opentrades == 0\n            strategy.entry(\"short\",strategy.short)\n        strategy.exit(\"exit short 1\",\"short\",qty_percent = sellqty ,limit = shorttakeprofit1\n        strategy.exit(\"exit short 2\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n        if low <= shorttakeprofit1\n            strategy.cancel(\"exit short 2\")\n        strategy.exit(\"exit short 3\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\nelse\n    if direction == \"Both\"\n        if shortcondition and strategy.opentrades == 0\n            strategy.entry(\"long\" , strategy.long )\n        strategy.exit(\"exit long 1\",\"long\",qty_percent = sellqty ,limit = longtakeprofit1\n        strategy.exit(\"exit long 2\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if high >= longtakeprofit1\n            strategy.cancel(\"exit long 2\")\n            strategy.exit(\"exit long 3\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if longcondition and strategy.opentrades == 0\n            strategy.entry(\"short\",strategy.short)\n        strategy.exit(\"exit short 1\",\"short\",qty_percent = sellqty ,limit = shorttakeprofit1\n        strategy.exit(\"exit short 2\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n        if low <= shorttakeprofit1\n            strategy.cancel(\"exit short 2\")\n        strategy.exit(\"exit short 3\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n    else if direction == \"Long\"\n        if shortcondition and strategy.opentrades == 0\n            strategy.entry(\"long\" , strategy.long )\n        strategy.exit(\"exit long 1\",\"long\",qty_percent = sellqty ,limit = longtakeprofit1\n        strategy.exit(\"exit long 2\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n        if high >= longtakeprofit1\n            strategy.cancel(\"exit long 2\")\n            strategy.exit(\"exit long 3\",\"long\",qty_percent = 100 ,limit = longtakeprofit2\n    else if direction == \"Short\"\n        if longcondition and strategy.opentrades == 0\n            strategy.entry(\"short\",strategy.short)\n        strategy.exit(\"exit short 1\",\"short\",qty_percent = sellqty ,limit = shorttakeprofit1\n        strategy.exit(\"exit short 2\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n        if low <= shorttakeprofit1\n            strategy.cancel(\"exit short 2\")\n        strategy.exit(\"exit short 3\",\"short\",qty_percent = 100 ,limit = shorttakeprofit2\n////////////////////////////////////////////////////////////////////////////////////////////////////\nlsl1 = plot(strategy.position_size <= 0 ? na : longstoploss1, color= color.rgb(124\nltp1 = plot(strategy.position_size <= 0 ? na : longtakeprofit1, color= color.rgb(\nltp2 = plot(strategy.position_size <= 0 ? na : longtakeprofit2, color= color.rgb(\navg = plot(strategy.position_avg_price, color= color.rgb(255, 153, 0, 47), style=\nfill(ltp1,avg , color =strategy.position_size <= 0 ? na :  color.rgb(82, 255, 97,\nfill(ltp2,ltp1 , color =strategy.position_size <= 0 ? na :  color.rgb(82, 255, 97\n////////////////////////////////////////////////////////////////////////////////////////////////////\nssl1 = plot(strategy.position_size >= 0 ? na : shortstoploss1, color= color.red, \nstp1 = plot(strategy.position_size >= 0 ? na : shorttakeprofit2, color= color.green\nstp2 = plot(strategy.position_size >= 0 ? na : shorttakeprofit1, color= color.green\nfill(stp1,avg , color =strategy.position_size >= 0 ? na :  color.rgb(30, 92, 35, \nfill(stp2,stp1 , color =strategy.position_size >= 0 ? na :  color.rgb(30, 92, 35,\n////////////////////////////////////////////////////////////////////////////////////////////////////\nresplot = plot(res, color=ta.change(res) ? na :  #bf141446,  linewidth=3, offset=\nsupplot = plot(sup, color=ta.change(sup) ? na :  #118f113a,  linewidth=3, offset="}]}
{"messages": [{"role": "user", "content": "This is a script that can be used as a strategy or a standalone indicator. The Volume-Weighted Supertrend is a supertrend based on a rolling VWAP, instead of a normal price source. The strategy has two components - a supertrend based off of this VWAP (shown on the chart) and a supertrend from volume itself (not plotted on the chart directly). The supertrend from volume is an example of my \"Supertrend Any Source\" indicator, where a custom ATR is created from non-OHLC data; this is available as both a separate public script and also in my \"wbburgin_utils\" library for you to use in your own script creation. The supertrend from volume acts as a confirmation filter for the VWAP-supertrend shown on-chart. If the volume supertrend is trending up and the VWAP-based supertrend is also trending up, a buy signal is generated. Likewise, if the volume supertrend is trending down and the VWAP-supertrend is trending down, a sell signal is generated. The colors are based off of whether both supertrends are trending up or down: green for both up, blue for only price up, orange for only price down, and red for both down. The settings enable you to change the volume length and the ATR length separately, as well as the multiplier and the source for the price supertrend. If you load the indicator for the first time and see no entries and exits, this is because \"Show Strategy Entries and Exits\" is disabled in the settings. This is if you plan on using the strategy as an indicator and don't want to be bothered by the entry and exit symbols on the chart. Additionally, for those who like clean charts (like me), you can turn all the labels off in the settings, as well as the highlighting. My default strategy settings for the strategy results shown below are as follows: 5% equity per trade, 5 degrees of pyramiding, commissions of 0.08% per trade. This strategy doesn't come with stops yet, so please be aware of that before using it to trade - I highly suggest you create your own stops based off of your R/R ratio and personal risk tolerance. Additionally, it works best on trending assets (b/c of the supertrends) with high volume. This might mean it does not work as well on lower timeframes."}, {"role": "assistant", "content": "import TradingView/ta/5\u200aas ta\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 wbburgin\n//@version=5\nstrategy(\"Volume-Weighted Supertrend Strategy [wbburgin]\", overlay=true, pyramiding\n default_qty_value = 5, commission_value = 0.08, initial_capital = 100000)\nimport wbburgin/wbburgin_utils/2 as u\nvwsupertrend(src, length, factor, atrPeriod) =>\n    atr = ta.atr(atrPeriod)\n    sumPriceVolume = 0.0\n    sumVolume = 0.0\n    for i = 0 to length - 1\n        sumPriceVolume += src[i] * volume[i]\n        sumVolume += volume[i]\n    vwap = sumPriceVolume / sumVolume\n    upperBand = vwap + factor * atr\n    lowerBand = vwap - factor * atr\n    prevLowerBand = nz(lowerBand[1])\n    prevUpperBand = nz(upperBand[1])\n    lowerBand := lowerBand > prevLowerBand or src[1] < prevLowerBand ? lowerBand : \n    upperBand := upperBand < prevUpperBand or src[1] > prevUpperBand ? upperBand : \n    int direction = na\n    float superTrend = na\n    prevSuperTrend = superTrend[1]\n    if na(atr[1])\n        direction := 1\n    else if prevSuperTrend == prevUpperBand\n        direction := close > upperBand ? -1 : 1\n    else\n        direction := close < lowerBand ? 1 : -1\n    superTrend := direction == -1 ? lowerBand : upperBand\n    [superTrend, direction]\nshowStrategy = input(false, title=\"Show Strategy Entries and Exits\")\nsrc = input.source(close,\"Source\")\natrPeriod = input.int(10,\"ATR Period\")\nvolPeriod = input.int(10,\"Volume Length\")\nfactor = input.float(3.0,\"ATR Multiplier\")\nhighlighting = input.bool(true,\"Highlighting\")\nlabels = input.bool(true,\"Labels\")\n[supertrend,dir] = vwsupertrend(src, volPeriod, factor, atrPeriod)\nsupertrend_up = dir == -1 ? supertrend : na\nsupertrend_dn = dir == 1 ? supertrend : na\nsupertrend_up_start = dir == -1 and dir[1] == 1 ? supertrend : na\nsupertrend_dn_start = dir == 1 and dir[1] == -1 ? supertrend : na\nin_rising_trend = supertrend < src\n[volume_supertrend,volume_direction] = u.supertrend_anysource(volume,factor,volPeriod\nvolume_supertrend_change_up = volume_direction[1] == 1 and volume_direction == -1\nvolume_supertrend_change_dn = volume_direction[1] == -1 and volume_direction == 1\nin_rising_volume = volume_supertrend < volume\nbuyconditions = (in_rising_volume and supertrend_up_start) or (volume_supertrend_change_up\nsellconditions = not  in_rising_volume and supertrend_dn_start or (volume_supertrend_change_dn\nif buyconditions and showStrategy\n    strategy.entry(\"Long\",strategy.long)\nif sellconditions and showStrategy\n    strategy.close(\"Long\")\nchangeColor = volume_supertrend_change_dn ?  color.orange : volume_supertrend_change_up\nlinecolor = switch\n    dir == -1 and in_rising_volume =>  color.green\n    dir == 1 and in_rising_volume =>  color.red\n    dir == -1 and not in_rising_volume =>  color.new(color.blue,50)\n    dir == 1 and not in_rising_volume =>  color.new(color.orange,50)\nfillcolor = switch\n    dir == -1 and in_rising_volume =>  color.new(color.green,88)\n    dir == 1 and in_rising_volume =>  color.new(color.red,88)\n    dir == -1 and not in_rising_volume =>  color.new(color.blue,94)\n    dir == 1 and not in_rising_volume =>  color.new(color.orange,94)\nsup = plot(supertrend_up,title=\"Up Supertrend\",color=linecolor,style=plot.style_linebr\nsdn = plot(supertrend_dn,title=\"Down Supertrend\",color=linecolor,style=plot.style_linebr\nmid = plot(hl2,color=na,title=\"HL2 (for Highlighting)\")\nplotshape(supertrend_up_start,title=\"Supertrend Up Start\",style=shape.circle,location\n color=linecolor, size=size.tiny)\nplotshape(supertrend_dn_start,title=\"Supertrend Down Start\",style=shape.circle,location\n color=linecolor, size=size.tiny)\nplotshape(labels==false?na:buyconditions ? supertrend : na,title=\"Supertrend Buy Label\"\n color= color.green,textcolor= color.white,text = \"Buy\")\nplotshape(labels==false?na:sellconditions ? supertrend : na,title=\"Supertrend Sell Label\"\n color= color.red,textcolor= color.white,text = \"Sell\")\nfill(sup,mid,highlighting==true ? fillcolor : na)\nfill(sdn,mid,highlighting==true ? fillcolor : na)"}]}
{"messages": [{"role": "user", "content": "This is a custom indicator that implements a trading strategy based on Renko charts, but they can be used on regular candlestick charts and on any time frame. Renko charts are known for filtering market noise and displaying price movements in a clearer way. However, it is important to note that this indicator is provided for educational and informational purposes only and is not a guarantee of profitable returns. Features: - The indicator uses Renko charts to generate buy and sell signals. - Renko bricks are built based on a predefined price variation, rather than time. - The length of the Average True Range (ATR) used to calculate Renko bricks can be customized. - Buy signals are generated when the price crosses below the current Renko brick. - Sell signals are generated when the price crosses above the current Renko brick. - Entry points are marked with \"Buy\" and \"Sell\" arrows on the chart. It is essential to emphasize that no indicator or trading strategy guarantees profitable results. The financial market is complex and subject to unpredictable changes. It is recommended to perform additional tests and analysis before using this indicator on a real trading account. Always remember to manage your risks properly and consider other factors such as fundamental analysis and market conditions when making trading decisions. The use of this indicator is entirely the user's responsibility. DISCLAIMER: This indicator is not financial advice and should not be interpreted as such. Always consult with a qualified financial professional before making any investment decisions."}, {"role": "assistant", "content": "//@version=5\nstrategy(title='[SMT] Buy & Sell Renko Based - Strategy', shorttitle='[SMT] B&S Renko'\n//INPUTS\nrenkoATRLength = input.int(10, minval=1, title='ATR Length')\n//CALCULATION\nparam = ticker.renko(syminfo.tickerid, 'ATR', renkoATRLength)\nrenkoClose = request.security(param, timeframe.period, close)\nrenkoOpen = request.security(param, timeframe.period, open)\nbuySignal = ta.crossunder(renkoOpen, renkoClose)\nsellSignal = ta.crossover(renkoOpen, renkoClose)\ncol = renkoClose < renkoOpen ?  #F23645 :  #089981\n//PLOTS\nplot(renkoOpen, title=\"Renko Open\", style=plot.style_line, linewidth=2, color=col)\nplotshape(buySignal, \"Buy\", shape.labelup, location.belowbar,  #089981, 0, \"Buy\", \nplotshape(sellSignal, \"Sell\", shape.labeldown, location.abovebar,  #F23645, 0, \"Sell\"\n// STRATEGY\nif (buySignal)\n    strategy.entry(\"Long\", strategy.long)\nif (sellSignal)\n    strategy.entry(\"Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    V2 - Minor Bug Fixes                                                    Release Notes:                                                    V3 - Added : - Take Profit & Stop Loss Placement Methods - Added Code For Deleting Pending Orders With Pine Connector Automation Updated : - Updated To CNTLibrary Version 2 - Updated Monthly Performance Table                                                    Release Notes:                                                    V4 - Added :  - Limit & Stop Order Automation Capabilities Using PineConnector  - Minor Bug Fixes Updated : - Updated To CNTLibrary V3"}, {"role": "assistant", "content": "//==================================================================================================\n// Strategy Header\n//==================================================================================================\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9CN_FX-999\n// \u00a9Christian Nataliano 2022-2023\n// Coded By Christian Nataliano\n// First Coded In 14/06/2023\n// Last Edited In 21/07/2023\n//@version=5\nstrategy(title = \"Default Strategy Template\", shorttitle = \"DefTemp\", overlay = true\n         initial_capital = 100000, currency = currency.USD, \n         max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, \n         use_bar_magnifier = true\n         )\n//Import Libraries\nimport CN_FX-999/CNTLibrary/3 as Cnt\n//==================================================================================================\n// User Inputs\n//==================================================================================================\nvar GDate = \"=== Strategy Testing Date ===\"\nStart_Date              = input.time(defval = timestamp(\"01 Jan 2020 13:30 +0000\")\nEnd_Date                = input.time(defval = timestamp(\"01 Jan 2024 13:30 +0000\")\nTradeDetails            = input.bool(defval = false, title = \"Display Each Trade Details\"\nvar GIndicator = \"=== 1st Indicator Settings ===\"\n//Your Own Indicator Settings Here\nvar GFilter = \"=== Filter Settings ===\"\n//Your Own Filter Settings Here\nvar GRisk = \"=== Risk Management Settings ===\"\nFixedLongSize           = input.int(defval = 0, title = \"Fixed Long Size\", group =\nFixedShortSize          = input.int(defval = 0, title = \"Fixed Short Size\", group \nLongRPT                 = input.float(defval = 1, title = \"Long Risk Per Trade\", group\nShortRPT                = input.float(defval = 1, title = \"Short Risk Per Trade\", \nInLots                  = input.bool(defval = true, title = \"Position Size In Lots\"\nvar GTPSL = \"=== TP / SL Settings ===\"\nATR_Period              = input.int(defval = 20, title = \"ATR Period\", group = GTPSL\nSL_Multiplyer           = input.float(defval = 1, title = \"Stop Loss Multiplyer\", \nRRR                     = input.float(defval = 1, title = \"Risk Reward Ratio\", group\nTPSL_Mode               = input.string(defval = \"Instant TP SL\", title = \"Take Profit & Stop Loss Mode\"\nvar GBT = \"=== Backtest Settings ===\"\nStartingBalance         = input.int(defval = 100000, title = \"Starting Balance\", minval\nShowBacktestPanel       = input.bool(defval = true, title = \"Show Backtest Panel\",\nCalculateFee            = input.bool(defval = true, title = \"Calculate Randomized Fees\"\nMaxFee                  = input.float(defval = 0.025, title = \"Maximum Fee Randomized Rate In %\"\nLongOnly                = input.bool(defval = false, title = \"Trade Long Only\", group\nShortOnly               = input.bool(defval = false, title = \"Trade Short Only\", group\nvar string GPT = \"=== Monthly Performance Table Settings ===\"\nmptable_on              = input.bool(title=\"Turn On |\", defval=true, display=display.none\nmptable_debug           = input.bool(title=\"Debug Mode |\", defval=false, display=display.none\nmptable_precision       = input.int(title=\"Decimal Precision\", defval=2, minval=1,\nmptable_titleColor      = input.color(title=\"Title Cell Color\", defval= #cccccc, \nmptable_titleTextColor  = input.color(title=\"Title Text Color\", defval= #363a45, \nmptable_textColor       = input.color(title=\"Cell Text Color\", defval= color.white\nmptable_ProfitColor     = input.color(title=\"Year Profit Color\", defval= color.new\nmptable_LossColor       = input.color(title=\"Year Loss Color\", defval= color.new(\nmptable_BreakEvenColor  = input.color(title=\"Year B/E Color\", defval= color.new(color.yellow\nmptable_pageNumber      = input.int(title=\"Page Number\", defval=1, minval=1, step=\nmptable_pageSize        = input.int(title=\"Page Size (Rows)\", defval=20, minval=1,\nmptable_tableTextSize   = input.string(title=\"Text Size\", defval=\"Normal\", options\nvar string GPC = \"=== PineConnector Automation Settings ===\"\nConnectedBroker         = input.string(defval = \"FX\", title = \"Connected Broker\", \nAccountID               = input.string(defval = \"1234567890123\", title = \"PineConnector ID\"\nSymbolPrefix            = input.string(defval = \"\", title = \"Traded Symbol Prefix (If Any)\"\nSymbolSuffix            = input.string(defval = \"\", title = \"Traded Symbol Suffix (If Any)\"\nOrderSpread             = input.int(defval = 50, minval = 0, maxval = 100, title =\nOrderComment            = input.string(defval = \"PC Trade\", title = \"Order Comment\"\nUseLimit                = input.bool(defval = false, title = \"Use Limit Order\", group\nUseStop                 = input.bool(defval = false, title = \"Use Stop Order\", group\n//==================================================================================================\n// Indicator Calculation\n//==================================================================================================\nDate_Filter = time >= Start_Date and time <= End_Date\nATR = ta.atr(ATR_Period)\n//Your Indicator Calculations Here\n//==================================================================================================\n// Filters Calculation\n//==================================================================================================\n//Your Filters Calculations Here\n//==================================================================================================\n// Entry & Exit Conditions\n//==================================================================================================\n//Buy & Sell Signal Trigger\nBuy_Signal = Date_Filter and strategy.position_size == 0 and not na(ATR) and not(ShortOnly\nSell_Signal = Date_Filter and strategy.position_size == 0 and not na(ATR) and not(\n//Buy & Sell Exit Signal (If Any)\n//LongExitReason = LongExitReason\n//ShortExitReason = ShortExitReasom\n//==================================================================================================\n// Risk Management Calculation\n//==================================================================================================\n//Set Persistant Variables\nvar float TradeEntry = na\nvar int TradeEntryIndex = na\nvar float TradeTP = na\nvar float TradeSL = na\nvar float TradeLots = na\nvar float BuyPending = na\nvar float SellPending = na\n//Calculate TP SL Levels\nBuySL = Cnt.CalculateStopLossLevel(1, close[0], ATR * SL_Multiplyer)\nSellSL = Cnt.CalculateStopLossLevel(-1, close[0], ATR * SL_Multiplyer)\nBuySLDistance = Cnt.CalculateStopLossDistance(1, close[0], BuySL)\nSellSLDistance = Cnt.CalculateStopLossDistance(-1, close[0], SellSL)\nBuyTP = Cnt.CalculateTakeProfitLevel(1,close[0],BuySLDistance,RRR)\nSellTP = Cnt.CalculateTakeProfitLevel(-1,close[0],SellSLDistance,RRR)  \n//Calculate Lot Size\n[ConvertCurrency,CurrencyConversion] = Cnt.CalculateConversionCurrency(currency.USD\nCurrencyRate = Cnt.CalculateConversionRate(ConvertCurrency,request.security(CurrencyConversion\nBuyUnits = FixedLongSize\nSellUnits = FixedShortSize\nBuyLots = syminfo.type == \"forex\" ? Cnt.LotSize(false,strategy.equity,LongRPT,BuySLDistance\nSellLots = syminfo.type == \"forex\" ? Cnt.LotSize(false,strategy.equity,ShortRPT,SellSLDistance\n//==================================================================================================\n// Strategy Executions\n//==================================================================================================\n//Buy Signal Condition\nif Buy_Signal and barstate.isconfirmed and strategy.position_size == 0 and Cnt.BrokerCheck\n    //Update Persistant Variables\n    TradeEntry := close[0]\n    TradeTP := BuyTP\n    TradeSL := BuySL\n    TradeLots := LongRPT == 0 ? BuyUnits : BuyLots\n    TradeEntryIndex := bar_index\n    //Strategy Entry\n    Cnt.OpenLong(\"Long\", InLots ? Cnt.ToLotsInUnits(TradeLots):TradeLots, na, na, \n    alert(Cnt.OpenPC(AccountID,1,UseLimit,UseStop,BuyPending,SymbolPrefix,syminfo.ticker\n    //Instant TP SL Placement\n    if TPSL_Mode == \"Instant TP SL\"\n        Cnt.TP_SLExit(\"Long\", TradeTP, TradeSL, 100, \"\", \"\")\n//Sell Signal Condition\nif Sell_Signal and barstate.isconfirmed and strategy.position_size == 0 and Cnt.BrokerCheck\n    //Update Persistant Variables\n    TradeEntry := close[0]\n    TradeTP := SellTP\n    TradeSL := SellSL\n    TradeLots := ShortRPT == 0 ? SellUnits : SellLots\n    TradeEntryIndex := bar_index\n    //Strategy Entry\n    Cnt.OpenShort(\"Short\", InLots ? Cnt.ToLotsInUnits(TradeLots):TradeLots, na, na\n    alert(Cnt.OpenPC(AccountID,-1,UseLimit,UseStop,SellPending,SymbolPrefix,syminfo.ticker\n    //Instant TP SL Placement\n    if TPSL_Mode == \"Instant TP SL\"\n        Cnt.TP_SLExit(\"Short\", TradeTP, TradeSL, 100, \"\", \"\")\n//Setting TP & SL Levels On Opened Order\nif TPSL_Mode == \"Normal TP SL\"\n    //Place TP & SL On Next Bar\n    if strategy.position_size > 0\n        Cnt.TP_SLExit(\"Long\", TradeTP, TradeSL, 100, \"\", \"\")\n    if strategy.position_size < 0\n        Cnt.TP_SLExit(\"Short\", TradeTP, TradeSL, 100, \"\", \"\")\n//Close On Conditional Parameters\n//if LongExitReason\n//    Cnt.CloseLong(\"Long\", 100, \"Long Exit With SL Distance Of : \", str.tostring(BuySLDistance,'#.#\n//    alert(Cnt.ClosePC(AccountID,1,SymbolPrefix,syminfo.ticker,SymbolSuffix,OrderComment), alert.fr\n//if ShortExitReason\n//    Cnt.CloseLong(\"Short\", 100, \"Short Exit With SL Distance Of : \", str.tostring(SellSLDistance,'\n//    alert(Cnt.ClosePC(AccountID,-1,SymbolPrefix,syminfo.ticker,SymbolSuffix,OrderComment), alert.f\n//Cancle Pending Orders\n//if TradeEntryIndex != bar_index and strategy.position_size[1] == 0 and strategy.position_size[0] =\n//    strategy.cancel_all()\n//    if Buy_Signal[2] \n//        alert(Cnt.CancelPC(AccountID,1,SymbolPrefix,syminfo.ticker,SymbolSuffix,OrderComment), ale\n//    else if Sell_Signal[2]\n//        alert(Cnt.CancelPC(AccountID,-1,SymbolPrefix,syminfo.ticker,SymbolSuffix,OrderComment), al\n//==================================================================================================\n// Plot Data\n//==================================================================================================\n//Plot Indicator Values\n//Plot Your Indicator Values Here\n//Plot Filter Values\n//Plot Your Filter Indicator Here\n//Plot Signals\nplotshape(not TradeDetails ? Buy_Signal:na, title = \"Buy Entry Signal\", style = shape.triangleup\n         size = size.small, display = display.all - display.status_line)\nplotshape(not TradeDetails ? Sell_Signal:na, title = \"Sell Entry Signal\", style = \n         size = size.small, display = display.all - display.status_line)\nplotshape(not TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\n         title = \"Buy Hit TP\", style = shape.triangledown, location = location.abovebar\nplotshape(not TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\n         title = \"Sell Hit TP\", style = shape.triangleup, location = location.belowbar\nplotshape(not TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\n         title = \"Buy Hit SL\", style = shape.triangleup, location = location.belowbar\nplotshape(not TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\n         title = \"Sell Hit SL\", style = shape.triangledown, location = location.abovebar\n//Plot Trade Info\nplot(strategy.position_size != 0 ? TradeTP:na, title = \"Trade Take Profit\", color \nplot(strategy.position_size != 0 ? TradeSL:na, title = \"Trade Stop Loss\", color = \nplot(strategy.position_size != 0 ? TradeLots:na, title = \"Trade Lots\", color =  color.blue\n//Show QT Trades In Chart\nQTTrades = Cnt.IsQuestionableTrades(TradeTP, TradeSL)\nvar QTTradesCount = 0\nif QTTrades \n    QTTradesCount += 1\nbgcolor(QTTrades ?  color.yellow:na, title = \"Questionable Trades\")\n//==================================================================================================\n// Backtest Data Plotting\n//==================================================================================================\n///Backtest Persistant Data\nvar float Balance = na\nvar float MaxBalance = na\nvar float DD = na\nvar float MaxDD = na\nvar float MeanDD = 0\nvar float PNL = na\nvar float Fee = na\nvar float CumFee = 0\nvar float AvgRRR = 0\nEntryTime = Cnt.UNIXToDate(strategy.closedtrades.entry_time(strategy.closedtrades \nExitTime = Cnt.UNIXToDate(strategy.closedtrades.exit_time(strategy.closedtrades - \n//Backtest Info Data\n[LongWinRate, ShortWinRate, TotalWinRate, WinTrade, LossTrade, TotalLong, TotalShort\nPrevEntry = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\nPrevExit = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\nPrevLots = strategy.closedtrades.size(strategy.closedtrades - 1)\nConvertedPNL = Cnt.Truncate(Cnt.CalculatePNL(PrevEntry, PrevExit, PrevLots,CurrencyRate\nCheckMaxDD = ta.max(DD) \nCheckMeanDD = 0\nCumProfit = Cnt.Truncate(Balance - StartingBalance,2)\nCAGR =  Cnt.Truncate(Cnt.CAGR(Start_Date,StartingBalance,End_Date,Balance) ,2)\n//Update On OrderClose\nif strategy.closedtrades[0] != strategy.closedtrades[1]\n    PNL := ConvertedPNL\n    Balance := Cnt.UpdateBalance(na(Balance) ? StartingBalance:Balance,PNL)\n    if(Balance > MaxBalance) or na(MaxBalance)\n        MaxBalance := Balance\n    DD := Cnt.UpdateDD(MaxBalance, Balance)\n    MaxDD := CheckMaxDD\n    MeanDD := MeanDD[0] + DD\n    Fee := CalculateFee ? Cnt.CalculateSlpComm(PNL,MaxFee):0\n    CumFee := CumFee[1] + Fee\n    AvgRRR := Cnt.CalculateAvgRRR(WinTrade, LossTrade)\n//Draw Backtest Table\nvar table BacktestTable = table.new(position.top_right, 6, 2, border_width = 2)\nvar BgColor =  color.black\nvar TextColor =  color.white\nDollarReturn = Balance - StartingBalance\nif(ShowBacktestPanel)\n    if(barstate.isconfirmed)\n        Cnt.DisplayBTResultsV2(BacktestTable,BgColor,TextColor,TotalWinRate,QTTradesCount\n//Check Draw Conditions\nBuyHitTP = TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\nBuyHitSL = TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\nSellHitTP = TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\nSellHitSL = TradeDetails and strategy.position_size[0] == 0 and strategy.position_size\n//Draw Trade Details\nif BuyHitSL or SellHitTP\n    //Set SL & TP Distance\n    BuySLDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateStopLossDistance(1,TradeEntry\n    BuyTPDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateTakeProfitDistance(1,TradeEntry\n    SellSLDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateStopLossDistance(-1,TradeEntry\n    SellTPDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateTakeProfitDistance(-1,TradeEntry\n    //Label Drawing\n    label.new(bar_index,low, color = BuyHitSL ?  color.orange: color.blue, textcolor\n             tooltip = \n             \"Trade No : \" + str.tostring(strategy.closedtrades) + \n             \"\\nEntryTime : \"  + str.tostring(EntryTime) + \n             \"\\nExitTime : \"  + str.tostring(ExitTime) + \n             \"\\nWinRate : \"  + str.tostring(TotalWinRate) + \"%\" +\n             \"\\nTotalLong : \"  + str.tostring(TotalLong) + \n             \"\\nTotalShort : \"  + str.tostring(TotalShort) + \n              \"\\n\" +\n             \"\\nSLDist : \"  + str.tostring(BuyHitSL ? BuySLDist:SellTPDist) + \n             \"\\nTPDist : \"  + str.tostring(BuyHitSL ? BuyTPDist:SellSLDist) + \n             \"\\nLot : \"  + str.tostring(InLots ? Cnt.Truncate(TradeLots / 100000,2\n              \"\\n\" +\n             \"\\nStartBalnce: \"  + str.tostring(Balance[1]) + \n             \"\\nEndBalnce: \"  + str.tostring(Balance) + \n             \"\\nPNL : \" + str.tostring(PNL) +\n             \"\\nCumProfit: \"  + str.tostring(Balance - strategy.initial_capital) +\n             \"\\n\" +\n             \"\\nFee: \"  + str.tostring(Fee) + \n             \"\\nCumFee: \"  + str.tostring(CumFee) + \n             \"\\n\" +\n             \"\\nMaxBalnce: \"  + str.tostring(MaxBalance) + \n             \"\\nDD: \"  + str.tostring(DD) + \n             \"\\nMaxDD: \"  + str.tostring(MaxDD) +\n             \"\\nMeanDD: \"  + str.tostring(Cnt.Truncate(MeanDD / strategy.closedtrades\n             \"\\nCAGR: \"  + str.tostring(CAGR) + \n             \"\\nCAGR / MeanDD: \"  + str.tostring(Cnt.Truncate(CAGR/MeanDD,2)) + \n             \"\\n\" +\n             \"\\nTotalWR: \"  + str.tostring(TotalWinRate) +\n             \"\\nAvgRRR: \"  + str.tostring(AvgRRR) +\n             \"\\nLongWR: \"  + str.tostring(LongWinRate) +\n             \"\\nShortWR: \"  + str.tostring(ShortWinRate) +\n             \"\\n\" \n             )\nelse if BuyHitTP or SellHitSL\n    //Set SL & TP Distance\n    BuySLDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateStopLossDistance(1,TradeEntry\n    BuyTPDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateTakeProfitDistance(1,TradeEntry\n    SellSLDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateStopLossDistance(-1,TradeEntry\n    SellTPDist = Cnt.Truncate(Cnt.ToWhole(Cnt.CalculateTakeProfitDistance(-1,TradeEntry\n    //Label Drawing\n    label.new(bar_index,high, color = BuyHitTP ?  color.blue: color.orange, textcolor\n             tooltip = \n             \"Trade No : \" + str.tostring(strategy.closedtrades) + \n             \"\\nEntryTime : \"  + str.tostring(EntryTime) + \n             \"\\nExitTime : \"  + str.tostring(ExitTime) +\n             \"\\nWinRate : \"  + str.tostring(TotalWinRate) + \"%\" +\n             \"\\nTotalLong : \"  + str.tostring(TotalLong) + \n             \"\\nTotalShort : \"  + str.tostring(TotalShort) +  \n              \"\\n\" +\n             \"\\nSLDist : \"  + str.tostring(BuyHitTP ? BuySLDist:SellTPDist) + \n             \"\\nTPDist : \"  + str.tostring(BuyHitTP ? BuyTPDist:SellSLDist) + \n             \"\\nLot : \"  + str.tostring(InLots ? Cnt.Truncate(TradeLots / 100000,2\n              \"\\n\" +\n             \"\\nStartBalnce: \"  + str.tostring(Balance[1]) + \n             \"\\nEndBalnce: \"  + str.tostring(Balance) + \n             \"\\nPNL : \" + str.tostring(PNL) +\n             \"\\nCumProfit: \"  + str.tostring(Balance - strategy.initial_capital) +\n             \"\\n\" +\n             \"\\nFee: \"  + str.tostring(Fee) + \n             \"\\nCumFee: \"  + str.tostring(CumFee) + \n             \"\\n\" +\n             \"\\nMaxBalnce: \"  + str.tostring(MaxBalance) + \n             \"\\nDD: \"  + str.tostring(DD) + \n             \"\\nMaxDD: \"  + str.tostring(MaxDD) +\n             \"\\nMeanDD: \"  + str.tostring(Cnt.Truncate(MeanDD / strategy.closedtrades\n             \"\\nCAGR: \"  + str.tostring(CAGR) + \n             \"\\nCAGR / MeanDD: \"  + str.tostring(Cnt.Truncate(CAGR/MeanDD,2)) + \n             \"\\n\" +\n             \"\\nTotalWR: \"  + str.tostring(TotalWinRate) +\n             \"\\nAvgRRR: \"  + str.tostring(AvgRRR) +\n             \"\\nLongWR: \"  + str.tostring(LongWinRate) +\n             \"\\nShortWR: \"  + str.tostring(ShortWinRate) +\n             \"\\n\" \n             )\n//==================================================================================================\n// Table Data Plotting - All Credist To \u00a9 ZenAndTheArtOfTrading For This Section\n//==================================================================================================\n// Custom function for getting table text sized based on user input\ntable_text_size(_size) =>\n    switch _size\n        \"Auto\"   => size.auto   \n        \"Huge\"   => size.huge   \n        \"Large\"  => size.large  \n        \"Normal\" => size.normal \n        \"Small\"  => size.small\n        => size.tiny\ntableTextSize = table_text_size(mptable_tableTextSize)\n// Custom function for getting decimal precision based on given number \n// (eg. if number is > 0 but < 0.05 or < 0 and > -0.05, set precision to 3 to avoid rounding to 0 wh\nGetRoundingPrecision(float num) =>\n    if (num > 0 and num < 0.05) or (num < 0 and num > -0.05)\n        3\n    else\n        mptable_precision\n// Define an open trade's cost (used to calculate commission cost)\ntype TradeCost\n    int entryTime\n    float entryPrice\n    float cost\n// Define a monthly/yearly return type\ntype StrategyReturn\n    float profit\n    float drawdown\n    float peak\n    int timestamp\n// Store accumulated P&L values\nvar float accumulatedMonthlyPL = 0\nvar float accumulatedYearlyPL = 0\nvar float bestAccumulatedMonthlyPL = 0\nvar float bestAccumulatedYearlyPL = 0\n// Store drawdown values\nvar float equityPeak = strategy.initial_capital\nvar float yearlyEquityHigh = 0\nvar float currentYearlyDrawdown = 0\nvar float yearlyMaxDrawdown = 0\nvar float worstDrawdown = 0\nvar float monthlyEquityHigh = 0\nvar float currentMonthlyDrawdown = 0\nvar float monthlyMaxDrawdown = 0\nvar int currentDrawdownBars = 0\nvar int maxDrawdownBars = 0\n// Store stat arrays\nvar totalDrawdownBars = array.new<int>(0)\nvar totalDrawdowns = array.new<float>(0)\n// Store long & short trade count\nvar int totalBreakEvenTrades = 0\nvar int totalLongTrades = 0\nvar int totalLongTradeWins = 0\nvar int totalShortTrades = 0\nvar int totalShortTradeWins = 0\n// Store open trade commission costs in array\nvar costOfOpenTrades = array.new<TradeCost>(0)\n// Detect opened trade and save cost of trade (I tried many methods to get my numbers to match the C\nif strategy.opentrades != strategy.opentrades[1] and strategy.closedtrades == strategy.closedtrades\n    costOfTrade = strategy.grossloss - strategy.grossloss[1]\n    costOfOpenTrades.push(TradeCost.new(strategy.opentrades.entry_time(strategy.opentrades\n// Detect a closed trade\n// TV Documentation: Trade List's Cumulative Profit % Formula = TradeProfit / (InitialCapital + Cumu\nif strategy.closedtrades != strategy.closedtrades[1]\n        // Retrieve trade cost for the closed trade\n    float tradeCost = 0\n    int removeIdx = -1\n    if costOfOpenTrades.size() > 0\n        for i = 0 to costOfOpenTrades.size() - 1\n            TradeCost tc = costOfOpenTrades.get(i)\n            if tc.entryTime == strategy.closedtrades.entry_time(strategy.closedtrades\n                tradeCost := tc.cost\n                removeIdx := i \n                break\n        // Remove cost\n    if removeIdx != -1\n        costOfOpenTrades.remove(removeIdx)\n    // Calculate equity before trade closed (strategy.equity will not do, because it changes bar-by-bar \n    float preEquity = strategy.initial_capital + strategy.netprofit[1]\n    // Calculate P&L + cost of this trade\n    float profitLoss = 0 \n    if strategy.losstrades > strategy.losstrades[1]\n        profitLoss := (strategy.grossloss - (strategy.grossloss[1] - tradeCost)) *\n    else\n        profitLoss := strategy.grossprofit - strategy.grossprofit[1]\n        // Check if this was a long or short trade and if it won or lost\n    if strategy.position_size[1] > 0\n        totalLongTrades := totalLongTrades + 1\n        if profitLoss > 0\n            totalLongTradeWins := totalLongTradeWins + 1\n    else if strategy.position_size[1] < 0\n        totalShortTrades := totalShortTrades + 1\n        if profitLoss > 0\n            totalShortTradeWins := totalShortTradeWins + 1\n            // Check if the trade broke even\n    if profitLoss == 0\n        totalBreakEvenTrades := totalBreakEvenTrades + 1\n    // Calculate cumulative profit % for this trade \n    float cumulativeProfitPercent = (profitLoss / preEquity) * 100\n    // Store highest peak value of equity (we can now use strategy.equity since equity has updated to re\n    if strategy.equity > equityPeak\n        equityPeak := strategy.equity\n    // Calculate total system drawdown %\n    float equityDD = ((strategy.equity - equityPeak) / equityPeak) * 100\n    if equityDD < worstDrawdown\n        worstDrawdown := equityDD\n    // Store accumulated monthly + yearly P&L\n    accumulatedMonthlyPL := cumulativeProfitPercent + accumulatedMonthlyPL[1]\n    accumulatedYearlyPL := accumulatedYearlyPL + cumulativeProfitPercent\n    // Save max favourable excursion for this month (ie. peak return as %)\n    if accumulatedMonthlyPL > bestAccumulatedMonthlyPL\n        bestAccumulatedMonthlyPL := accumulatedMonthlyPL\n    // Save max favourable excursion for this year (ie. peak return as %)\n    if accumulatedYearlyPL > bestAccumulatedYearlyPL\n        bestAccumulatedYearlyPL := accumulatedYearlyPL\n    // Track max equity high over current year for max yearly drawdown calculation\n    if accumulatedYearlyPL > yearlyEquityHigh\n        yearlyEquityHigh := accumulatedYearlyPL\n        // Check if our yearly realized equity high minus current realized equity exceeds our stored max dra\n    if accumulatedYearlyPL - yearlyEquityHigh < 0\n        currentYearlyDrawdown := accumulatedYearlyPL - yearlyEquityHigh\n        if currentYearlyDrawdown < yearlyMaxDrawdown\n            yearlyMaxDrawdown := currentYearlyDrawdown\n        currentDrawdownBars := currentDrawdownBars + 1\n        // Track max equity high over current month for max monthly drawdown calculation\n    if accumulatedMonthlyPL > monthlyEquityHigh\n        monthlyEquityHigh := accumulatedMonthlyPL\n        // Check if our monthly realized equity high minus current realized equity exceeds our stored max dr\n    if accumulatedMonthlyPL - monthlyEquityHigh < 0\n        currentMonthlyDrawdown := accumulatedMonthlyPL - monthlyEquityHigh\n        if currentMonthlyDrawdown < monthlyMaxDrawdown\n            monthlyMaxDrawdown := currentMonthlyDrawdown\n        // Debug label\n    if mptable_debug\n        string debugTip = \"Equity = $\" + str.tostring(strategy.equity, \"#.##\") + \n         \"\\nP&L=\" + str.tostring(cumulativeProfitPercent) + \"%\" +\n         \"\\nAccumMonthlyP&L=\" + str.tostring(math.round(accumulatedMonthlyPL, GetRoundingPrecision\n         \"\\nAccumYearlyP&L=\" + str.tostring(math.round(accumulatedYearlyPL, GetRoundingPrecision\n         \"\\nMonthlyMaxDD=\" + str.tostring(math.round(monthlyMaxDrawdown, GetRoundingPrecision\n         \"\\nYearlyMaxDD=\" + str.tostring(math.round(yearlyMaxDrawdown, GetRoundingPrecision\n         \"\\nTotalMaxDD=\" + str.tostring(math.round(worstDrawdown, GetRoundingPrecision\n         \"\\nCurrentDDBars=\" + str.tostring(currentDrawdownBars) +\n         \"\\nMaxDDBars=\" + str.tostring(maxDrawdownBars) +\n         \"\\nTotalBreakEven=\" + str.tostring(totalBreakEvenTrades) +\n         \"\\nTotalLongs=\" + str.tostring(totalLongTrades) +\n         \"\\nTotalLongWins=\" + str.tostring(totalLongTradeWins) +\n         \"\\nTotalShorts=\" + str.tostring(totalShortTrades) +\n         \"\\nTotalShortWins=\" + str.tostring(totalShortTradeWins)\n        label.new(bar_index, high + (high * 0.01), \"P&L \" + str.tostring(math.round\n// Calculate drawdown since last equity high (NOT max drawdown, just the current max DD since we wer\nfloat t_equityDD = ((strategy.equity - equityPeak) / equityPeak) * 100\nvar float currentMaxDrawdownSinceLast = 0\n// Update Max Drawdown bar count and current DD if equity is under water, check isconfirmed to preve\nif strategy.equity < equityPeak and barstate.isconfirmed\n    currentDrawdownBars := currentDrawdownBars + 1\n    if currentDrawdownBars > maxDrawdownBars\n        maxDrawdownBars := currentDrawdownBars\n    if t_equityDD < currentMaxDrawdownSinceLast\n        currentMaxDrawdownSinceLast := t_equityDD\nelse\n    if currentDrawdownBars > 0\n        totalDrawdownBars.push(currentDrawdownBars)\n        totalDrawdowns.push(currentMaxDrawdownSinceLast)\n    currentDrawdownBars := 0\n    currentMaxDrawdownSinceLast := 0\n// Prepare arrays to store Yearly and Monthly P&Ls\nvar monthlyReturns = array.new<StrategyReturn>(0)\nvar yearlyReturns = array.new<StrategyReturn>(0)\nvar bool firstEntryTime = false\n// Retrieve entry time of initial entry in open position\nif not firstEntryTime and strategy.opentrades.entry_time(0)\n    firstEntryTime := true\n// Detect new month and year\nnew_month = month(time) != month(time[1])\nnew_year = year(time) != year(time[1])\n// Detect a new month and store its return profile\nif not barstate.isfirst and new_month and firstEntryTime or barstate.islastconfirmedhistory\n    StrategyReturn mr = StrategyReturn.new(accumulatedMonthlyPL, monthlyMaxDrawdown\n    monthlyReturns.push(mr)\n    accumulatedMonthlyPL := 0\n    monthlyMaxDrawdown := 0\n    monthlyEquityHigh := 0\n    currentMonthlyDrawdown := 0\n    bestAccumulatedMonthlyPL := 0\n    // Detect a new year and reset tracking variables\nif not barstate.isfirst and new_year and firstEntryTime or barstate.islastconfirmedhistory\n    StrategyReturn yr = StrategyReturn.new(accumulatedYearlyPL, yearlyMaxDrawdown,\n    yearlyReturns.push(yr)\n    accumulatedYearlyPL := 0\n    yearlyMaxDrawdown := 0\n    yearlyEquityHigh := 0\n    currentYearlyDrawdown := 0\n    bestAccumulatedYearlyPL := 0\n// DEBUG code\nbgcolor(mptable_debug and new_month ?  color.lime : na, title=\"New Month\", display\nbgcolor(mptable_debug and new_year ?  color.red : na, title=\"New Year\", display=display.none\n// END DEBUG CODE\n// Define Monthly P&L Table    \nvar table performance_table = table(na)\n//Adjust mptable_pageSize if the years are less than the mptable_pageSize\nif yearlyReturns.size() < mptable_pageSize\n    mptable_pageSize := yearlyReturns.size()\n// Caluclate the start and end of page to display\nstartIndex = math.max(math.min(yearlyReturns.size() - 1, yearlyReturns.size() - 1 \nendIndex = math.max(startIndex - mptable_pageSize, 0)\nmptable_pageSize := endIndex <= mptable_pageSize ? endIndex : mptable_pageSize\n// If this is the last bar on our chart, display the performance table\nvar int EXTRA_STAT_ROWS = 5 // This ensures table includes enough rows for CAGR etc\nif mptable_on and monthlyReturns.size() > 0 and barstate.islastconfirmedhistory\n    // Create table (100 rows = 100 years of data, should be plenty for all markets!)\n    performance_table := table.new(position.bottom_right, columns=17, rows=yearlyReturns\n    // Set column headers\n    performance_table.cell(0, 0, \"Year\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(1, 0, \"Jan\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(2, 0, \"Feb\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(3, 0, \"Mar\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(4, 0, \"Apr\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(5, 0, \"May\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(6, 0, \"Jun\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(7, 0, \"Jul\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(8, 0, \"Aug\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(9, 0, \"Sep\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(10, 0, \"Oct\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(11, 0, \"Nov\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(12, 0, \"Dec\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(13, 0, \"TOTAL\", bgcolor=mptable_titleColor, text_color=\n    performance_table.cell(14, 0, \"MaxDD\", bgcolor=mptable_titleColor, text_color=\n    // Set yearly values\n    for year_index = startIndex to yearlyReturns.size() == 0 ? na : endIndex\n                // Get yearly return for this loop, set year number in first column, determine color of cell\n        StrategyReturn yearlyReturn = yearlyReturns.get(year_index)\n        // Set year title and determine color\n        performance_table.cell(0, year_index + 1, str.tostring(year(yearlyReturn.timestamp\n        color y_color = yearlyReturn.profit > 0 ? mptable_ProfitColor : yearlyReturn\n        // Populate yearly cell values\n        string yearlyTip = \"MaxDD: \" + str.tostring(math.round(yearlyReturn.drawdown\n             \"\\nMFE: \" + str.tostring(math.round(yearlyReturn.peak, GetRoundingPrecision\n        performance_table.cell(13, year_index + 1, (yearlyReturn.profit > 0 ? \"+\" \n        performance_table.cell(14, year_index + 1, str.tostring(math.round(yearlyReturn\n        // Set monthly values\n        for month_index = 0 to monthlyReturns.size() - 1\n            // Get monthly return for this loop, get current year for this loop, then calculate the correspondin\n            StrategyReturn monthlyReturn = monthlyReturns.get(month_index)\n            int yearOfMonth = year(monthlyReturn.timestamp)\n            int monthCol = month(monthlyReturn.timestamp)\n                        // populate monthly profit only if the years of the yearly return match with the monthly return. \n            if yearOfMonth == year(yearlyReturn.timestamp)\n                 // Determine color for monthly P&L\n                color m_color = monthlyReturn.profit > 0 ? color.new(mptable_ProfitColor\n                                // Set monthly P&L cell\n                string monthlyTip = \"MaxDD: \" + str.tostring(math.round(monthlyReturn\n                     \"\\nMFE: \" + str.tostring(math.round(monthlyReturn.peak, GetRoundingPrecision\n                performance_table.cell(monthCol, year_index + 1, str.tostring(math.round\n    float percentReturn = (strategy.netprofit / strategy.initial_capital) * 100\n    float cagr = (math.pow((strategy.netprofit + strategy.initial_capital) / strategy.initial_capital\n    float mar = cagr / math.abs(worstDrawdown)\n    lastMonthRowIndex = startIndex < 5 ? 5 : startIndex\n    // Populate table data\n    float totalWinRate = (strategy.wintrades / strategy.closedtrades) * 100\n    float longWinRate = nz((totalLongTradeWins / totalLongTrades) * 100)\n    float shortWinRate = nz((totalShortTradeWins / totalShortTrades) * 100)\n    string returnTip = \"Based on a total of \" + str.tostring(strategy.closedtrades\n         \"\\nWin Rate = \" + str.tostring(math.round(totalWinRate, GetRoundingPrecision\n         \"\\nLong Trades = \" + str.tostring(totalLongTrades) + \" (Win \" + str.tostring\n         \"\\nShort Trades = \" + str.tostring(totalShortTrades) + \" (Win \" + str.tostring\n    //performance_table.cell(15, lastMonthRowIndex, \"Return: \" + (percentReturn > 0 ? \"+\" : \"\") + str.to\n    //performance_table.cell(15, lastMonthRowIndex - 1, \"MAR: \" + str.tostring(mar, \"#.##\"), bgcolor=mpt\n    //performance_table.cell(15, lastMonthRowIndex - 2, \"DD Bars: \" + str.tostring(maxDrawdownBars), bgc\n    //performance_table.cell(15, lastMonthRowIndex - 3, \"MaxDD: \" + str.tostring(math.round(worstDrawdow\n    //performance_table.cell(15, lastMonthRowIndex - 4, \"CAGR: \" + (cagr > 0 ? \"+\" : \"\") + str.tostring(\n    //performance_table.cell(15, lastMonthRowIndex - 5, \"REALIZED P&L\", bgcolor=mptable_titleColor, text\n//==================================================================================================\n// End Of Code\n//=================================================================================================="}]}
{"messages": [{"role": "user", "content": "**User Guide for the \"Heikin Ashi ROC Percentile Strategy\"** This strategy, \"Heikin Ashi ROC Percentile Strategy\", is designed to provide an easy-to-use framework for trading based on the Heikin Ashi Rate of Change (ROC) and its percentiles. Here's how you can use it: 1. **Setting the Start Date**: You can set the start date for the strategy in the user inputs at the top of the script. The variable `startDate` defines the point from which the script begins executing trades. Simply input the desired date in the format \"YYYY MM DD\". For example, to start the strategy from March 3, 2023, you would enter `startDate = timestamp(\"2023 03 03\")`. 2. **Adjusting the Midline, Lookback Period, and Stop Loss Level**: The `zerohLine`, `rocLength`, and `stopLossLevel` inputs allow you to adjust the baseline for ROC, the lookback period for the SMA and ROC, and the level at which the strategy stops the loss, respectively. By tweaking these parameters, you can fine-tune the strategy to better suit your trading style or the particular characteristics of the asset you are trading. 3. **Understanding the Trade Conditions**: The script defines conditions for entering and exiting long and short positions based on crossovers and crossunders of the ROC and the upper and lower \"kill lines\". These lines are defined as certain percentiles of the ROC's highest and lowest values over a specified lookback period. When the ROC crosses above the lower kill line, the script enters a long position; when it crosses below the upper kill line, it exits the position. Similarly, when the ROC crosses below the upper kill line, the script enters a short position; when it crosses above the lower kill line, it exits the position. In my testing, this strategy performed best on a day and hour basis. However, I encourage you to experiment with different timeframes and settings to see how the strategy performs under various conditions. Remember, there's no one-size-fits-all approach to trading; what works best will depend on your specific circumstances, goals, and risk tolerance. If you find other useful applications for this strategy, please let me know in the comments. Your feedback is invaluable in helping to refine and improve this tool. Happy trading!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 jensenvilhelm\n//@version=5\nstrategy(\"Heikin Ashi ROC Percentile Strategy\", shorttitle=\"ROC ON\" , overlay=false\n// User Inputs\nzerohLine = input(0, title=\"Midline\")  // Zero line, baseline for ROC (customer can modif\nrocLength = input(100, title=\"roc Length\")  // Lookback period for SMA and ROC (customer can m\nstopLossLevel = input(2, title=\"Stop Loss (%)\")  // Level at which the strategy stops the loss (cus\nstartDate = timestamp(\"2015 03 03\")  // Start date for the strategy (customer can modif\n// Heikin Ashi values\nvar float haClose = na  // Define Heikin Ashi close price\nvar float haOpen = na  // Define Heikin Ashi open price\nhaClose := ohlc4  // Calculate Heikin Ashi close price as average of OHLC4 (no customer modification needed here)\nhaOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2  // Calculate Heikin Ashi open price (no customer m\n// ROC Calculation\nroc = ta.roc(ta.sma(haClose, rocLength), rocLength)  // Calculate Rate of Change (ROC) (customer can mo\nrocHigh = ta.highest(roc, 50)  // Get the highest ROC of the last 50 periods (customer can modify this to adjust lookback period)\nrocLow = ta.lowest(roc, 50)  // Get the lowest ROC of the last 50 periods (customer can modify this to adjust lookback period)\nupperKillLine = ta.percentile_linear_interpolation(rocHigh, 10, 75)  // Calculate upper kill line (customer can modify \nlowerKillLine = ta.percentile_linear_interpolation(rocLow, 10, 25)  // Calculate lower kill line (customer can modify \n// Trade conditions\nenterLong = ta.crossover(roc, lowerKillLine)  // Define when to enter long positions (customer c\nexitLong = ta.crossunder(roc, upperKillLine)  // Define when to exit long positions (customer ca\nenterShort = ta.crossunder(roc, upperKillLine)  // Define when to enter short positions (customer \nexitShort = ta.crossover(roc, lowerKillLine )  // Define when to exit short positions (customer c\n// Strategy execution\nif(time >= startDate)  // Start strategy from specified start date\n    if (enterLong)\n        strategy.entry(\"Long\", strategy.long)  // Execute long trades\n    if (exitLong)\n        strategy.close(\"Long\")  // Close long trades\n    if (enterShort)\n        strategy.entry(\"Short\", strategy.short)  // Execute short trades\n    if (exitShort)\n        strategy.close(\"Short\")  // Close short trades\n// Plotting\nplot(zerohLine,title=\"Zeroline\")  // Plot zero line\nplot(roc, \"RSI\", color= color.rgb(248, 248, 248))  // Plot ROC\nplot(rocHigh, \"Roc High\", color =  color.rgb(175, 78, 76))  // Plot highest ROC\nplot(rocLow, \"Roc Low\", color =  color.rgb(175, 78, 76))  // Plot lowest ROC\nplot(upperKillLine, \"Upper Kill Line\", color =  color.aqua)  // Plot upper kill line\nplot(lowerKillLine, \"Lower Kill Line\", color =  color.aqua)  // Plot lower kill line"}]}
{"messages": [{"role": "user", "content": "Trailing Stop with RSI - Momentum-Based Strategy Description: The Trailing Stop with RSI strategy combines momentum analysis and trailing stop functionality to help traders identify potential entry and exit points in their trading decisions. This strategy is suitable for various markets and timeframes. Key Features:     Momentum Analysis: The strategy incorporates momentum indicators to identify potential buying and selling opportunities based on momentum shifts in the price.     Trailing Stop Functionality: The strategy utilizes a trailing stop to protect profits and dynamically adjust the stop loss level as the trade moves in the desired direction.     RSI Confirmation: The Relative Strength Index (RSI) is included to provide additional confirmation for trade entries by considering overbought and oversold conditions. How to Use:     Entry Conditions: Long positions are triggered when positive momentum is detected, and the RSI confirms an oversold condition. Short positions are triggered when negative momentum is detected, and the RSI confirms an overbought condition.     Trailing Stop Activation: Once a position is opened, the trailing stop is activated when the specified profit level (as a percentage) is reached.     Trailing Stop Level: The trailing stop maintains a stop loss level at a specified distance (as a percentage) from the highest profit achieved since opening the position.     Exit Conditions: The trailing stop will trigger an exit and close all positions when the trailing stop level is breached. Markets and Conditions: This strategy can be applied to various markets, including stocks, forex, cryptocurrencies, and commodities. It can be used in trending and ranging market conditions, making it versatile for different market environments. Important Considerations:     Adjust Parameters: Traders can modify the length of the momentum and RSI indicators to suit their preferred timeframe and trading style.     Risk Management: It is recommended to consider appropriate position sizing, risk-to-reward ratios, and overall risk management practices when using this strategy.     Backtesting and Optimization: Traders are encouraged to backtest the strategy on historical data and optimize the parameters to find the best settings for their chosen market and timeframe. By incorporating momentum analysis, trailing stop functionality, and RSI confirmation, this strategy aims to provide traders with a systematic approach to capturing profitable trades while managing risk effectively."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Trailing Stop with RSI\", overlay=true)\nlength = input.int(12, \"Momentum Length\")\nprice = close\nmomentum(seria, length) =>\n    mom = seria - seria[length]\n    mom\nmom0 = momentum(price, length)\nmom1 = momentum(mom0, 1)\nrsiLength = input.int(14, \"RSI Length\")\nrsiOverbought = input(70, \"RSI Overbought Level\")\nrsiOversold = input(30, \"RSI Oversold Level\")\nrsiValue = ta.rsi(close, rsiLength)\ntsact = input.float(0.0, \"Trailing Stop Activation (%)\", group=\"strategy\", tooltip=\ntsact := tsact ? tsact : na\nts = input.float(0.0, \"Position Trailing Stop (%)\", group=\"strategy\", tooltip=\"Trails your position with a stop loss at this dis\nts := ts ? ts : na\nin_long = strategy.position_size > 0\nin_short = strategy.position_size < 0\nvar ts_ = array.new_float()\nts_size = array.size(ts_)\nts_get = ts_size > 0 ? array.get(ts_, ts_size - 1) : 0\nif in_long\n    if tsact and high > strategy.position_avg_price + strategy.position_avg_price *\n        if ts_size > 0 and ts_get < high\n            array.push(ts_, high)\n        if ts_size < 1\n            array.push(ts_, high)\n    if not tsact\n        if ts_size > 0 and ts_get < high\n            array.push(ts_, high)\n        if ts_size < 1\n            array.push(ts_, high)\nif in_short\n    if tsact and low < strategy.position_avg_price - strategy.position_avg_price * \n        if ts_size > 0 and ts_get > low\n            array.push(ts_, low)\n        if ts_size < 1\n            array.push(ts_, low)\n    if not tsact\n        if ts_size > 0 and ts_get > low\n            array.push(ts_, low)\n        if ts_size < 1\n            array.push(ts_, low)\ntrail = in_long and ts_size > 0 ? low < ts_get - ts_get * ts : in_short and ts_size\nif (mom0 > 0 and mom1 > 0)\n    strategy.entry(\"MomLE\", strategy.long, stop=high+syminfo.mintick, comment=\"MomLE\"\nelse\n    strategy.cancel(\"MomLE\")\nif (mom0 < 0 and mom1 < 0)\n    strategy.entry(\"MomSE\", strategy.short, stop=low-syminfo.mintick, comment=\"MomSE\"\nelse\n    strategy.cancel(\"MomSE\")\ntsClose = in_long ? ts_get - ts_get * ts : in_short ? ts_get + ts_get * ts : na\nif trail\n    strategy.close_all()\nif not strategy.opentrades\n    array.clear(ts_)\nrsiOverboughtCondition = rsiValue >= rsiOverbought\nrsiOversoldCondition = rsiValue <= rsiOversold\nif rsiOverboughtCondition\n    strategy.close(\"SHORT\", \"SX\")\n    strategy.entry(\"LONG\", strategy.long)\nif rsiOversoldCondition\n    strategy.close(\"LONG\", \"LX\")\n    strategy.entry(\"SHORT\", strategy.short)\nplotchar(ts_get, \"GET\", \"\")\nplot(strategy.position_avg_price > 0 ? strategy.position_avg_price : na, \"Average\",\nplot(tsClose > 0 ? tsClose : na, \"Trailing\",  color.rgb(251, 64, 64), 2, plot.style_cross\nplot(strategy.position_avg_price - strategy.position_avg_price * tsact > 0 ? strategy.position_avg_price"}]}
{"messages": [{"role": "user", "content": "1. The script is a trading strategy based on the Williams %R indicator and a 200-period moving average (MA) filter. 2. The user can input the length of the Williams %R indicator (`wrLength`), the threshold for %R crossing (`crossPips`), the take profit level in pips (`takeProfitPips`), and the stop loss level in pips (`stopLossPips`). 3. The script calculates the Williams %R using the `ta.highest` and `ta.lowest` functions to find the highest high and lowest low over the specified length (`wrLength`). 4. It also calculates a 200-period simple moving average (`ma200`) using the `ta.sma` function. 5. The entry conditions are defined as follows:    - For a long entry, it checks if the Williams %R crosses above the -50 line by a threshold of `crossPips` and if the close price is above the 200-period MA.    - For a short entry, it checks if the Williams %R crosses below the -50 line by a threshold of `crossPips` and if the close price is below the 200-period MA. 6. The exit conditions are defined as follows:    - For a long position, it checks if the close price reaches the take profit level (defined as the average entry price plus `takeProfitPips` in pips) or the stop loss level (defined as the average entry price minus `stopLossPips` in pips).    - For a short position, it checks if the close price reaches the take profit level (defined as the average entry price minus `takeProfitPips` in pips) or the stop loss level (defined as the average entry price plus `stopLossPips` in pips). 7. The script uses the `strategy.entry` function to place long and short orders when the respective entry conditions are met. 8. It uses the `strategy.close` function to close the long and short positions when the respective exit conditions are met. The script allows you to customize the parameters such as the length of Williams %R, the crossing threshold, take profit and stop loss levels, and the moving average period to suit your trading preferences."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Williams %R Cross Strategy with MA Filter\", overlay=true)\n// User Inputs\nwrLength = input(14, title=\"Williams %R Length\")\ncrossPips = input(10, title=\"Cross Threshold (Pips)\")\ntakeProfitPips = input(30, title=\"Take Profit (Pips)\")\nstopLossPips = input(20, title=\"Stop Loss (Pips)\")\n// Calculate Williams %R\nwrHigh = ta.highest(high, wrLength)\nwrLow = ta.lowest(low, wrLength)\nwr = (wrHigh - close) / (wrHigh - wrLow) * -100\n// Calculate 200-period Simple Moving Average\nma200 = ta.sma(close, 200)\n// Entry Conditions\nenterLong = ta.crossover(wr, -50 - crossPips) and close > ma200\nenterShort = ta.crossunder(wr, -50 + crossPips) and close < ma200\n// Exit Conditions\nexitLong = close >= (strategy.position_avg_price + (takeProfitPips / syminfo.mintick\nexitShort = close <= (strategy.position_avg_price - (takeProfitPips / syminfo.mintick\n// Order Management\nif enterLong\n    strategy.entry(\"Long\", strategy.long)\n    if enterShort\n    strategy.entry(\"Short\", strategy.short)\nif exitLong\n    strategy.close(\"Long\")\nif exitShort\n    strategy.close(\"Short\")"}]}
{"messages": [{"role": "user", "content": "The Z-score, also known as the standard score, is a statistical measurement that describes a value's relationship to the mean of a group of values. It's measured in terms of standard deviations from the mean. If a Z-score is 0, it indicates that the data point's score is identical to the mean score. Z-scores may be positive or negative, with a positive value indicating the score is above the mean and a negative score indicating it is below the mean. The concept of Z-score was introduced by statistician Carl Friedrich Gauss as part of his \"method of the least squares,\" which was an important step in the development of the normal distribution and Z-score tables. It's a key concept in statistics and is used in various statistical tests. In financial analysis, Z-scores are used to determine whether a data point is usual or unusual. You can think of it as a measure of how many standard deviations an element is from the mean. For instance, a Z-score of 1.0 would denote a value that is one standard deviation from the mean. Z-scores are also used to predict probabilities, with Z-scores having a distribution that is expected to be normal. In trading, a Z-score is used to determine how often a trading system may produce a string of winners or losers. It can help a trader to understand whether the losses or profits they see are something that the system would most likely produce, or if it's a once in a blue moon situation. This helps traders make decisions about when to start or stop a system. I just wanted to play a bit with the Z-score I guess.  Feel free to share your findings if you discover additional applications for this strategy or identify timeframes where it appears to perform more optimally. How it works: This strategy is based on a statistical concept called Z-score, which measures the number of standard deviations a data point is from the mean. In other words, it helps determine how unusual or usual a data point is. In the context of this strategy, Z-score is applied to a 10-period EMA (Exponential Moving Average) of Heikin-Ashi candlestick close prices. The Z-score is calculated over a look-back period of 25 bars. The EMA of the Z-score is then calculated over a 20-bar period, and the upper and lower thresholds (bounds for buy and sell signals) are defined using the 90th and 10th percentiles of this EMA score. Long positions are taken when the Z-score crosses above the lower threshold or crosses above the mid-line (50th percentile). An additional long entry is made when the Z-score crosses above the highest value the EMA has been in the past 100 periods. Short positions are initiated when the EMA crosses below the upper threshold, lower threshold or the highest value the EMA has been in the past 100 periods. Positions are closed when opposing entry conditions are met, for example, a long position is closed when the short entry condition is true, and vice versa. Set your desired start date for the strategy. This can be modified in the timestamp(\"YYYY MM DD\") function at the top of the script."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 jensenvilhelm\n// Here is an attempt to create a robust strategy for BTCUSD on a 5 minute chart\n// I can't seem to get this code to work the way i want.... if you want to give it a try, please let\n// how it goes in comment section. \n//@version=5\n// Define the strategy settings\nstrategy(\"The Z-score\", shorttitle=\"TZS\", overlay=true)\n// User can set the start date for the strategy\nstartDate = timestamp(\"2023 06 01\")\n// Heikin-Ashi Open, Close, High and Low calculation\nhaClose = ohlc4\nvar float haOpen = na\nhaOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2\nhaHigh = math.max(nz(haOpen, high), nz(haClose, high), high)\nhaLow = math.min(nz(haOpen, low), nz(haClose, low), low)\n// Function to calculate the Z-Score\nz_score(_series, _length) =>\n    _mean = ta.sma(_series, _length)\n    _stddev = ta.stdev(_series, _length)\n    (_series - _mean) / _stddev\n// Compute the score and its EMA\nscore = z_score(ta.ema(haClose, 10), 25)\nemaScore = ta.ema(score, 20)\n// Calculate lower and upper thresholds using percentiles of EMA\nlowerBlue = ta.percentile_linear_interpolation(emaScore, 50, 10)\nupperBlue = ta.percentile_linear_interpolation(emaScore, 50, 90)\n// Calculate the middle line as 50th percentile\nmiddleLine = ta.percentile_linear_interpolation(emaScore, 50, 50) \n// Plot the EMA of the score and the thresholds\nplot(emaScore,\"The White Line\", color= color.white, linewidth=2)\nplot(lowerBlue,\"Lower Blue Line\", linewidth=2)\nplot(upperBlue, \"Upper Blue Line\", linewidth=2)\nplot(middleLine, \"Middle Yellow Line\", linewidth=2, color= color.yellow)\nplot(score,\"The Z-Score Mixed With EMA 10\", color= color.green)\n// Calculate highest and lowest EMA score over 100 bars period\nhighest = ta.highest(emaScore, 100)\nlowest = ta.lowest(emaScore, 100)\n// Plot highest and lowest EMA score lines \nplot(highest, \"Highest of emaScore\", color= color.red, linewidth=2)\nplot(lowest, \"Lowest of emaScore\", color= color.red, linewidth=2)\n// Define entry and exit conditions for long and short positions\nlongCon = ta.crossover(score, lowerBlue) or ta.crossover(emaScore, middleLine)\naddOn = ta.crossover(score, highest)\nshortCon = ta.crossunder(emaScore, upperBlue) or ta.crossunder(emaScore, lowerBlue)\n// Execute trading logic based on conditions and after the start date\nif (time >= startDate)\n    if longCon\n        strategy.entry(\"Long\", strategy.long)\n        if shortCon\n            strategy.close(\"Long\")\n    if addOn\n        strategy.entry(\"LongNR2\", strategy.long)\n        if shortCon\n            strategy.close(\"LongNR2\")\n        if shortCon\n        strategy.entry(\"Short\", strategy.short)\n        if longCon\n            strategy.close(\"Short\")"}]}
{"messages": [{"role": "user", "content": "Dostlar selamlar, \u0130\u015fte son derece basit ama etkili ve h\u0131zl\u0131, HTF de \u00e7ok iyi sonu\u00e7lar veren bir strateji daha, hepinize bol kazan\u00e7lar dilerim ... Nedir, Nas\u0131l \u00c7al\u0131\u015f\u0131r: Strateji, iki ana girdiye dayan\u0131r: SMA ve RSI. SMA hesaplama aral\u0131\u011f\u0131 200 olarak, RSI ise 14 olarak ayarlanm\u0131\u015ft\u0131r. Bu de\u011ferler, kullan\u0131c\u0131 tercihlerine veya geriye d\u00f6n\u00fck test sonu\u00e7lar\u0131na g\u00f6re ayarlanabilir. Strateji, iki ko\u015ful kar\u015f\u0131land\u0131\u011f\u0131nda bir short sinyali olu\u015fturur: RSI de\u011feri, belirlenen bir giri\u015f seviyesini (burada 51 olarak belirlenmi\u015f) a\u015far ve kapan\u0131\u015f fiyat\u0131 SMA de\u011ferinin alt\u0131ndad\u0131r. Strateji, k\u0131sa pozisyonu \u00fc\u00e7 durumda kapat\u0131r: Kapan\u0131\u015f fiyat\u0131, takip eden durdurma seviyesinden (pozisyon a\u00e7\u0131ld\u0131\u011f\u0131ndan beri en d\u00fc\u015f\u00fck kapan\u0131\u015f olarak belirlenmi\u015ftir) b\u00fcy\u00fckse, RSI de\u011feri belirlenen bir durdurma seviyesini (bu durumda 54) a\u015farsa veya RSI de\u011feri belirli bir kar al seviyesinin (bu durumda 32) alt\u0131na d\u00fc\u015ferse. G\u00fc\u00e7l\u00fc Y\u00f6nleri: \u0130ki farkl\u0131 g\u00f6sterge (SMA ve RSI) kullan\u0131m\u0131, yaln\u0131zca birini kullanmaktan daha sa\u011flam bir sinyal sa\u011flayabilir. Strateji, karlar\u0131 korumaya ve fiyat dalgalanmalar\u0131nda kay\u0131plar\u0131 s\u0131n\u0131rlamaya yard\u0131mc\u0131 olabilecek bir iz s\u00fcren durdurma seviyesi i\u00e7erir. Script olduk\u00e7a anla\u015f\u0131l\u0131r ve de\u011fi\u015ftirmesi nispeten kolayd\u0131r. Zay\u0131f Y\u00f6nleri: Strateji, hacim, oynakl\u0131k veya daha geni\u015f piyasa e\u011filimleri gibi di\u011fer potansiyel \u00f6nemli fakt\u00f6rleri g\u00f6z \u00f6n\u00fcnde bulundurmaz. RSI seviyeleri ve SMA s\u00fcresi i\u00e7in belirli parametreler sabittir ve t\u00fcm piyasa ko\u015fullar\u0131 veya zaman aral\u0131klar\u0131 i\u00e7in optimal olmayabilir. Strateji olduk\u00e7a basittir. Trade maliyetini (kayma veya komisyonlar gibi) hesaba katmaz, bu da trade performans\u0131n\u0131 \u00f6nemli \u00f6l\u00e7\u00fcde etkileyebilir. Bu Stratejiyle Nas\u0131l \u0130\u015flem Yap\u0131l\u0131r: Strateji, short i\u015flemler i\u00e7in tasarlanm\u0131\u015ft\u0131r. RSI, 51'in \u00fczerine \u00e7\u0131kt\u0131\u011f\u0131nda ve kapan\u0131\u015f fiyat\u0131 200 periyotluk SMA'n\u0131n alt\u0131nda oldu\u011funda i\u015fleme girer. RSI, 54'\u00fcn \u00fczerine \u00e7\u0131kt\u0131\u011f\u0131nda veya 32'nin alt\u0131na d\u00fc\u015ft\u00fc\u011f\u00fcnde veya fiyat, pozisyon a\u00e7\u0131ld\u0131\u011f\u0131ndan beri en d\u00fc\u015f\u00fck kapan\u0131\u015f fiyat\u0131n\u0131n \u00fczerine \u00e7\u0131kt\u0131\u011f\u0131nda i\u015flemi kapat\u0131r. L\u00fctfen Dikkat, bu strateji veya herhangi bir strateji izole bir \u015fekilde kullan\u0131lmamal\u0131d\u0131r. T\u00fcm bu \u00e7al\u0131\u015fmalar e\u011fitsel ama\u00e7l\u0131d\u0131r. Yat\u0131r\u0131m tavsiyesi i\u00e7ermez. This script defines a trading strategy based on Simple Moving Average (SMA) and the Relative Strength Index (RSI) indicators. Here's an overview of how it works, along with its strengths and weaknesses, and how to trade using this strategy: How it works: The strategy involves two key inputs: SMA and RSI. The SMA length is set to 200, and the RSI length is set to 14. These values can be adjusted based on user preferences or back-testing results. The strategy generates a short signal when two conditions are met: The RSI value crosses over a defined entry level (set at 51 here), and the closing price is below the SMA value. When a short signal is generated, the strategy opens a short position. The strategy closes the short position under three conditions: If the close price is greater than the trailing stop (which is set as the lowest close since the position opened), if the RSI value exceeds a defined stop level (54 in this case), or if the RSI value drops below a certain take-profit level (32 in this case). Strengths: The use of two different indicators (SMA and RSI) can provide a more robust signal than using just one. The strategy includes a trailing stop, which can help to protect profits and limit losses as the price fluctuates. The script is straightforward and relatively easy to understand and modify. Weaknesses: The strategy doesn't consider other potentially important factors, such as volume, volatility, or broader market trends. The specific parameters for the RSI levels and SMA length are hard-coded, and may not be optimal for all market conditions or timeframes. The strategy is very simplistic. It doesn't take into account the cost of trading (like slippage or commissions), which can significantly impact trading performance. How to trade with this strategy: The strategy is designed for short trades. It enters a trade when the RSI crosses above 51 and the closing price is below the 200-period SMA. It will exit the trade when the RSI goes above 54 or falls below 32, or when the price rises above the lowest closing price since the position was opened. Please note, this strategy or any strategy should not be used in isolation. It's important to consider other aspects of trading such as risk management, capital allocation, and combining different strategies to diversify. Back-testing the strategy on historical data and demo trading before going live is also a recommended practice."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 abdllhatn\n//@version=5\nstrategy(\"Alpha Short SMA and RSI Strategy\", overlay=true, initial_capital=10000, default_qty_value\n// Inputs\nsma_length = input(200, title=\"SMA Length\")\nrsi_length = input(14, title=\"RSI Length\")\nrsi_entry = input(51, title=\"RSI Entry Level\")\nrsi_stop = input(54, title=\"RSI Stop Level\")\nrsi_take_profit = input(32, title=\"RSI Take Profit Level\")\n// Indicators\nsma_value = ta.sma(close, sma_length)\nrsi_value = ta.rsi(close, rsi_length)\nvar float trailingStop = na\nvar float lastLow = na\n// Conditions\nshortCondition = ta.crossover(rsi_value, rsi_entry) and close < sma_value\nif (shortCondition)\n    strategy.entry(\"Sell\", strategy.short)\n    trailingStop := na\n    lastLow := na\nif (strategy.position_size < 0)\n    if (na(lastLow) or close < lastLow)\n        lastLow := close\n        trailingStop := close\nif not na(trailingStop) and close > trailingStop\n    strategy.close(\"Sell\")\nif (rsi_value >= rsi_stop)\n    strategy.close(\"Sell\")\nif (rsi_value <= rsi_take_profit)\n    strategy.close(\"Sell\")\n// Plot\nplot(sma_value, color= color.red, linewidth=2)"}]}
{"messages": [{"role": "user", "content": "Hello dear Traders, Here is a simple yet effective strategy to use, for best profit higher time frame, such as daily. Structure of the code The code defines inputs for SMA (simple moving average) length, RSI (relative strength index) length, RSI entry level, RSI stop loss level, and RSI take profit level. The default values of these variables can be customized as per the user's preferences. The script calculates SMA and RSI based on the input parameters and the closing price of the asset. Trading logic This strategy allows the placement of a long position when: The RSI crosses above the RSI entry level and The close price is above the SMA value. After entering a long position, it applies a trailing stop mechanism. The stop price is updated to the close price if the close price is lower than the last close price. The script closes the long position when: RSI falls below the stop loss level. RSI reaches or exceeds the take profit level. If the trailing stop is activated (once RSI reaches or exceeds the take profit level), the closing price falls below the trailing stop level. Strengths The strategy includes mechanisms for entering a position, taking profit, and stopping losses, which are fundamental aspects of a trading strategy. It applies a trailing stop mechanism that allows to capture further gains if the price keeps increasing while protecting from losses if the price starts to decrease. Weaknesses This strategy only contemplates long positions. Depending on the market situation, the strategy may miss opportunities for short selling when the market is on a downward trend. The choice of the fixed RSI entry, stop loss, and take profit levels may not be ideal for all market conditions or assets. It might benefit from a more adaptive mechanism that adjusts these levels according to market volatility or trend. The strategy doesn't factor in trading costs (such as spread or commission), which could have a significant impact on the net profit, especially if the user is trading with a high frequency or in a low liquidity market. How to trade with this strategy Given these parameters and the strategy outlined by the code, the trader would enter a long position when the RSI crosses above the RSI entry level (default 34) and the closing price is above the SMA value (SMA calculated with default period of 200). The trader would exit the position when either the RSI falls below the RSI stop loss level (default 30), or RSI rises above the RSI take profit level (default 50), or when the trailing stop is hit. Remember \"The strategies I have prepared are entirely for educational purposes and should not be considered as investment advice. Support your trades using other tools. Wishing everyone profitable trades...\""}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 abdllhatn\n//@version=5\nstrategy(\"Alpha RSI Breakout Strategy\", overlay=true, initial_capital=10000, default_qty_value\n// Inputs\nsma_length = input(200, title=\"SMA Length\")\nrsi_length = input(14, title=\"RSI Length\")\nrsi_entry = input(34, title=\"RSI Entry Level\")\nrsi_stop_loss = input(30, title=\"RSI Stop Loss Level\")\nrsi_take_profit = input(50, title=\"RSI Take Profit Level\")\n// Indicators\nsma_value = ta.sma(close, sma_length)\nrsi_value = ta.rsi(close, rsi_length)\nvar bool trailing_stop_activate = false\nvar float trailingStop = na\nvar float lastClose = na\n// Conditions\nlongCondition = ta.crossover(rsi_value, rsi_entry) and close > sma_value\nif (longCondition)\n    strategy.entry(\"Buy\", strategy.long)\n    trailingStop := na\n    lastClose := na\n    trailing_stop_activate := false\nif (strategy.position_size > 0)\n    if (na(lastClose) or close < lastClose)\n        lastClose := close\n        trailingStop := close\n    if (rsi_value >= rsi_take_profit)\n        trailing_stop_activate := true\nif (trailing_stop_activate and not na(trailingStop) and close < trailingStop)\n    strategy.close(\"Buy\")\nif (rsi_value <= rsi_stop_loss)\n    strategy.close(\"Buy\")\nif (not trailing_stop_activate and rsi_value >= rsi_take_profit)\n    strategy.close(\"Buy\")\nif (trailing_stop_activate and rsi_value >= rsi_take_profit)\n    strategy.close(\"Buy\")\n// Plot\nplot(sma_value, color= color.red, linewidth=2)\nplot(rsi_value, color= color.blue, linewidth=2)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    The \"Mechanical Trading Strategy\" is a simple and systematic approach to trading that aims to capture short-term price movements in the financial markets. This strategy focuses on executing trades based on specific conditions and predetermined profit targets and stop loss levels. Key Features: Profit Target: The strategy allows you to set a profit target as a percentage of the entry price. This target represents the desired level of profit for each trade. Stop Loss: The strategy incorporates a stop loss level as a percentage of the entry price. This level represents the maximum acceptable loss for each trade, helping to manage risk. Entry Condition: The strategy triggers trades at a specific time. In this case, the condition for entering a trade is based on the hour of the candle being 16 (4:00 PM). This time-based entry condition provides a systematic approach to executing trades. Position Sizing: The strategy determines the position size based on a fixed percentage of the available equity. This approach ensures consistent risk management and allows for potential portfolio diversification. Execution: When the entry condition is met, signified by the hour being 16, the strategy initiates a long position using the strategy.entry function. It sets the exit conditions using the strategy.exit function, with a limit order for the take profit level and a stop order for the stop loss level. Take Profit and Stop Loss: The take profit level is calculated by adding a percentage of the entry price to the entry price itself. This represents the profit target for the trade. Conversely, the stop loss level is calculated by subtracting a percentage of the entry price from the entry price. This level represents the maximum acceptable loss for the trade. By using this mechanical trading strategy, traders can establish a disciplined and systematic approach to their trading decisions. The predefined profit target and stop loss levels provide clear exit rules, helping to manage risk and potentially maximize returns. However, it is important to note that no trading strategy is guaranteed to be profitable, and careful analysis and monitoring of market conditions are always recommended.                                                    Release Notes:                                                    added hour input                                                    Release Notes:                                                    Typo error                                                    Release Notes:                                                    Added logic for short testing.                                                    Release Notes:                                                    Change variable name                                                    Release Notes:                                                    Remove comments"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Mechanical Trading Strategy\", overlay=true)\nprofitTarget = input(0.4, \"Profit Target (%)\") / 100\nstopLoss = input(0.2, \"Stop Loss (%)\") / 100\ntradeHour = input(16, \"Enter Hour you want to trade every day\")\nisShort = input(false, \"check this box if you want to test short/selling trade\")\nentryPrice = close\nif (hour(time) == tradeHour)\n    if(isShort)\n        takeProfitLevel = entryPrice - (entryPrice * profitTarget)\n        stopLossLevel =  entryPrice + (entryPrice * stopLoss)\n        strategy.entry(\"Sell\", strategy.short)\n        strategy.exit(\"Take Profit\", \"Sell\", limit=takeProfitLevel,stop = stopLossLevel\n    else\n        takeProfitLevel = entryPrice + (entryPrice * profitTarget)\n        stopLossLevel =  entryPrice - (entryPrice * stopLoss)\n        strategy.entry(\"Buy\", strategy.long)\n        strategy.exit(\"Take Profit\", \"Buy\", limit=takeProfitLevel,stop = stopLossLevel"}]}
{"messages": [{"role": "user", "content": "RSI-CCI Fusion Strategy: Harnessing the Power of RSI and CCI The \"RSI-CCI Fusion Strategy\" is a powerful trading approach that combines the strengths of the Relative Strength Index (RSI) and the Commodity Channel Index (CCI) to provide enhanced trading insights. This strategy is based on the popular \"RSI & CCI Fusion + Alerts\" indicator, which utilizes the RSI and CCI indicators from TradingView. 1. Overview of RSI and CCI: The Relative Strength Index (RSI) is a widely used momentum oscillator that measures the speed and change of price movements. It helps traders identify overbought and oversold conditions in the market. On the other hand, the Commodity Channel Index (CCI) is a versatile indicator that identifies cyclical trends and provides insights into overbought and oversold levels. 2. The RSI-CCI Fusion Strategy: The RSI-CCI Fusion Strategy harnesses the combined power of the RSI and CCI indicators to generate robust trading signals. By blending the RSI and CCI, this strategy captures both momentum and cyclical trend dynamics, offering a more comprehensive view of the market. 3. Utilizing the RSI-CCI Fusion Indicator + Alerts: The \"RSI & CCI Fusion + Alerts\" indicator serves as the backbone of the RSI-CCI Fusion Strategy. It integrates the RSI and CCI indicators from TradingView, providing traders with a clear and actionable trading signal. 4. How it Works: - The indicator calculates the RSI and CCI values, standardizes them using z-score, and combines them with a weighted fusion approach. - The resulting RSI-CCI Fusion indicator is plotted on the chart, accompanied by dynamic upper and lower bands, which help identify potential overbought and oversold conditions. - Traders can customize alerts based on their preferred thresholds and timeframes, enabling them to receive timely notifications for potential buy and sell signals. 5. Implementing the RSI-CCI Fusion Strategy: Traders following the RSI-CCI Fusion Strategy can utilize the buy and sell signals generated by the RSI-CCI Fusion indicator. When the indicator crosses below the upper band, it may signal a potential selling opportunity. Conversely, when it crosses above the lower band, it may indicate a potential buying opportunity. Traders can also consider additional factors and technical analysis tools to validate the signals before making trading decisions. Conclusion: The RSI-CCI Fusion Strategy provides traders with a robust approach to analyze the market and make well-informed trading decisions. By incorporating the RSI and CCI indicators through the \"RSI & CCI Fusion + Alerts\" indicator, traders can take advantage of the combined strengths of these indicators. However, it is important to remember that no strategy guarantees success, and traders should always practice risk management and conduct thorough analysis before executing trades using this strategy. Disclaimer: Trading involves risks, and it is important to conduct your own research and consult with a financial advisor before making any investment decisions. Note: The RSI-CCI Fusion Strategy serves as a general guide, and individual traders may have different preferences and trading styles."}, {"role": "assistant", "content": "// \u00a9 Julien_Eche\n//@version=5\nstrategy(\"RSI-CCI Fusion Strategy\", shorttitle=\"RSI-CCI Fusion Strategy\", overlay=true\nlength = input(14, title=\"Length\")\nrsi_weight = input.float(0.5, title=\"RSI Weight\", minval=0.0, maxval=1.0)\ncci_weight = 1.0 - rsi_weight\nenableShort = input(false, \"Enable Short Positions\")\nsrc = close\nrsi = ta.rsi(src, length)\ncci = ta.cci(src, length)\n// Standardize the RSI and CCI values using z-score\nrsi_std = ta.stdev(rsi, length)\nrsi_mean = ta.sma(rsi, length)\nrsi_z = (rsi - rsi_mean) / rsi_std\ncci_std = ta.stdev(cci, length)\ncci_mean = ta.sma(cci, length)\ncci_z = (cci - cci_mean) / cci_std\n// Combine the standardized RSI and CCI\ncombined_z = rsi_weight * rsi_z + cci_weight * cci_z\n// Rescale to the original scale\nrescaled = combined_z * ta.stdev(combined_z, length) + ta.sma(combined_z, length)\n// Calculate dynamic upper and lower bands\nupper_band = ta.sma(rescaled, length) + ta.stdev(rescaled, length)\nlower_band = ta.sma(rescaled, length) - ta.stdev(rescaled, length)\n// Buy and sell conditions\nbuySignal = ta.crossover(rescaled, lower_band)\nsellSignal = ta.crossunder(rescaled, upper_band)\n// Enter long position\nif buySignal\n    strategy.entry(\"Buy\", strategy.long)\n// Exit long position\nif sellSignal\n    strategy.close(\"Buy\")\n// Enter short position if enabled\nif enableShort and sellSignal\n    strategy.entry(\"Sell\", strategy.short)\n// Exit short position if enabled\nif enableShort and buySignal\n    strategy.close(\"Sell\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    I have modified the conditions to make them more conventional. Everyone can make their own adjustments.                                                    Release Notes:                                                    I forgot to update the chart.                                                    Release Notes:                                                    I have enabled short positions."}, {"role": "assistant", "content": "// \u00a9 Julien_Eche\n//@version=5\nstrategy(\"Ultimate Balance Strategy\", overlay=false, default_qty_type=strategy.percent_of_equity\n// Indicator Weights\nweightROC = input.float(2, \"Rate of Change (ROC) Weight\", group=\"Weightings\")\nweightRSI = input.float(0.5, \"Relative Strength Index (RSI) Weight\", group=\"Weightings\"\nweightCCI = input.float(2, \"Commodity Channel Index (CCI) Weight\", group=\"Weightings\"\nweightWilliamsR = input.float(0.5, \"Williams %R Weight\", group=\"Weightings\")\nweightADX = input.float(0.5, \"Average Directional Index (ADX) Weight\", group=\"Weightings\"\nenableShort = input(false, \"Enable Short Positions\")\n// Overbought/Oversold Levels\nobLevel = input.float(0.75, \"Overbought Level\")\nosLevel = input.float(0.25, \"Oversold Level\")\n// MA Type\nmaType = input.string(\"SMA\", \"MA Type\", options=[\"SMA\", \"EMA\", \"WMA\", \"DEMA\"], group\nmaLength = input.int(9, \"MA Length\", minval=1)\n// Calculating the indicators\nrocValue = ta.change(close, 20)\nrsiValue = ta.rsi(close, 14)\ncciValue = (close - ta.sma(close, 20)) / (0.015 * ta.dev(close, 20))\nwilliamsRValue = -100 * (ta.highest(high, 14) - close) / (ta.highest(high, 14) - ta.lowest\ndirmov(len) =>\n    up = ta.change(high)\n    down = -ta.change(low)\n    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\n    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n    truerange = ta.rma(ta.tr, len)\n    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)\n    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)\n    [plus, minus]\nadx(dilen, adxlen) =>\n    [plus, minus] = dirmov(dilen)\n    sum = plus + minus\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)\nadxValue = adx(14, 14)\n// Normalizing the values\nnormalize(value, min, max) =>\n    (value - min) / (max - min)\nnormalizedROC = normalize(rocValue, ta.lowest(rocValue, 20), ta.highest(rocValue, 20\nnormalizedRSI = normalize(rsiValue, 0, 100)\nnormalizedCCI = normalize(cciValue, ta.lowest(cciValue, 20), ta.highest(cciValue, 20\nnormalizedWilliamsR = normalize(williamsRValue, ta.lowest(williamsRValue, 14), ta.highest\nnormalizedADX = normalize(adxValue, 0, 50)\n// Calculating the combined oscillator line\noscillatorLine = (normalizedROC * weightROC + normalizedRSI * weightRSI + normalizedCCI\n// Moving Average\nma = ta.sma(oscillatorLine, maLength)\n// Buy and sell conditions\nbuySignal = ta.crossover(ma, osLevel)\nsellSignal = ta.crossunder(ma, obLevel)\n// Enter long position\nif buySignal\n    strategy.entry(\"Buy\", strategy.long)\n// Exit long position\nif sellSignal\n    strategy.close(\"Buy\")\n// Enter short position if enabled\nif enableShort and sellSignal\n    strategy.entry(\"Sell\", strategy.short)\n// Exit short position if enabled\nif enableShort and buySignal\n    strategy.close(\"Sell\")\n//  Plotting\nplot(oscillatorLine, title=\"Ultimate Balance Oscillator\", color= color.rgb(41, 98,\nplot(ma, title=\"Moving Average\", color= color.orange)\nhline(obLevel, \"Overbought\", color= color.gray, linestyle=hline.style_dotted)\nhline(osLevel, \"Oversold\", color= color.gray, linestyle=hline.style_dotted)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    - Updated Alerts with API input for bot trading - Added Dashboard to show strategy results & new Time filtering (Credits @VerMT) - Improved code structuring for displaying Signals - Changed default entry signal to Entry1 - Price crossing Tenkan Line - Reduced TP levels from 5 to 3 - Separate ATRs for SL and TP                                                    Release Notes:                                                    - Improved X- Exit Signals as indicator                                                    Release Notes:                                                    - Improved plotting Letters/emojis (giving more accurate entries based on default settings/user choice)4 and removed overflowing exit signals - Improved logic for Kumo cloud plotting - Improvement on logic for Entry signals ( 3 types of entry conditions now) - Removed option for Reverse & Reopen Deals - Improved 2 Ichimoku Signal Filter system ( Above/below Kumo cloud and Bullish/Bearish Kijun) - Corrected and replaced Alerts Input codes ( thanks to @Daveatt templates)                                                    Release Notes:                                                    - Updated Kumo Plotting & Filters - Added optional Exit signals to be used as Indicator"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n//@version=5\n//@strategy_alert_message {{strategy.order.alert_message}}\"\n//Base Indicator SuperIchi from LuxALgo with changes\n//Created by Mia & Nomi\n//Backtester template from @Haldro \n//Dashboard & Time filter template from Vermt\nstrategy('CITI Moku Strategy(Free) by @MiaIsTheNewBird', shorttitle = \"CITI Moku Strategy (Free)\"\n         overlay           = true,\n         initial_capital   = 10000,\n         commission_value  = 0.025,\n         default_qty_value = 25,\n         slippage          = 1,\n         pyramiding        = 0,\n         max_lines_count   = 500,\n         max_labels_count  = 500,\n         currency          = currency.USD,\n         default_qty_type  = strategy.percent_of_equity)\n//------------------------------------------------------------------------------\ntenkan_len  = input(9,'Tenkan',inline='tenkan',group=\"Ichimoku Lines & Cloud Settings\"\ntenkan_mult = input(2.,'',inline='tenkan',group=\"Ichimoku Lines & Cloud Settings\")\nkijun_len   = input(26,'Kijun',inline='kijun',group=\"Ichimoku Lines & Cloud Settings\"\nkijun_mult  = input(8.,'',inline='kijun',group=\"Ichimoku Lines & Cloud Settings\")\nspanB_len   = input(52,'Senkou Span B',inline='span',group=\"Ichimoku Lines & Cloud Settings\"\nspanB_mult  = input(8.,'',inline='span',group=\"Ichimoku Lines & Cloud Settings\")\nchikou_offset      = input(26,'Chikou Offset',group=\"Ichimoku Lines & Cloud Settings\"\nkumo_offset        = input(26,'Kumo Offset',group=\"Ichimoku Lines & Cloud Settings\"\n//------------------------------------------------------------------------------\navg(src,length,mult)=>\n    atr = ta.atr(length)*mult\n    up = hl2 + atr\n    dn = hl2 - atr\n    upper = 0.,lower = 0.\n    upper := src[1] < upper[1] ? math.min(up,upper[1]) : up\n    lower := src[1] > lower[1] ? math.max(dn,lower[1]) : dn\n       os = 0,max = 0.,min = 0.\n    os := src > upper ? 1 : src < lower ? 0 : os[1]\n    spt = os == 1 ? lower : upper\n    max := ta.cross(src,spt) ? math.max(src,max[1]) : os == 1 ? math.max(src,max[1\n    min := ta.cross(src,spt) ? math.min(src,min[1]) : os == 0 ? math.min(src,min[1\n    math.avg(max,min)\ntenkan = avg(close,tenkan_len,tenkan_mult)\nkijun = avg(close,kijun_len,kijun_mult)\nsenkouA = math.avg(kijun,tenkan)\nsenkouB = avg(close,spanB_len,spanB_mult)\nchikou = close\n//------------------------------------------------------------------------------\nplot(tenkan, title = 'Tenkan-Sen', linewidth=1, color= #32C4EE )\nplot(kijun, title = 'Kinjun-Sen', linewidth=1, color= #EC3E6F )\nplot(chikou, title = 'Chikou Span', linewidth=1, offset = -chikou_offset+1, color=\ncloud_a =  #0C3D4E       \ncloud_b =  #451721 \nA = plot(senkouA,'Senkou Span A',na,offset=kumo_offset-1)\nB = plot(senkouB,'Senkou Span B',na,offset=kumo_offset-1)\nfill(A,B,senkouA > senkouB ? cloud_a : cloud_b)\n//Entry Signals\nEntry1 = input.bool(false, title=\"Price Crossing Tenkan Line\", group=\"Entry Signals Settings - Select Conditions for En\nEntry2 = input.bool(true, title=\"Tenkan Line Crossing Kijun Line\", group=\"Entry Signals Settings - Select Conditions for En\nEntry3 = input.bool(false, title=\"Price Crossing Kijun Line\", group=\"Entry Signals Settings - Select Conditions for En\nEntry1Long = Entry1 ? ta.crossover(close,tenkan) : true\nEntry2Long = Entry2 ? ta.crossover(tenkan,kijun) : true\nEntry3Long = Entry3 ? ta.crossover(close,kijun) : true\nEntry1Short = Entry1 ? ta.crossunder(close,tenkan) : true\nEntry2Short = Entry2 ? ta.crossunder(tenkan,kijun) : true\nEntry3Short = Entry3 ? ta.crossunder(close,kijun) : true\n//Assemble Entries\nlongEntry = Entry1Long and Entry2Long and Entry3Long \nshortEntry = Entry1Short and Entry2Short and Entry3Short \n// Exit Signals\nExit1 = input.bool(false, title=\"Price Crossunder Tenkan Line\", group=\"Exit Signals Settings- Use as Indicator\"\nExit2 = input.bool(true, title=\"Tenkan Line Crossunder Kijun Line\", group=\"Exit Signals Settings- Use as Indicator\"\nExit3 = input.bool(false, title=\"Price Crossunder Kijun Line\", group=\"Exit Signals Settings- Use as Indicator\"\n//Assemble Exit Filters\nExit1Long = Exit1 ? ta.crossunder(close,tenkan) : true\nExit2Long = Exit2 ? ta.crossunder(tenkan,kijun) : true\nExit3Long = Exit3 ? ta.crossunder(close,kijun) : true\nExit1Short = Exit1 ? ta.crossover(close,tenkan) : true\nExit2Short = Exit2 ? ta.crossover(tenkan,kijun) : true\nExit3Short = Exit3 ? ta.crossover(close,kijun) : true\n//Assemble Exits\nlongExit = Exit1Long and Exit2Long and Exit3Long \nshortExit = Exit1Short and Exit2Short and Exit3Short \n///Plot Letters as Indicators\nvar bool PlotLong = input.bool (true, \"Plot Buy Trades\" , group=\"Use as Indicator\"\nvar bool PlotShorts = input.bool (true, \"Plot Sell Trades\" , group=\"Use as Indicator\"\nvar bool PlotLongExit = input.bool (true, \"Plot Buy- Exit Trades\" , group=\"Use as Indicator\"\nvar bool PlotShortsExit = input.bool (true, \"Plot Sell- Exit Trades\" , group=\"Use as Indicator\"\n//Backtester from @Haldro\n// \u2014\u2014\u2014\u2014\u2014\u2014 ToolTips\nTTreversesignal  = 'Wait End Deal- Enable/Disable waiting for a trade to close at Stop Loss/Take Profit. Until the trad\nTTreOpenDeal     = 'ReEntry Deal- If true trade was long and  SL/TP was reached then go long again and vice versa. \\n'\n                 + 'ReOpen Deal- If true and Wait End Deal is false then in case you are in a Long position and a new s\nTTslType         = 'Fixed%- Fixed SL/TP in percent. \\n'\n                 + 'Fixed$- Fixed SL/TP in cash. \\n'\n                 + 'Trailing %- Trailing stop in % like on exchanges. Regulated by the \"Trailing%\" parameter. \\n'\n                 + 'Fast Trail- If in a long, it immediately follows the price when it rises otherwise it stands still.\n                 + 'ATR - Fixed TP/SL depending on the current ATR. It is regulated by the \"ATR period\" | \"Multiplier\" \n                 + 'R:R- Risk Reward sets the TP depending on the size of the SL. For example, if SL is $100, and R:R =\n                 + 'HH/LL- Searches for the last Extremum (High/Low) for the specified number of bars and sets a fixed \n                 + 'LO/HI Sets the SL for High/Low candles. \"LO/HI\" = 1 Sets the SL for the last High/Low. \\n'\n                 + 'MA- Movinng Average SL. A very diverse type of SL.'\n// \u2014\u2014\u2014\u2014\u2014\u2014 Main Inputs\nbullDeal         = input.bool   (true,        '\u2002Long Deals\u2002\u2002\u2002\u2002',      group='Trade Direction'\nbearDeal         = input.bool   (true,        '\u2002Short Deals',         group='Trade Direction'\ngroupset         = 'TP-SL Strategy'\nwaitEndDeal      = input.bool   (true,        '\u2002Wait End Deal\u2002',      group=groupset\nreEntryDeal      = input.bool   (true,       '\u2002ReEntry Deal\u2002\u2002',      group=groupset\ntpType           = input.string ('ATR TP',       '\u2002\ud835\udc13\ud835\udc1a\ud835\udc24\ud835\udc1e\u2002\ud835\udc0f\ud835\udc2b\ud835\udc28\ud835\udc1f\ud835\udc22\ud835\udc2d',        group=groupset\nslType           = input.string ('ATR SL', '\u2002\ud835\udc12\ud835\udc2d\ud835\udc28\ud835\udc29\u2002\ud835\udc0b\ud835\udc28\ud835\udc2c\ud835\udc2c\u200a',          group=groupset, \ngrouptakes       = 'Take Profit Levels'\nontake1          = input.bool   (true,       '\ud83c\uddf9\ud83c\uddf5\u00b9',                  group=grouptakes\nqtake1           = input.int    (5,          '\ufffd',                   group=grouptakes\nontake2          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u00b2',                  group=grouptakes\nqtake2           = input.int    (20,          '\ufffd',                   group=grouptakes\nontake3          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u00b3',                  group=grouptakes\nqtake3           = input.int    (50,          '\ufffd',                   group=grouptakes\nonstop0          = input.bool   (false,       '\ud83c\uddf8\ud83c\uddf1\u2070\u200a',                 group=grouptakes\nqstop0           = input.int    (30,          '\ufffd',                   group=grouptakes\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 SIGNAL FOR BACKTEST SYSTEM \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\nEntrysignals_ = longEntry ? +1 : shortEntry ? -1 : 0\n// \u2014\u2014\u2014\u2014\u2014\u2014 Variables Initialisation\nEntrysignals = nz(Entrysignals_)\nbull = Entrysignals == +1 // +1 is bull signal\nbear = Entrysignals == -1 // -1 is bear signal\n//Backtester //Credit \u00a9VertMT\nstartFilter    = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"              \", defval\nendFilter      = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"              \", defval\nstartTime      = input.time    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Start Time\u3164\u3164\", defval\nendTime        = input.time    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"End Time \u3164 \u3164\", defval\nsession        = input.session (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Time Session  \", defval\nzoneTime       = input.string  (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"UTC           \", defval\nmon            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Mon\u3164         \", defval\ntue            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Tue\u3164         \", defval\nwed            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Wed\u3164         \", defval\nthu            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Thu\u3164         \", defval\nfri            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Fri\u3164         \", defval\nsat            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Sat\u3164         \", defval\nsun            = input.bool    (group='\ud83d\udcc6 Time Filter \ud83d\udcc6', title=\"Sun\u3164         \", defval\n// \ud83d\udcc6 Time Filter \ud83d\udcc6 \u2014\u2014\u2014\u2014\u2014\ntradeDateIsAllowed() =>\n    start = startFilter ? time >= startTime : true\n    end   = endFilter   ? time <= endTime   : true\n       ses   = time == time(\"S\", session, zoneTime) ? true : false\n    monF  = ( dayofweek(time, zoneTime) == dayofweek.monday    ) and mon ? true : \n    tueF  = ( dayofweek(time, zoneTime) == dayofweek.tuesday   ) and tue ? true : \n    wedF  = ( dayofweek(time, zoneTime) == dayofweek.wednesday ) and wed ? true : \n    thuF  = ( dayofweek(time, zoneTime) == dayofweek.thursday  ) and thu ? true : \n    friF  = ( dayofweek(time, zoneTime) == dayofweek.friday    ) and fri ? true : \n    satF  = ( dayofweek(time, zoneTime) == dayofweek.saturday  ) and sat ? true : \n    sunF  = ( dayofweek(time, zoneTime) == dayofweek.sunday    ) and sun ? true : \n    dayF   = monF or tueF or wedF or thuF or friF or satF or sunF ? true : false\n    filter = start ? end ? ses ? dayF ? true : false : false : false : false\ndateRange = tradeDateIsAllowed()\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Signal Filters \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \ngroupsignal           = 'Signal Filters'\nFilterType1         = input.bool (true,           '1. MA Filter',                                           \nFilterType1MAType    = input.string ('EMA',           '',                                                 \nFilterType1Len       = input.int    (21,             '',                                                 \nvar bool ma1Status      = input.bool(false, group=groupsignal, title=\"Show MA Line?\"\nsource = close\nMA(FilterType4MAType, source, FilterType4Len) =>\n    ma = 0.0\n    if FilterType4MAType == \"SMA\" // Simple\n        ma := ta.sma(source, FilterType4Len)\n        if FilterType4MAType == \"EMA\" // Exponential\n        ma := ta.ema(source, FilterType4Len)\n        if FilterType4MAType == \"VWMA\" // Volume Weighted\n        ma := ta.vwma(source, FilterType4Len)\n        if FilterType4MAType == \"HMA\" // Hull MA\n        ma := ta.hma(source, FilterType4Len)\n        resultMA = ma\nma = MA(FilterType1MAType, source, FilterType1Len)\nplot(ma, \"Moving Average 1\", color = ma1Status ?  color.yellow : na)\nFilterType2          = input.bool   (true,           '2.  Above/Below Kumo Cloud Settings'\nFilterType3          = input.bool   (false,          '3. Bullish/Bearish Kumo Cloud Filter Settings'\nFilterType4         = input.bool   (false,            '4. Bullish/Bearish Kijun Filter Settings'\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 1: Moving Average\nFilter1Ma      = FilterType1 ? MA(FilterType1MAType, close, FilterType1Len) : 0.\nFilter1Long    = FilterType1 ? close > Filter1Ma : true\nFilter1Short   = FilterType1 ? close < Filter1Ma : true\n// Filter 2: Above/Below Kumo Cloud Settings\nFilter2Long  = FilterType2 ? close > math.max(senkouA[kumo_offset-1],senkouB[kumo_offset\nFilter2Short = FilterType2 ? close < math.min(senkouA[kumo_offset-1],senkouB[kumo_offset\n// Filter 3: Bullish/Bearish Kumo Cloud Filter Settings\nFilter3Long = FilterType3 ? senkouA[kumo_offset-1] > senkouB[kumo_offset-1] : true\nFilter3Short = FilterType3 ? senkouA[kumo_offset-1] < senkouB[kumo_offset-1]  : true\n// Filter 4: Bullish/Bearish Kijun Filter Settings\nFilter4Long = FilterType4 ? kijun > math.max(senkouA[kumo_offset-1],senkouB[kumo_offset\nFilter4Short = FilterType4 ? kijun < math.min(senkouA[kumo_offset-1],senkouB[kumo_offset\n//  \u2014\u2014\u2014\u2014\u2014\u2014 Filter 12: Bullish/Bearish Chikou Span Settings\n// \u2014\u2014\u2014\u2014\u2014\u2014 Assemble Filters\nFilterLongOK    = Filter1Long and Filter2Long and Filter3Long and Filter4Long\nFilterShortOK   = Filter1Short and Filter2Short and Filter3Short and Filter4Short\n// Risk Managment \\\\ // Credit @Daveatt\ngrouprisk               = 'Risk Management'\nsetmaxLosingStreak      = input.bool   (false,           '',                   group\nmaxLosingStreak         = input.int    (15,              'Loss Streak\u2002\u2002\u2002',     group\nsetmaxWinStreak         = input.bool   (false,           '',                   group\nmaxWinStreak            = input.int    (15,              'Win Streak\u2002\u2002\u2002',      group\nsetmaxLosingDaysStreak  = input.bool   (false,           '',                   group\nmaxLosingDaysStreak     = input.int    (3,               'Row Loss InDay',     group\nsetMaxDrawdown          = input.bool   (false,           '',                   group\nmaxPercDd               = input.int    (10,              'DrawDown \uff05',        group\nsetMaxIntradayLoss      = input.bool   (false,           '',                   group\nmaxIntradayLoss         = input.int    (3,               'InDay Loss \uff05\u2002',     group\nsetNumberDailyTrades    = input.bool   (false,           '',                   group\nmaxDailyTrades          = input.int    (10,              'Daily Trades\u2002\u2002',     group\nsetNumberWeeklyTrades   = input.bool   (false,           '',                   group\nmaxWeeklyTrades         = input.int    (50,              'Weekly Trades',      group\nQTYMethod               = input.string ('EQUITY',        '\u2002\u2002\u2002\u2002\u2002Order Size',    group\nuseNetProfit            = input.bool   (true,            'Use Net Profit',     group\nriskPerc                = input.int    (30,              '\ud83c\uddea\ud83c\uddf6\ud83c\uddfa\ud83c\uddee\ud83c\uddf9\ud83c\uddfe',              group\nriskSize                = input.int    (1000,            '\ud83c\uddf8\ud83c\uddee\ud83c\uddff\ud83c\uddea',                group\nriskCntr                = input.int    (1,               '\ud83c\udde8\ud83c\uddf4\ud83c\uddf3\ud83c\uddf9\ud83c\uddf7\ud83c\udde6\ud83c\udde8\ud83c\uddf9\ud83c\uddf8',           group\n// \u2014\u2014\u2014\u2014\u2014\u2014 Order Size\neqty = switch QTYMethod\n    'NONE'      => na\n    'EQUITY'    => riskPerc / close\n    'SIZE'      => riskSize / close\n    'CONTRACTS' => riskCntr\n//\n// \u2014\u2014\u2014\u2014\u2014\u2014 Intraday Loss \uff05\ncondintradayloss = setMaxIntradayLoss ? maxIntradayLoss : 100\nstrategy.risk.max_intraday_loss(value=condintradayloss, type=strategy.percent_of_equity\n// \u2014\u2014\u2014\u2014\u2014\u2014 Max Drawdown \uff05\ncondmaxdrawdown = setMaxDrawdown ? maxPercDd : 100\nstrategy.risk.max_drawdown(value=condmaxdrawdown, type=strategy.percent_of_equity)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Daily trades calculation\ntradesIntradayCount = setNumberDailyTrades ? maxDailyTrades : 1000\nstrategy.risk.max_intraday_filled_orders(count=tradesIntradayCount)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Weekly trades calculation\ntradesLastWeek = 0\ntradesLastWeek := dayofweek == dayofweek.monday and dayofweek != dayofweek[1] ? strategy.closedtrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate number of trades this week\nweeklyTrades = strategy.closedtrades + strategy.opentrades - tradesLastWeek\nokToTradeWeekly = setNumberWeeklyTrades ? weeklyTrades < maxWeeklyTrades : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Consecutive loss days in a row\ncountConsLossDays = setmaxLosingDaysStreak ? maxLosingDaysStreak : 1000\nstrategy.risk.max_cons_loss_days(countConsLossDays)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate the total losing streaks\nnewLoss = strategy.losstrades > strategy.losstrades[1] and strategy.wintrades == strategy.wintrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Determine current losing streak length\nstreakLossLen = 0\nstreakLossLen := newLoss ? nz(streakLossLen[1]) + 1 : strategy.wintrades > strategy.wintrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Check if losing streak is under max allowed\nokToTradeLossStreak = setmaxLosingStreak ? streakLossLen < maxLosingStreak : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate the total winning streaks\nnewWin = strategy.wintrades > strategy.wintrades[1] and strategy.losstrades == strategy.losstrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Figure out current winning streak length\nstreakWinLen = 0\nstreakWinLen := newWin ? nz(streakWinLen[1]) + 1 : strategy.losstrades > strategy.losstrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Check if winning streak is under max allowed\nokToTradeWinStreak = setmaxWinStreak ? streakWinLen < maxWinStreak : true\n// TP-SL Exit Strategy\npercentTP    = input.float  (4.5,             '\u2002Profit \uff05\u2002\u2002\u2002\u2002',            group=groupset\npercentSL    = input.float  (1.5,             '\u2002Stop \uff05\u2002\u2002',                group=groupset\nmoneyTP      = input.float  (333,             '\u2002Profit \uff04\u2002\u2002\u2002\u2002',            group=groupset\nmoneySL      = input.float  (100,             '\u2002Stop \uff04\u2002\u2002',                group=groupset\nATRLenTP       = input.int    (30,              '\u2002ATR TP Period\u2002\u2002',             group\nATRMultTP      = input.float  (3,               '\u2002TP Multiplier',               group\nATRLenSL       = input.int    (30,              '\u2002ATR SL Period\u2002\u2002',             group\nATRMultSL     = input.float  (4,               'SL Multiplier',               group\ntrailPerc    = input.float  (3,               '\u2002Trailing \uff05\u2002\u2002',            group=groupset\nriskReward   = input.float  (2,               '\u2002R:R\u2002\u2002\u2002\u20021:',                group=groupset\nfixedRR      = input.bool   (true,            ' Fixed RR',                 group=groupset\nHHLL         = input.int    (200,             '\u2002HH / LL\u2003\u2002\u2002',               group=groupset\nLoHi         = input.int    (5,               '\u2002\u2002LO / HI\u2003',                group=groupset\naddPerc      = input.bool   (false,           ' Add \uff05',                   group=groupset\nmaStopType   = input.string ('EMA',           '\u2002MA Stop',                  group=groupset\nmaStopLen    = input.int    (15,              '\u2002Len',                      group=groupset\nmaPerc       = input.float  (0.1,             '\u2002Step',                     group=groupset\nvar bool PaintStrategy= input.bool (false, \"Paint Strategy and TP/SL on Chart\" , group\nslNumber     = input.int    (1,               '\u2002SL 0 Position',            group=grouptakes\nontpBE       = input.bool   (false,           '',                          group=grouptakes\ntpBEnumber   = input.int    (2,               'Breakeven on TP',           group=grouptakes\nbarCoolDwn   = input.int    (0,               '\u2002CoolDown # Bars',          group=grouptakes\n// \u2014\u2014\u2014\u2014\u2014\u2014 Trade variables\nentry        = strategy.position_avg_price\nsizePos      = strategy.position_size\ninLong       = sizePos > 0\ninShort      = sizePos < 0\ninTrade      = inLong or inShort\ninPos        = (inLong and not inShort[1]) or (inShort and not inLong[1])\nvar ID       = 'TradeID'\nvar tpPrice  = float(na)\nvar slPrice  = float(na)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Entry solutions\ndirection    = 0\ndirectionL   = bull and (nz(direction[1]) == 0 or nz(direction[1]) == -1)\ndirectionS   = bear and (nz(direction[1]) == 0 or nz(direction[1]) == +1)\ndirection   := directionL ? +1 : directionS ? -1 : (reEntryDeal ? direction[1] : direction\ncheckCoolDwn = barCoolDwn >0 ? not inTrade[barCoolDwn] : true\nOkToTrade    = dateRange and okToTradeLossStreak and okToTradeWinStreak and checkCoolDwn\ngoLong       = ( waitEndDeal ? not inTrade and direction==+1 : direction==+1 ) and\ngoShort      = ( waitEndDeal ? not inTrade and direction==-1 : direction==-1 ) and\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \nDynamicStops = (slType == 'TRAILING' or slType == 'FAST TRAIL' or slType == 'MA')\n// \u2014\u2014\u2014\u2014\u2014\u2014 Fixed SL/TP\nif tpType == 'FIXED \uff05'\n    tpPrice := inLong and not inTrade[1] ? entry * (1 + percentTP/100) : inShort and\nif slType == 'FIXED \uff05'\n    slPrice := inLong and not inTrade[1] ? entry * (1 - percentSL/100) : inShort and\n// \u2014\u2014\u2014\u2014\u2014\u2014 Money SL/TP\nif tpType == 'FIXED \uff04'\n    tpPrice := inLong and not inTrade[1] ? entry + (moneyTP / math.abs(sizePos)) :\nif slType == 'FIXED \uff04'\n    slPrice := inLong and not inTrade[1] ? entry - (moneySL / math.abs(sizePos)) :\n// \u2014\u2014\u2014\u2014\u2014\u2014 Trailing Stop\nif slType == 'TRAILING'\n    StopL    = 0., StopS = 0.\n    StopL   := inLong  ? math.max(close * (1 - trailPerc/100), StopL[1]) : 0\n    StopS   := inShort ? math.min(close * (1 + trailPerc/100), StopS[1]) : 999999\n    slPrice := inLong  ? StopL : inShort ? StopS : slPrice\n// \u2014\u2014\u2014\u2014\u2014\u2014 Fast Trailing Stop\nif slType == 'FAST TRAIL'\n    var stop = float(na)\n    stop    := inLong and not inTrade[1] ? entry * (1 - trailPerc/100) : inShort and\n    stop    := inLong and close > close[1] ? stop + (close - close[1]) : inShort and\n    slPrice := stop\n// \u2014\u2014\u2014\u2014\u2014\u2014 ATR Fixed TP\nStopATRTP     = ta.atr(ATRLenTP) * ATRMultTP\nif tpType == 'ATR TP'\n    tpPrice := inLong and not inTrade[1] ? entry + StopATRTP: inShort and not inTrade\n// \u2014\u2014\u2014\u2014\u2014\u2014 ATR Fixed SL\nStopATRSL     = ta.atr(ATRLenSL) * ATRMultSL\nif slType == 'ATR SL'\n    slPrice := inLong and not inTrade[1] ? entry - StopATRSL : inShort and not inTrade\n// \u2014\u2014\u2014\u2014\u2014\u2014 LO / HI Stop\nif slType == 'LO / HI'\n    HiStop   = ta.highest(high, LoHi)\n    LoStop   = ta.lowest (low,  LoHi)\n    slPrice := inLong and not inTrade[1] ? LoStop : inShort and not inTrade[1] ? HiStop\n// \u2014\u2014\u2014\u2014\u2014\u2014 HH / LL Take\nif tpType == 'HH / LL'\n    HiStop   = ta.highest(high, HHLL)\n    LoStop   = ta.lowest (low,  HHLL)\n    tpPrice := inLong and not inTrade[1] ? HiStop : inShort and not inTrade[1] ? LoStop\n// \u2014\u2014\u2014\u2014\u2014\u2014 MA's Stops\nif slType == 'MA'\n    maSType  = MA(maStopType, close, maStopLen)\n    Stop     = maSType * (maPerc / 100)\n    slPrice := inLong  ? math.max(nz(slPrice[1], 0), maSType - Stop) : inShort ? math.min\n// \u2014\u2014\u2014\u2014\u2014\u2014 Risk Reward Take\nif tpType == 'R:R'\n    check    = fixedRR ? not inTrade[1] : true\n    tpPrice := inLong and check ? entry + (entry - slPrice) * riskReward : inShort\n// \u2014\u2014\u2014\u2014\u2014\u2014 Add Percents to SL\nif addPerc\n    check    = DynamicStops ? true : not inTrade[1]\n    slPrice := inLong and check ? slPrice * (1 - percentSL/100) : inShort and check\n// \u2014\u2014\u2014\u2014\u2014\u2014 TPSL's\nTypeStop = tpType != 'None' or slType == 'FIXED \uff05' or slType == 'FIXED \uff04' or slType\nBuildLeveles(take, nTake) => // Creating Intermediate Levels of the SL/TP - by shifting the current TP/SL to the entry level\n    nTakes = 4\n    var offset = float(na)\n    offset := not inPos[1] ? (entry - take) : offset\n    xentry = take + offset\n    levels = array.new_float()\n    for i = 1 to nTakes - 1\n        array.push(levels, xentry + (take - xentry) * i / (nTakes))\n    result = nTake >= 0 and nTake <= nTakes ? array.get(levels, nTake) : na\nCheckLevels(lvl, isTake) => // Check if the SL/TP is reached \n    var float level = na\n    if isTake and ((inLong and high >= lvl) or (inShort and low <= lvl))\n        level := entry\n    if not isTake and ((inLong and low <= lvl) or (inShort and high >= lvl))\n        level := entry\n    if not inTrade\n        level := na\n    level\n// \u2014\u2014\u2014\u2014\u2014\u2014 Get and Check Levels\nstop0 = tpType != 'None' ? BuildLeveles(slPrice, slNumber-1) : slPrice , checkStop0\ntake1 = BuildLeveles(TypeStop ? tpPrice : slPrice, 0)                  , checkTake1\ntake2 = BuildLeveles(TypeStop ? tpPrice : slPrice, 1)                  , checkTake2\ntake3 = BuildLeveles(TypeStop ? tpPrice : slPrice, 2)                  , checkTake3\n// \u2014\u2014\u2014\u2014\u2014\u2014 Move Stop to Breakeven\nslbecheck = (tpBEnumber==1 and ontake1) or (tpBEnumber==2 and ontake2) or (tpBEnumber\nif ontpBE and slbecheck and not DynamicStops\n    slbe     = TypeStop ? CheckLevels(BuildLeveles(tpPrice, tpBEnumber-1), true) :\n    slPrice := slbe > 0 ? slbe : slPrice\n    stop0   := slPrice == entry ? slPrice : stop0\n// ALERTS\ni_alert_message_long_txt = input.text_area(defval = \"\",title = 'API Long Entry' , \ni_alert_message_short_txt =input.text_area(defval = \"\",title = 'API Short Entry' ,\ni_alert_txt_exit_TPSL0 = input.text_area(defval = \"\",title = 'API Exit 0' , group \ni_alert_txt_exit_TPSL1 = input.text_area(defval = \"\",title = 'API Exit 1' , group \ni_alert_txt_exit_TPSL2 = input.text_area(defval = \"\",title = 'API Exit 2' , group \ni_alert_txt_exit_TPSL3 = input.text_area(defval = \"\",title = 'API Exit 3' , group \ni_alert_txt_exit_TPSLX = input.text_area(defval = \"\",title = 'API Exit X' , group \n// \u2014\u2014\u2014\u2014\u2014\u2014 Entry's\neqty(qty) => QTYMethod=='EQUITY' ? qty / 100 * (strategy.initial_capital + (useNetProfit\nif goLong\n    ID := 'Long'\n    strategy.entry(ID, strategy.long,  qty=eqty(eqty), comment=ID, alert_message =\nif goShort\n    ID := 'Short'\n    strategy.entry(ID, strategy.short, qty=eqty(eqty), comment=ID, alert_message =\n// \u2014\u2014\u2014\u2014\u2014\u2014 Exit's\nqty(perc) => math.abs(sizePos*perc/100)\nif inTrade \n    strategy.exit('End_0', onstop0 ? ID : 'na', qty=qty(qstop0), limit=tpPrice,                    \n    strategy.exit('End_1', ontake1 ? ID : 'na', qty=qty(qtake1), limit=TypeStop ? \n    strategy.exit('End_2', ontake2 ? ID : 'na', qty=qty(qtake2), limit=TypeStop ? \n    strategy.exit('End_3', ontake3 ? ID : 'na', qty=qty(qtake3), limit=TypeStop ? \n    strategy.exit('End_X',           ID,                         limit=tpPrice,                    \n// =================================================================================================\n///=================================================================================================\n// Plotting and Debugging - Style 1 - Paint Strategy\n// =================================================================================================\nbullcolor    = input.color  ( color.new(color.teal,70),     'Colors:  FG',               \nbearcolor    = input.color  ( color.new(color.red,70),     '',                          \nbullcolorb   = input.color  ( color.new(color.teal,80),     'BG',                        \nbearcolorb   = input.color  ( color.new(color.red,80),     '',                          \n//Style 1- Paint Strategy on Chart\nplotColx = inLong and PaintStrategy? bullcolor  : inShort ? bearcolor  : na\nplotColy = inLong and PaintStrategy ? bullcolorb : inShort ? bearcolorb : na\ntpcolor  = tpType != 'None' ? bullcolor : plotColx\ntp1 = plot(inPos and PaintStrategy? tpPrice : na, 'Take', color=tpType != 'None' ?\nsl1 = plot(inPos and PaintStrategy ? slPrice : na, 'Stop', color=tpType != 'None' \nen1 = plot(TypeStop and PaintStrategy ? (inLong and slPrice > entry or inShort and\nfill(tp1, en1, color=TypeStop ? bullcolorb : plotColy, editable=false)\nfill(sl1, en1, color=TypeStop ? bearcolorb : plotColy, editable=false)\nplotchar(inPos and not inPos[1] and PaintStrategy? tpPrice : na, 'Take Start', color\nplotchar(inPos and not inPos[1] and PaintStrategy? slPrice : na, 'Stop Start', color\nplot(inPos and ontake1 and not checkTake1[1] and PaintStrategy? take1 : na, 'TP 1'\nplot(inPos and ontake2 and not checkTake2[1] and PaintStrategy? take2 : na, 'TP 2'\nplot(inPos and ontake3 and not checkTake3[1] and PaintStrategy? take3 : na, 'TP 3'\nplot(inPos and onstop0 and not checkStop0[1] and PaintStrategy? stop0 : na, 'SL 0'\n//Style- Plot Letters on Chart\nplotshape(goLong and PlotLong,'Bullish Signals',text='Buy',location=location.belowbar\nplotshape(inLong and longExit and PlotLong and PlotLongExit,'Long Exit',location=location.abovebar\nplotshape(goShort and PlotShorts ,'Bearish Signals',text='Sell', location=location.abovebar\nplotshape(inShort and shortExit and PlotShorts and PlotShortsExit ,'Short Exit',location\n//Plot Dashboard\n// \ud83d\udcca Plots \ud83d\udcca\n//The data collected during the backtest will be displayed on screen within a dashboard and various \nplotDashboard  = input.bool    (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"Plot Dashboard          \"\nmaxProfit      = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"Profit \u3164 \u3164\ud83d\udfe2 if > to:\", defval\nminProfit      = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"\u3164\ud83d\udd34 if < to:          \", \nmaxWinRate     = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"Win Rate\u3164\ud83d\udfe2 if > to:  \", \nminWinRate     = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"\u3164\ud83d\udd34 if < to:          \", \nmaxPFactor     = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"P. Factor\u3164\ud83d\udfe2 if > to: \", \nminPFactor     = input.float   (group=\"\ud83d\udcca Plots \ud83d\udcca\", title=\"\u3164\ud83d\udd34 if < to:          \", \nbgcolor(dateRange ? na :  color.new(color.white, 80))\nMTLabel(ftimestamp, etimestamp, statusProfit, statusWinRate, statusPFactor, maxWinRow\n    timefr = timeframe.isminutes ? 'min' : ''\n    string _text = '         \ud83d\udd30CITI Moku (Free)\ud83d\udd30' + '\\n'\n    _text += '\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796' + '\\n'\n    _text += '' + '\\n'\n    _text += ' Ticker:' + '\\n'\n    _text += '     ' + syminfo.ticker + '  ' + timeframe.period + timefr\n    _text += '' + '\\n\\n'\n    _text += ' Since:' + '\\n'\n    _text += str.format(\"    {0,date,long}  \", ftimestamp) + str.format(\"{0,time,HH:mm}\"\n    _text += ' To:' + '\\n'\n    _text += str.format(\"    {0,date,long}  \", etimestamp) + str.format(\"{0,time,HH:mm}\"\n    _text += '' + '\\n'\n    _text += '\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796' + '\\n'\n    _text += '' + '\\n'\n    _text += ' #Trades:  ' + str.tostring(strategy.closedtrades, '##.##') + '\\n'\n    _text += '' + '\\n'\n    _text += ' Profit:' + '\\n'\n    _text += '     ' + str.tostring(statusProfit)  + str.tostring(( strategy.netprofit\n    _text += ' Win Rate:' + '\\n'\n    _text += '     ' + str.tostring(statusWinRate) + str.tostring(( strategy.wintrades\n    _text += ' Profit Factor:' + '\\n'\n    _text += '     ' + str.tostring(statusPFactor) + str.tostring(( strategy.grossprofit\n    _text += '' + '\\n'\n    _text += ' Win Trades:   '  + str.tostring(strategy.wintrades, '######') + '\\n'\n    _text += ' Loss Trades:   ' + str.tostring(strategy.losstrades, '######') + '\\n'\n    _text += '' + '\\n'\n    _text += ' Avg Win:  '  + str.tostring((( strategy.grossprofit / strategy.wintrades\n    _text += ' Avg Loss:  ' + str.tostring((( strategy.grossloss / strategy.losstrades\n    _text += '' + '\\n'\n    _text += ' Max Win in a Row:  '  + str.tostring(maxWinRow, '######')  + '\\n'\n    _text += ' Max Loss in a Row:  ' + str.tostring(maxLossRow, '######')  + '\\n'\n    _text += '' + '\\n'\n    _text += '\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796\u2796' + '\\n'\nftimestamp = startFilter ? timestamp(year(startTime, zoneTime), month(startTime, zoneTime\netimestamp = endFilter   ? timestamp(year(endTime, zoneTime),   month(endTime, zoneTime\nstatusProfit  = (( strategy.netprofit / strategy.initial_capital ) * 100) + 0.001 \nstatusWinRate = (( strategy.wintrades / strategy.closedtrades )    * 100) + 0.001 \nstatusPFactor = ( strategy.grossprofit / strategy.grossloss )             + 0.001 \nvarip int winRow     = 0\nvarip int lossRow    = 0\nvarip int maxWinRow  = 0\nvarip int maxLossRow = 0\nif (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades == strategy.losstrades\n    lossRow := 0\n    winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\nif (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades  > strategy.losstrades\n    winRow := 0\n    lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\nlabel la = na\nlabel.delete(la[1])\nla := plotDashboard ? label.new(x=bar_index + 5, y=close, text=MTLabel(ftimestamp,"}]}
{"messages": [{"role": "user", "content": "The script presented is a trading strategy called \"Breaker Block Strategy with Price Channel\". This strategy uses multiple time frames (1 minute, 5 minutes, 15 minutes, 1 hour, and 4 hours) to detect support and resistance areas on the chart. The strategy uses parameters such as length, deviations, multiplier, Fibonacci level, move lag and volume threshold for each time frame. These parameters are adjustable by the user. The script then calculates support and resistance levels using the simple moving average (SMA) and standard deviation (STDEV) of closing prices for each time frame. It also detects \"Breaker Blocks\" based on price movement from support and resistance levels, as well as trade volume. A Breaker Block occurs when there is a significant breakout of a support or resistance level with high volume. Buy and sell signals are generated based on the presence of a Breaker Block and price movement from support and resistance levels. When a buy signal is generated, a buy order is placed, and when a sell signal is generated, a sell order is placed. The script also plots price channels for each time frame, representing resistance and support levels. Profit limit levels are set for each time range, indicating that the price levels assigned to positions should be closed with a profit. Stop-loss levels are also set to limit losses in the event of canceled price movements. In summary, this trading strategy uses a combination of Breaker Block detection, support and resistance levels, price channels and profit limit levels to generate buy and sell signals and manage positions on different time ranges."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"DZ Strategy ICT\", overlay=true)\n// Param\u00e8tres de l'indicateur\nlength1 = input.int(14, minval=1, title='Longueur 1 min')\ndeviations1 = input.float(2.0, title='D\u00e9viations 1 min')\nmultiplier1 = input.float(1.0, minval=0.1, maxval=10, title='Multiplicateur 1 min'\nfibonacciLevel1 = input.float(0.618, title='Niveau de Fibonacci 1 min')\ndisplacement1 = input.int(3, minval=1, title='D\u00e9calage de Displacement 1 min')\nvolumeThreshold1 = input.float(1.0, minval=0, title='Seuil de Volume 1 min')\nfibLevelInput1 = input.float(0.0, \"Niveau de Limite de Profit 1 min\", minval=0.0)\nlength5 = input.int(14, minval=1, title='Longueur 5 min')\ndeviations5 = input.float(2.0, title='D\u00e9viations 5 min')\nmultiplier5 = input.float(1.0, minval=0.1, maxval=10, title='Multiplicateur 5 min'\nfibonacciLevel5 = input.float(0.618, title='Niveau de Fibonacci 5 min')\ndisplacement5 = input.int(3, minval=1, title='D\u00e9calage de Displacement 5 min')\nvolumeThreshold5 = input.float(1.0, minval=0, title='Seuil de Volume 5 min')\nfibLevelInput5 = input.float(0.0, \"Niveau de Limite de Profit 5 min\", minval=0.0)\nlength15 = input.int(14, minval=1, title='Longueur 15 min')\ndeviations15 = input.float(2.0, title='D\u00e9viations 15 min')\nmultiplier15 = input.float(1.0, minval=0.1, maxval=10, title='Multiplicateur 15 min'\nfibonacciLevel15 = input.float(0.618, title='Niveau de Fibonacci 15 min')\ndisplacement15 = input.int(3, minval=1, title='D\u00e9calage de Displacement 15 min')\nvolumeThreshold15 = input.float(1.0, minval=0, title='Seuil de Volume 15 min')\nfibLevelInput15 = input.float(0.0, \"Niveau de Limite de Profit 15 min\", minval=0.0\nlength60 = input.int(14, minval=1, title='Longueur 1 h')\ndeviations60 = input.float(2.0, title='D\u00e9viations 1 h')\nmultiplier60 = input.float(1.0, minval=0.1, maxval=10, title='Multiplicateur 1 h')\nfibonacciLevel60 = input.float(0.618, title='Niveau de Fibonacci 1 h')\ndisplacement60 = input.int(3, minval=1, title='D\u00e9calage de Displacement 1 h')\nvolumeThreshold60 = input.float(1.0, minval=0, title='Seuil de Volume 1 h')\nfibLevelInput60 = input.float(0.0, \"Niveau de Limite de Profit 1 h\", minval=0.0)\nlength240 = input.int(14, minval=1, title='Longueur 4 h')\ndeviations240 = input.float(2.0, title='D\u00e9viations 4 h')\nmultiplier240 = input.float(1.0, minval=0.1, maxval=10, title='Multiplicateur 4 h'\nfibonacciLevel240 = input.float(0.618, title='Niveau de Fibonacci 4 h')\ndisplacement240 = input.int(3, minval=1, title='D\u00e9calage de Displacement 4 h')\nvolumeThreshold240 = input.float(1.0, minval=0, title='Seuil de Volume 4 h')\nfibLevelInput240 = input.float(0.0, \"Niveau de Limite de Profit 4 h\", minval=0.0)\n// Calcul des supports et r\u00e9sistances pour chaque plage de temps\nbasis1 = ta.sma(close, length1)\nrange_1 = multiplier1 * ta.stdev(close, length1)\nupper1 = basis1 + deviations1 * range_1\nlower1 = basis1 - deviations1 * range_1\nbasis5 = ta.sma(close, length5)\nrange_5 = multiplier5 * ta.stdev(close, length5)\nupper5 = basis5 + deviations5 * range_5\nlower5 = basis5 - deviations5 * range_5\nbasis15 = ta.sma(close, length15)\nrange_15 = multiplier15 * ta.stdev(close, length15)\nupper15 = basis15 + deviations15 * range_15\nlower15 = basis15 - deviations15 * range_15\nbasis60 = ta.sma(close, length60)\nrange_60 = multiplier60 * ta.stdev(close, length60)\nupper60 = basis60 + deviations60 * range_60\nlower60 = basis60 - deviations60 * range_60\nbasis240 = ta.sma(close, length240)\nrange_240 = multiplier240 * ta.stdev(close, length240)\nupper240 = basis240 + deviations240 * range_240\nlower240 = basis240 - deviations240 * range_240\n// Calcul du volume moyen sur chaque p\u00e9riode donn\u00e9e\naverageVolume1 = ta.sma(volume, length1)\naverageVolume5 = ta.sma(volume, length5)\naverageVolume15 = ta.sma(volume, length15)\naverageVolume60 = ta.sma(volume, length60)\naverageVolume240 = ta.sma(volume, length240)\n// D\u00e9tection du Breaker Block en fonction du d\u00e9placement et du volume pour chaque plage de \nbreakerBlock1 = ta.crossover(close[displacement1], lower1) and volume > volumeThreshold1\nbreakerBlock1 := breakerBlock1 or (ta.crossunder(close[displacement1], upper1) and\nbreakerBlock5 = ta.crossover(close[displacement5], lower5) and volume > volumeThreshold5\nbreakerBlock5 := breakerBlock5 or (ta.crossunder(close[displacement5], upper5) and\nbreakerBlock15 = ta.crossover(close[displacement15], lower15) and volume > volumeThreshold15\nbreakerBlock15 := breakerBlock15 or (ta.crossunder(close[displacement15], upper15)\nbreakerBlock60 = ta.crossover(close[displacement60], lower60) and volume > volumeThreshold60\nbreakerBlock60 := breakerBlock60 or (ta.crossunder(close[displacement60], upper60)\nbreakerBlock240 = ta.crossover(close[displacement240], lower240) and volume > volumeThreshold240\nbreakerBlock240 := breakerBlock240 or (ta.crossunder(close[displacement240], upper240\n// Affichage du Breaker Block sur le graphique\nbgcolor(breakerBlock1 ?  color.new(color.yellow, 70) : na)\nbgcolor(breakerBlock5 ?  color.new(color.yellow, 70) : na)\nbgcolor(breakerBlock15 ?  color.new(color.yellow, 70) : na)\nbgcolor(breakerBlock60 ?  color.new(color.yellow, 70) : na)\nbgcolor(breakerBlock240 ?  color.new(color.yellow, 70) : na)\n// D\u00e9finition de la zone limite de l'ordre de profit pour chaque plage de temps\nfibLevel1 = basis1 * fibonacciLevel1\nfibLevel5 = basis5 * fibonacciLevel5\nfibLevel15 = basis15 * fibonacciLevel15\nfibLevel60 = basis60 * fibonacciLevel60\nfibLevel240 = basis240 * fibonacciLevel240\n// Signal d'achat modifi\u00e9 en fonction du Breaker Block et du d\u00e9placement pour chaque plage de temps\nbuySignal1 = ta.crossover(close[displacement1], lower1) and volume > volumeThreshold1\nbuySignal5 = ta.crossover(close[displacement5], lower5) and volume > volumeThreshold5\nbuySignal15 = ta.crossover(close[displacement15], lower15) and volume > volumeThreshold15\nbuySignal60 = ta.crossover(close[displacement60], lower60) and volume > volumeThreshold60\nbuySignal240 = ta.crossover(close[displacement240], lower240) and volume > volumeThreshold240\n// Signal de vente modifi\u00e9 en fonction du Breaker Block et du d\u00e9placement pour chaque plage de temps\nsellSignal1 = ta.crossunder(close[displacement1], upper1) and volume > volumeThreshold1\nsellSignal5 = ta.crossunder(close[displacement5], upper5) and volume > volumeThreshold5\nsellSignal15 = ta.crossunder(close[displacement15], upper15) and volume > volumeThreshold15\nsellSignal60 = ta.crossunder(close[displacement60], upper60) and volume > volumeThreshold60\nsellSignal240 = ta.crossunder(close[displacement240], upper240) and volume > volumeThreshold240\n// Trac\u00e9 des niveaux de limite de profit pour chaque plage de temps\nhline(fibLevelInput1, color= color.green, linestyle=hline.style_dashed, title=\"Niveau de Limite de Profit 1 min\"\nhline(fibLevelInput5, color= color.green, linestyle=hline.style_dashed, title=\"Niveau de Limite de Profit 5 min\"\nhline(fibLevelInput15, color= color.green, linestyle=hline.style_dashed, title=\"Niveau de Limite de Profit 15 min\"\nhline(fibLevelInput60, color= color.green, linestyle=hline.style_dashed, title=\"Niveau de Limite de Profit 1 h\"\nhline(fibLevelInput240, color= color.green, linestyle=hline.style_dashed, title=\"Niveau de Limite de Profit 4 h\"\n// D\u00e9finition des ordres de vente et d'achat pour chaque plage de temps\nif buySignal1\n    strategy.entry(\"Achat 1 min\", strategy.long)\n    if sellSignal1\n    strategy.entry(\"Vente 1 min\", strategy.short)\nif buySignal5\n    strategy.entry(\"Achat 5 min\", strategy.long)\n    if sellSignal5\n    strategy.entry(\"Vente 5 min\", strategy.short)\nif buySignal15\n    strategy.entry(\"Achat 15 min\", strategy.long)\n    if sellSignal15\n    strategy.entry(\"Vente 15 min\", strategy.short)\nif buySignal60\n    strategy.entry(\"Achat 1 h\", strategy.long)\n    if sellSignal60\n    strategy.entry(\"Vente 1 h\", strategy.short)\nif buySignal240\n    strategy.entry(\"Achat 4 h\", strategy.long)\n    if sellSignal240\n    strategy.entry(\"Vente 4 h\", strategy.short)\n// Configuration des ordres de sortie (Take Profit) pour chaque plage de temps\nprofitRatio = 2\nstopLossRatio = 1\nstopLossLevel1 = strategy.position_avg_price * (1 - stopLossRatio / (stopLossRatio\nstopLossLevel5 = strategy.position_avg_price * (1 - stopLossRatio / (stopLossRatio\nstopLossLevel15 = strategy.position_avg_price * (1 - stopLossRatio / (stopLossRatio\nstopLossLevel60 = strategy.position_avg_price * (1 - stopLossRatio / (stopLossRatio\nstopLossLevel240 = strategy.position_avg_price * (1 - stopLossRatio / (stopLossRatio\nstrategy.exit(\"Stop Loss 1 min\", \"Achat 1 min\", stop=stopLossLevel1)\nstrategy.exit(\"Stop Loss 1 min\", \"Vente 1 min\", stop=stopLossLevel1)\nstrategy.exit(\"Stop Loss 5 min\", \"Achat 5 min\", stop=stopLossLevel5)\nstrategy.exit(\"Stop Loss 5 min\", \"Vente 5 min\", stop=stopLossLevel5)\nstrategy.exit(\"Stop Loss 15 min\", \"Achat 15 min\", stop=stopLossLevel15)\nstrategy.exit(\"Stop Loss 15 min\", \"Vente 15 min\", stop=stopLossLevel15)\nstrategy.exit(\"Stop Loss 1 h\", \"Achat 1 h\", stop=stopLossLevel60)\nstrategy.exit(\"Stop Loss 1 h\", \"Vente 1 h\", stop=stopLossLevel60)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    enable short positions"}, {"role": "assistant", "content": "// \u00a9 Julien_Eche\n//@version=5\nstrategy(\"Williams %R Strategy\", overlay=true, initial_capital=100000, shorttitle=\"W%R Strategy\"\n// Parameters\nlength = input(14, \"Length\")\noverboughtLevel = input(-20, \"Overbought Level\")\noversoldLevel = input(-80, \"Oversold Level\")\nenableShort = input(false, \"Enable Short Positions\")\n// Calculation of Williams %R\nwilliamsR = -100 * (ta.highest(high, length) - close) / (ta.highest(high, length) -\n// Buy and sell conditions\nbuySignal = ta.crossover(williamsR, oversoldLevel)\nsellSignal = ta.crossunder(williamsR, overboughtLevel)\n// Enter long position\nif buySignal\n    strategy.entry(\"Buy\", strategy.long)\n// Exit long position\nif sellSignal\n    strategy.close(\"Buy\")\n// Enter short position if enabled\nif enableShort and sellSignal\n    strategy.entry(\"Sell\", strategy.short)\n// Exit short position if enabled\nif enableShort and buySignal\n    strategy.close(\"Sell\")"}]}
{"messages": [{"role": "user", "content": "9:22 5 MIN 15 MIN BANKNIFTY Strategy with Additional Filters  The 9:22 5 MIN 15 MIN BANKNIFTY Strategy with Additional Filters is a trend-following strategy designed for trading the BANKNIFTY instrument on a 5-minute chart. It aims to capture potential price movements by generating buy and sell signals based on moving average crossovers, breakout confirmations, and additional filters. Key Features:  Fast MA Length: 9  Slow MA Length: 22  ATR Length: 14  ATR Filter: 0.5  Trailing Stop Percentage: 1.5%  Pullback Threshold: 0.5  Minimum Candle Body Percentage: 0.5  Use Breakout Confirmation: Enabled Additional Filters: Volume Threshold: Set a minimum volume requirement for trades. Trend Filter: Optionally enable a trend filter based on a higher timeframe moving average. Momentum Filter: Optionally enable a momentum filter using the RSI indicator. Support/Resistance Filter: Optionally enable a filter based on predefined support and resistance levels. Buy and Sell Signals: Buy Signal: A buy signal is generated when the fast moving average crosses above the slow moving average, with additional confirmation from breakout and volume criteria, along with optional trend, momentum, and support/resistance filters. Sell Signal: A sell signal is generated when the fast moving average crosses below the slow moving average, with similar confirmation and filtering criteria as the buy signal. Exit Strategy: The strategy employs a trailing stop-loss mechanism based on a percentage of the average entry price. The stop-loss is dynamically adjusted to protect profits while allowing for potential upside. Please note that this strategy should be thoroughly backtested and evaluated in different market conditions before applying it to live trading. It is also recommended to adjust the parameters and filters according to individual preferences and risk tolerance. Feel free to customise and adapt the description as needed to suit your preferences and the specific details of your strategy."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"9:22 5 MIN 15 MIN BANKNIFTY\", overlay=true)\nfastLength = input(9, title=\"Fast MA Length\")\nslowLength = input(22, title=\"Slow MA Length\")\natrLength = input(14, title=\"ATR Length\")\natrFilter = input(0.5, title=\"ATR Filter\")\ntrailingStop = input(1.5, title=\"Trailing Stop Percentage\")\npullbackThreshold = input(0.5, title=\"Pullback Threshold\")\nminCandleBody = input(0.5, title=\"Minimum Candle Body Percentage\")\nbreakoutConfirmation = input(true, title=\"Use Breakout Confirmation\")\nprice = close\nmafast = ta.sma(price, fastLength)\nmaslow = ta.sma(price, slowLength)\natrValue = ta.atr(atrLength)\nlong_entry = ta.crossover(mafast, maslow) and atrValue > atrFilter\nshort_entry = ta.crossunder(mafast, maslow) and atrValue > atrFilter\n// Pullback Filter\npullbackLong = ta.crossover(price, mafast) and ta.change(price) <= -pullbackThreshold\npullbackShort = ta.crossunder(price, mafast) and ta.change(price) >= pullbackThreshold\n// Include pullback condition only if a valid entry signal is present\nlong_entry := long_entry and (pullbackLong or not ta.crossover(price, mafast))\nshort_entry := short_entry and (pullbackShort or not ta.crossunder(price, mafast))\n// Filter based on candle body size\nvalidLongEntry = long_entry and ta.change(price) > 0 and ta.change(price) >= minCandleBody\nvalidShortEntry = short_entry and ta.change(price) < 0 and ta.change(price) <= -minCandleBody\n// Breakout confirmation filter\nbreakoutLong = breakoutConfirmation ? (close > ta.highest(high, fastLength)[1]) : true\nbreakoutShort = breakoutConfirmation ? (close < ta.lowest(low, fastLength)[1]) : true\nlong_entry := validLongEntry and breakoutLong\nshort_entry := validShortEntry and breakoutShort\nif (long_entry)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.close(\"Short\")\n    alert(\"Long trade iniated\")\n    if (short_entry)\n    strategy.entry(\"Short\", strategy.short)\n    strategy.close(\"Long\")\n    alert(\"Short trade initated\")\n// Trailing Stop-Loss\nlong_stop = strategy.position_avg_price * (1 - trailingStop / 100)\nshort_stop = strategy.position_avg_price * (1 + trailingStop / 100)\nstrategy.exit(\"Exit Long\", \"Long\", stop = long_stop)\nstrategy.exit(\"Exit Short\", \"Short\", stop = short_stop)\nplot(mafast, color= color.green, linewidth=2, title=\"Fast MA\")\nplot(maslow, color= color.red, linewidth=2, title=\"Slow MA\")"}]}
{"messages": [{"role": "user", "content": "This script is designed to execute a trading strategy based on Heikin Ashi candlesticks, moving averages, and percentile levels. Please note that you should keep your original chart in normal candlestick mode and not switch it to Heikin Ashi mode. The script itself calculates Heikin Ashi values from regular candlesticks. If your chart is already in Heikin Ashi mode, the script would be calculating Heikin Ashi values based on Heikin Ashi values, which would produce incorrect results. The strategy begins trading from a start date that you can specify by modifying the `startDate` parameter. The format of the date is \"YYYY MM DD\". So, for example, to start the strategy from January 1, 2022, you would set `startDate = timestamp(\"2022 01 01\")`. The script uses Heikin Ashi candlesticks, which are plotted in the chart. This approach can be useful for spotting trends and reversals more easily than with regular candlestick charts. This is particularly useful when backtesting in TradingView's \"Rewind\" mode, as you can see how the Heikin Ashi candles behaved at each step of the strategy. Buy and sell signals are generated based on two factors: 1. The crossing over or under of the Heikin Ashi close price and the 75th percentile price level. 2. The Heikin Ashi close price being above certain moving averages. You have the flexibility to adjust several parameters in the script, including: 1. The stop loss and trailing stop percentages (`stopLossPercentage` and `trailStopPercentage`). These parameters allow the strategy to exit trades if the price moves against you by a certain percentage. 2. The lookback period (`lookback`) used to calculate percentile levels. This determines the range of past bars used in the percentile calculation. 3. The lengths of the two moving averages (`yellowLine_length` and `purplLine_length`). These determine how sensitive the moving averages are to recent price changes. 4. The minimum holding period (`holdPeriod`). This sets the minimum number of bars that a trade must be kept open before it can be closed. Please adjust these parameters according to your trading preferences and risk tolerance. Happy trading!"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"HK Percentile Interpolation One\",shorttitle = \"HKPIO\", overlay=false, default_qty_type\n// Input parameters\nstopLossPercentage = input(3, title=\"Stop Loss (%)\") // User can set Stop Loss as a percentage\ntrailStopPercentage = input(1.5, title=\"Trailing Stop (%)\") // User can set Trailing Stop as a percentage\nlookback = input.int(14, title=\"Lookback Period\", minval=1) // User can set the lookback period for percentile\nyellowLine_length = input.int(5, \"Yellow\", minval=1) // User can set the length for Yellow EMA\npurplLine_length = input.int(10, \"Purple\", minval=1) // User can set the length for Purple EMA\nholdPeriod = input.int(200, title=\"Minimum Holding Period\", minval=10) // User can set the minimum holding period\nstartDate = timestamp(\"2021 01 01\")  // User can set the start date for the strategy\n// Calculate Heikin Ashi values\nhaClose = ohlc4\nvar float haOpen = na\nhaOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2\nhaHigh = math.max(nz(haOpen, high), nz(haClose, high), high)\nhaLow = math.min(nz(haOpen, low), nz(haClose, low), low)\n// Calculate Moving Averages\nyellowLine = ta.ema(haClose, yellowLine_length)\npurplLine = ta.ema(haClose, purplLine_length)\n// Calculate 25th and 75th percentiles\np25 = ta.percentile_linear_interpolation(haClose, lookback, 28)\np75 = ta.percentile_linear_interpolation(haClose, lookback, 78)\n// Generate buy/sell signals\nlongSignal = ta.crossover(haClose, p75) and haClose > yellowLine\nsellSignal = ta.crossunder(haClose, yellowLine)\nlongSignal1 = ta.crossover(haClose, p75) and haClose > purplLine\nsellSignal1 = ta.crossunder(haClose, purplLine)\n// Set start time and trade conditions\nif(time >= startDate)\n    // When longSignal is true, enter a long trade and set stop loss and trailing stop conditions\n    if (longSignal)\n        strategy.entry(\"Long\", strategy.long, 100)\n        strategy.exit(\"Sell\", \"Long\", stop=close*(1-stopLossPercentage/100), trail_points\n    // When sellSignal is true, close the long trade\n    if (sellSignal)\n        strategy.close(\"Long\")\n    // When sellSignal1 is true, enter a short trade\n    if (sellSignal1)\n        strategy.entry(\"Short\", strategy.short, 100)\n    // When longSignal1 is true, close the short trade\n    if (longSignal1)\n        strategy.close(\"Short\")\n// Plot Heikin Ashi candles\nplotcandle(haOpen, haHigh, haLow, haClose, title=\"Heikin Ashi\", color=(haClose >= haOpen\n// Plot 25th and 75th percentile levels\nplot(p25, title=\"25th Percentile\", color= color.green, linewidth=1, style=plot.style_circles\nplot(p75, title=\"75th Percentile\", color= color.red, linewidth=1, style=plot.style_circles\n// Plot Moving Averages\nplot(yellowLine, color =  color.rgb(254, 242, 73, 2), linewidth = 2, style = plot.style_stepline\nplot(purplLine, color =  color.rgb(255, 77, 234, 2), linewidth = 2, style = plot.style_stepline"}]}
{"messages": [{"role": "user", "content": "moving average crossover startegy 10*30  it indicates when to buy or sell"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Moving Average Crossover Strategy\", overlay=true)\n// Define the lengths for the fast and slow moving averages\nfastLength = input(10, title=\"Fast Moving Average Length\")\nslowLength = input(30, title=\"Slow Moving Average Length\")\n// Calculate the moving averages\nfastMA = ta.sma(close, fastLength)\nslowMA = ta.sma(close, slowLength)\n// Determine the crossover conditions\nbullishCrossover = ta.crossover(fastMA, slowMA)\nbearishCrossover = ta.crossunder(fastMA, slowMA)\n// Execute a long trade when a bullish crossover occurs\nif bullishCrossover\n    strategy.entry(\"Buy\", strategy.long)\n// Execute a short trade when a bearish crossover occurs\nif bearishCrossover\n    strategy.entry(\"Sell\", strategy.short)\n// Plot the moving averages on the chart\nplot(fastMA, color= color.blue, title=\"Fast MA\")\nplot(slowMA, color= color.red, title=\"Slow MA\")"}]}
{"messages": [{"role": "user", "content": "This script is designed as a TradingView strategy that uses Bollinger Bands (BB) and Keltner Channels (KC) as the primary indicators for generating trade signals. It aims to catch potential market trends by comparing the movements of these two popular volatility measures. Key aspects of this strategy: 1. **Bollinger Bands and Keltner Channels:** Both are volatility-based indicators. The Bollinger Bands consist of a middle band (simple moving average) and two outer bands calculated based on standard deviation, which adjusts itself to market conditions. Keltner Channels are a set of bands placed above and below an exponential moving average of the price. The distance between the bands is calculated based on the Average True Range (ATR), a measure of price volatility. 2. **Entry Signals:** The strategy enters a long position when the upper KC line crosses above the upper BB line and the volume is above its moving average. Conversely, it enters a short position when the lower KC line crosses below the lower BB line and the volume is above its moving average. 3. **Exit Signals:** The strategy exits a position under two conditions. First, if the trade has been open for a certain number of bars defined by the user (default 20 bars). Second, a stop loss and trailing stop are in place to limit potential losses and lock in profits as the price moves favorably. The stop loss is set at a percentage of the entry price (default 1.5% for long and -1.5% for short), and the trailing stop is also a percentage of the entry price (default 2%). 4. **Trade Quantity:** The script allows specifying the investment amount for each trade, set to a default of 1000 currency units. Remember, this is a strategy script, which means it is used for backtesting and not for real-time signals or live trading. It is also recommended that it is used as a tool to aid your trading, not as a standalone system. As with any strategy, it should be tested over different market conditions and used in conjunction with other aspects of technical and fundamental analysis to ensure robustness and effectiveness."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 jensenvilhelm\n//@version=5\nstrategy(\"BB and KC Strategy\", overlay=true, default_qty_type=strategy.cash, default_qty_value\n// Define the input parameters for the strategy, these can be changed by the user to adjust the stra\nkcLength = input.int(20, \"KC Length\", minval=1) // Length for Keltner Channel calculation\nkcStdDev = input.float(2.2, \"KC StdDev\") // Standard Deviation for Keltner Channel calculat\nbbLength = input.int(20, \"BB Length\", minval=1) // Length for Bollinger Bands calculation\nbbStdDev = input.float(2, \"BB StdDev\") // Standard Deviation for Bollinger Bands calculat\nvolumeLength = input.int(10, \"Volume MA Length\", minval=1) // Length for moving average of volume calculation\nstopLossPercent = input.float(1.5, \"Stop Loss (%)\") // Percent of price for Stop loss \ntrailStopPercent = input.float(2, \"Trail Stop (%)\") // Percent of price for Trailing Stop\nbarsInTrade = input.int(20, \"Bars in trade before exit\", minval = 1) // Minimum number of bars in trade before consider\n// Calculate Bollinger Bands and Keltner Channel\n[bb_middle, bb_upper, bb_lower] = ta.bb(close, bbLength, bbStdDev) // Bollinger Bands calculation\n[kc_middle, kc_upper, kc_lower] = ta.kc(close, kcLength, kcStdDev) // Keltner Channel calculation\n// Calculate moving average of volume\nvol_ma = ta.sma(volume, volumeLength) // Moving average of volume calculation\n// Plotting Bollinger Bands and Keltner Channels on the chart\nplot(bb_upper, color= color.red) // Bollinger Bands upper line\nplot(bb_middle, color= color.blue) // Bollinger Bands middle line\nplot(bb_lower, color= color.red) // Bollinger Bands lower line\nplot(kc_upper, color= color.rgb(105, 255, 82)) // Keltner Channel upper line\nplot(kc_middle, color= color.blue) // Keltner Channel middle line\nplot(kc_lower, color= color.rgb(105, 255, 82)) // Keltner Channel lower line\n// Define entry conditions: long position if upper KC line crosses above upper BB line and volume is\n// and short position if lower KC line crosses below lower BB line and volume is above MA of volume\nlongCond = ta.crossover(kc_upper, bb_upper) and volume > vol_ma // Entry condition for long position\nshortCond = ta.crossunder(kc_lower, bb_lower) and volume > vol_ma // Entry condition for short position\n// Define variables to store entry price and bar counter at entry point\nvar float entry_price = na // variable to store entry price\nvar int bar_counter = na // variable to store bar counter at entry point\n// Check entry conditions and if met, open long or short position\nif (longCond)\n    strategy.entry(\"Buy\", strategy.long) // Open long position\n    entry_price := close // Store entry price\n    bar_counter := 1 // Start bar counter\nif (shortCond)\n    strategy.entry(\"Sell\", strategy.short) // Open short position\n    entry_price := close // Store entry price\n    bar_counter := 1 // Start bar counter\n// If in a position and bar counter is not na, increment bar counter\nif (strategy.position_size != 0 and na(bar_counter) == false)\n    bar_counter := bar_counter + 1 // Increment bar counter\n// Define exit conditions: close position if been in trade for more than specified bars\n// or if price drops by more than specified percent for long or rises by more than specified percent\nif (bar_counter > barsInTrade) // Only consider exit after minimum bars in trade\n    if (bar_counter >= barsInTrade)\n        strategy.close_all() // Close all positions\n    // Stop loss and trailing stop\n    if (strategy.position_size > 0)\n        strategy.exit(\"Sell\", \"Buy\", stop=entry_price * (1 - stopLossPercent/100), \n    else if (strategy.position_size < 0)\n        strategy.exit(\"Buy\", \"Sell\", stop=entry_price * (1 + stopLossPercent/100),"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    fix"}, {"role": "assistant", "content": "//@version=5\nstrategy('Equity Curve Trade with EMA', overlay=false, format=format.price, precision\neqlen = input.int(25, \"EQ EMA len\", group = \"New Equity Curve Settings\")\nshEQandMA = input.bool(true, \"Show Original Equity Curve and MA\")\nshEQfilt = input.bool(true, \"Show Filtered Equity Curve by MA\")\nPeriods = input(title='ATR Period', defval=10, group = \"SuperTrend Settings\")\nsrc = input(hl2, title='Source', group = \"SuperTrend Settings\")\nMultiplier = input.float(title='ATR Multiplier', step=0.1, defval=3.0, group = \"SuperTrend Settings\"\nchangeATR = input(title='Change ATR Calculation Method ?', defval=true, group = \"SuperTrend Settings\"\n//SuperTrend Code\natr2 = ta.sma(ta.tr, Periods)\natr = changeATR ? ta.atr(Periods) : atr2\nup = src - Multiplier * atr\nup1 = nz(up[1], up)\nup := close[1] > up1 ? math.max(up, up1) : up\ndn = src + Multiplier * atr\ndn1 = nz(dn[1], dn)\ndn := close[1] < dn1 ? math.min(dn, dn1) : dn\ntrend = 1\ntrend := nz(trend[1], trend)\ntrend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend\n// Strategy main code\nbuySignal = trend == 1 and trend[1] == -1\nsellSignal = trend == -1 and trend[1] == 1\nif buySignal\n    strategy.entry('Long', strategy.long)\nif sellSignal\n    strategy.entry('Short', strategy.short)\n//Equity Curve calcs\neq = strategy.netprofit\nch = ta.change(eq)\nneq = ch != 0 ? eq : na\nmova = ta.ema(neq,eqlen)\n// New Equity Curve\nvar float neweq = 0\nvar int ttrades = 0\nvar int wintrades = 0\nvar int losetrades = 0\nswitch\n    strategy.netprofit == strategy.netprofit[1]  => na\n    strategy.netprofit < mova and strategy.netprofit[1] > mova  => neweq := neweq \n    strategy.netprofit < mova and strategy.netprofit[1] < mova => na\n    strategy.netprofit > mova and strategy.netprofit[1] > mova => neweq := neweq +\nnewch = ta.change(neweq)\nswitch\n    newch == 0 => na\n    newch > 0 => \n        wintrades := wintrades +1\n        ttrades := ttrades +1\n    newch < 0 =>\n        losetrades := losetrades +1\n        ttrades := ttrades +1\n//plot(eq, linewidth = 2)\n//plot(mova, color=color.red)\n//plot(neweq, color= color.green, linewidth = 3)\n//Table \nvar testTable = table.new(position = position.top_right, columns = 5, rows = 10, bgcolor\ntable.cell(table_id = testTable, column = 0, row = 0, text = \"Strategy: \", bgcolor\ntable.cell(table_id = testTable, column = 1, row = 0, text = \"Original: \", bgcolor\ntable.cell(table_id = testTable, column = 2, row = 0, text = \"Equity Curve EMA: \",\ntable.cell(table_id = testTable, column = 0, row = 1, text = \"Total Trades: \", bgcolor\ntable.cell(table_id = testTable, column = 0, row = 2, text = \"Win Trades: \", bgcolor\ntable.cell(table_id = testTable, column = 0, row = 3, text = \"Lose Trades: \", bgcolor\ntable.cell(table_id = testTable, column = 0, row = 4, text = \"Win Rate: \", bgcolor\ntable.cell(table_id = testTable, column = 0, row = 5, text = \"Net Profit: \", bgcolor\n//Equity Curve EMA stat\ntable.cell(table_id = testTable, column = 2, row = 1, text = str.tostring(ttrades)\ntable.cell(table_id = testTable, column = 2, row = 2, text = str.tostring(wintrades\ntable.cell(table_id = testTable, column = 2, row = 3, text = str.tostring(losetrades\ntable.cell(table_id = testTable, column = 2, row = 4, text = str.tostring(math.round\ntable.cell(table_id = testTable, column = 2, row = 5, text = str.tostring(math.round\n//Original Strategy stat\ntable.cell(table_id = testTable, column = 1, row = 1, text = str.tostring(strategy.closedtrades\ntable.cell(table_id = testTable, column = 1, row = 2, text = str.tostring(strategy.wintrades\ntable.cell(table_id = testTable, column = 1, row = 3, text = str.tostring(strategy.losstrades\ntable.cell(table_id = testTable, column = 1, row = 4, text = str.tostring(math.round\ntable.cell(table_id = testTable, column = 1, row = 5, text = str.tostring(math.round\n//New Equity curve\nvar newcurve = array.new_float(0)\nvar int ida = 0\nvar bool printEQ = false\nif newch !=0 \n    array.push(newcurve, neweq)\nif bar_index > last_bar_index - array.size(newcurve) - 1 - 20  and array.size(newcurve\n    printEQ := true\nelse\n    printEQ := false\nplot(printEQ and ida < strategy.closedtrades and shEQfilt ? array.get(newcurve, ida\nif printEQ\n    ida := ida + 1\nif ida >= array.size(newcurve) and printEQ\n    ida := array.size(newcurve) -1\n//Original Equity curve\nvar newcurve2 = array.new_float(0)\nvar int ida2 = 0\nvar bool printEQ2 = false\nif ch !=0 \n    array.push(newcurve2, eq)\nif bar_index > last_bar_index - array.size(newcurve2) - 1 - 20  and array.size(newcurve2\n    printEQ2 := true\nelse\n    printEQ2 := false\nplot(printEQ2 and ida2 < strategy.closedtrades and shEQandMA  ? array.get(newcurve2\nif printEQ2\n    ida2 := ida2 + 1\nif ida2 >= array.size(newcurve2) and printEQ2\n    ida2 := array.size(newcurve2) -1\n//Moving Average Array\nvar marray = array.new_float(0)\nif ch\n    array.push(marray, mova)\nplot(printEQ2 and  array.size(marray) > 40 and shEQandMA ? array.get(marray, ida2-1\nhline(0,\"0 line\", color= color.black, linestyle = hline.style_dotted)\nif (last_bar_index-1) and array.size(newcurve2) > 20 and array.size(newcurve) > 20\n    l = label.new(bar_index+2, array.get(newcurve2, array.size(newcurve2)-1), \"Original Equity Curve\"\n    label.delete(l[1])\n    f = label.new(bar_index+2, array.get(newcurve, array.size(newcurve)-1), \"Filtered Equity Curve\"\n    label.delete(f[1])"}]}
{"messages": [{"role": "user", "content": "Here is the strategy version of the indicator - Master Supertrend Options and variations are same throughout. \ud83c\udfb2 Variations Following variations are provided in the form of settings. \ud83c\udfaf Range Type Instead of ATR, different types of ranges can be used for stop calculation. Here is the complete list used in the script. Plus/Minus Range* - Calculates plus range and minus range for each candle and uses them for different sides of stop calculation Ladder ATR - Based on the existing concept of Ladder ATR defined in Supertrend-Ladder-ATR True Range - True range derived from standard function ta.tr Standard Deviation - Standard deviation of close prices \ud83c\udfaf Applied Calculation In standard ATR, rma of TR is used for calculations. But, the application calculation provides option to users to use different mechanisms. It can be a type of moving average or few other types of calculations. Available values are sma ema hma rma wma high median  \ud83c\udfaf Other options Few other options provided are Use Close Price - If selected stops are calculated based on the close price instead of high/low prices Wait for Close If selected, change of supertrend direction is calculated based on close price instead of high/low prices Diminishing Stop Distance - When selected, stop distance for the trend direction can only reduce and cannot increase. This option is useful for keeping the tight stops on strong trends. \ud83c\udfaf Plus Minus Range* One of the range type used is Plus/Minus Range. What it means and how are these ranges calculated? Let's have a look. Plus Range is an upward movement of a candle from its last price or open price whichever is lower. Minus Range is a downward movement of a candle from its last price or open price whichever is higher. This divides True Range into two separate range for positive and negative side. Note: Effectiveness on daily charts are quire visible. However, if you want to use it for lower timeframes, please play around with settings before settling on suitable configuration."}, {"role": "assistant", "content": "// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Internation\n// \u00a9 Trendoscope Pty Ltd\n//                                       \u2591\u2592             \n//                                  \u2592\u2592\u2592   \u2592\u2592      \n//                              \u2592\u2592\u2592\u2592\u2592     \u2592\u2592      \n//                      \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591     \u2592     \u2592\u2592          \n//                  \u2592\u2592\u2592\u2592\u2592\u2592           \u2592     \u2592\u2592          \n//             \u2593\u2592\u2592\u2592       \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592  \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2592  \u2592       \u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591        \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592\u2592                       \n//    \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592\u2592\u2592                            \n//                 \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592                           \n//                \u2592\u2592\u2592\u2592\u2592 \u2592\u2592\u2592\u2592\u2592                          \n//               \u2591\u2592\u2592\u2592\u2592   \u2592\u2592\u2592\u2592\u2593      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n//              \u2593\u2592\u2592\u2592\u2592     \u2592\u2592\u2592\u2592      \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n//              \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592        \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//             \u2592\u2592\u2592\u2592\u2592       \u2592\u2592\u2592\u2592\u2592       \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//            \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592      \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \n//             \u2592\u2592             \u2592   \n//\n//@version=5\n// indicator(\"Master Supertrend [Trendoscope]\", \"MST [Trendoscope]\", overlay = true)\nstrategy(\"Master Supertrend Strategy [Trendoscope]\", \"MSTS [Trendoscope]\", overlay=\n         default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type\n         pyramiding=1, commission_value=0.05, close_entries_rule=\"ANY\", margin_long\n         max_lines_count=500, max_labels_count=500, max_boxes_count=500, use_bar_magnifier\nimport HeWhoMustNotBeNamed/ta/1 as eta\nimport HeWhoMustNotBeNamed/arrayutils/22 as pa\nsupertrendType = input.string('Plus/Minus Range', 'Range Type', ['Plus/Minus Range'\nrangeType = input.string('high', 'Applied Calculation', ['sma', 'ema', 'hma', 'rma'\nlength = input.int(60, 'Length', 10, 1000, 10, tooltip = 'Supertrend range calculation length'\nmultiplier = input.int(2, 'Multiplier', 2, 100, 1, tooltip='Supertrend range multiplier'\nuseClosePrices = input.bool(true, 'Use Close Price', tooltip = 'Use close price as reference instad of high/low f\nwaitForClose = input.bool(true, 'Wait for Close', tooltip = 'Wait for close before changing the direction and \nuseDiminishingRange = input.bool(true, 'Diminishing Stop Distance', tooltip = 'When selected stop distance from reference price \nfloat ladderPositiveAtr = na\nfloat ladderNegativeAtr = na\nif(supertrendType == 'Ladder TR')\n    var plusLadderAtr = array.new<float>()\n    var minusLadderAtr = array.new<float>()\n    if(open < close)\n        pa.push(plusLadderAtr, ta.tr, length)\n    else\n        pa.push(minusLadderAtr, ta.tr, length)\n    ladderPositiveAtr := pa.ma(plusLadderAtr, rangeType, length)\n    ladderNegativeAtr := pa.ma(minusLadderAtr, rangeType, length)\nplusRange = supertrendType == 'Plus/Minus Range' ? math.max(high-open, high-close[1\nminusRange = supertrendType == 'Plus/Minus Range' ? math.max(open-low, close[1]-low\nappliedPlusRange = supertrendType == 'Ladder TR'? plusRange : eta.ma(plusRange, rangeType\nappliedMinusRange = supertrendType == 'Ladder TR'? minusRange: eta.ma(minusRange, rangeType\nvar direction = 1\nvar derivedPlusRange = appliedPlusRange*multiplier\nvar derivedMinusRange = appliedMinusRange*multiplier\ncurrentDerivedPlusRange = appliedPlusRange*multiplier\nderivedPlusRange := direction < 0 and useDiminishingRange? math.min(nz(derivedPlusRange\ncurrentDerivedMinusRange = appliedMinusRange*multiplier\nderivedMinusRange := direction > 0 and useDiminishingRange? math.min(nz(derivedMinusRange\nbuyStopCurrent = (useClosePrices? close : low) - derivedMinusRange\nvar buyStop = buyStopCurrent\nsellStopCurrent = (useClosePrices? close : high) + derivedPlusRange\nvar sellStop = sellStopCurrent\nbuyStop:= direction > 0? math.max(nz(buyStop, buyStopCurrent), buyStopCurrent) : buyStopCurrent\nsellStop:=direction < 0? math.min(nz(sellStop, sellStopCurrent), sellStopCurrent) :\ndirection := direction > 0 and (waitForClose?close:low) < buyStop? -1 :\n                 direction < 0 and (waitForClose?close:high) > sellStop? 1 : direction\nsupertrend = direction[1] > 0? buyStop : sellStop\nplot(supertrend, 'Supertrend', direction[1]>0?  color.red: color.green)\nplot(direction, \"direction\", display = display.data_window)\nplot(strategy.equity, \"Equity\", display = display.data_window)\nplot(strategy.openprofit, \"Open Profit\", display = display.data_window)\nplot(strategy.opentrades, \"Open Trades\", display = display.data_window)\nif(direction > 0)\n    strategy.entry(\"Long\", strategy.long)\nif(direction < 0)\n    strategy.entry(\"Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    (Disclaimer: this script is still a work-in-progress, and it cannot possibly take into account every nuance of every tradeable market or asset class, so use at your own risk and always take the time to verify the numbers are correct) Huge thanks to Marc (www.tradingview.com/u/Mrcrbw/) for providing major improvements and fixes to the code that made this script much better! The script now *appears* to work on markets it didn't work on before (like crypto). Added/changed:  - Pages (select a 'page' of results to display, useful for markets with decades of data) - Page size (configure X number of rows/years to display per page - 20 by default) - Text size (configure size of table text, set to small by default) - Removed all table inputs displaying on status bar and cluttering up indicator values                                                    Release Notes:                                                    Latest Changes: - Added 'DD Bars' to strategy stats. This metric counts the maximum number of bars the system endured during its longest drawdown (note: longest drawdown doesn't necessarily correspond to \"worst\" drawdown) - Added Average Max Drawdown metric (check MaxDD tooltip and DD Bars tooltip for averages) - Fixed Short trade count being equal to Long trade count on Return tooltip"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 ZenAndTheArtOfTrading\n// Version 2 (Last Updated 29th June, 2023)\n// Huge thanks to Marc (https://www.tradingview.com/u/Mrcrbw/) for providing\n// major improvements and fixes to the code that made this script much better!\n// @version=5\n//////////////////////////////////////////////////////////////////////////\n// EXAMPLE STRATEGY (REPLACE THIS CODE WITH YOUR OWN)                   //\n// Replace lines 15 -> 69 with your own strategy script code!           //\n// This example system is my Simple Pullback Strategy                   //\n// Check my TradingView profile for more info about this script         //\n//////////////////////////////////////////////////////////////////////////\nstrategy(\"Monthly Performance Table\", \n     overlay=true, \n     initial_capital=100000,\n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=100,\n     commission_type=strategy.commission.cash_per_contract, \n     commission_value=0.005)\n// Get user input\ni_ma1           = input.int(title=\"MA 1 Length\", defval=200, step=10, group=\"Strategy Parameters\"\ni_ma2           = input.int(title=\"MA 2 Length\", defval=10, step=10, group=\"Strategy Parameters\"\ni_stopPercent   = input.float(title=\"Stop Loss Percent\", defval=0.10, step=0.1, group\ni_lowerClose    = input.bool(title=\"Exit On Lower Close\", defval=false, group=\"Strategy Parameters\"\ni_startTime     = input.time(title=\"Start Filter\", defval=timestamp(\"01 Jan 1995 13:30 +0000\"\ni_endTime       = input.time(title=\"End Filter\", defval=timestamp(\"1 Jan 2099 19:30 +0000\"\n// Get indicator values\nma1 = ta.sma(close, i_ma1)\nma2 = ta.sma(close, i_ma2)\n// Check filter(s)\nf_dateFilter = time >= i_startTime and time <= i_endTime\n// Check buy/sell conditions\nvar float buyPrice = 0\nbuyCondition    = close > ma1 and close < ma2 and strategy.position_size == 0 and \nsellCondition   = close > ma2 and strategy.position_size > 0 and (not i_lowerClose\nstopDistance    = strategy.position_size > 0 ? ((buyPrice - close) / close) : na\nstopPrice       = strategy.position_size > 0 ? buyPrice - (buyPrice * i_stopPercent\nstopCondition   = strategy.position_size > 0 and stopDistance > i_stopPercent\n// Enter positions\nif buyCondition\n    strategy.entry(id=\"Long\", direction=strategy.long, comment=\"Equity = $\" + str.tostring\nif buyCondition[1]\n    buyPrice := strategy.position_avg_price\n// Exit positions\nif sellCondition or stopCondition\n    strategy.close(id=\"Long\", comment=\"Exit\" + (stopCondition ? \"SL=true\" : \"\"))\n    buyPrice := na\n// Draw pretty colors\nplot(buyPrice, color= color.lime, style=plot.style_linebr)\nplot(stopPrice, color= color.red, style=plot.style_linebr, offset=-1)\nplot(ma1, color= color.blue)\nplot(ma2, color= color.orange)\n////////////////////////////////////////////////////////////\n// END EXAMPLE STRATEGY (REPLACE THIS CODE WITH YOUR OWN) //\n////////////////////////////////////////////////////////////\n//-------------------------------------------------------------------------//\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// MONTHLY TABLE based on the script written by QuantNomad - Copy & Paste code from here down into y\n// Original Script: https://tradingview.com/script/kzp8e4X3-Monthly-Returns-in-PineScript-Strategies/\n////////////////////////////////////////////////////////////////////////////////////////////////////\nvar string GROUP_PERFORMANCE_TABLE = \"Monthly Performance Table\"\nmptable_on = input.bool(title=\"Turn On |\", defval=true, display=display.none, group\nmptable_debug = input.bool(title=\"Debug Mode |\", defval=false, display=display.none\nmptable_precision = input.int(title=\"Decimal Precision\", defval=2, minval=1, display\nmptable_titleColor = input.color(title=\"Title Cell Color\", defval= #cccccc, display\nmptable_titleTextColor = input.color(title=\"Title Text Color\", defval= #363a45, display\nmptable_textColor = input.color(title=\"Cell Text Color\", defval= color.white, display\nmptable_ProfitColor = input.color(title=\"Year Profit Color\", defval= color.new(color.green\nmptable_LossColor = input.color(title=\"Year Loss Color\", defval= color.new(color.red\nmptable_BreakEvenColor = input.color(title=\"Year B/E Color\", defval= color.new(color.white\nmptable_pageNumber = input.int(title=\"Page Number\", defval=1, minval=1, step=1, maxval\nmptable_pageSize = input.int(title=\"Page Size (Rows)\", defval=20, minval=1, display\nmptable_tableTextSize = input.string(title=\"Text Size\", defval=\"Small\", options=[\"Auto\"\n// Custom function for getting table text sized based on user input\ntable_text_size(_size) =>\n    switch _size\n        \"Auto\"   => size.auto   \n        \"Huge\"   => size.huge   \n        \"Large\"  => size.large  \n        \"Normal\" => size.normal \n        \"Small\"  => size.small\n        => size.tiny\ntableTextSize = table_text_size(mptable_tableTextSize)\n// Custom function for getting decimal precision based on given number \n// (eg. if number is > 0 but < 0.05 or < 0 and > -0.05, set precision to 3 to avoid rounding to 0 wh\nGetRoundingPrecision(float num) =>\n    if (num > 0 and num < 0.05) or (num < 0 and num > -0.05)\n        3\n    else\n        mptable_precision\n// Define an open trade's cost (used to calculate commission cost)\ntype TradeCost\n    int entryTime\n    float entryPrice\n    float cost\n// Define a monthly/yearly return type\ntype StrategyReturn\n    float profit\n    float drawdown\n    float peak\n    int timestamp\n// Store accumulated P&L values\nvar float accumulatedMonthlyPL = 0\nvar float accumulatedYearlyPL = 0\nvar float bestAccumulatedMonthlyPL = 0\nvar float bestAccumulatedYearlyPL = 0\n// Store drawdown values\nvar float equityPeak = strategy.initial_capital\nvar float yearlyEquityHigh = 0\nvar float currentYearlyDrawdown = 0\nvar float yearlyMaxDrawdown = 0\nvar float worstDrawdown = 0\nvar float monthlyEquityHigh = 0\nvar float currentMonthlyDrawdown = 0\nvar float monthlyMaxDrawdown = 0\nvar int currentDrawdownBars = 0\nvar int maxDrawdownBars = 0\n// Store stat arrays\nvar totalDrawdownBars = array.new<int>(0)\nvar totalDrawdowns = array.new<float>(0)\n// Store long & short trade count\nvar int totalBreakEvenTrades = 0\nvar int totalLongTrades = 0\nvar int totalLongTradeWins = 0\nvar int totalShortTrades = 0\nvar int totalShortTradeWins = 0\n// Store open trade commission costs in array\nvar costOfOpenTrades = array.new<TradeCost>(0)\n// Detect opened trade and save cost of trade (I tried many methods to get my numbers to match the C\nif strategy.opentrades != strategy.opentrades[1] and strategy.closedtrades == strategy.closedtrades\n    costOfTrade = strategy.grossloss - strategy.grossloss[1]\n    costOfOpenTrades.push(TradeCost.new(strategy.opentrades.entry_time(strategy.opentrades\n// Detect a closed trade\n// TV Documentation: Trade List's Cumulative Profit % Formula = TradeProfit / (InitialCapital + Cumu\nif strategy.closedtrades != strategy.closedtrades[1]\n        // Retrieve trade cost for the closed trade\n    float tradeCost = 0\n    int removeIdx = -1\n    if costOfOpenTrades.size() > 0\n        for i = 0 to costOfOpenTrades.size() - 1\n            TradeCost tc = costOfOpenTrades.get(i)\n            if tc.entryTime == strategy.closedtrades.entry_time(strategy.closedtrades\n                tradeCost := tc.cost\n                removeIdx := i \n                break\n        // Remove cost\n    if removeIdx != -1\n        costOfOpenTrades.remove(removeIdx)\n    // Calculate equity before trade closed (strategy.equity will not do, because it changes bar-by-bar \n    float preEquity = strategy.initial_capital + strategy.netprofit[1]\n    // Calculate P&L + cost of this trade\n    float profitLoss = 0 \n    if strategy.losstrades > strategy.losstrades[1]\n        profitLoss := (strategy.grossloss - (strategy.grossloss[1] - tradeCost)) *\n    else\n        profitLoss := strategy.grossprofit - strategy.grossprofit[1]\n        // Check if this was a long or short trade and if it won or lost\n    if strategy.position_size[1] > 0\n        totalLongTrades := totalLongTrades + 1\n        if profitLoss > 0\n            totalLongTradeWins := totalLongTradeWins + 1\n    else if strategy.position_size[1] < 0\n        totalShortTrades := totalShortTrades + 1\n        if profitLoss > 0\n            totalShortTradeWins := totalShortTradeWins + 1\n            // Check if the trade broke even\n    if profitLoss == 0\n        totalBreakEvenTrades := totalBreakEvenTrades + 1\n    // Calculate cumulative profit % for this trade \n    float cumulativeProfitPercent = (profitLoss / preEquity) * 100\n    // Store highest peak value of equity (we can now use strategy.equity since equity has updated to re\n    if strategy.equity > equityPeak\n        equityPeak := strategy.equity\n    // Calculate total system drawdown %\n    float equityDD = ((strategy.equity - equityPeak) / equityPeak) * 100\n    if equityDD < worstDrawdown\n        worstDrawdown := equityDD\n    // Store accumulated monthly + yearly P&L\n    accumulatedMonthlyPL := cumulativeProfitPercent + accumulatedMonthlyPL[1]\n    accumulatedYearlyPL := accumulatedYearlyPL + cumulativeProfitPercent\n    // Save max favourable excursion for this month (ie. peak return as %)\n    if accumulatedMonthlyPL > bestAccumulatedMonthlyPL\n        bestAccumulatedMonthlyPL := accumulatedMonthlyPL\n    // Save max favourable excursion for this year (ie. peak return as %)\n    if accumulatedYearlyPL > bestAccumulatedYearlyPL\n        bestAccumulatedYearlyPL := accumulatedYearlyPL\n    // Track max equity high over current year for max yearly drawdown calculation\n    if accumulatedYearlyPL > yearlyEquityHigh\n        yearlyEquityHigh := accumulatedYearlyPL\n        // Check if our yearly realized equity high minus current realized equity exceeds our stored max dra\n    if accumulatedYearlyPL - yearlyEquityHigh < 0\n        currentYearlyDrawdown := accumulatedYearlyPL - yearlyEquityHigh\n        if currentYearlyDrawdown < yearlyMaxDrawdown\n            yearlyMaxDrawdown := currentYearlyDrawdown\n        currentDrawdownBars := currentDrawdownBars + 1\n        // Track max equity high over current month for max monthly drawdown calculation\n    if accumulatedMonthlyPL > monthlyEquityHigh\n        monthlyEquityHigh := accumulatedMonthlyPL\n        // Check if our monthly realized equity high minus current realized equity exceeds our stored max dr\n    if accumulatedMonthlyPL - monthlyEquityHigh < 0\n        currentMonthlyDrawdown := accumulatedMonthlyPL - monthlyEquityHigh\n        if currentMonthlyDrawdown < monthlyMaxDrawdown\n            monthlyMaxDrawdown := currentMonthlyDrawdown\n        // Debug label\n    if mptable_debug\n        string debugTip = \"Equity = $\" + str.tostring(strategy.equity, \"#.##\") + \n         \"\\nP&L=\" + str.tostring(cumulativeProfitPercent) + \"%\" +\n         \"\\nAccumMonthlyP&L=\" + str.tostring(math.round(accumulatedMonthlyPL, GetRoundingPrecision\n         \"\\nAccumYearlyP&L=\" + str.tostring(math.round(accumulatedYearlyPL, GetRoundingPrecision\n         \"\\nMonthlyMaxDD=\" + str.tostring(math.round(monthlyMaxDrawdown, GetRoundingPrecision\n         \"\\nYearlyMaxDD=\" + str.tostring(math.round(yearlyMaxDrawdown, GetRoundingPrecision\n         \"\\nTotalMaxDD=\" + str.tostring(math.round(worstDrawdown, GetRoundingPrecision\n         \"\\nCurrentDDBars=\" + str.tostring(currentDrawdownBars) +\n         \"\\nMaxDDBars=\" + str.tostring(maxDrawdownBars) +\n         \"\\nTotalBreakEven=\" + str.tostring(totalBreakEvenTrades) +\n         \"\\nTotalLongs=\" + str.tostring(totalLongTrades) +\n         \"\\nTotalLongWins=\" + str.tostring(totalLongTradeWins) +\n         \"\\nTotalShorts=\" + str.tostring(totalShortTrades) +\n         \"\\nTotalShortWins=\" + str.tostring(totalShortTradeWins)\n        label.new(bar_index, high + (high * 0.01), \"P&L \" + str.tostring(math.round\n// Calculate drawdown since last equity high (NOT max drawdown, just the current max DD since we wer\nfloat t_equityDD = ((strategy.equity - equityPeak) / equityPeak) * 100\nvar float currentMaxDrawdownSinceLast = 0\n// Update Max Drawdown bar count and current DD if equity is under water, check isconfirmed to preve\nif strategy.equity < equityPeak and barstate.isconfirmed\n    currentDrawdownBars := currentDrawdownBars + 1\n    if currentDrawdownBars > maxDrawdownBars\n        maxDrawdownBars := currentDrawdownBars\n    if t_equityDD < currentMaxDrawdownSinceLast\n        currentMaxDrawdownSinceLast := t_equityDD\nelse\n    if currentDrawdownBars > 0\n        totalDrawdownBars.push(currentDrawdownBars)\n        totalDrawdowns.push(currentMaxDrawdownSinceLast)\n    currentDrawdownBars := 0\n    currentMaxDrawdownSinceLast := 0\n// Prepare arrays to store Yearly and Monthly P&Ls\nvar monthlyReturns = array.new<StrategyReturn>(0)\nvar yearlyReturns = array.new<StrategyReturn>(0)\nvar bool firstEntryTime = false\n// Retrieve entry time of initial entry in open position\nif not firstEntryTime and strategy.opentrades.entry_time(0)\n    firstEntryTime := true\n// Detect new month and year\nnew_month = month(time) != month(time[1])\nnew_year = year(time) != year(time[1])\n// Detect a new month and store its return profile\nif not barstate.isfirst and new_month and firstEntryTime or barstate.islastconfirmedhistory\n    StrategyReturn mr = StrategyReturn.new(accumulatedMonthlyPL, monthlyMaxDrawdown\n    monthlyReturns.push(mr)\n    accumulatedMonthlyPL := 0\n    monthlyMaxDrawdown := 0\n    monthlyEquityHigh := 0\n    currentMonthlyDrawdown := 0\n    bestAccumulatedMonthlyPL := 0\n    // Detect a new year and reset tracking variables\nif not barstate.isfirst and new_year and firstEntryTime or barstate.islastconfirmedhistory\n    StrategyReturn yr = StrategyReturn.new(accumulatedYearlyPL, yearlyMaxDrawdown,\n    yearlyReturns.push(yr)\n    accumulatedYearlyPL := 0\n    yearlyMaxDrawdown := 0\n    yearlyEquityHigh := 0\n    currentYearlyDrawdown := 0\n    bestAccumulatedYearlyPL := 0\n// DEBUG code\nbgcolor(mptable_debug and new_month ?  color.lime : na, title=\"New Month\", display\nbgcolor(mptable_debug and new_year ?  color.red : na, title=\"New Year\", display=display.none\n// END DEBUG CODE\n// Define Monthly P&L Table    \nvar table performance_table = table(na)\n//Adjust mptable_pageSize if the years are less than the mptable_pageSize\nif yearlyReturns.size() < mptable_pageSize\n    mptable_pageSize := yearlyReturns.size()\n// Caluclate the start and end of page to display\nstartIndex = math.max(math.min(yearlyReturns.size() - 1, yearlyReturns.size() - 1 \nendIndex = math.max(startIndex - mptable_pageSize, 0)\nmptable_pageSize := endIndex <= mptable_pageSize ? endIndex : mptable_pageSize\n// If this is the last bar on our chart, display the performance table\nvar int EXTRA_STAT_ROWS = 5 // This ensures table includes enough rows for CAGR etc\nif mptable_on and monthlyReturns.size() > 0 and barstate.islastconfirmedhistory\n    // Create table (100 rows = 100 years of data, should be plenty for all markets!)\n    performance_table := table.new(position.bottom_right, columns=17, rows=yearlyReturns\n    // Set column headers\n    performance_table.cell(0, 0, \"Year\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(1, 0, \"Jan\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(2, 0, \"Feb\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(3, 0, \"Mar\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(4, 0, \"Apr\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(5, 0, \"May\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(6, 0, \"Jun\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(7, 0, \"Jul\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(8, 0, \"Aug\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(9, 0, \"Sep\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(10, 0, \"Oct\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(11, 0, \"Nov\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(12, 0, \"Dec\", bgcolor=mptable_titleColor, text_color=mptable_titleTextColor\n    performance_table.cell(13, 0, \"TOTAL\", bgcolor=mptable_titleColor, text_color=\n    performance_table.cell(14, 0, \"MaxDD\", bgcolor=mptable_titleColor, text_color=\n    // Set yearly values\n    for year_index = startIndex to yearlyReturns.size() == 0 ? na : endIndex\n                // Get yearly return for this loop, set year number in first column, determine color of cell\n        StrategyReturn yearlyReturn = yearlyReturns.get(year_index)\n        // Set year title and determine color\n        performance_table.cell(0, year_index + 1, str.tostring(year(yearlyReturn.timestamp\n        color y_color = yearlyReturn.profit > 0 ? mptable_ProfitColor : yearlyReturn\n        // Populate yearly cell values\n        string yearlyTip = \"MaxDD: \" + str.tostring(math.round(yearlyReturn.drawdown\n             \"\\nMFE: \" + str.tostring(math.round(yearlyReturn.peak, GetRoundingPrecision\n        performance_table.cell(13, year_index + 1, (yearlyReturn.profit > 0 ? \"+\" \n        performance_table.cell(14, year_index + 1, str.tostring(math.round(yearlyReturn\n        // Set monthly values\n        for month_index = 0 to monthlyReturns.size() - 1\n            // Get monthly return for this loop, get current year for this loop, then calculate the correspondin\n            StrategyReturn monthlyReturn = monthlyReturns.get(month_index)\n            int yearOfMonth = year(monthlyReturn.timestamp)\n            int monthCol = month(monthlyReturn.timestamp)\n                        // populate monthly profit only if the years of the yearly return match with the monthly return. \n            if yearOfMonth == year(yearlyReturn.timestamp)\n                 // Determine color for monthly P&L\n                color m_color = monthlyReturn.profit > 0 ? color.new(mptable_ProfitColor\n                                // Set monthly P&L cell\n                string monthlyTip = \"MaxDD: \" + str.tostring(math.round(monthlyReturn\n                     \"\\nMFE: \" + str.tostring(math.round(monthlyReturn.peak, GetRoundingPrecision\n                performance_table.cell(monthCol, year_index + 1, str.tostring(math.round\n    float percentReturn = (strategy.netprofit / strategy.initial_capital) * 100\n    float cagr = (math.pow((strategy.netprofit + strategy.initial_capital) / strategy.initial_capital\n    float mar = cagr / math.abs(worstDrawdown)\n    lastMonthRowIndex = startIndex < 5 ? 5 : startIndex\n    // Populate table data\n    float totalWinRate = (strategy.wintrades / strategy.closedtrades) * 100\n    float longWinRate = nz((totalLongTradeWins / totalLongTrades) * 100)\n    float shortWinRate = nz((totalShortTradeWins / totalShortTrades) * 100)\n    string returnTip = \"Based on a total of \" + str.tostring(strategy.closedtrades\n         \"\\nWin Rate = \" + str.tostring(math.round(totalWinRate, GetRoundingPrecision\n         \"\\nLong Trades = \" + str.tostring(totalLongTrades) + \" (Win \" + str.tostring\n         \"\\nShort Trades = \" + str.tostring(totalShortTrades) + \" (Win \" + str.tostring\n    performance_table.cell(15, lastMonthRowIndex, \"Return: \" + (percentReturn > 0 \n    performance_table.cell(15, lastMonthRowIndex - 1, \"MAR: \" + str.tostring(mar, \n    performance_table.cell(15, lastMonthRowIndex - 2, \"DD Bars: \" + str.tostring(maxDrawdownBars\n    performance_table.cell(15, lastMonthRowIndex - 3, \"MaxDD: \" + str.tostring(math.round\n    performance_table.cell(15, lastMonthRowIndex - 4, \"CAGR: \" + (cagr > 0 ? \"+\" :\n    performance_table.cell(15, lastMonthRowIndex - 5, \"REALIZED P&L\", bgcolor=mptable_titleColor\n// } END MONTHLY TABLE\n/////////// END OF PERFORMANCE TABLE CODE. ///////////"}]}
{"messages": [{"role": "user", "content": "This is a simple strategy that is working well on SPY but also well performing on Mini Futures SP500. The strategy is composed by the followin rules: 1. If RSI(2) is less than 15, then enter at the close. 2. Exit on close if today\u2019s close is higher than yesterday\u2019s high. If you backtest it on Mini Futures SP500 you will be able to track data from 1993. It is important to select D1 as timeframe. Please share any comment or idea below. Have a good trading, Ram\u00f3n."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 hobbiecode\n// If RSI(2) is less than 15, then enter at the close.\n// Exit on close if today\u2019s close is higher than yesterday\u2019s high.\n//@version=5\nstrategy(\"Hobbiecode - RSI + Close previous day\", overlay=true)\n// RSI parameters\nrsi_period = 2\nrsi_lower = 15\n// Calculate RSI\nrsi_val = ta.rsi(close, rsi_period)\n// Check if RSI is lower than the defined threshold\nif (rsi_val < rsi_lower)\n    strategy.entry(\"Buy\", strategy.long)\n// Check if today's close is higher than yesterday's high\nif (strategy.position_size > 0 and close > ta.highest(high[1], 1))\n    strategy.close(\"Buy\")\n// Plot RSI on chart\nplot(rsi_val, title=\"RSI\", color= color.red)\nhline(rsi_lower, title=\"Oversold Level\", color= color.blue)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Backtest updated."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 hobbiecode\n// If today\u2019s close is below yesterday\u2019s five-day low, go long at the close.\n// Sell at the close when the two-day RSI closes above 50.\n// There is a time stop of five days if the sell criterium is not triggered.\n//@version=5\nstrategy(\"Hobbiecode - Five Day Low RSI Strategy\", overlay=true)\n// RSI parameters\nrsi_period = 2\nrsi_upper = 50\n// Calculate RSI\nrsi_val = ta.rsi(close, rsi_period)\n// Check if today's close is below yesterday's 5 day low\nconditionEntry = close < ta.lowest(low[1], 5) and strategy.position_size < 1\nif (conditionEntry)\n    strategy.entry(\"Buy\", strategy.long)\n// Check if RSI closes above 50\nif (strategy.position_size > 0 and rsi_val > rsi_upper)\n    strategy.close(\"Buy\")\n// If position held for more than 5 days without sell criteria, then close position\nif (strategy.position_size > 0 and ta.barssince(conditionEntry) >= 5)\n    strategy.close(\"Buy\")\n// Plot RSI on chart\nplot(rsi_val, title=\"RSI\", color= color.red)\nhline(rsi_upper, title=\"Overbought Level\", color= color.blue)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Backtesting adjusted."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 hobbiecode\n// Today is Monday.\n// The close must be lower than the close on Friday.\n// The IBS must be below 0.5.\n// If 1-3 are true, then enter at the close.\n// Sell 5 trading days later (at the close).\n//@version=5\nstrategy(\"Hobbiecode - SP500 IBS + Higher\", overlay=true)\n// Check if it's Monday\nisMonday = dayofweek(time) == dayofweek.monday\n// Calculate the IBS (Intraday Breadth Strength) indicator\nibs = (close - low) / (high - low)\n// Calculate the close on the previous Friday\nprevFridayClose = request.security(syminfo.tickerid, \"W\", close[1])\n// Entry conditions\nenterCondition = isMonday and close < prevFridayClose and ibs < 0.5 and strategy.position_size\n// Exit conditions\nexitCondition = (close > high[1] or ta.barssince(enterCondition) == 4) and strategy.position_size\n// Entry signal\nif enterCondition\n    strategy.entry(\"Buy\", strategy.long)\n// Exit signal\nif exitCondition\n    strategy.close(\"Buy\")\n// Plotting the close, previous Friday's close, and entry/exit points on the chart\nplot(close, title=\"Close\", color= color.blue)\nplot(prevFridayClose, title=\"Previous Friday Close\", color= color.orange)\nplotshape(enterCondition, title=\"Enter\", location=location.belowbar, color= color.green\nplotshape(exitCondition, title=\"Exit\", location=location.abovebar, color= color.red"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added take profit, fixed commission regime, and changed default % equity to be more realistic. A note to new people interested in the strategy - use this strategy as the basis for your own strategies, it is still experimental."}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"VWAP Trendfollow Strategy [wbburgin]\", shorttitle=\"VWAP Trendfollow [wbburgin]\"\n default_qty_type = strategy.percent_of_equity,default_qty_value = 3,initial_capital\n  commission_value = 0.025)\nimport wbburgin/wbburgin_utils/2 as utils\nhideonDWM = input(false, title=\"Hide VWAP on 1D or Above\", group=\"VWAP Settings\")\nvar anchor = input.string(defval = \"Session\", title=\"Anchor Period\",\n options=[\"Session\", \"Week\", \"Month\", \"Quarter\", \"Year\", \"Decade\", \"Century\", \"Earnings\"\nsrc = input(title = \"Source\", defval = hlc3, group=\"VWAP Settings\")\noffset = input(0, title=\"Offset\", group=\"VWAP Settings\")\nshowBand_1 = input(true, title=\"\", group=\"Standard Deviation Bands Settings\", inline\nstdevMult_1 = input(0.88, title=\"Standard Deviation Multiplier\", group=\"Standard Deviation Bands Settings\"\nmatchedTrends = input.bool(true,\"Only Enter on Matched Trends\",tooltip = \"This setting will only enter a long trade\"\n \" when the VWAP is trending up and will only enter a short trade when the VWAP is trending down.\"\ndisplaybars = input.bool(true,\"Barcolors\",group=\"Display\")\nif barstate.islast and ta.cum(volume) == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nnew_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on\nnew_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on\nnew_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, \nisNewPeriod = switch anchor\n    \"Earnings\"  => not na(new_earnings)\n    \"Dividends\" => not na(new_dividends)\n    \"Splits\"    => not na(new_split)\n    \"Session\"   => timeframe.change(\"D\")\n    \"Week\"      => timeframe.change(\"W\")\n    \"Month\"     => timeframe.change(\"M\")\n    \"Quarter\"   => timeframe.change(\"3M\")\n    \"Year\"      => timeframe.change(\"12M\")\n    \"Decade\"    => timeframe.change(\"12M\") and year % 10 == 0\n    \"Century\"   => timeframe.change(\"12M\") and year % 100 == 0\n    => false\nisEsdAnchor = anchor == \"Earnings\" or anchor == \"Dividends\" or anchor == \"Splits\"\nif na(src[1]) and not isEsdAnchor\n    isNewPeriod := true\nfloat vwapValue = na\nfloat upperBandValue1 = na\nfloat lowerBandValue1 = na\nfloat upperBandValue2 = na\nfloat lowerBandValue2 = na\nif not (hideonDWM and timeframe.isdwm)\n    [_vwap, _stdevUpper, _] = ta.vwap(src, isNewPeriod, 1)\n    vwapValue := _vwap\n    stdevAbs = _stdevUpper - _vwap\n    upperBandValue1 := _vwap + stdevAbs * stdevMult_1\n    lowerBandValue1 := _vwap - stdevAbs * stdevMult_1\n    upperBandValue2 := _vwap + 2 * stdevAbs * stdevMult_1\n    lowerBandValue2 := _vwap - 2 * stdevAbs * stdevMult_1\nvTopBreak = ta.crossover(close,upperBandValue1)\nvBottomBreak = ta.crossunder(close,lowerBandValue1)\ninLongTrade = ta.barssince(vTopBreak) < ta.barssince(vBottomBreak)\nupV = utils.trendUp(vwapValue)\nmatchedTrendsFilter_long = not matchedTrends ? true : upV\nmatchedTrendsFilter_short = not matchedTrends ? true : not upV\nb_vwap = vTopBreak and matchedTrendsFilter_long\ns_vwap = vBottomBreak and matchedTrendsFilter_short\ntakeprofit_long = ta.crossunder(close,upperBandValue2)\ntakeprofit_short = ta.crossover(close,lowerBandValue2)\nif b_vwap\n    strategy.entry(\"Long\",strategy.long)\nif s_vwap\n    strategy.entry(\"Short\",strategy.short)\nif takeprofit_long\n    strategy.close(\"Long\")\nif takeprofit_short\n    strategy.close(\"Short\")\nplot(vwapValue, title=\"VWAP\", color= color.white, offset=offset)\nupperBand_1 = plot(upperBandValue1, title=\"Upper Band #1\", color=na, offset=offset)\nlowerBand_1 = plot(lowerBandValue1, title=\"Lower Band #1\", color=na, offset=offset)\nplot(upperBandValue2,color =  color.lime)\nplot(lowerBandValue2,color= color.red)\nhl2_plot = plot(hl2,color=na,title=\"HL2\")\nfill(hl2_plot,upperBand_1,color = hl2 > upperBandValue1 ?  color.new(color.green,50\nfill(hl2_plot,lowerBand_1,color = hl2 < lowerBandValue1 ?   color.new(color.red,50\nfill(upperBand_1, lowerBand_1, title=\"Bands Fill\", color= upV ?  color.new(color.lime\nbarcolor(displaybars == true ? inLongTrade ?  color.lime :  color.red : na)"}]}
{"messages": [{"role": "user", "content": "Strategy Description: Range Breaker The Range Breaker strategy is a breakout trading strategy that aims to capture profits when the price of a financial instrument moves out of a defined range. The strategy identifies swing highs and swing lows over a specified lookback period and enters long or short positions when the price breaks above the swing high or below the swing low, respectively. It also employs stop targets based on a percentage to manage risk and protect profits. Beginner's Guide: Understand the concepts: a. Swing High: A swing high is a local peak in price where the price is higher than the surrounding prices. b. Swing Low: A swing low is a local trough in price where the price is lower than the surrounding prices. c. Lookback Period: The number of bars or periods the strategy analyzes to determine swing highs and swing lows. d. Stop Target: A predetermined price level at which the strategy will exit the position to manage risk and protect profits. Configure the strategy: a. Set the initial capital, order size, commission, and pyramiding as needed for your specific trading account. b. Choose the desired lookback period to identify the swing highs and lows. c. Set the stop target multiplier and stop target percentage as desired to manage risk and protect profits. Backtest the strategy: a. Set the backtest start date to analyze the strategy's historical performance. b. Observe the backtesting results to evaluate the strategy's effectiveness and adjust the parameters if necessary. Implement the strategy: a. Apply the strategy to your preferred financial instrument on the TradingView platform. b. Monitor the strategy's performance and adjust the parameters as needed to optimize its effectiveness. Risk management: a. Always use a stop target to protect your trading capital and manage risk. b. Don't risk more than a small percentage of your trading capital on a single trade. c. Be prepared to adjust the strategy or stop trading it if the market conditions change significantly. Adjusting the Lookback Period and Timeframes for Optimal Strategy Performance The Range Breaker strategy uses a lookback period to identify swing highs and lows, which serve as the basis for determining entry and exit points for long and short positions. By adjusting the lookback period and analyzing different timeframes, you can potentially find the best strategy configuration for each specific asset. Adjusting the lookback period: The lookback period is a critical parameter that affects the sensitivity of the strategy to price movements. A shorter lookback period will make the strategy more sensitive to smaller price fluctuations, resulting in more frequent trading signals. On the other hand, a longer lookback period will make the strategy less sensitive, generating fewer signals but potentially capturing larger price movements. To optimize the lookback period for a specific asset, you can test different lookback values and compare their performance in terms of risk-adjusted returns, win rate, and other relevant metrics. Keep in mind that using an overly short lookback period may lead to overtrading and increased transaction costs, while an overly long lookback period may cause the strategy to miss profitable trading opportunities. Analyzing different timeframes: Timeframes refer to the duration of each bar or candlestick on the chart. Shorter timeframes (e.g., 5-minute, 15-minute, or 30-minute) focus on intraday price movements, while longer timeframes (e.g., daily, weekly, or monthly) capture longer-term trends. The choice of timeframe affects the number of trading signals generated by the strategy and the length of time each position is held. To find the best strategy for each asset, you can test the Range Breaker strategy on different timeframes and analyze its performance. Keep in mind that shorter timeframes may require more active monitoring and management due to the increased frequency of trading signals. Longer timeframes, on the other hand, may require more patience as positions are held for extended periods. Finding the best strategy for each asset: Every asset has unique price characteristics that may affect the performance of a trading strategy. To find the best strategy for each asset, you should: a. Test various lookback periods and timeframes, observing the strategy's performance in terms of profitability, risk-adjusted returns, and win rate. b. Consider the asset's historical price behavior, such as its volatility, liquidity, and trend-following or mean-reverting tendencies. c. Evaluate the strategy's performance during different market conditions, such as bullish, bearish, or sideways markets, to ensure its robustness. d. Keep in mind that each asset may require a unique set of strategy parameters for optimal performance, and there may be no one-size-fits-all solution. By experimenting with different lookback periods and timeframes, you can fine-tune the Range Breaker strategy for each specific asset, potentially improving its overall performance and adaptability to changing market conditions. Always practice proper risk management and be prepared to make adjustments as needed. Remember that trading strategies carry inherent risk, and past performance is not indicative of future results. Always practice proper risk management and consider your own risk tolerance before trading with real money."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 deperp\n//@version=5\nstrategy(\"Range Breaker\", overlay=true, initial_capital=100000, default_qty_type=strategy.percent_of_equity\n// Backtest Time Period\nuseDateFilter = input.bool(true, title=\"Begin Backtest at Start Date\",\n     group=\"Backtest Time Period\")\nbacktestStartDate = input.time(timestamp(\"1 Jan 2020\"), \n     title=\"Start Date\", group=\"Backtest Time Period\",\n     tooltip=\"This start date is in the time zone of the exchange \" + \n     \"where the chart's instrument trades. It doesn't use the time \" + \n     \"zone of the chart or of your computer.\")\ninTradeWindow = not useDateFilter or time >= backtestStartDate\nswingLookback = input.int(20, title=\"Swing Lookback\", minval=3)\nstopTargetPercent = input.float(5, title=\"Stop Target Percentage\", step=0.1)\n// Calculate lockback swings\nswings(len) =>\n    var highIndex = bar_index\n    var lowIndex = bar_index\n    var swingHigh = float(na)\n    var swingLow = float(na)\n        upper = ta.highest(len)\n    lower = ta.lowest(len)\n        if high[len] > upper\n        highIndex := bar_index[len]\n        swingHigh := high[len]\n    if low[len] < lower\n        lowIndex := bar_index[len]\n        swingLow := low[len]\n    [swingHigh, swingLow, highIndex, lowIndex]\n// Strategy logic\n[swingHigh, swingLow, highIndex, lowIndex] = swings(swingLookback)\nlongCondition = inTradeWindow and (ta.crossover(close, swingHigh))\nshortCondition = inTradeWindow and (ta.crossunder(close, swingLow))\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\nlongStopTarget = close * (1 + stopTargetPercent / 100)\nshortStopTarget = close * (1 - stopTargetPercent / 100)\nstrategy.exit(\"Long Stop Target\", \"Long\", limit=longStopTarget)\nstrategy.exit(\"Short Stop Target\", \"Short\", limit=shortStopTarget)\n// Plot break lines\nline.new(x1=highIndex, y1=swingHigh, x2=bar_index, y2=swingHigh, color= color.rgb(\nline.new(x1=lowIndex, y1=swingLow, x2=bar_index, y2=swingLow, color= color.rgb(76,\n// Alert conditions for entry and exit\nlongEntryCondition = inTradeWindow and (ta.crossover(close, swingHigh))\nshortEntryCondition = inTradeWindow and (ta.crossunder(close, swingLow))\nlongExitCondition = close >= longStopTarget\nshortExitCondition = close <= shortStopTarget\nalertcondition(longEntryCondition, title=\"Long Entry Alert\", message=\"Enter Long Position\"\nalertcondition(shortEntryCondition, title=\"Short Entry Alert\", message=\"Enter Short Position\"\nalertcondition(longExitCondition, title=\"Long Exit Alert\", message=\"Exit Long Position\"\nalertcondition(shortExitCondition, title=\"Short Exit Alert\", message=\"Exit Short Position\""}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Fix Exit Alerts"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 deperp\n//@version=5\nstrategy(\"Wyckoff Range Strategy by deperp\", overlay=true, initial_capital=1000, default_qty_type\n// Input Variables\nAccumulationLength = input(32, \"Accumulation\")\nDistributionLength = input(35, \"Distribution\")\nSpringLength = input(10, \"Spring\")\nUpthrustLength = input(20, \"Upthrust\")\nstopPercentage = input(10, \"Stop Percentage\")\n// Accumulation Phase\nisAccumulation = ta.crossover(close, ta.sma(close, AccumulationLength))\n// Distribution Phase\nisDistribution = ta.crossunder(close, ta.sma(close, DistributionLength))\n// Spring and Upthrust\nisSpring = ta.crossover(low, ta.sma(low, SpringLength))\nisUpthrust = ta.crossunder(high, ta.sma(high, UpthrustLength))\n// Strategy Conditions\nenterLong = isAccumulation and isSpring\nenterShort = isDistribution and isUpthrust\n// Entry and Exit Conditions\nif (enterLong)\n    strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long, comment=\"Enter Long\")\n    alert(\"Enter Long Position\")\nif (enterShort)\n    strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short,  comment=\"Enter Short\")\n    alert(\"Enter Short Position\")\n// Stop Loss\nstopLossLevelLong = close * (1 - stopPercentage / 100)\nstopLossLevelShort = close * (1 + stopPercentage / 100)\nstrategy.exit(\"Stop Loss Long\", \"Long\", stop=stopLossLevelLong)\nstrategy.exit(\"Stop Loss Short\", \"Short\", stop=stopLossLevelShort)\n// Plotting Wyckoff Schematics\nplotshape(isAccumulation, title=\"Accumulation Phase\", location=location.belowbar, color\nplotshape(isDistribution, title=\"Distribution Phase\", location=location.abovebar, color\nplotshape(isSpring, title=\"Spring\", location=location.belowbar, color= color.blue,\nplotshape(isUpthrust, title=\"Upthrust\", location=location.abovebar, color= color.orange"}]}
{"messages": [{"role": "user", "content": "Initial Balance Strategy Initial Balance Strategy uses a source code of \"Initial Balance Monitoring Panel\" that build from \"Initial Balance Markets Time Zones - Overall Highest and Lowest\". Initial Balance is based on the highest and lowest price action within the first 60 minutes of trading. Reading online this can depict which way the market can trend for the session. More information about Initial Balance Panel you can read at the end of the article. Strategy idea The main idea is to catch the trend move when most of the 16 Crypto pairs break the Low or High levels together. I found good results when 15 of 16 pairs is break that levels and after we manage the trade within some trail stop indicator, I choose Volatility Stop for this strategy. Additional Strategy idea The second one idea that was not made is to catch the pullback after fully green/red zones in Initial Balance Panel become white. That mean the main trend can be finished and we can try to catch good pullback in opposite direction.  Binance Crypto pairs The strategy use the 16 default Crypto currencies pairs from the Binance. As additional variations of the strategy can be changing the currencies pairs and their number. List of default pairs: BINANCE:BTCUSDT, BINANCE:ETHUSDT, BINANCE:EOSUSDT, BINANCE:LTCUSDT, BINANCE:XRPUSDT, BINANCE:DASHUSDT, BINANCE:IOTAUSDT, BINANCE:NEOUSDT, BINANCE:QTUMUSDT, BINANCE:XMRUSDT, BINANCE:ZECUSDT, BINANCE:ETCUSDT, BINANCE:ADAUSDT, BINANCE:XTZUSDT, BINANCE:LINKUSDT, BINANCE:DOTUSDT Summary The strategy works very well for a buy trades with settings 15 crypto pairs of 16 that follow the trend with breaking the long initial balance level. Initial Balance Monitoring Panel Allows you to have an instant view of 16 Crypto pairs within a monitoring panel, monitoring Initial Balance (Asia, London, New York Stock Exchanges). The code can easily be changed to suit the crypto pairs you are trading. The setup of my chart would also include this indicator and the \"Initial Balance Markets Time Zones - Overall Highest and Lowest\" (with all IBs enabled) as shown above. Initial Balance is based on the highest and lowest price action within the first 60 minutes of trading. Reading online this can depict which way the market can trend for the session. The indicator has been coded for Crypto (so other symbols may not work as expected). Though Initial Balance is based off the first 60 minutes of the trading markets opening, but Crypto is 24/7, this indicator looks at how Asia, London and New York Stock Exchanges opening trading can affect Crypto price action. Source: Initial Balance Monitoring Panel"}, {"role": "assistant", "content": "//@version=5\nstrategy(title='Initial Balance Panel Strategy', shorttitle='Initial Balance Strategy'\n////////////////////////////////////////////////////////////////////////////////////////////////////\nLongCNT = input.int(15, \"Num of pairs for Long\", group = \"Main Settings\")\nShortCNT = input.int(17, \"Num of pairs for Short\", group = \"Main Settings\")\nBTCsame = input.bool(false, \"BTC break the level\")\nBTCNB = input.bool(false, \"BTC not break the level\")\n// Volatility Stop\nlength = input.int(20, \"Length\", minval = 2, group = \"Volatility Stop\")\nsrc = input.source(close, \"Source\", group = \"Volatility Stop\")\nfactor = input.float(2.0, \"Multiplier\", minval = 0.25, step = 0.25, group = \"Volatility Stop\"\nvolStop(src, atrlen, atrfactor) =>\n    var max     = src\n    var min     = src\n    var uptrend = true\n    var stop    = 0.0\n    atrM        = nz(ta.atr(atrlen) * atrfactor, ta.tr)\n    max         := math.max(max, src)\n    min         := math.min(min, src)\n    stop        := nz(uptrend ? math.max(stop, max - atrM) : math.min(stop, min + \n    uptrend     := src - stop >= 0.0\n    if uptrend != nz(uptrend[1], true)\n        max    := src\n        min    := src\n        stop   := uptrend ? max - atrM : min + atrM\n    [stop, uptrend]\n[vStop, uptrend] = volStop(src, length, factor)\nplot(vStop, \"Volatility Stop\", style=plot.style_line, linewidth =2, color= uptrend\n// USER Symbol Input\nSymbol01 = input(title='Symbol Selection', defval='BINANCE:BTCUSDT')\nSymbol02 = input(title='Symbol Selection', defval='BINANCE:ETHUSDT')\nSymbol03 = input(title='Symbol Selection', defval='BINANCE:EOSUSDT')\nSymbol04 = input(title='Symbol Selection', defval='BINANCE:LTCUSDT')\nSymbol05 = input(title='Symbol Selection', defval='BINANCE:XRPUSDT')\nSymbol06 = input(title='Symbol Selection', defval='BINANCE:DASHUSDT')\nSymbol07 = input(title='Symbol Selection', defval='BINANCE:IOTAUSDT')\nSymbol08 = input(title='Symbol Selection', defval='BINANCE:NEOUSDT')\nSymbol09 = input(title='Symbol Selection', defval='BINANCE:QTUMUSDT')\nSymbol10 = input(title='Symbol Selection', defval='BINANCE:XMRUSDT')\nSymbol11 = input(title='Symbol Selection', defval='BINANCE:ZECUSDT')\nSymbol12 = input(title='Symbol Selection', defval='BINANCE:ETCUSDT')\nSymbol13 = input(title='Symbol Selection', defval='BINANCE:ADAUSDT')\nSymbol14 = input(title='Symbol Selection', defval='BINANCE:XTZUSDT')\nSymbol15 = input(title='Symbol Selection', defval='BINANCE:LINKUSDT')\nSymbol16 = input(title='Symbol Selection', defval='BINANCE:DOTUSDT')\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Start of the function, must include all calculations\nIBCALC() =>\n    // Asia START //\n    //////////////////////////////////// Initial Balance Asia Start\n    time_int_01 = input.session('0000-0100:1234567', 'Asia IB Range')\n    in_time_int_01 = time(timeframe.period, time_int_01)\n    var highe_01 = 0.0\n    var lowe_01 = 10e10\n    if in_time_int_01\n        if not in_time_int_01[1]\n            highe_01 := high\n            lowe_01 := low\n            lowe_01\n        else\n            highe_01 := math.max(high, highe_01)\n            lowe_01 := math.min(low, lowe_01)\n            lowe_01\n    //////////////////////////////////// Initial Balance Asia Finish\n    //////////////////////////////////// Asia IB Plot Start\n    //High\n    AsiaIBHighInput = input('0100-0101:1234567', title='Capture Asia IB High')\n    AsiaIBHigh = time('1', AsiaIBHighInput)\n    var AsiaIBHighPA = 0.0\n    if AsiaIBHigh\n        if not AsiaIBHigh[1]\n            AsiaIBHighPA := highe_01\n            AsiaIBHighPA\n    //Low\n    AsiaIBLowInput = input('0100-0101:1234567', title='Capture Asia IB Low')\n    AsiaIBLow = time('1', AsiaIBLowInput)\n    var AsiaIBLowPA = 0.0\n    if AsiaIBLow\n        if not AsiaIBLow[1]\n            AsiaIBLowPA := lowe_01\n            AsiaIBLowPA\n    // Asia FINISH //\n    // London START //\n    //////////////////////////////////// Initial Balance London Start\n    time_int_02 = input.session('0800-0900:1234567', 'London IB Range')\n    time_lon_pre = input.session('0500-0800:1234567', 'London Pre Market Trading')\n    in_time_int_02 = time(timeframe.period, time_int_02)\n    PreMarketLon = time(timeframe.period, time_lon_pre)\n    var highe_02 = 0.0\n    var lowe_02 = 10e10\n    if in_time_int_02\n        if not in_time_int_02[1]\n            highe_02 := high\n            lowe_02 := low\n            lowe_02\n        else\n            highe_02 := math.max(high, highe_02)\n            lowe_02 := math.min(low, lowe_02)\n            lowe_02\n    //////////////////////////////////// Initial Balance London Finsh\n    //////////////////////////////////// London IB Plot Start\n    //High\n    LonIBHighInput = input('0900-0901:1234567', title='Capture London IB High')\n    LonIBHigh = time('1', LonIBHighInput)\n    var LonIBHighPA = 0.0\n    if LonIBHigh\n        if not LonIBHigh[1]\n            LonIBHighPA := highe_02\n            LonIBHighPA\n    //Low\n    LonIBLowInput = input('0900-0901:1234567', title='Capture London IB Low')\n    LonIBLow = time('1', LonIBLowInput)\n    var LonIBLowPA = 0.0\n    if LonIBLow\n        if not LonIBLow[1]\n            LonIBLowPA := lowe_02\n            LonIBLowPA\n    //////////////////////////////////// London IB Plot Finish\n    // London FINISH //\n    // New York START //\n    //////////////////////////////////// Initial Balance New York Start\n    time_int_03 = input.session('1430-1530:1234567', 'New York IB Range')\n    time_ny_pre = input.session('1130-1430:1234567', 'New York Pre Market Trading'\n    in_time_int_03 = time(timeframe.period, time_int_03)\n    PreMarketNY = time(timeframe.period, time_ny_pre)\n    var highe_03 = 0.0\n    var lowe_03 = 10e10\n    if in_time_int_03\n        if not in_time_int_03[1]\n            highe_03 := high\n            lowe_03 := low\n            lowe_03\n        else\n            highe_03 := math.max(high, highe_03)\n            lowe_03 := math.min(low, lowe_03)\n            lowe_03\n    //////////////////////////////////// Initial Balance New York Finish\n    //////////////////////////////////// New York IB Plot Start\n    //High\n    NYIBHighInput = input('1530-1531:1234567', title='Capture New York IB High')\n    NYIBHigh = time('1', NYIBHighInput)\n    var NYIBHighPA = 0.0\n    if NYIBHigh\n        if not NYIBHigh[1]\n            NYIBHighPA := highe_03\n            NYIBHighPA\n    //Low\n    NYIBLowInput = input('1530-1531:1234567', title='Capture New York IB Low')\n    NYIBLow = time('1', NYIBLowInput)\n    var NYIBLowPA = 0.0\n    if NYIBLow\n        if not NYIBLow[1]\n            NYIBLowPA := lowe_03\n            NYIBLowPA\n    //////////////////////////////////// New York IB Plot Finish\n    // New York FINISH //\n    // IB Highest Settings\n    AsiaAboveHigh = close > AsiaIBHighPA\n    LondonAboveHigh = close > LonIBHighPA\n    NewYorkAboveHigh = close > NYIBHighPA\n    Buy = AsiaAboveHigh and LondonAboveHigh and NewYorkAboveHigh\n    // IB Lowest Settings\n    AsiaBelowLow = close < AsiaIBLowPA\n    LondonBelowLow = close < LonIBLowPA\n    NewYorkBelowLow = close < NYIBLowPA\n    Sell = AsiaBelowLow and LondonBelowLow and NewYorkBelowLow\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // IB Color Settings\n    AboveAllIBs =  color.green  //#0CAB07 // Dark Green  -> Long\n    BelowAllIBs =  color.red  //#DE071C // Dark Red    -> Short\n    InBetween =  color.white  //#E1DE14 // Yellow      #000000   #555555\n    IBcolor_ = Buy ? AboveAllIBs : Sell ? BelowAllIBs : InBetween\n//    NYIB = in_time_int_03\n    NYIB =  #00008b  //dark blue\n    AsiaIB =  color.purple\n    LonIB =  #9b870c  //color.yellow\n    NoIB =  color.black\n    PreTradeLon =  color.yellow  //#FFFF99 // Light Yellow\n    PreTradeNY =  color.blue  //#FFFF99 // Light Yellow\n    IBBuildColor_ = PreMarketLon ? PreTradeLon : PreMarketNY ? PreTradeNY : in_time_int_03\n    [IBcolor_, IBBuildColor_]\n////////////////////////////////////////////////////////////////////////////////////////////////////\n[IBcolor_, IBBuildColor_] = IBCALC()\ncolor_Sym01 = request.security(Symbol01, timeframe.period, IBcolor_)\ncolor_Sym02 = request.security(Symbol02, timeframe.period, IBcolor_)\ncolor_Sym03 = request.security(Symbol03, timeframe.period, IBcolor_)\ncolor_Sym04 = request.security(Symbol04, timeframe.period, IBcolor_)\ncolor_Sym05 = request.security(Symbol05, timeframe.period, IBcolor_)\ncolor_Sym06 = request.security(Symbol06, timeframe.period, IBcolor_)\ncolor_Sym07 = request.security(Symbol07, timeframe.period, IBcolor_)\ncolor_Sym08 = request.security(Symbol08, timeframe.period, IBcolor_)\ncolor_Sym09 = request.security(Symbol09, timeframe.period, IBcolor_)\ncolor_Sym10 = request.security(Symbol10, timeframe.period, IBcolor_)\ncolor_Sym11 = request.security(Symbol11, timeframe.period, IBcolor_)\ncolor_Sym12 = request.security(Symbol12, timeframe.period, IBcolor_)\ncolor_Sym13 = request.security(Symbol13, timeframe.period, IBcolor_)\ncolor_Sym14 = request.security(Symbol14, timeframe.period, IBcolor_)\ncolor_Sym15 = request.security(Symbol15, timeframe.period, IBcolor_)\ncolor_Sym16 = request.security(Symbol16, timeframe.period, IBcolor_)\ncolor_Sym17 = request.security(Symbol01, timeframe.period, IBBuildColor_)\nvar int cntL = 0\nvar int cntS = 0\ncntL := 0\ncntS := 0\nif color_Sym01 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym02 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym03 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym04 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym05 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym06 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym07 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym08 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym09 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym10 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym11 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym12 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym13 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym14 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym15 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym16 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym17 ==  color.green\n    cntL += 1\n    cntL\nif color_Sym01 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym02 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym03 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym04 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym05 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym06 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym07 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym08 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym09 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym10 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym11 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym12 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym13 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym14 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym15 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym16 ==  color.red\n    cntS += 1\n    cntS\nif color_Sym17 ==  color.red\n    cntS += 1\n    cntS\nbuysignal = cntL >= LongCNT and uptrend and (not BTCsame or color_Sym01 ==  color.green\nsellsignal = cntS >= ShortCNT and not uptrend and (not BTCsame or color_Sym01 ==  \nexitFL = strategy.position_size > 0 and uptrend[1] and not uptrend\nexitFS = strategy.position_size < 0 and not uptrend[1] and uptrend\nif buysignal\n    strategy.entry(\"Long\", strategy.long)\nif sellsignal\n    strategy.entry(\"Short\", strategy.short)\nif exitFL\n    strategy.close(\"Long\")\nif exitFS\n    strategy.close(\"Short\")\n//plot(cntL, color=color.new(color.green, 0))\n//plot(cntS, color=color.new(color.red, 0))"}]}
{"messages": [{"role": "user", "content": "As traders, we're always looking for opportunities to profit from sudden price breakouts, and the Volatility Breakout Strategy aims to do just that. This script is the perfect starting point for traders who want to experiment with capturing price movements resulting from increased volatility. The script plots the Average True Range (ATR) on the chart, which is a measure of the asset's volatility over a specified period. By setting the \"Length\" parameter, you can customize the period over which the volatility is measured. Using the ATR, the strategy calculates upper and lower breakout levels and plots them on the chart. The signals for long and short positions are generated when the price crosses above the upper breakout level or below the lower breakout level, respectively. They are confirmed by checking the current bar state. The strategy also fills the space between the upper and lower breakout levels with a color that indicates the latest signal direction. This feature helps traders quickly identify the prevailing trend. The strategy uses the generated signals to enter trades. When a long or short signal is confirmed, and there is no open position in the direction of the signal, the strategy enters a long or short trade, respectively. Choice of parameters.  Choosing the right value for the Length input parameter is crucial for tailoring the Volatility Breakout Strategy to suit your trading preferences. In general, a higher Length value implies a focus on capturing longer price moves. For instance, in this script, we have set the Length value to 20, resulting in trades that span approximately 100 candles. These trades encompass price trends consisting of multiple swings. However, if your goal is to trade individual swings rather than longer trends, it's advisable to experiment with smaller values for the Length parameter. By reducing the Length, you can target shorter-term price movements and potentially increase the frequency of trades. It's important to note that while a higher Length value tends to lead to longer trades, there is no strict correlation between the Length parameter and the average length of trades. This can vary across different markets. Therefore, it's essential to conduct thorough experimentation with various Length values and closely observe the length of trades they generate. Comparing these trade lengths with the average trend or swing length in the specific market can provide valuable insights. Ideally, you should aim to select a Length value that aligns with the average trend or swing length observed in the market you are trading. This way, you can optimize the strategy to capture price movements that closely match the prevailing market conditions. Remember, finding the optimal Length value is a process of trial and error, combined with careful observation of trade lengths and their correlation with market trends. So, don't be afraid to experiment and refine the Length parameter to maximize the effectiveness of the Volatility Breakout Strategy in your chosen market. Disclaimer: This trading strategy is provided for educational and informational purposes only.Trading involves risk, and past performance is not indicative of future results."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n//@version=5\nstrategy(\"Volatility Breakout Strategy [Angel Algo]\", overlay = true)\n// Inputs\nlength = input(title=\"Length\", defval=20)\n// Calculate the average true range (ATR)\natr = ta.atr(length)\n// Plot the ATR on the chart\nplot(atr, color= color.blue, linewidth=2, title=\"ATR\")\n// Calculate the upper and lower breakouts\nupper_breakout = high + atr\nlower_breakout = low - atr\n// Plot the upper and lower breakouts on the chart\nul = plot(upper_breakout[1], color =  color.new(color.green, 100), linewidth=2, title\nll = plot(lower_breakout[1], color =  color.new(color.red, 100), linewidth=2, title\n// Create the signals\nlong_entry = ta.crossover(close, upper_breakout[1]) and barstate.isconfirmed\nshort_entry = ta.crossunder(close, lower_breakout[1]) and barstate.isconfirmed\nactive_signal_color =ta.barssince(long_entry) < ta.barssince(short_entry) ? \n    color.new(color.green,85) :  color.new(color.red,85)\n// Plot the signals on the chart\nplotshape(long_entry and ta.barssince(long_entry[1]) > ta.barssince(short_entry[1])\n   color= color.green, size=size.normal, text = \"Bullish breakout\", textcolor =  \nplotshape(short_entry and ta.barssince(long_entry[1]) < ta.barssince(short_entry[1]\n   color= color.red, size=size.normal,text = \"Bearish breakout\",  textcolor =  color.red\n// Fill the space between the upper and lower levels with the color that indicates the latest signal\nfill(ul,ll, color=active_signal_color)   \nlong_condition = long_entry and strategy.position_size <= 0 and barstate.isconfirmed\nshort_condition = short_entry and strategy.position_size >= 0 and barstate.isconfirmed\nif long_condition\n    strategy.entry(\"Volatility Breakout Long\", strategy.long)\nif short_condition\n    strategy.entry(\"Volatility Breakout Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "The new \"Pure Morning 2.0 - Candlestick Pattern Doji Strategy\" is a trend-following, intraday cryptocurrency trading system authored by devil_machine.  The system identifies Doji and Morning Doji Star candlestick formations above the EMA60 as entry points for long trades.  For best results we recommend to use on 15-minute, 30-minute, or 1-hour timeframes, and are ideal for high-volatility markets.  The strategy also utilizes a profit target or trailing stop for exits, with stop loss set at the lowest low of the last 100 candles. The strategy's configuration details, such as Doji tolerance, and exit configurations are adjustable.  In this new version 2.0, we've incorporated a new selectable filter. Since the stop loss is set at the lowest low, this filter ensures that this value isn't too far from the entry price, thereby optimizing the Risk-Reward ratio. In the specific case of ALPINE, a 9% Take-Profit and and Stop-Loss at Lowest Low of the last 100 candles were set, with an activated trailing-stop percentage, Max Loss Filter is not active. Name: Pure Morning 2.0 - Candlestick Pattern Doji Strategy  Author: @devil_machine Category: Trend Follower based on candlestick patterns.  Operating mode: Spot or Futures (only long).  Trades duration: Intraday  Timeframe: 15m, 30m, 1H Market: Crypto Suggested usage: Short-term trading, when the market is in trend and it is showing high volatility .  Entry: When a Doji or Morning Doji Star formation occurs above the EMA60.  Exit: Profit target or Trailing stop, Stop loss on the lowest low of the last 100 candles.  Configuration:   - Doji Settings (tolerances) for Entry Condition  - Max Loss Filter (Lowest Low filter)  - Exit Long configuration  - Trailing stop Backtesting:  \u2043 Exchange: BINANCE \u2043 Pair: ALPINEUSDT \u2043 Timeframe: 30m \u2043 Fee: 0.075% \u2043 Slippage: 1 - Initial Capital: 10000 USDT - Position sizing: 10% of Equity - Start: 2022-02-28 (Out Of Sample from 2022-12-23) - Bar magnifier: on Disclaimer: Risk Management is crucial, so adjust stop loss to your comfort level. A tight stop loss can help minimise potential losses. Use at your own risk.  How you or we can improve? Source code is open so share your ideas!  Leave a comment and smash the boost button!  Thanks for your attention, happy to support the TradingView community."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Creative Commons Attribution-NonCommercial-ShareA\n// \u00a9 TheSocialCryptoClub\n// Author: @devil_machine\n//@version=5\nstrategy(\"PURE MORNING 2.0\", overlay=true, pyramiding=1,\n         initial_capital=10000, \n         default_qty_type=strategy.percent_of_equity, default_qty_value=10,\n         slippage=1,backtest_fill_limits_assumption=1,use_bar_magnifier= true,\n         commission_type=strategy.commission.percent, commission_value=0.075\n         )\n//------------------------------\n// Indicators\n//------------------------------\nrma=ta.rma(close, 60)\nmfi=ta.mfi(close, 10)\nrsi=ta.rsi(close, 14)\natr7= ta.atr(7)\nema60=ta.ema(close,60)\nplot(ema60,\"EMA 60\",  color.new(color.aqua,0))\n//------------------------------\n// Doji settings \n//------------------------------\n//-----------------------------------------------MORNING DOJI STAR CODE\nrange1= high - low\ntolerance = input.float(defval=0.09, title=\"MDS Tolerance\",group= \"DOJI SETTINGS\",\ncandle1 = math.abs (close[2] - open[2]) /range1[2] > .6 and close[2] < open[2]\ncandle2 = ((open[1] > close[1] and open[1] < close[1]*(1+tolerance)) or (open[1] <\ncandle3 = close > open and close > (close[2]+range1[2])\nMDS = candle1 and candle2 and candle3\nplotshape (MDS and close > ema60, text=\"MD\", textcolor= color.yellow, offset=-1, \nplotshape (MDS and close < ema60, text=\"MD\", textcolor= color.olive, offset=-1, location\n//------------------------------------------------DOJI CODE\ntolerance1= input.float(defval=0.05, title=\"DOJI Tolerance\",group= \"DOJI SETTINGS\"\nIs_OC_Equal= (open > close and open < close*(1+tolerance1)) or (open < close and open\nplotshape(Is_OC_Equal and close < ema60, text=\"D\", textcolor= color.red, location\nplotshape(Is_OC_Equal and close > ema60, text=\"D\", textcolor =  color.green, location\n//------------------------------\n// Filter\n//------------------------------\nxl_tp_percent      = input.float(9,step=0.5, title=\"Take Profit\", group=\"EXIT LONG\"\nsl_type_ll         = input.bool(true, \"SL type Lowest Low\", group=\"EXIT LONG\")\nsl_len             = input.int(100, \"Stop Length\", group=\"EXIT LONG\")\nmax_loss_filter    = input.bool(false,\"Max Loss Filter\", group =\"Filter\")\nfilter_percent     = input.int(10, \"Max Loss %\", group=\"Filter\")\nsl_type_percent    = input.bool(false, \"SL type Percent\", group=\"EXIT LONG\")\nxl_sl_percent      = input.float(2,step=.5, title=\"Stop Loss\", group=\"EXIT LONG\") \nfilter_stop= max_loss_filter == true ? close - ta.lowest (low, sl_len) < (close*filter_percent\nif sl_type_percent == true \n    sl_type_ll := false\n//------------------------------\n// Entry Long\n//------------------------------\nel_cond = Is_OC_Equal and close > ta.ema(close, 60) and filter_stop\nel_cond_02 = MDS and close > ta.ema(close, 60) and filter_stop\nmess = \"!buy \" + syminfo.ticker // Executor command to buy automatically \nif el_cond \n    strategy.entry (\"EL\", strategy.long, alert_message = mess,comment = \"EL cond 1\"\nplotshape(el_cond and strategy.position_size == 0, \"el_long\", shape.circle, color=\nif el_cond_02       \n    strategy.entry (\"EL\", strategy.long, alert_message = mess,comment = \"EL cond 2\"\nplotshape(el_cond_02 and strategy.position_size == 0, \"el_long_02\", shape.circle, \n//------------------------------\n//Exit Long TP - SL\n//------------------------------\nxl_sl_price = strategy.position_avg_price * (1-xl_sl_percent/100)\nxl_tp_price = strategy.position_avg_price * (1+xl_tp_percent/100)\nif sl_type_ll == true\n    xl_sl_price := ta.lowest (low, sl_len) \n//------------------------------\n//Trailing stop \n//------------------------------\nxl_ts_percent      = input.float(1,   step=0.5, title= \"Trailing theshold\", group=\nxl_to_percent      = input.float(0.5, step=0.5, title= \"Trailing offset\",   group=\nxl_ts_tick = xl_ts_percent * close/syminfo.mintick/100\nxl_to_tick = xl_to_percent * close/syminfo.mintick/100\nmess_sell = \"!sell \" + syminfo.ticker // Executor command to sell automatically \nstrategy.exit(\"XL+SL/TP\", \"EL\", stop=xl_sl_price, limit=xl_tp_price, trail_points=\n//------------------------------\n// Conditional close on MFI\n//------------------------------\nxl_cond= ta.crossover(mfi, 90)\nif xl_cond\n    strategy.close(\"XL\", alert_message = mess_sell)\nplotshape(xl_cond, \"xl_cond\", shape.circle, color= color.red)"}]}
{"messages": [{"role": "user", "content": "Using \"Price Action - Support & Resistance by DGT\" and the MACD (Moving Average Convergence Divergence) indicator in TradingView can help develop a trade strategy. Here's a step-by-step approach you can follow: 1. Identifying Support and Resistance Levels: Apply the \"Price Action - Support & Resistance by DGT\" indicator to your chart. This indicator helps you identify key support and resistance levels based on price action. These levels act as potential areas where the price may reverse or consolidate. 2. Confirming Support and Resistance Levels: Once the indicator has plotted support and resistance levels on your chart, analyze the historical price action around these levels. Look for multiple touches or bounces from the same level, which adds strength to the support or resistance zone. 3. Analyzing the MACD Indicator: Add the MACD indicator to your chart. The MACD consists of two lines: the MACD line and the signal line, along with a histogram representing the difference between the two lines. The MACD helps identify momentum and potential trend reversals.     When the MACD line crosses above the signal line and the histogram turns positive, it suggests bullish momentum. 4. Identifying Trade Opportunities:    Bullish Trade: Look for a bullish setup when the price approaches a strong support level identified by the \"Price Action - Support & Resistance by DGT\" indicator. Wait for the MACD lines to cross above the signal line and the histogram to turn positive, indicating bullish momentum. Enter a long position with a stop loss below the     support level. Managing the Trade: Once you enter a trade, consider setting a target based on the distance between your entry point and the nearest significant support or resistance level. You can also use trailing stop losses or other risk management techniques to protect your profits and limit potential losses. Remember that no trading strategy is guaranteed to be successful, and it's important to practice proper risk management and conduct thorough analysis before making any trading decisions. Additionally, it's recommended to backtest and demo trade this strategy before using it with real money."}, {"role": "assistant", "content": "//@version=4\nstrategy(\"Price Action - Support & Resistance + MACD Strategy\", overlay=true)\n// Price Action - Support & Resistance\nsupportLevel = input(100, title=\"Support Level Strength\", minval=1)\nresistanceLevel = input(100, title=\"Resistance Level Strength\", minval=1)\nvar supportPrice = 0.0\nvar resistancePrice = 0.0\nif low <= supportPrice or barstate.islast\n    supportPrice := low\nif high >= resistancePrice or barstate.islast\n    resistancePrice := high\nplot(supportPrice, color= color.green, linewidth=1, title=\"Support\")\nplot(resistancePrice, color= color.red, linewidth=1, title=\"Resistance\")\n// MACD Indicator\n[macdLine, signalLine, _] = macd(close, 26, 100, 9)\nmacdHistogram = macdLine - signalLine\n// Bullish Trade Setup\nbullishSetup = crossover(macdLine, signalLine) and macdHistogram > 0 and close > supportPrice\nplotshape(bullishSetup, color= color.green, title=\"Bullish Setup\", style=shape.triangleup\n// Stop Loss and Take Profit Levels\nstopLossLevel = input(5, title=\"Stop Loss Level (%)\", minval=0.1, step=0.1)\ntakeProfitLevel = input(7.5, title=\"Take Profit Level (%)\", minval=0.1, step=0.1)\n// Execute Long Trades\nif bullishSetup\n    stopLossPrice = close * (1 - stopLossLevel / 100)\n    takeProfitPrice = close * (1 + takeProfitLevel / 100)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Exit\", \"Long\", stop=stopLossPrice, limit=takeProfitPrice)"}]}
{"messages": [{"role": "user", "content": "The \"Bollinger Bands, RSI and MA Strategy\" is a trend-following strategy that combines the Bollinger Bands indicator, the Relative Strength Index (RSI), and a moving average (MA). It aims to identify potential entry and exit points in the market based on price volatility, momentum, and trend. The strategy uses two Bollinger Bands with different standard deviations to create price channels. The default settings for the Bollinger Bands are a length of 20 periods and a standard deviation of 2.0. The upper and lower bands of the Bollinger Bands serve as dynamic resistance and support levels, respectively. The RSI indicator is employed to gauge the strength of price momentum.  The strategy also incorporates a 50-period moving average (MA) to help identify the overall trend direction. When the price is above the MA, it suggests an uptrend, and when the price is below the MA, it suggests a downtrend. The entry conditions for long trades are when the RSI is above the overbought level and there is no contraction in the Bollinger Bands. For short trades, the entry conditions are when the RSI is below the oversold level and there is no contraction in the Bollinger Bands. The exit conditions for long trades are when the RSI drops below the overbought level or when the price closes below the 50-period MA.  For short trades, the exit conditions are when the RSI goes above the oversold level or when the price closes above the 50-period MA. The strategy generates alerts for potential long and short entry signals, as well as for exit signals when the specified conditions are met. These alerts can be used to receive notifications or take further actions, such as placing trades manually or using automated trading systems. It is important to note that this strategy serves as a starting point and should be thoroughly backtested and validated with historical data before applying it to live trading. Additionally, it is recommended to consider risk management techniques, including setting appropriate stop-loss and take-profit levels, to effectively manage trades."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Bollinger Bands, RSI, and MA Strategy\", overlay=true)\n// Define input variables\nb_len = input(20, title=\"BB Length\")\nbb_mult = input(2.0, title=\"BB Standard Deviation\")\nbb_deviation1 = input(1.0, title=\"BB Deviation 1\")\nrsi_len = input(14, title=\"RSI Length\")\noverbought = input(70, title=\"Overbought RSI Level\")\noversold = input(30, title=\"Oversold RSI Level\")\nma_len = input(50, title=\"MA Length\")\nstop_loss_percent = input(1.0, title=\"Stop Loss Percentage\")\nsource = input(close, title=\"Source\")\n// Calculate Bollinger Bands\nbb_upper = ta.sma(source, b_len) + bb_mult * ta.stdev(source, b_len)\nbb_lower = ta.sma(source, b_len) - bb_mult * ta.stdev(source, b_len)\nbb_upper1 = ta.sma(source, b_len) + bb_deviation1 * ta.stdev(source, b_len)\nbb_lower1 = ta.sma(source, b_len) - bb_deviation1 * ta.stdev(source, b_len)\n// Calculate RSI\nrsi = ta.rsi(source, rsi_len)\n// Calculate Moving Average\nma = ta.sma(source, ma_len)\n// Determine if Bollinger Bands are contracting\nbb_contracting = ta.stdev(source, b_len) < ta.stdev(source, b_len)[1]\n// Entry conditions\nenterLong = rsi > overbought and not bb_contracting\nenterShort = rsi < oversold and not bb_contracting\n// Exit conditions\nexitLong = close < ma\nexitShort = close > ma\n// Exit trades and generate alerts\nif strategy.position_size > 0 and exitLong\n    strategy.close(\"Long\") // Exit the long trade\n    alert(\"Long Exit\", alert.freq_once_per_bar_close)\nif strategy.position_size < 0 and exitShort\n    strategy.close(\"Short\") // Exit the short trade\n    alert(\"Short Exit\", alert.freq_once_per_bar_close)\n// Strategy orders\nif enterLong\n    strategy.entry(\"Long\", strategy.long)\nif enterShort\n    strategy.entry(\"Short\", strategy.short)\nif exitLong\n    strategy.close(\"Long\")\nif exitShort\n    strategy.close(\"Short\")\n// Plotting Bollinger Bands\nplot(bb_upper, color= color.blue, title=\"BB Upper 2\")\nplot(bb_lower, color= color.blue, title=\"BB Lower 2\")\nplot(bb_upper1, color= color.red, title=\"BB Upper 1\")\nplot(bb_lower1, color= color.red, title=\"BB Lower 1\")\n// Plotting RSI\nplot(rsi, color= color.orange, title=\"RSI\")\n// Plotting Moving Average\nplot(ma, color= color.green, title=\"Moving Average\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    plot selectedMA"}, {"role": "assistant", "content": "// Based on indicator by Julien_Eche named \"Advanced Trend Channel Detection (Log Scale)\" \n//https://www.tradingview.com/script/dGyhoTE5-Advanced-Trend-Channel-Detection-Log-Scale/\n// \u00a9 Julien_Eche\n//@version=5\nstrategy(\"Advanced Trend Detection Strategy\", shorttitle=\"ATD Strategy\", overlay=true\nlengthInput1 = input.int(50, title=\"Length 1\", minval = 1, maxval = 5000)\nlengthInput2 = input.int(100, title=\"Length 2\", minval = 1, maxval = 5000)\nlengthInput3 = input.int(150, title=\"Length 3\", minval = 1, maxval = 5000)\nlengthInput4 = input.int(200, title=\"Length 4\", minval = 1, maxval = 5000)\nlengthInput5 = input.int(250, title=\"Length 5\", minval = 1, maxval = 5000)\nlengthInput6 = input.int(300, title=\"Length 6\", minval = 1, maxval = 5000)\nlengthInput7 = input.int(350, title=\"Length 7\", minval = 1, maxval = 5000)\nlengthInput8 = input.int(400, title=\"Length 8\", minval = 1, maxval = 5000)\nlengthInput9 = input.int(450, title=\"Length 9\", minval = 1, maxval = 5000)\nlengthInput10 = input.int(500, title=\"Length 10\", minval = 1, maxval = 5000)\nlengthInput11 = input.int(550, title=\"Length 11\", minval = 1, maxval = 5000)\nlengthInput12 = input.int(600, title=\"Length 12\", minval = 1, maxval = 5000)\nlengthInput13 = input.int(650, title=\"Length 13\", minval = 1, maxval = 5000)\nlengthInput14 = input.int(700, title=\"Length 14\", minval = 1, maxval = 5000)\nlengthInput15 = input.int(750, title=\"Length 15\", minval = 1, maxval = 5000)\nlengthInput16 = input.int(800, title=\"Length 16\", minval = 1, maxval = 5000)\nlengthInput17 = input.int(850, title=\"Length 17\", minval = 1, maxval = 5000)\nlengthInput18 = input.int(900, title=\"Length 18\", minval = 1, maxval = 5000)\nlengthInput19 = input.int(950, title=\"Length 19\", minval = 1, maxval = 5000)\nlengthInput20 = input.int(1000, title=\"Length 20\", minval = 1, maxval = 5000)\nsourceInput = input.source(close, title=\"Source\")\ngroup1 = \"Channel Settings\"\nuseUpperDevInput = input.bool(true, title=\"Upper Deviation\", inline = \"Upper Deviation\"\nupperMultInput = input.float(2.0, title=\"\", inline = \"Upper Deviation\", group = group1\nuseLowerDevInput = input.bool(true, title=\"Lower Deviation\", inline = \"Lower Deviation\"\nlowerMultInput = input.float(2.0, title=\"\", inline = \"Lower Deviation\", group = group1\ngroup2 = \"Display Settings\"\nshowPearsonInput = input.bool(true, \"Show Pearson's R\", group = group2)\nextendLeftInput = input.bool(false, \"Extend Lines Left\", group = group2)\nextendRightInput = input.bool(true, \"Extend Lines Right\", group = group2)\nextendStyle = switch\n    extendLeftInput and extendRightInput => extend.both\n    extendLeftInput => extend.left\n    extendRightInput => extend.right\n    => extend.none\ngroup3 = \"Color Settings\"\ncolorUpper = input.color( color.new(color.blue, 85), \"\", inline = group3, group =\ncolorLower = input.color( color.new(color.red, 85), \"\", inline = group3, group = \ncalcSlope(source, length) =>\n    max_bars_back(source, 5000)\n    if not barstate.islast or length <= 1\n        [float(na), float(na), float(na)]\n    else\n        sumX = 0.0\n        sumY = 0.0\n        sumXSqr = 0.0\n        sumXY = 0.0\n        for i = 0 to length - 1 by 1\n            val = math.log(source[i])\n            per = i + 1.0\n            sumX += per\n            sumY += val\n            sumXSqr += per * per\n            sumXY += val * per\n        slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)\n        average = sumY / length\n        intercept = average - slope * sumX / length + slope\n        [slope, average, intercept]\ncalcDev(source, length, slope, average, intercept) =>\n    upDev = 0.0\n    dnDev = 0.0\n    stdDevAcc = 0.0\n    dsxx = 0.0\n    dsyy = 0.0\n    dsxy = 0.0\n    periods = length - 1\n    daY = intercept + slope * periods / 2\n    val = intercept\n    for j = 0 to periods by 1\n        price = math.log(high[j]) - val\n        if price > upDev\n            upDev := price\n        price := val - math.log(low[j])\n        if price > dnDev\n            dnDev := price\n        price := math.log(source[j])\n        dxt = price - average\n        dyt = val - daY\n        price -= val\n        stdDevAcc += price * price\n        dsxx += dxt * dxt\n        dsyy += dyt * dyt\n        dsxy += dxt * dyt\n        val += slope\n    stdDev = math.sqrt(stdDevAcc / (periods == 0 ? 1 : periods))\n    pearsonR = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)\n    [stdDev, pearsonR, upDev, dnDev]\n[s1, a1, i1] = calcSlope(sourceInput, lengthInput1)\n[s2, a2, i2] = calcSlope(sourceInput, lengthInput2)\n[s3, a3, i3] = calcSlope(sourceInput, lengthInput3)\n[s4, a4, i4] = calcSlope(sourceInput, lengthInput4)\n[s5, a5, i5] = calcSlope(sourceInput, lengthInput5)\n[s6, a6, i6] = calcSlope(sourceInput, lengthInput6)\n[s7, a7, i7] = calcSlope(sourceInput, lengthInput7)\n[s8, a8, i8] = calcSlope(sourceInput, lengthInput8)\n[s9, a9, i9] = calcSlope(sourceInput, lengthInput9)\n[s10, a10, i10] = calcSlope(sourceInput, lengthInput10)\n[s11, a11, i11] = calcSlope(sourceInput, lengthInput11)\n[s12, a12, i12] = calcSlope(sourceInput, lengthInput12)\n[s13, a13, i13] = calcSlope(sourceInput, lengthInput13)\n[s14, a14, i14] = calcSlope(sourceInput, lengthInput14)\n[s15, a15, i15] = calcSlope(sourceInput, lengthInput15)\n[s16, a16, i16] = calcSlope(sourceInput, lengthInput16)\n[s17, a17, i17] = calcSlope(sourceInput, lengthInput17)\n[s18, a18, i18] = calcSlope(sourceInput, lengthInput18)\n[s19, a19, i19] = calcSlope(sourceInput, lengthInput19)\n[s20, a20, i20] = calcSlope(sourceInput, lengthInput20)\n[stdDev1, pearsonR1, upDev1, dnDev1] = calcDev(sourceInput, lengthInput1, s1, a1, \n[stdDev2, pearsonR2, upDev2, dnDev2] = calcDev(sourceInput, lengthInput2, s2, a2, \n[stdDev3, pearsonR3, upDev3, dnDev3] = calcDev(sourceInput, lengthInput3, s3, a3, \n[stdDev4, pearsonR4, upDev4, dnDev4] = calcDev(sourceInput, lengthInput4, s4, a4, \n[stdDev5, pearsonR5, upDev5, dnDev5] = calcDev(sourceInput, lengthInput5, s5, a5, \n[stdDev6, pearsonR6, upDev6, dnDev6] = calcDev(sourceInput, lengthInput6, s6, a6, \n[stdDev7, pearsonR7, upDev7, dnDev7] = calcDev(sourceInput, lengthInput7, s7, a7, \n[stdDev8, pearsonR8, upDev8, dnDev8] = calcDev(sourceInput, lengthInput8, s8, a8, \n[stdDev9, pearsonR9, upDev9, dnDev9] = calcDev(sourceInput, lengthInput9, s9, a9, \n[stdDev10, pearsonR10, upDev10, dnDev10] = calcDev(sourceInput, lengthInput10, s10\n[stdDev11, pearsonR11, upDev11, dnDev11] = calcDev(sourceInput, lengthInput11, s11\n[stdDev12, pearsonR12, upDev12, dnDev12] = calcDev(sourceInput, lengthInput12, s12\n[stdDev13, pearsonR13, upDev13, dnDev13] = calcDev(sourceInput, lengthInput13, s13\n[stdDev14, pearsonR14, upDev14, dnDev14] = calcDev(sourceInput, lengthInput14, s14\n[stdDev15, pearsonR15, upDev15, dnDev15] = calcDev(sourceInput, lengthInput15, s15\n[stdDev16, pearsonR16, upDev16, dnDev16] = calcDev(sourceInput, lengthInput16, s16\n[stdDev17, pearsonR17, upDev17, dnDev17] = calcDev(sourceInput, lengthInput17, s17\n[stdDev18, pearsonR18, upDev18, dnDev18] = calcDev(sourceInput, lengthInput18, s18\n[stdDev19, pearsonR19, upDev19, dnDev19] = calcDev(sourceInput, lengthInput19, s19\n[stdDev20, pearsonR20, upDev20, dnDev20] = calcDev(sourceInput, lengthInput20, s20\nhighestPearsonR = math.max(pearsonR1, pearsonR2, pearsonR3, pearsonR4, pearsonR5, \nselectedLength = highestPearsonR == pearsonR1 ? lengthInput1 : (highestPearsonR ==\nselectedS = highestPearsonR == pearsonR1 ? s1 : (highestPearsonR == pearsonR2 ? s2\nselectedI = highestPearsonR == pearsonR1 ? i1 : (highestPearsonR == pearsonR2 ? i2\nselectedStdDev = highestPearsonR == pearsonR1 ? stdDev1 : (highestPearsonR == pearsonR2\nselectedUpDev = highestPearsonR == pearsonR1 ? upDev1 : (highestPearsonR == pearsonR2\nselectedDnDev = highestPearsonR == pearsonR1 ? dnDev1 : (highestPearsonR == pearsonR2\nsmaLength = selectedLength\nsmaColor = input.color( color.blue, \"SMA Color\")\nsmaWidth = input.int(1, \"SMA Width\", minval=1)\nsmaStyle = plot.style_line\nsmaValue = ta.sma(sourceInput, smaLength)\n//plot(smaValue, color=smaColor, linewidth=smaWidth, style=smaStyle)\nstartPrice = math.exp(selectedI + selectedS * (selectedLength - 1))\nendPrice = math.exp(selectedI)\nvar line baseLine = na\nif na(baseLine) and not na(startPrice)\n    baseLine := line.new(bar_index - selectedLength + 1, startPrice, bar_index, endPrice\nelse\n    line.set_xy1(baseLine, bar_index - selectedLength + 1, startPrice)\n    line.set_xy2(baseLine, bar_index, endPrice)\n    na\nupperStartPrice = startPrice * math.exp(useUpperDevInput ? upperMultInput * selectedStdDev\nupperEndPrice = endPrice * math.exp(useUpperDevInput ? upperMultInput * selectedStdDev\nvar line upper = na\nlowerStartPrice = startPrice / math.exp(useLowerDevInput ? lowerMultInput * selectedStdDev\nlowerEndPrice = endPrice / math.exp(useLowerDevInput ? lowerMultInput * selectedStdDev\nvar line lower = na\nif na(upper) and not na(upperStartPrice)\n    upper := line.new(bar_index - selectedLength + 1, upperStartPrice, bar_index, \nelse\n    line.set_xy1(upper, bar_index - selectedLength + 1, upperStartPrice)\n    line.set_xy2(upper, bar_index, upperEndPrice)\n    na\nif na(lower) and not na(lowerStartPrice)\n    lower := line.new(bar_index - selectedLength + 1, lowerStartPrice, bar_index, \nelse\n    line.set_xy1(lower, bar_index - selectedLength + 1, lowerStartPrice)\n    line.set_xy2(lower, bar_index, lowerEndPrice)\n    na\nlinefill.new(upper, baseLine, color = colorUpper)\nlinefill.new(baseLine, lower, color = colorLower)\n// Pearson's R\nvar label r = na\nlabel.delete(r[1])\nif showPearsonInput and not na(highestPearsonR)\n    r := label.new(bar_index - selectedLength + 1, lowerStartPrice, str.tostring(highestPearsonR\nselectedMA = ta.sma(close, selectedLength/3)\nplot(selectedMA, color=smaColor, linewidth=smaWidth, style=smaStyle)\nif (ta.crossover(close, selectedMA))\n    strategy.entry(\"Buy\", strategy.long)\nif (ta.crossunder(close, selectedMA))\n    strategy.close(\"Buy\")"}]}
{"messages": [{"role": "user", "content": "Grid Spot Trading Algorithm V2 is the last grid trading algorithm made by our developer team.  Grid Spot Trading Algorithm V2 is a fixed 10-level grid trading algorithm. The grid is divided into an accumulation area (red) and a selling area (green). In the accumulation area, the algorithm will place new buy orders, selling the long positions on the top of the grid.  BUYING AND SELLING LOGIC  The algorithm places up to 5 limit orders on the accumulation section of the grid, each time the price cross through the middle grid. Each single order uses 20% of the equity. Positions are closed at the top of the grid by default, with the algorithm closing all orders at the first sell level. The exit level can be adjusted using the user interface, from the first level up to the fifth level above. CONFIGURING THE ALGORITHM  1) Add it to the chart: Add the script to the current chart that you want to analyze.  2) Select the top of the grid: Confirm a price level with the mouse on which to fix the top of the grid.  3) Select the bottom of the grid: Confirm a price level with the mouse on which to fix the bottom of the grid.  4) Wait for the automatic creation of the grid. USING THE ALGORITHM  Once the grid configuration process is completed, the algorithm will generate automatic backtesting.  You can add a stop loss that destroys the grid by setting the destruction price and activating the feature from the user interface. When the stop loss is activated, you can view it on the chart."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551  \n// \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \n// \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551       \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551 \n// \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551       \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551   \n//  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d       \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \n                                                                                                    //@version=5\nstrategy(\n     title = 'Grid Spot Trading Algorithm V2 - The Quant Science\u2122', \n     overlay = true,\n     calc_on_every_tick = true,\n     initial_capital = 10000, \n     commission_type = strategy.commission.percent, \n     commission_value = 0.10, \n     pyramiding = 5,\n     default_qty_type = strategy.percent_of_equity,\n     close_entries_rule = 'ANY'\n     )\n/////////////////////////////// Coded by The Quant Science\u2122 ////////////////////////////////////\n// Upgrade 2.00 (2022.30.07) \n// Upgrade 3.00 (2022.11.11)\n// Upgrade 4.00 (2022.20.01)\n// New release version 2.0 (2023.10.05)\n////////////////////////////////////////////////////////////////////////////////////////////////////\nhigh_price  = input.price(defval = 0.00, title = 'High price: ', group = \"TOP PRICE GRID\"\nclose_price = input.price(defval = 0.00, title = 'Low price: ',  group = \"BOTTOM PRICE GRID\"\ngrid_destroyer = input.bool(defval = false,title = 'Active grid destroyer:',group \nstop_level     = input.price(defval = 0.00, title = '',group = \"STOP LOSS CONFIGURATION\"\ngrid_range = high_price - close_price\nvar float grid_1  = 0\nvar float grid_2  = 0\nvar float grid_3  = 0\nvar float grid_4  = 0\nvar float grid_5  = 0\nvar float grid_6  = 0\nvar float grid_7  = 0\nvar float grid_8  = 0\nvar float grid_9  = 0\nvar float grid_10 = 0\nvar float grid_factor = 0 \nif (high_price > 0 or close_price > 0)\n    grid_factor := grid_range / 9\n    grid_1 := (high_price)\n    grid_2 := (high_price - (grid_factor * 1)) \n    grid_3 := (high_price - (grid_factor * 2)) \n    grid_4 := (high_price - (grid_factor * 3)) \n    grid_5 := (high_price - (grid_factor * 4))\n    grid_6  := (high_price - (grid_factor * 5)) \n    grid_7  := (high_price - (grid_factor * 6)) \n    grid_8  := (high_price - (grid_factor * 7)) \n    grid_9  := (high_price - (grid_factor * 8))\n    grid_10 := (close_price)\n    var float lots = 0\nvar float account_balance = 0 \nlong = (ta.crossunder(close, grid_5) or ta.crossover(close, grid_5))\nif (high_price > 0 or close_price > 0)\n    if strategy.opentrades==0\n        account_balance := strategy.equity\n        lots := (account_balance / close)/5\n        if long\n            strategy.order(id = \"O #1\", direction = strategy.long, qty = lots, limit\n            strategy.order(id = \"O #2\", direction = strategy.long, qty = lots, limit\n            strategy.order(id = \"O #3\", direction = strategy.long, qty = lots, limit\n            strategy.order(id = \"O #4\", direction = strategy.long, qty = lots, limit\n            strategy.order(id = \"O #5\", direction = strategy.long, qty = lots, limit\nExit(type) => \n        switch type\n        \"Grid level 5\" => grid_1\n        \"Grid level 4\" => grid_2\n        \"Grid level 3\" => grid_3\n        \"Grid level 2\" => grid_4\n        \"Grid level 1\" => grid_5\nexit_input = input.string(\"Grid level 1\", title = \"Select exit\", options = [\"Grid level 1\"\nexit_price = Exit(exit_input)\nif ta.crossover(close, exit_price) and (high_price > 0 or close_price > 0)\n    strategy.close_all(\"Close-Position\")\n    strategy.cancel(\"O #1\")\n    strategy.cancel(\"O #2\")\n    strategy.cancel(\"O #3\")\n    strategy.cancel(\"O #4\")\n    strategy.cancel(\"O #5\")\nif (close < grid_10 or ta.crossover(close, grid_10))\n    strategy.cancel_all()\n    if (high_price > 0 or close_price > 0) and grid_destroyer==true \n    if ta.crossunder(close, stop_level)\n        strategy.close_all(\"Grid Destroyed !!!\") \nvar float new_ten_grid_1  = 0 \nvar float new_ten_grid_2  = 0 \nvar float new_ten_grid_3  = 0 \nvar float new_ten_grid_4  = 0 \nvar float new_ten_grid_5  = 0 \nvar float new_ten_grid_6  = 0 \nvar float new_ten_grid_7  = 0 \nvar float new_ten_grid_8  = 0 \nvar float new_ten_grid_9  = 0 \nvar float new_ten_grid_10 = 0 \nvar float grid_destroyed_ten = 0 \nif (high_price > 0 or close_price > 0)\n    new_ten_grid_1  := grid_1\n    new_ten_grid_2  := grid_2\n    new_ten_grid_3  := grid_3\n    new_ten_grid_4  := grid_4\n    new_ten_grid_5  := grid_5\n    new_ten_grid_6  := grid_6\n    new_ten_grid_7  := grid_7\n    new_ten_grid_8  := grid_8\n    new_ten_grid_9  := grid_9\n    new_ten_grid_10 := grid_10\n    if grid_destroyer == true \n        grid_destroyed_ten := stop_level\nelse \n    new_ten_grid_1  := na\n    new_ten_grid_2  := na\n    new_ten_grid_3  := na\n    new_ten_grid_4  := na\n    new_ten_grid_5  := na\n    new_ten_grid_6  := na\n    new_ten_grid_7  := na\n    new_ten_grid_8  := na\n    new_ten_grid_9  := na\n    new_ten_grid_10 := na\n    if grid_destroyer == false \n        grid_destroyed_ten := na\nfill(plot(new_ten_grid_1, color =  color.new(#35f83b, 90)), \n     plot(new_ten_grid_2, color =  color.new(#36fa3d, 90)), \n         color =  color.new(#37ff3e, 90))\nfill(plot(new_ten_grid_2, color =  color.new(#35f53c, 85)), \n     plot(new_ten_grid_3, color =  color.new(#36f53c, 85)), \n         color =  color.new(#34fc3b, 85))\nfill(plot(new_ten_grid_3, color =  color.new(#35fa3c, 80)), \n     plot(new_ten_grid_4, color =  color.new(#33f83a, 80)), \n         color =  color.new(#32ff39, 80))\nfill(plot(new_ten_grid_4, color =  color.new(#35fc3c, 70)), \n     plot(new_ten_grid_5, color =  color.new(#35f83c, 70)), \n         color =  color.new(#34ff3b, 70))\nfill(plot(new_ten_grid_5, color =  color.new(#35f13b, 60)), \n     plot(new_ten_grid_6, color =  color.new(#34fc3b, 60)), \n         color =  color.new(#37ff3d, 60))\nfill(plot(new_ten_grid_6, color =  color.new(#f83333, 60)), \n     plot(new_ten_grid_7, color =  color.new(#fd3838, 60)), \n         color =  color.new(#ff3434, 60))\nfill(plot(new_ten_grid_7, color =  color.new(#fa3636, 70)), \n     plot(new_ten_grid_8, color =  color.new(#fa3737, 70)), \n         color =  color.new(#ff3636, 70))\nfill(plot(new_ten_grid_8, color =  color.new(#f83535, 80)), \n     plot(new_ten_grid_9, color =  color.new(#fa3636, 80)), \n         color =  color.new(#fd3434, 80))\nfill(plot(new_ten_grid_9, color =  color.new(#fc3434, 85)), \n     plot(new_ten_grid_10, color =  color.new(#fc3737, 85)), \n         color =  color.new(#ff3636, 85))\nplot(grid_destroyed_ten, color =  color.new(#fc3636, 80), linewidth = 10)"}]}
{"messages": [{"role": "user", "content": "This strategy uses the MACD indicator to determine buy and sell signals. In addition, the strategy employs the use of \"TrueLevel Bands,\" which are essentially envelope bands that are calculated based on the linear regression and standard deviation of the price data over various lengths. The TrueLevel Bands are calculated for 14 different lengths and are plotted on the chart as lines. The bands are filled with a specified color to make them more visible. The highest upper band and lowest lower band values are stored in variables for easy access. The user can input the lengths for the TrueLevel Bands and adjust the multiplier for the standard deviation. They can also select the bands they want to use for entry and exit, and enable long and short positions. The entry conditions for a long position are either a crossover of the MACD line over the signal line or a crossover of the price over the selected entry lower band. The entry conditions for a short position are either a crossunder of the MACD line under the signal line or a crossunder of the price under the selected exit upper band. The exit conditions for both long and short positions are not specified in the code and are left to the user to define.  Overall, the strategy aims to capture trends by entering long or short positions based on the MACD and TrueLevel Bands, and exiting those positions when the trend reverses."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Julien_Eche\n//@version=4\nstrategy(\"MACD TrueLevel Strategy\", shorttitle=\"MACD TL\", overlay=true, default_qty_type\n// Input parameters for MACD\nfastLength = input(12, title=\"Fast Length\", type=input.integer)\nslowLength = input(26, title=\"Slow Length\", type=input.integer)\nsignalLength = input(9, title=\"Signal Length\", type=input.integer)\n// Inputs for selecting bands\nentry_band = input(12, title=\"Entry TrueLevel Band\", type=input.integer, minval=1,\nexit_band = input(12, title=\"Exit TrueLevel Band\", type=input.integer, minval=1, maxval\n// Input for long and short mode\nlong_and_short = input(false, title=\"Enable Long and Short\", type=input.bool)\n// Calculate the MACD\n[macdLine, signalLine, _] = macd(close, fastLength, slowLength, signalLength)\n// User inputs\nlen1 = input(title=\"Length 1\", type=input.integer, defval=126)\nlen2 = input(title=\"Length 2\", type=input.integer, defval=189)\nlen3 = input(title=\"Length 3\", type=input.integer, defval=252)\nlen4 = input(title=\"Length 4\", type=input.integer, defval=378)\nlen5 = input(title=\"Length 5\", type=input.integer, defval=504)\nlen6 = input(title=\"Length 6\", type=input.integer, defval=630)\nlen7 = input(title=\"Length 7\", type=input.integer, defval=756)\nlen8 = input(title=\"Length 8\", type=input.integer, defval=1008)\nlen9 = input(title=\"Length 9\", type=input.integer, defval=1260)\nlen10 = input(title=\"Length 10\", type=input.integer, defval=1638)\nlen11 = input(title=\"Length 11\", type=input.integer, defval=2016)\nlen12 = input(title=\"Length 12\", type=input.integer, defval=2646)\nlen13 = input(title=\"Length 13\", type=input.integer, defval=3276)\nlen14 = input(title=\"Length 14\", type=input.integer, defval=4284)\nfill_color = input(title=\"Fill Color\", type=input.color, defval= color.rgb(0, 191\nmult = input(title=\"Multiple\", type=input.float, defval=1, step=0.2, options=[0.6,\nsrc = input(title=\"Source\", type=input.source, defval=close)\n// Upper band calculation function\nupperBand(length) =>\n    linreg = linreg(src, length, 0)\n    stddev = mult * stdev(src, length)\n    upperband = linreg + stddev\n    upperband\n// Lower band calculation function\nlowerBand(length) =>\n    linreg = linreg(src, length, 0)\n    stddev = mult * stdev(src, length)\n    lowerband = linreg - stddev\n    lowerband\n// Calculate upper and lower bands for each length\nupperband_1 = upperBand(len1)\nupperband_2 = upperBand(len2)\nupperband_3 = upperBand(len3)\nupperband_4 = upperBand(len4)\nupperband_5 = upperBand(len5)\nupperband_6 = upperBand(len6)\nupperband_7 = upperBand(len7)\nupperband_8 = upperBand(len8)\nupperband_9 = upperBand(len9)\nupperband_10 = upperBand(len10)\nupperband_11 = upperBand(len11)\nupperband_12 = upperBand(len12)\nupperband_13 = upperBand(len13)\nupperband_14 = upperBand(len14)\nlowerband_1 = lowerBand(len1)\nlowerband_2 = lowerBand(len2)\nlowerband_3 = lowerBand(len3)\nlowerband_4 = lowerBand(len4)\nlowerband_5 = lowerBand(len5)\nlowerband_6 = lowerBand(len6)\nlowerband_7 = lowerBand(len7)\nlowerband_8 = lowerBand(len8)\nlowerband_9 = lowerBand(len9)\nlowerband_10 = lowerBand(len10)\nlowerband_11 = lowerBand(len11)\nlowerband_12 = lowerBand(len12)\nlowerband_13 = lowerBand(len13)\nlowerband_14 = lowerBand(len14)\n// Plot envelope bands for each length\nupperband_1_plot = plot(upperband_1, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_1_plot = plot(lowerband_1, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_2_plot = plot(upperband_2, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_2_plot = plot(lowerband_2, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_3_plot = plot(upperband_3, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_3_plot = plot(lowerband_3, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_4_plot = plot(upperband_4, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_4_plot = plot(lowerband_4, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_5_plot = plot(upperband_5, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_5_plot = plot(lowerband_5, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_6_plot = plot(upperband_6, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_6_plot = plot(lowerband_6, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_7_plot = plot(upperband_7, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_7_plot = plot(lowerband_7, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_8_plot = plot(upperband_8, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_8_plot = plot(lowerband_8, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_9_plot = plot(upperband_9, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_9_plot = plot(lowerband_9, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_10_plot = plot(upperband_10, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_10_plot = plot(lowerband_10, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_11_plot = plot(upperband_11, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_11_plot = plot(lowerband_11, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_12_plot = plot(upperband_12, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_12_plot = plot(lowerband_12, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_13_plot = plot(upperband_13, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_13_plot = plot(lowerband_13, color= color.rgb(14, 139, 212, 95), linewidth\nupperband_14_plot = plot(upperband_14, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_14_plot = plot(lowerband_14, color= color.rgb(14, 139, 212, 95), linewidth\n// Plot fills for each length\nfill(upperband_1_plot, lowerband_1_plot, color=fill_color, title=\"Fill 1\")\nfill(upperband_2_plot, lowerband_2_plot, color=fill_color, title=\"Fill 2\")\nfill(upperband_3_plot, lowerband_3_plot, color=fill_color, title=\"Fill 3\")\nfill(upperband_4_plot, lowerband_4_plot, color=fill_color, title=\"Fill 4\")\nfill(upperband_5_plot, lowerband_5_plot, color=fill_color, title=\"Fill 5\")\nfill(upperband_6_plot, lowerband_6_plot, color=fill_color, title=\"Fill 6\")\nfill(upperband_7_plot, lowerband_7_plot, color=fill_color, title=\"Fill 7\")\nfill(upperband_8_plot, lowerband_8_plot, color=fill_color, title=\"Fill 8\")\nfill(upperband_9_plot, lowerband_9_plot, color=fill_color, title=\"Fill 9\")\nfill(upperband_10_plot, lowerband_10_plot, color=fill_color, title=\"Fill 10\")\nfill(upperband_11_plot, lowerband_11_plot, color=fill_color, title=\"Fill 11\")\nfill(upperband_12_plot, lowerband_12_plot, color=fill_color, title=\"Fill 12\")\nfill(upperband_13_plot, lowerband_13_plot, color=fill_color, title=\"Fill 13\")\nfill(upperband_14_plot, lowerband_14_plot, color=fill_color, title=\"Fill 14\")\n// Add variables to store the highest upper band and lowest lower band values\nvar float highestUpperBand = na\nvar float lowestLowerBand = na\n// Calculate the trueLevelUpperBand and trueLevelLowerBand\ntrueLevelUpperBand = max(upperband_1, max(upperband_2, max(upperband_3, max(upperband_4\ntrueLevelLowerBand = min(lowerband_1, min(lowerband_2, min(lowerband_3, min(lowerband_4\n// Update the highest upper band and lowest lower band\nhighestUpperBand := highest(trueLevelUpperBand, 1)\nlowestLowerBand := lowest(trueLevelLowerBand, 1)\n// Store the upper and lower bands in an array for easy access\nupperbands = array.new_float(14)\nlowerbands = array.new_float(14)\narray.set(upperbands, 0, upperband_1)\narray.set(upperbands, 1, upperband_2)\narray.set(upperbands, 2, upperband_3)\narray.set(upperbands, 3, upperband_4)\narray.set(upperbands, 4, upperband_5)\narray.set(upperbands, 5, upperband_6)\narray.set(upperbands, 6, upperband_7)\narray.set(upperbands, 7, upperband_8)\narray.set(upperbands, 8, upperband_9)\narray.set(upperbands, 9, upperband_10)\narray.set(upperbands, 10, upperband_11)\narray.set(upperbands, 11, upperband_12)\narray.set(upperbands, 12, upperband_13)\narray.set(upperbands, 13, upperband_14)\narray.set(lowerbands, 0, lowerband_1)\narray.set(lowerbands, 1, lowerband_2)\narray.set(lowerbands, 2, lowerband_3)\narray.set(lowerbands, 3, lowerband_4)\narray.set(lowerbands, 4, lowerband_5)\narray.set(lowerbands, 5, lowerband_6)\narray.set(lowerbands, 6, lowerband_7)\narray.set(lowerbands, 7, lowerband_8)\narray.set(lowerbands, 8, lowerband_9)\narray.set(lowerbands, 9, lowerband_10)\narray.set(lowerbands, 10, lowerband_11)\narray.set(lowerbands, 11, lowerband_12)\narray.set(lowerbands, 12, lowerband_13)\narray.set(lowerbands, 13, lowerband_14)\n// Get the selected bands for entry and exit\nselected_entry_lowerband = array.get(lowerbands, entry_band - 1)\nselected_exit_upperband = array.get(upperbands, exit_band - 1)\n// Entry conditions\nlongCondition = crossover(macdLine, signalLine) or crossover(close, selected_entry_lowerband\nshortCondition = crossunder(macdLine, signalLine) or crossunder(close, selected_exit_upperband\n// Exit conditions\nexitLongCondition = crossunder(macdLine, signalLine) or crossunder(close, selected_exit_upperband\nexitShortCondition = crossover(macdLine, signalLine) or crossover(close, selected_entry_lowerband\n// Strategy execution\nstrategy.entry(\"Long\", strategy.long, when = longCondition)\nstrategy.entry(\"Short\", strategy.short, when = shortCondition and long_and_short)\nstrategy.close(\"Long\", when = exitLongCondition)\nstrategy.close(\"Short\", when = exitShortCondition)"}]}
{"messages": [{"role": "user", "content": "This strategy is a momentum-based strategy that uses the Relative Strength Index (RSI) indicator and a TrueLevel envelope to generate trade signals. The strategy uses user-defined input parameters to calculate TrueLevel envelopes for 14 different lengths. The TrueLevel envelope is a volatility-based technical indicator that consists of upper and lower bands. The upper band is calculated by adding a multiple of the standard deviation to a linear regression line of the price data, while the lower band is calculated by subtracting a multiple of the standard deviation from the same regression line. The strategy generates long signals when the RSI crosses above the oversold level or when the price crosses above the selected lower band of the TrueLevel envelope. It generates short signals when the RSI crosses below the overbought level or when the price crosses below the selected upper band of the TrueLevel envelope. The strategy allows for long and short trades and sets the trade size as a percentage of the account equity. The colors of the bands and fills are also customizable through user-defined input parameters. In this strategy, the 12th TrueLevel band was chosen due to its ability to capture significant price movements while still providing a reasonable level of noise reduction. The strategy utilizes a total of 14 TrueLevel bands, each with varying lengths. The 12th band, with a length of 2646, strikes a balance between sensitivity to market changes and reducing false signals, making it a suitable choice for this strategy. RSI Parameters: In this strategy, the RSI overbought and oversold levels are set at 65 and 40, respectively. These values were chosen to filter out more noise in the market and focus on stronger trends. Traditional RSI overbought and oversold levels are set at 70 and 30, respectively. By raising the oversold level and lowering the overbought level, the strategy aims to identify more significant trend reversals and potential trade opportunities.  Of course, the parameters can be adjusted to suit individual preferences."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Julien_Eche\n//@version=4\nstrategy(\"RSI TrueLevel Strategy\", shorttitle=\"RSI TL\", overlay=true, default_qty_type\n// Input parameters for RSI\nrsiPeriod = input(14, title=\"RSI Period\", type=input.integer)\nrsiOverbought = input(65, title=\"RSI Overbought Level\", type=input.integer)\nrsiOversold = input(40, title=\"RSI Oversold Level\", type=input.integer)\n// Inputs for selecting bands\nentry_band = input(12, title=\"Entry TrueLevel Band\", type=input.integer, minval=1,\nexit_band = input(12, title=\"Exit TrueLevel Band\", type=input.integer, minval=1, maxval\n// Input for long and short mode\nlong_and_short = input(false, title=\"Enable Long and Short\", type=input.bool)\n// Calculate the RSI\nrsi = rsi(close, rsiPeriod)\n// User inputs\nlen1 = input(title=\"Length 1\", type=input.integer, defval=126)\nlen2 = input(title=\"Length 2\", type=input.integer, defval=189)\nlen3 = input(title=\"Length 3\", type=input.integer, defval=252)\nlen4 = input(title=\"Length 4\", type=input.integer, defval=378)\nlen5 = input(title=\"Length 5\", type=input.integer, defval=504)\nlen6 = input(title=\"Length 6\", type=input.integer, defval=630)\nlen7 = input(title=\"Length 7\", type=input.integer, defval=756)\nlen8 = input(title=\"Length 8\", type=input.integer, defval=1008)\nlen9 = input(title=\"Length 9\", type=input.integer, defval=1260)\nlen10 = input(title=\"Length 10\", type=input.integer, defval=1638)\nlen11 = input(title=\"Length 11\", type=input.integer, defval=2016)\nlen12 = input(title=\"Length 12\", type=input.integer, defval=2646)\nlen13 = input(title=\"Length 13\", type=input.integer, defval=3276)\nlen14 = input(title=\"Length 14\", type=input.integer, defval=4284)\nfill_color = input(title=\"Fill Color\", type=input.color, defval= color.rgb(0, 191\nmult = input(title=\"Multiple\", type=input.float, defval=1, step=0.2, options=[0.6,\nsrc = input(title=\"Source\", type=input.source, defval=close)\n// Upper band calculation function\nupperBand(length) =>\n    linreg = linreg(src, length, 0)\n    stddev = mult * stdev(src, length)\n    upperband = linreg + stddev\n    upperband\n// Lower band calculation function\nlowerBand(length) =>\n    linreg = linreg(src, length, 0)\n    stddev = mult * stdev(src, length)\n    lowerband = linreg - stddev\n    lowerband\n// Calculate upper and lower bands for each length\nupperband_1 = upperBand(len1)\nupperband_2 = upperBand(len2)\nupperband_3 = upperBand(len3)\nupperband_4 = upperBand(len4)\nupperband_5 = upperBand(len5)\nupperband_6 = upperBand(len6)\nupperband_7 = upperBand(len7)\nupperband_8 = upperBand(len8)\nupperband_9 = upperBand(len9)\nupperband_10 = upperBand(len10)\nupperband_11 = upperBand(len11)\nupperband_12 = upperBand(len12)\nupperband_13 = upperBand(len13)\nupperband_14 = upperBand(len14)\nlowerband_1 = lowerBand(len1)\nlowerband_2 = lowerBand(len2)\nlowerband_3 = lowerBand(len3)\nlowerband_4 = lowerBand(len4)\nlowerband_5 = lowerBand(len5)\nlowerband_6 = lowerBand(len6)\nlowerband_7 = lowerBand(len7)\nlowerband_8 = lowerBand(len8)\nlowerband_9 = lowerBand(len9)\nlowerband_10 = lowerBand(len10)\nlowerband_11 = lowerBand(len11)\nlowerband_12 = lowerBand(len12)\nlowerband_13 = lowerBand(len13)\nlowerband_14 = lowerBand(len14)\n// Plot envelope bands for each length\nupperband_1_plot = plot(upperband_1, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_1_plot = plot(lowerband_1, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_2_plot = plot(upperband_2, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_2_plot = plot(lowerband_2, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_3_plot = plot(upperband_3, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_3_plot = plot(lowerband_3, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_4_plot = plot(upperband_4, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_4_plot = plot(lowerband_4, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_5_plot = plot(upperband_5, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_5_plot = plot(lowerband_5, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_6_plot = plot(upperband_6, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_6_plot = plot(lowerband_6, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_7_plot = plot(upperband_7, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_7_plot = plot(lowerband_7, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_8_plot = plot(upperband_8, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_8_plot = plot(lowerband_8, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_9_plot = plot(upperband_9, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_9_plot = plot(lowerband_9, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_10_plot = plot(upperband_10, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_10_plot = plot(lowerband_10, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_11_plot = plot(upperband_11, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_11_plot = plot(lowerband_11, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_12_plot = plot(upperband_12, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_12_plot = plot(lowerband_12, color= color.rgb(14, 116, 212, 95), linewidth\nupperband_13_plot = plot(upperband_13, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_13_plot = plot(lowerband_13, color= color.rgb(14, 139, 212, 95), linewidth\nupperband_14_plot = plot(upperband_14, color= color.rgb(14, 116, 212, 95), linewidth\nlowerband_14_plot = plot(lowerband_14, color= color.rgb(14, 139, 212, 95), linewidth\n// Plot fills for each length\nfill(upperband_1_plot, lowerband_1_plot, color=fill_color, title=\"Fill 1\")\nfill(upperband_2_plot, lowerband_2_plot, color=fill_color, title=\"Fill 2\")\nfill(upperband_3_plot, lowerband_3_plot, color=fill_color, title=\"Fill 3\")\nfill(upperband_4_plot, lowerband_4_plot, color=fill_color, title=\"Fill 4\")\nfill(upperband_5_plot, lowerband_5_plot, color=fill_color, title=\"Fill 5\")\nfill(upperband_6_plot, lowerband_6_plot, color=fill_color, title=\"Fill 6\")\nfill(upperband_7_plot, lowerband_7_plot, color=fill_color, title=\"Fill 7\")\nfill(upperband_8_plot, lowerband_8_plot, color=fill_color, title=\"Fill 8\")\nfill(upperband_9_plot, lowerband_9_plot, color=fill_color, title=\"Fill 9\")\nfill(upperband_10_plot, lowerband_10_plot, color=fill_color, title=\"Fill 10\")\nfill(upperband_11_plot, lowerband_11_plot, color=fill_color, title=\"Fill 11\")\nfill(upperband_12_plot, lowerband_12_plot, color=fill_color, title=\"Fill 12\")\nfill(upperband_13_plot, lowerband_13_plot, color=fill_color, title=\"Fill 13\")\nfill(upperband_14_plot, lowerband_14_plot, color=fill_color, title=\"Fill 14\")\n// Add variables to store the highest upper band and lowest lower band values\nvar float highestUpperBand = na\nvar float lowestLowerBand = na\n// Calculate the trueLevelUpperBand and trueLevelLowerBand\ntrueLevelUpperBand = max(upperband_1, max(upperband_2, max(upperband_3, max(upperband_4\ntrueLevelLowerBand = min(lowerband_1, min(lowerband_2, min(lowerband_3, min(lowerband_4\n// Update the highest upper band and lowest lower band\nhighestUpperBand := highest(trueLevelUpperBand, 1)\nlowestLowerBand := lowest(trueLevelLowerBand, 1)\n// Store the upper and lower bands in an array for easy access\nupperbands = array.new_float(14)\nlowerbands = array.new_float(14)\narray.set(upperbands, 0, upperband_1)\narray.set(upperbands, 1, upperband_2)\narray.set(upperbands, 2, upperband_3)\narray.set(upperbands, 3, upperband_4)\narray.set(upperbands, 4, upperband_5)\narray.set(upperbands, 5, upperband_6)\narray.set(upperbands, 6, upperband_7)\narray.set(upperbands, 7, upperband_8)\narray.set(upperbands, 8, upperband_9)\narray.set(upperbands, 9, upperband_10)\narray.set(upperbands, 10, upperband_11)\narray.set(upperbands, 11, upperband_12)\narray.set(upperbands, 12, upperband_13)\narray.set(upperbands, 13, upperband_14)\narray.set(lowerbands, 0, lowerband_1)\narray.set(lowerbands, 1, lowerband_2)\narray.set(lowerbands, 2, lowerband_3)\narray.set(lowerbands, 3, lowerband_4)\narray.set(lowerbands, 4, lowerband_5)\narray.set(lowerbands, 5, lowerband_6)\narray.set(lowerbands, 6, lowerband_7)\narray.set(lowerbands, 7, lowerband_8)\narray.set(lowerbands, 8, lowerband_9)\narray.set(lowerbands, 9, lowerband_10)\narray.set(lowerbands, 10, lowerband_11)\narray.set(lowerbands, 11, lowerband_12)\narray.set(lowerbands, 12, lowerband_13)\narray.set(lowerbands, 13, lowerband_14)\n// Get the selected bands for entry and exit\nselected_entry_lowerband = array.get(lowerbands, entry_band - 1)\nselected_exit_upperband = array.get(upperbands, exit_band - 1)\n// Entry conditions\nlongCondition = crossover(rsi, rsiOversold) or crossover(close, selected_entry_lowerband\nshortCondition = crossunder(rsi, rsiOverbought) or crossunder(close, selected_exit_upperband\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nif (long_and_short and shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n// Exit conditions\nexitLongCondition = crossunder(rsi, rsiOverbought) or crossunder(close, selected_exit_upperband\nexitShortCondition = crossover(rsi, rsiOversold) or crossover(close, selected_entry_lowerband\nstrategy.close(\"Long\", when=exitLongCondition)\nstrategy.close(\"Short\", when=long_and_short and exitShortCondition)"}]}
{"messages": [{"role": "user", "content": "Introducing a Powerful Trading Indicator: Chandelier Exit with ZLSMA If you're a trader, you know the importance of having the right tools and indicators to make informed decisions. That's why we're excited to introduce a powerful new trading indicator that combines the Chandelier Exit and ZLSMA: two widely-used and effective indicators for technical analysis. The Chandelier Exit (CE) is a popular trailing stop-loss indicator developed by Chuck LeBeau. It's designed to follow the price trend of a security and provide an exit signal when the price crosses below the CE line. The CE line is based on the Average True Range (ATR), which is a measure of volatility. This means that the CE line adjusts to the volatility of the security, making it a reliable indicator for trailing stop-losses. The ZLEMA (Zero Lag Exponential Moving Average) is a type of exponential moving average that's designed to reduce lag and improve signal accuracy. The ZLSMA takes into account not only the current price but also past prices, using a weighted formula to calculate the moving average. This makes it a smoother indicator than traditional moving averages, and less prone to giving false signals. When combined, the CE and ZLSMA create a powerful indicator that can help traders identify trend changes and make more informed trading decisions. The CE provides the trailing stop-loss signal, while the ZLSMA provides a smoother trend line to help identify potential entry and exit points. In our indicator, the CE and ZLSMA are plotted together on the chart, making it easy to see both the trailing stop-loss and the trend line at the same time. The CE line is displayed as a dotted line, while the ZLSMA line is displayed as a solid line. Using this indicator, traders can set their stop-loss levels based on the CE line, while also using the ZLSMA line to identify potential entry and exit points. The combination of these two indicators can help traders reduce their risk and improve their trading performance. In conclusion, the Chandelier Exit with ZLSMA is a powerful trading indicator that combines two effective technical analysis tools. By using this indicator, traders can identify trend changes, set stop-loss levels, and make more informed trading decisions. Try it out for yourself and see how it can improve your trading performance. Warning: The results in the backtest are from a repainting strategy. Don't take them seriously. You need to do a dry live test in order to test it for its useability. - Here is a description of each input field in the provided source code: length: An integer input used as the period for the ATR (Average True Range) calculation. Default value is 1. mult: A float input used as a multiplier for the ATR value. Default value is 2. showLabels: A boolean input that determines whether to display buy/sell labels on the chart. Default value is false. isSignalLabelEnabled: A boolean input that determines whether to display signal labels on the chart. Default value is true. useClose: A boolean input that determines whether to use the close price for extrema calculations. Default value is true. zcolorchange: A boolean input that determines whether to enable rising/decreasing highlighting for the ZLSMA (Zero-Lag Exponential Moving Average) line. Default value is false. zlsmaLength: An integer input used as the length for the ZLSMA calculation. Default value is 50. offset: An integer input used as an offset for the ZLSMA calculation. Default value is 0. - Ty for checking this out and good luck on your trading journey! Likes and comments are appreciated.\ud83d\udc4d -- Credits to: \u25aa @everget \u2013 Chandelier Exit (CE) \u25aa @netweaver2022 \u2013 ZLSMA"}, {"role": "assistant", "content": "//@version=5\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 simwai\nstrategy('Chandelier Exit ZLSMA Strategy', shorttitle='CE_ZLSMA', overlay = true, \n// -- Colors --\ncolor maximumYellowRed =  color.rgb(255, 203, 98) // yellow\ncolor rajah =  color.rgb(242, 166, 84) // orange\ncolor magicMint =  color.rgb(171, 237, 198)\ncolor languidLavender =  color.rgb(232, 215, 255)\ncolor maximumBluePurple =  color.rgb(181, 161, 226)\ncolor skyBlue =  color.rgb(144, 226, 244)\ncolor lightGray =  color.rgb(214, 214, 214)\ncolor quickSilver =  color.rgb(163, 163, 163)\ncolor mediumAquamarine =  color.rgb(104, 223, 153)\ncolor carrotOrange =  color.rgb(239, 146, 46)\n// -- Inputs --\nlength = input(title='ATR Period', defval=1)\nmult = input.float(title='ATR Multiplier', step=0.1, defval=2)\nshowLabels = input(title='Show Buy/Sell Labels ?', tooltip='Created by Chandelier Exit (CE)'\nisSignalLabelEnabled = input(title='Show Signal Labels ?', defval=true)\nuseClose = input(title='Use Close Price for Extrema ?', defval=true)\nzcolorchange = input(title='Enable Rising/Decreasing Highlightning', defval=false)\nzlsmaLength = input(title='ZLSMA Length', defval=50)\noffset = input(title='Offset', defval=0)\n// -- CE - Credits to @everget --\nfloat haClose = float(1) / 4 * (open[1] + high[1] + low[1] + close[1])\natr = mult * ta.atr(length)[1]\nlongStop = (useClose ? ta.highest(haClose, length) : ta.highest(haClose, length)) \nlongStopPrev = nz(longStop[1], longStop)\nlongStop := haClose > longStopPrev ? math.max(longStop, longStopPrev) : longStop\nshortStop = (useClose ? ta.lowest(haClose, length) : ta.lowest(haClose, length)) +\nshortStopPrev = nz(shortStop[1], shortStop)\nshortStop := haClose < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop\nvar int dir = 1\ndir := haClose > shortStopPrev ? 1 : haClose < longStopPrev ? -1 : dir\nbuySignal = dir == 1 and dir[1] == -1\nplotshape(buySignal and showLabels ? longStop : na, title='Buy Label', text='Buy',\nsellSignal = dir == -1 and dir[1] == 1\nplotshape(sellSignal and showLabels ? shortStop : na, title='Sell Label', text='Sell'\nchangeCond = dir != dir[1]\n// -- ZLSMA - Credits to @netweaver2011 --\nlsma = ta.linreg(haClose, zlsmaLength, offset)\nlsma2 = ta.linreg(lsma, zlsmaLength, offset)\neq = lsma - lsma2\nzlsma = lsma + eq\nzColor = zcolorchange ? zlsma > zlsma[1] ? magicMint : rajah : languidLavender\nplot(zlsma, title='ZLSMA', linewidth=2, color=zColor)\n// -- Signals --\nvar string isTradeOpen = ''\nvar string signalCache = ''\nbool enterLong = buySignal and ta.crossover(haClose, zlsma) \nbool exitLong = ta.crossunder(haClose, zlsma) \nbool enterShort = sellSignal and ta.crossunder(haClose, zlsma)\nbool exitShort = ta.crossover(haClose, zlsma)\nif (signalCache == 'long entry')\n    signalCache := ''\n    enterLong := true\nelse if (signalCache == 'short entry')\n    signalCache := ''\n    enterShort := true\nif (isTradeOpen == '')\n    if (exitShort and (not enterLong))\n        exitShort := false\n    if (exitLong and (not enterShort))\n        exitLong := false   \n    if (enterLong and exitShort)\n        isTradeOpen := 'long'\n        exitShort := false\n    else if (enterShort and exitLong)\n        isTradeOpen := 'short'\n        exitLong := false\n    else if (enterLong)\n        isTradeOpen := 'long'\n    else if (enterShort)\n        isTradeOpen := 'short'\nelse if (isTradeOpen == 'long')\n    if (exitShort)\n        exitShort := false\n    if (enterLong)\n        enterLong := false\n    if (enterShort and exitLong)\n        enterShort := false\n        signalCache := 'short entry'\n    if (exitLong)\n        isTradeOpen := ''\nelse if (isTradeOpen == 'short')\n    if (exitLong)\n        exitLong := false\n    if (enterShort)\n        enterShort := false\n    if (enterLong and exitShort)\n        enterLong := false\n        signalCache := 'long entry'\n    if (exitShort)\n        isTradeOpen := ''\nplotshape((isSignalLabelEnabled and enterLong) ? zlsma : na, title='LONG', text='L'\nplotshape((isSignalLabelEnabled and enterShort) ? zlsma : na, title='SHORT', text=\nplotshape((isSignalLabelEnabled and exitLong) ? zlsma : na, title='LONG EXIT', style\nplotshape((isSignalLabelEnabled and exitShort) ? zlsma : na, title='SHORT EXIT', style\nbarcolor(color=isTradeOpen == 'long' ? mediumAquamarine : isTradeOpen == 'short' ?\n// -- Long Exits --\nif (exitLong and strategy.position_size > 0)\n    strategy.close('long', comment='EXIT_LONG')\n// -- Short Exits --\nif (exitShort and strategy.position_size < 0)\n    strategy.close('short', comment='EXIT_SHORT')\n// -- Long Entries --\nif (enterLong)\n    strategy.entry('long', strategy.long, comment='ENTER_LONG')\n// -- Short Entries --\nif (enterShort)\n    strategy.entry('short', strategy.short, comment='ENTER_SHORT')"}]}
{"messages": [{"role": "user", "content": "5 indicators. Backtesting available. Uses ADX, RSI, Stochastic, MACD, and crossing EMAs (1,2, or 3). This strategy creator allows you to turn on or off these indicators and adjust the parameters for each indicator. It allows you to make one trade at a time e.g the next trade doesn't open until the last one closes. (You are also able to enter how many trades in one direction you want for example if you want only 2 long trades in a row, then the strategy waits for the next short position without making anymore long trades. Once there are 2 short positions in a row, it waits for a long position). The code can be edited to for automated trading by editing the comment in the source code for the strategy parameters. This took many hours to finish. ENJOY."}, {"role": "assistant", "content": "//@version=5\n // By Jordan Hall\n// finished: 3/28/2023\nstrategy(\"Strategy Creator\", overlay=true, margin_long=100, margin_short=100, pyramiding\n////////////////////////////////////////////////////////////////////////////////////////////////////\n/// PERIOD /// \ntestStartYear = input(2023, \"Backtest Start Year\") \ntestStartMonth = input(1, \"Backtest Start Month\") \ntestStartDay = input(1, \"Backtest Start Day\") \ntestPeriodStart = timestamp(testStartYear,testStartMonth,testStartDay,0,0) \n testStopYear = input(2023, \"Backtest Stop Year\") \ntestStopMonth = input(12, \"Backtest Stop Month\") \ntestStopDay = input(31, \"Backtest Stop Day\") \ntestPeriodStop = timestamp(testStopYear,testStopMonth,testStopDay,0,0) \n testPeriod() => \n    time >= testPeriodStart and time <= testPeriodStop ? true : false\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////EMA INPUTS///////////////////////////////////////////////\nEMAON = input.bool(true, \"EMA ON?\", group = \"EMA Settings\", tooltip = \"Check box for on\"\nIS1EMA = input.bool(false,\"Only 1 EMA\", \" USE EMA FAST LENGTH FOR INPUT\", group = \nIS2EMA = input.bool(false, \"Only 2 EMAs\", \"Only leave this box checked for 2 EMAs. USE EMA M\nEMAFAST = input.int(50,title = \"EMA Fast Length\", minval = 1, maxval = 2000, group\nEMAMIDDLE = input.int(100, title= \"EMA middle Length\", minval = 1, maxval = 2000, \nEMASLOW = input.int(200, title= \"EMA Slow Length\", minval = 1, maxval = 2000, group\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////RSI//////////////////////////////////////////////////\nRSION = input.bool(true, \"RSI ON?\", group = \"RSI Settings\", tooltip = \"Check box for on\"\nma(source, length, type) =>\n    switch type\n        \"SMA\" => ta.sma(source, length)\n        \"Bollinger Bands\" => ta.sma(source, length)\n        \"EMA\" => ta.ema(source, length)\n        \"SMMA (RMA)\" => ta.rma(source, length)\n        \"WMA\" => ta.wma(source, length)\n        \"VWMA\" => ta.vwma(source, length)\n//INPUTS & CALCULATIONS\nRSIUL = input.float(52, \"RSI SHORT\", 0,100, tooltip = \"RSI must be greater this number to enter a SHORT \nRSILL = input.float(48, \"RSI LONG\", 0,100, tooltip = \"RSI must be lower this number to enter a LONG pos\nrsiLengthInput = input.int(14, minval=1, title=\"RSI Length\", group=\"RSI Settings\")\nrsiSourceInput = input.source(close, \"Source\", group=\"RSI Settings\")\nmaTypeInput = input.string(\"SMA\", title=\"MA Type\", options=[\"SMA\", \"Bollinger Bands\"\nmaLengthInput = input.int(14, title=\"MA Length\", group=\"RSI Settings\")\nup = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)\ndown = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)\nrsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\nrsiMA = ma(rsi, maLengthInput, maTypeInput)\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// ////////////////////////////////////////////////////TSI//////////////////////////////////////////\n// TSION = input.bool(true, \"TSI ON?\", group = \"TSI Settings\", tooltip = \"Check box for on\")\n// TSIUL = input.float(1, \"TSI SHORT\", -50,50, tooltip = \"TSI must be greater this number to enter a\n// TSILL = input.float(-1, \"TSI LONG\", -50,50, tooltip = \"TSI must be lower this number to enter a L\n// long = input(title=\"Long Length\", defval=25, group = \"TSI Settings\")\n// short = input(title=\"Short Length\", defval=13, group = \"TSI Settings\")\n// signaltsi = input(title=\"Signal Length\", defval=13,group = \"TSI Settings\")\n// price = close\n// double_smooth(src, long, short) =>\n//  fist_smooth = ta.ema(src, long)\n//  ta.ema(fist_smooth, short)\n// pc = ta.change(price)\n// double_smoothed_pc = double_smooth(pc, long, short)\n// double_smoothed_abs_pc = double_smooth(math.abs(pc), long, short)\n// tsi_value = 100 * (double_smoothed_pc / double_smoothed_abs_pc)\n// /////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////Stochastic/////////////////////////////////////////////\nSTOCHON = input.bool(true, \"STOCHASTIC ON?\", group = \"Stochastic Settings\", tooltip\nperiodK = input.int(14, title=\"%K Length\", minval=1,group = \"Stochastic Settings\")\nsmoothK = input.int(1, title=\"%K Smoothing\", minval=1,group = \"Stochastic Settings\"\nperiodD = input.int(3, title=\"%D Smoothing\", minval=1,group = \"Stochastic Settings\"\nk = ta.sma(ta.stoch(close, high, low, periodK), smoothK)\nd = ta.sma(k, periodD)\nbyValueOrByCrossover = input.bool(true, \"By Crossover?\", tooltip = \"Check box for crossover of k>d for LONG and k<d f\nkValueComparisonSHORT = input.float(50, \"k is greater than\", 0,100, tooltip = \"When k (blueline) is greater than this number, en\nkValueComparisonLONG = input.float(50, \"k is less than\", 0,100, tooltip = \"When k (blueline) is less than this number, enter\n////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////MACD W/ diff timeframes////////////////////////////////\n//Create inputs\nMACDON = input.bool(true, \"MACD ON?\", group = \"MACD Settings\", tooltip = \"Check box for on\"\nMACD_Other_TimeFrame = input.timeframe(\"1\", title=\"Time Frame MACD\", group = \"MACD Settings\"\nfastAvgLength   = input(title=\"Fast Length\", defval=12, group = \"MACD Settings\")\nslowAvgLength   = input(title=\"Slow Length\", defval=26, group = \"MACD Settings\")\nsrc = input(title=\"Source\", defval=close, group = \"MACD Settings\")\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nsma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\"SMA\"\nsma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\n// Calculating MACD\nfast_ma = sma_source == \"SMA\" ? ta.sma(src, fastAvgLength) : ta.ema(src, fastAvgLength\nslow_ma = sma_source == \"SMA\" ? ta.sma(src, slowAvgLength) : ta.ema(src, slowAvgLength\nmacd = fast_ma - slow_ma\nsignal = sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\nhist = macd - signal\n//AVERAGES MACD\nvar pos_hist_cnt = 0\nvar pos_hist_total = 0.0\nvar pos_hist_avg = 0.0\nvar neg_hist_cnt = 0\nvar neg_hist_total = 0.0\nvar neg_hist_avg = 0.0\nif (hist <0)\n    neg_hist_total := neg_hist_total + hist\n    neg_hist_cnt := neg_hist_cnt + 1\n    neg_hist_avg := neg_hist_total / neg_hist_cnt\nif (hist >0)\n    pos_hist_total := pos_hist_total + hist\n    pos_hist_cnt := pos_hist_cnt + 1\n    pos_hist_avg := pos_hist_total / pos_hist_cnt\nposavgadd = input(false, \"Add average positve histogram value?\", tooltip = \"current histogram value must be greater than the \nnegavgadd = input(false, \"Subtract average negative histogram value?\", tooltip = \"current histogram value must be less than the neg\nposnumber = input.float(0.0000, \" + (absolute val)\", tooltip = \"current histogram value must be greater than this\nnegnumber = input.float(0.0000, \" - (absolute val)\", tooltip = \"current histogram value must be less than this (m\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////// ADX//////////////////////////////////////////\nADXON = input.bool(true, \"ADX ON?\", group = \"ADX Settings\", tooltip = \"Check box for on\"\nadxlen = input(14, title=\"ADX Smoothing\", group = \"ADX Settings\")\ndilen = input(14, title=\"DI Length\", group = \"ADX Settings\")\ndirmov(len) =>\n    upADX = ta.change(high)\n    downADX = -ta.change(low)\n    plusDM = na(upADX) ? na : (upADX > downADX and upADX > 0 ? upADX : 0)\n    minusDM = na(downADX) ? na : (downADX > upADX and downADX > 0 ? downADX : 0)\n    truerange = ta.rma(ta.tr, len)\n    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)\n    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)\n    [plus, minus]\nadx(dilen, adxlen) =>\n    [plus, minus] = dirmov(dilen)\n    sum = plus + minus\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)\nsig = adx(dilen, adxlen)\nADXSIGNALSTRENGTH = input.float(25, \"ADX signal strength > \", 0, 100, group = \"ADX Settings\"\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////TP AND SL INPUTS AND CALCULATIONS/////////////////////////\nStopLossLongPercentage = input.float(title=\"Long Stop Loss (%)\", minval=0.0, step=\nStopLossLongPrice  = strategy.position_avg_price * (1 - StopLossLongPercentage)\nStopLossShortPercentage = input.float(title=\"Short Stop Loss (%)\", minval=0.0, step\nStopLossShortPrice  = strategy.position_avg_price * (1 + StopLossShortPercentage)\nTakeProfitLongPercentage = input.float(title=\"Long Take Profit (%)\", minval=0.0, step\nTakeProfitLongPrice  = strategy.position_avg_price * (1 + TakeProfitLongPercentage\nTakeProfitShortPercentage = input.float(title=\"Short Take Profit (%)\", minval=0.0,\nTakeProfitShortPrice  = strategy.position_avg_price * (1 - TakeProfitShortPercentage\n////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////VARIABLES//////////////////////////////////////////\n//EMAMIDDLE == SHORTER EMA LENGTH, EMASLOW == EMA LONGER LENGTH. IS1EMA == 1 EMA LINE?\n//rsi == RELATIVE STRENGTH INDEX VALUE (0 to 100)\n//tsi_value == TSI VALUES\n//k == K% VALUE (BLUE LINE), d == D% VALUE (RED LINE)\n//hist == MACD HISTOGRAM VALUES, macd == MACD VALUE, signal == SIGNAL LINE CROSSING MACD\n//neg_hist-avg == NEGATIVE HISTOGRAM VALUES, pos_hist_values == POSITIVE HISTOGRAM VALUES\n//adx == ADX VALUES (0 to 100)\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// IS1EMA = input.bool(false,\"Only 1 EMA\", \" USE EMA FAST LENGTH FOR INPUT\", group = \"EMA Settings\")\n// IS2EMA = input.bool(false, \"2 EMAs\", \"Only leave this box checked for 2 EMAs. USE EMA MIDDLE LENG\n// IS3EMA = input.bool(true, \"3 EMAs\", \"Only leave this box checked for 3 EMAs. USE EMA FAST LENGTH \n////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////ON OR OFF//////////////////////////////////////////////////\n                                            //EMA\nHowManyEMAsLong = IS1EMA ? close > ta.ema(close, EMAFAST) : IS2EMA ? ta.ema(close,\nHowManyEMAsShort = IS1EMA ? close < ta.ema(close, EMAFAST) : IS2EMA ? ta.ema(close\nEMAENTRYLONG = EMAON ? HowManyEMAsLong : true\nEMAENTRYSHORT = EMAON ? HowManyEMAsShort : true\n                                            //RSI\nRSILONG = rsi < RSILL\nRSISHORT = rsi > RSIUL\nRSIENTRYLONG = RSION ? RSILONG : true\nRSIENTRYSHORT = RSION ? RSISHORT : true\n                                         //STOCHASTIC\nSTOCHLONG = byValueOrByCrossover ? (k > d) : (k < kValueComparisonLONG)\nSTOCHSHORT = byValueOrByCrossover ? (k < d) : (k > kValueComparisonSHORT)\nSTOCHENTRYLONG = STOCHON ? STOCHLONG : true\nSTOCHENTRYSHORT = STOCHON ? STOCHSHORT : true\n                                            //MACD\nHISTLONG = negavgadd ? hist < (neg_hist_avg - negnumber) : hist < negnumber\nHISTSHORT = posavgadd ? hist > (pos_hist_avg + posnumber) : hist > posnumber\nHISTENTRYLONG = MACDON ? HISTLONG : true\nHISTENTRYSHORT = MACDON ? HISTSHORT : true\n                                             //ADX\nADXLONG = sig > ADXSIGNALSTRENGTH\nADXSHORT = sig > ADXSIGNALSTRENGTH\nADXLONGENTRY = ADXON ? ADXLONG : true\nADXSHORTENTRY = ADXON ? ADXSHORT : true\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////ONE TRADE AT A TIME/////////////////////////////////\nSTRATEGYISCLOSED = strategy.opentrades == 0 ? true : false\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////HOW MANY TRADES IN A ROW//////////////////////////\ngetLastPosSign1() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos1Back = getLastPosSign1()\nLastStrategy1BackWasLong = nz(lastPos1Back) >= 0 \nLastStrategy1BackWasShort = nz(lastPos1Back) <= 0 \noneTradeInOneDirectionLong = LastStrategy1BackWasShort ? true : false\noneTradeInOneDirectionShort = LastStrategy1BackWasLong ? true : false\ngetLastPosSign2() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos2Back = getLastPosSign2()\nLastStrategy2BackWasLong = nz(lastPos2Back) >= 0\nLastStrategy2BackWasShort = nz(lastPos2Back) <= 0 \ntwoTradesInOneDirectionLong = LastStrategy2BackWasShort or oneTradeInOneDirectionLong\ntwoTradesInOneDirectionShort = LastStrategy2BackWasLong or oneTradeInOneDirectionShort\ngetLastPosSign3() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos3Back = getLastPosSign3()\nLastStrategy3BackWasLong = nz(lastPos3Back) >= 0\nLastStrategy3BackWasShort = nz(lastPos3Back) <= 0 \nthreeTradesInOneDirectionLong = LastStrategy3BackWasShort or twoTradesInOneDirectionLong\nthreeTradesInOneDirectionShort = LastStrategy3BackWasLong or twoTradesInOneDirectionShort\ngetLastPosSign4() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos4Back = getLastPosSign4()\nLastStrategy4BackWasLong = nz(lastPos4Back) >= 0\nLastStrategy4BackWasShort = nz(lastPos4Back) <= 0 \nfourTradesInOneDirectionLong = LastStrategy4BackWasShort or threeTradesInOneDirectionLong\nfourTradesInOneDirectionShort = LastStrategy4BackWasLong or threeTradesInOneDirectionShort\ngetLastPosSign5() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos5Back = getLastPosSign5()\nLastStrategy5BackWasLong = nz(lastPos5Back) >= 0\nLastStrategy5BackWasShort = nz(lastPos5Back) <= 0 \nfiveTradesInOneDirectionLong = LastStrategy5BackWasShort or fourTradesInOneDirectionLong\nfiveTradesInOneDirectionShort = LastStrategy5BackWasLong or fourTradesInOneDirectionShort\ngetLastPosSign6() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos6Back = getLastPosSign6()\nLastStrategy6BackWasLong = nz(lastPos6Back) >= 0\nLastStrategy6BackWasShort = nz(lastPos6Back) <= 0 \nsixTradesInOneDirectionLong = LastStrategy6BackWasShort or fiveTradesInOneDirectionLong\nsixTradesInOneDirectionShort = LastStrategy6BackWasLong or fiveTradesInOneDirectionShort\ngetLastPosSign7() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos7Back = getLastPosSign7()\nLastStrategy7BackWasLong = nz(lastPos7Back) >= 0\nLastStrategy7BackWasShort = nz(lastPos7Back) <= 0 \nsevenTradesInOneDirectionLong = LastStrategy7BackWasShort or sixTradesInOneDirectionLong\nsevenTradesInOneDirectionShort = LastStrategy7BackWasLong or sixTradesInOneDirectionShort\ngetLastPosSign8() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos8Back = getLastPosSign8()\nLastStrategy8BackWasLong = nz(lastPos8Back) >= 0\nLastStrategy8BackWasShort = nz(lastPos8Back) <= 0 \neightTradesInOneDirectionLong = LastStrategy8BackWasShort or sevenTradesInOneDirectionLong\neightTradesInOneDirectionShort = LastStrategy8BackWasLong or sevenTradesInOneDirectionShort\ngetLastPosSign9() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos9Back = getLastPosSign9()\nLastStrategy9BackWasLong = nz(lastPos9Back) >= 0\nLastStrategy9BackWasShort = nz(lastPos9Back) <= 0 \nnineTradesInOneDirectionLong = LastStrategy9BackWasShort or eightTradesInOneDirectionLong\nnineTradesInOneDirectionShort = LastStrategy9BackWasLong or eightTradesInOneDirectionShort\ngetLastPosSign10() =>\n    strategy.closedtrades > 0 ? math.sign(strategy.closedtrades.size(strategy.closedtrades\nlastPos10Back = getLastPosSign10()\nLastStrategy10BackWasLong = nz(lastPos10Back) >= 0\nLastStrategy10BackWasShort = nz(lastPos10Back) <= 0 \ntenTradesInOneDirectionLong = LastStrategy10BackWasShort or nineTradesInOneDirectionLong\ntenTradesInOneDirectionShort = LastStrategy10BackWasLong or nineTradesInOneDirectionShort\nLongEntryArray = array.new<bool>()\narray.push(LongEntryArray, oneTradeInOneDirectionLong)\narray.push(LongEntryArray, twoTradesInOneDirectionLong)\narray.push(LongEntryArray, threeTradesInOneDirectionLong)\narray.push(LongEntryArray, fourTradesInOneDirectionLong)\narray.push(LongEntryArray, fiveTradesInOneDirectionLong)\narray.push(LongEntryArray, sixTradesInOneDirectionLong)\narray.push(LongEntryArray, sevenTradesInOneDirectionLong)\narray.push(LongEntryArray, eightTradesInOneDirectionLong)\narray.push(LongEntryArray, nineTradesInOneDirectionLong)\narray.push(LongEntryArray, tenTradesInOneDirectionLong)\nShortEntryArray = array.new<bool>()\narray.push(ShortEntryArray, oneTradeInOneDirectionShort)\narray.push(ShortEntryArray, twoTradesInOneDirectionShort)\narray.push(ShortEntryArray, threeTradesInOneDirectionShort)\narray.push(ShortEntryArray, fourTradesInOneDirectionShort)\narray.push(ShortEntryArray, fiveTradesInOneDirectionShort)\narray.push(ShortEntryArray, sixTradesInOneDirectionShort)\narray.push(ShortEntryArray, sevenTradesInOneDirectionShort)\narray.push(ShortEntryArray, eightTradesInOneDirectionShort)\narray.push(ShortEntryArray, nineTradesInOneDirectionShort)\narray.push(ShortEntryArray, tenTradesInOneDirectionShort)\nHowManyTradesInOneDirectionInput = input.int(3,\"How Many Trades Allowed In One Direction?\"\nTRADESINAROWLONG = array.get(LongEntryArray, HowManyTradesInOneDirectionInput -1)\nTRADESINAROWSHORT = array.get(ShortEntryArray, HowManyTradesInOneDirectionInput -1\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////OPEN LONG/////////////////////////////////////////\nif EMAENTRYLONG\n    if RSIENTRYLONG\n        if STOCHENTRYLONG\n            if HISTENTRYLONG\n                if ADXLONGENTRY\n                    if TRADESINAROWLONG\n                        if STRATEGYISCLOSED\n                            if testPeriod() \n                                strategy.entry(\"LONG\", strategy.long, comment= \"ENTER LONG DEAL COMMAND HERE\"\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////OPEN SHORT///////////////////////////////////////\nif EMAENTRYSHORT\n    if RSIENTRYSHORT\n        if STOCHENTRYSHORT\n            if HISTENTRYSHORT\n                if ADXSHORTENTRY\n                    if TRADESINAROWSHORT\n                        if STRATEGYISCLOSED\n                            if testPeriod() \n                                strategy.entry(\"SHORT\", strategy.short, comment= \"ENTER SHORT DEAL COMMAND HERE\"\n// /////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////CLOSE LONG////////////////////////////////////////\nif (strategy.position_size > 0)\n    strategy.exit(\"LONG\",stop=StopLossLongPrice, limit=TakeProfitLongPrice, comment_profit\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////CLOSE SHORT///////////////////////////////////////\nif (strategy.position_size < 0)\n    strategy.exit(\"SHORT\",stop=StopLossShortPrice, limit =TakeProfitShortPrice, comment_profit\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////"}]}
{"messages": [{"role": "user", "content": "Simply proof of concept to place a stop loss a percentage below entry price and move it to break even if the price moves the same percentage above the entre price."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 osmaras\n// based on https://kodify.net/tradingview/orders/percentage-trail/\n//@version=5\nstrategy(\"Break even stop loss (% of instrument price)\", overlay=true)\n// Configure trail stop level with input options (optional)\nlongTrailPerc = input.float(defval=3.0,step=0.1,title=\"Trail Long Loss (%)\")* 0.01 \nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nlastEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\nlongStopPrice := if (strategy.position_size > 0 and close > (lastEntryPrice * (1 + \n    stopValue = lastEntryPrice\n    math.max(stopValue, longStopPrice[1])\nelse\n    longStopPrice := if (strategy.position_size > 0)\n        stopValue = lastEntryPrice * (1 - longTrailPerc)\n        math.max(stopValue, longStopPrice[1])\n    else\n        0\n// Plot stop loss values for confirmation\nplot(series=(strategy.position_size > 0) ? longStopPrice : na,\n     color= color.fuchsia, style=plot.style_cross,\n     linewidth=2, title=\"Long Trail Stop\")\n// set strategy only long\nstrategy.risk.allow_entry_in(strategy.direction.long)\n// Submit entry orders\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nif (shortCondition)\n    strategy.close(\"Long\")\n// Submit exit orders for trail stop loss price\nif (strategy.position_size > 0)\n    strategy.exit(id=\"Stop Loss\", stop=longStopPrice)"}]}
{"messages": [{"role": "user", "content": "This strategy aims to identify long (buy) opportunities in the market using the SuperTrend indicator. It utilizes the Average True Range (ATR) and a multiplier to determine the dynamic support levels for entering long positions. This presentation will provide an overview of the strategy's components, explain its usage, and highlight that it focuses on long trades. Components of the Strategy: 1. ATR Period: This input determines the period used for calculating the Average True Range (ATR). A higher value may result in smoother trend lines but may lag behind recent price changes. 2. Source (src): This input determines the price source used for calculations, with \"hl2\" (the average of high and low prices) set as the default. 3. ATR Multiplier: This input specifies the multiplier applied to the ATR value to determine the distance of the support levels from the source. 4. Change ATR Calculation Method: This input allows toggling between two methods of ATR calculation: the default method using atr() or a simple moving average (SMA) of ATR values (sma(tr, Periods)). 5. Show Buy/Sell Signals: This input enables or disables the display of buy and sell signals on the chart. 6. Highlighter On/Off: This input controls whether highlighting of up and down trends is displayed on the chart. 7. Bar Coloring On/Off: This input determines whether the bars on the chart are colored based on the trend direction. 8. The \"SuperTrend Long STRATEGY\" has been enhanced by incorporating a trend filter. A moving average is used as the filter to confirm the prevailing trend before executing trades. This addition effectively reduces false signals and improves the strategy's reliability, all while maintaining its original name. Strategy Logic: 1. The strategy calculates the upper (up) and lower (dn) trend lines based on the ATR value and the chosen multiplier. 2. The trend variable keeps track of the current trend, with 1 indicating an uptrend and -1 indicating a downtrend. 3. Buy and sell signals are generated based on the change in trend direction. 4. The strategy includes an optional highlighting feature that colors the chart background based on the current trend. 5. Additionally, the bar coloring feature colors the bars based on the direction of the last trend change. Usage: 1. ATR Period and ATR Multiplier can be adjusted based on the desired sensitivity and risk tolerance. 2. Buy and sell signals can be displayed using the Show Buy/Sell Signals input, providing clear indications of entry and exit points. 3. The Highlighter On/Off input allows users to visually identify the prevailing trend by coloring the chart background. 4. The Bar Coloring On/Off input offers a quick visual reference for the most recent trend change. Long Strategy: The SuperTrend Long Strategy is specifically designed to identify long (buy) opportunities. It generates buy signals when the current trend changes from a downtrend to an uptrend, indicating a potential entry point for long positions. The strategy aims to capture upward price movements and maximize profits during bullish market conditions. The SuperTrend Long Strategy provides traders with a systematic approach to identifying long trade opportunities. By leveraging the SuperTrend indicator and dynamic support levels, this strategy aims to generate buy signals in uptrending markets. Traders can customize the inputs and utilize the visual features to adapt the strategy to their specific trading preferences. The modification adds a trend filter to the \"SuperTrend Long STRATEGY\" to improve its effectiveness. The trend filter uses a moving average to confirm the prevailing trend before taking trades. This addition helps filter out false signals and enhances the strategy's reliability without changing its name."}, {"role": "assistant", "content": "//@version=4\nstrategy(\"SuperTrend Long Strategy\", overlay=true, initial_capital=50000, currency=\nPeriods = input(title=\"ATR Period\", type=input.integer, defval=10)\nsrc = input(hl2, title=\"Source\")\nMultiplier = input(title=\"ATR Multiplier\", type=input.float, step=0.1, defval=3.0)\nchangeATR = input(title=\"Change ATR Calculation Method ?\", type=input.bool, defval=\nshowsignals = input(title=\"Show Buy/Sell Signals ?\", type=input.bool, defval=false)\nhighlighting = input(title=\"Highlighter On/Off ?\", type=input.bool, defval=true)\nbarcoloring = input(title=\"Bar Coloring On/Off ?\", type=input.bool, defval=true)\natr2 = sma(tr, Periods)\natr = changeATR ? atr(Periods) : atr2\nup = src - (Multiplier * atr)\nup1 = nz(up[1], up)\nup := close[1] > up1 ? max(up, up1) : up\ndn = src + (Multiplier * atr)\ndn1 = nz(dn[1], dn)\ndn := close[1] < dn1 ? min(dn, dn1) : dn\ntrend = 1\ntrend := nz(trend[1], trend)\ntrend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend\n// Moving Average as Trend Filter\nperiodes_ma = input(title=\"Moving Average Period\", type=input.integer, defval=20)\nsrc_ma = input(title=\"Moving Average Source\", type=input.source, defval=close)\nma = sma(src_ma, periodes_ma)\nupPlot = plot(trend == 1 ? up : na, title=\"Up Trend\", style=plot.style_linebr, linewidth\nbuySignal = trend == 1 and trend[1] == -1 and close > ma\nplotshape(buySignal ? up : na, title=\"UpTrend Begins\", location=location.absolute, \nplotshape(buySignal and showsignals ? up : na, title=\"Buy\", text=\"Buy\", location=location.absolute\ndnPlot = plot(trend == 1 ? na : dn, title=\"Down Trend\", style=plot.style_linebr, linewidth\nsellSignal = trend == -1 and trend[1] == 1 and close < ma\nplotshape(sellSignal ? dn : na, title=\"DownTrend Begins\", location=location.absolute\nplotshape(sellSignal and showsignals ? dn : na, title=\"Sell\", text=\"Sell\", location\nmPlot = plot(ohlc4, title=\"\", style=plot.style_circles, linewidth=0)\nlongFillColor = highlighting ? (trend == 1 ?  color.new(color.green, 70) :  color.white\nshortFillColor = highlighting ? (trend == -1 ?  color.new(color.red, 70) :  color.white\nfill(mPlot, upPlot, title=\"UpTrend Highlighter\", color=longFillColor)\nfill(mPlot, dnPlot, title=\"DownTrend Highlighter\", color=shortFillColor)\nFromMonth = input(defval = 9, title = \"From Month\", minval = 1, maxval = 12)\nFromDay   = input(defval = 1, title = \"From Day\", minval = 1, maxval = 31)\nFromYear  = input(defval = 2018, title = \"From Year\", minval = 999)\nToMonth   = input(defval = 1, title = \"To Month\", minval = 1, maxval = 12)\nToDay     = input(defval = 1, title = \"To Day\", minval = 1, maxval = 31)\nToYear    = input(defval = 9999, title = \"To Year\", minval = 999)\nstart     = timestamp(FromYear, FromMonth, FromDay, 00, 00)  \nfinish    = timestamp(ToYear, ToMonth, ToDay, 23, 59)       \nwindow()  => time >= start and time <= finish ? true : false\nlongCondition = buySignal\nif (longCondition)\n    strategy.entry(\"BUY\", strategy.long, when = window())\nshortCondition = sellSignal\nif (shortCondition)\n    strategy.close(\"BUY\")\n    strategy.entry(\"SELL\", strategy.short, when = window())\nbuy1 = barssince(buySignal)\nsell1 = barssince(sellSignal)\ncolor1 = buy1[1] < sell1[1] ?  color.green : buy1[1] > sell1[1] ?  color.red : na\nbarcolor(barcoloring ? color1 : na)"}]}
{"messages": [{"role": "user", "content": "Introduction: The Swing Momentum Strategy is a quantitative trading strategy designed to capture mid-term opportunities in the financial markets by combining swing trading principles with momentum indicators. It utilizes a combination of technical indicators, including moving averages, crossover signals, and volume analysis, to generate buy and sell signals. The strategy aims to identify market trends and capitalize on price momentum for profit generation. Highlights: The strategy offers several key highlights that make it unique and potentially attractive to traders: Swing Trading with Momentum: The strategy combines the principles of swing trading, which aim to capture short-to-medium-term price swings, with momentum indicators that help identify strong price trends and potential breakout opportunities. Technical Indicator Optimization: The strategy utilizes a selection of optimized technical indicators, including moving averages and crossover signals, to filter out the noise and focus on high-probability trading setups. This optimization enhances the strategy's ability to identify favourable entry and exit points. Risk Management: The strategy incorporates risk management techniques, such as position sizing based on equity and dynamic stop loss levels, to manage risk exposure and protect capital. This helps to minimize drawdowns and preserve profits. Buy Condition: The buy condition in the strategy is determined by a combination of factors, including A1, A2, A3, XG, and weeklySlope. Let's break it down: A1 Condition: The A1 condition checks for specific price relationships. It verifies that the ratio of the highest price to the closing price is less than 1.03, the ratio of the opening price to the lowest price is less than 1.03, and the ratio of the highest price to the previous day's closing price is greater than 1.06. This condition looks for a specific pattern indicating potential bullish momentum. A2 Condition: The A2 condition checks for price relationships related to the closing price. It verifies that the ratio of the closing price to the opening price is greater than 1.05 or that the ratio of the closing price to the previous day's closing price is greater than 1.05. This condition looks for signs of upward price movement and momentum. A3 Condition: The A3 condition focuses on volume. It checks if the current volume crosses above the highest volume over the last 60 periods. This condition aims to identify increased buying interest and potentially confirms the strength of the potential upward price movement. XG Condition: The XG condition combines the A1 and A2 conditions and checks if they are true for both the current and previous bars. It also verifies that the ratio of the closing price to the 5-period EMA crosses above the 9-period SMA of the same ratio. This condition helps identify potential buy signals when multiple factors align, indicating a strong bullish momentum and potential entry point. Weekly Trend Factor: The weekly slope condition calculates the slope of the 50-period SMA over a weekly timeframe. It checks if the slope is positive, indicating an overall upward trend on a weekly basis. This condition provides additional confirmation that the stock is in an upward trend. When all of these conditions align, the buy condition is triggered, indicating a favourable time to enter a long position. Sell Condition: The sell condition is relatively straightforward in the strategy: Sell Signal: The sell condition simply checks if the closing price crosses below the 10-period EMA. When this condition is met, it indicates a potential reversal or weakening of the upward price momentum, and a sell signal is generated. Backtest Outcome: The strategy was backtested over the period from January 22nd, 1999 to May 3rd, 2023, using daily candlestick charts for the NASDAQ: NVDA. The strategy used an initial capital of 1,000,000 USD, The order quantity is defined as 10% of the equity. The strategy allows for pyramiding with 1 order, and the transaction fee is set at 0.03% per trade. Here are the key outcomes of the backtest: Net Profit: 539,595.84 USD, representing a return of 53.96%. Percent Profitable: 48.82% Total Closed Trades: 127 Profit Factor: 2.331 Max Drawdown: 68,422.70 USD Average Trade: 4,248.79 USD Average Number of Bars in Trades: 11, indicating the average duration of the trades. Conclusion: In conclusion, the Swing Momentum Strategy is a quantitative trading approach that combines swing trading principles with momentum indicators to identify and capture mid term trading opportunities. The strategy has demonstrated promising results during backtesting, including a significant net profit and a favourable profit factor."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 fzj20020403\n//@version=5\nstrategy(\"Slight Swing Momentum Strategy.\", overlay=true)\n// Position Status Definition\nvar inPosition = false\n// Moving Average Definition\nma60 = ta.sma(close, 60)\n// A1 Condition Definition\nA1 = high / close < 1.03 and open / low < 1.03 and high / close[1] > 1.06\n// A2 Condition Definition\nA2 = close / open > 1.05 or close / close[1] > 1.05\n// A3 Condition Definition\nhighestVol = ta.highest(volume, 60)\nA3 = ta.crossover(volume, highestVol[1])\n// B1 Condition Definition\nema5 = ta.ema(close, 5)\nB1 = close / ema5\n// XG Condition Definition\nA1andA2 = (A1 and A2) and (A1[1] and A2[1])\nXG = ta.crossover(B1, ta.sma(B1, 9))\n// Weekly Trend Factor Definition\nweeklyMa = ta.sma(close, 50)\nweeklySlope = (weeklyMa - weeklyMa[4]) / 4 > 0\n// Buy Signal using XG Condition\nbuySignal = A1 and close > ma60 or A2 and A3 and XG and close > ma60 and weeklySlope\n// Sell Signal Condition\nsellSignal = close < ta.ema(close, 10)\n// Buy and Sell Conditions\nbuyCondition = buySignal and not inPosition\nsellCondition = sellSignal and inPosition\n// Execute Buy and Sell Operations\nif (buyCondition)\n    strategy.entry(\"Buy\", strategy.long)\n    inPosition := true\nif (sellCondition)\n    strategy.close(\"Buy\")\n    inPosition := false\n// Stop Loss and Take Profit Levels\nstopLoss = strategy.position_avg_price * 0.5\ntakeProfit = strategy.position_avg_price * 1.30\n// Apply Stop Loss and Take Profit Levels\nif inPosition\n    strategy.exit(\"Long Stop Loss\", \"Buy\", stop=stopLoss)\n    strategy.exit(\"Long Take Profit\", \"Buy\", limit=takeProfit)\n// Plot Buy and Sell Signal Shapes\nplotshape(buyCondition, style=shape.arrowdown, location=location.belowbar, color= \nplotshape(sellCondition, style=shape.arrowup, location=location.abovebar, color= color.red\n// EMA Variable Definition\nema = ta.ema(close, 5)\n// Plot Indicator Line\nplot(ema, color= color.green, title=\"EMA\")"}]}
{"messages": [{"role": "user", "content": "Thanks For Tradingview Built-in Script :: << Original From Consecutive Strategy Built-in Script >> ================== Read This First Before Use This Strategy ==============  Please be aware that this strategy is not a guarantee of success and may lead to losses.  Trading involves risk and you should always do your own research before making any decisions.  This Strategy Just an Idea For Help Your Decision For Open Position.  You Must Be Search and Make Your Self Understand What You Doing In This Strategy.  Example :: This Strategy and Indicator Find The Consecutive Bars And You, You Are Reading Must Be Decision Up to You !!  For Backtest Show It's That For a Newbie 100$ Portfolio and 16.333$ Per Order Size >>>> Read Me First !! <<<<< ========== Detailed and meaningful description =========  How It's Work : This Strategy are Following Green or Red Candle :: example 3 Green Candle To OpenLong Position  Can Set TP/SL if you want :: Just Fine The Best Value of Asset as you want  Fast Trend = MA FAST LINE   SLOW Trend = MA SLOW LINE   MID-TERM TREND = MA MID-TERM   LONG-TERM TREND = MA LONG-TERM  =========== Condition And Statement ===========  Long Condition Statement ::  Candles Consecutive Bars Up and close > golden_line and fast_line > golden_line  Short Condition Statement ::  Candles Consecutive Bars Down and close < golden_line and fast_line < golden_line  AutoCloseLong Condition ::  Candles ConsecutiveBarsDownStop and close > golden_line and close < death_line and close < death_line and close < death_line or fastUpdeath  AutoCloseShort Condition ::  Candles ConsecutiveBarsUpStop and close < golden_line and close > death_line and close > death_line and close > death_line or fastUpdeath  ====== For ADAPTIVE you can customize your ALL MA  For Your Statement /////////For Example Hook Alert Command ////////////  Just Easy Command >> :: {{strategy.order.alert_message}}  Or Other Json You Should Edit Command Like This Example  {\"ex\":\"'bnfuture'\",\"side\": \"AutoLong\", \"$16.333\", \"symbol\": \"{{ticker}}\", \"passphrase\": \"1234\",\"leverage\":\"10\", \"tp\" : \"5\", \"sl\" : \"2\", \"tl\" : \"2\", \"callback\" : \"1\"}  {\"ex\":\"'bnfuture'\",\"side\": \"AutoShort\", \"$16.333\", \"symbol\": \"{{ticker}}\", \"passphrase\": \"1234\",\"leverage\":\"10\", \"tp\" : \"5\", \"sl\" : \"2\", \"tl\" : \"2\", \"callback\" : \"1\"}"}, {"role": "assistant", "content": "//Thanks For Tradingview Built-in Script :: << Original From Consecutive Strategy Built-in Script >>\n//This Strategy Mod by ME : X4815162342\n//================== Read This First Before Use This Strategy ==============\n// *********** Please be aware that this strategy is not a guarantee of success and may lead to loss\n// *********** Trading involves risk and you should always do your own research before making any de\n// *********** This Strategy Just an Idea For Help Your Decision For OpenPosition.\n// *********** You Must Be Search and Make Your Self Understand What You Doing In This Strategy.\n// *********** Example :: This Strategy and Indicator Find The Consecutive Bars And You, You Are Rea\n// *********** For Backtest Show It's That For a Newbie 100$ Portfolio and 16.333$ Per Order Size\n//>>>> Read Me First !! <<<<< \n//========== Detailed and meaningful description =========\n// - How It's Work : This Strategy are Following [Length]Green or [Length]Red Candle :: example 3 Gr\n// - Can Set TP/SL if you want :: Just Fine The Best Value of Asset as you want\n// - Fast Trend = MA FAST LINE [Blue Line]\n// - SLOW Trend = MA SLOW LINE [Red Line]\n// - MID-TERM TREND = MA MID-TERM [Yellow Line]\n// - LONG-TERM TREND = MA LONG-TERM [White Line]\n//=========== Condition And Statement ===========\n// Long Condition Statement :: [Length] Candles Consecutive Bars Up and close > golden_line and fast\n// Short Condition Statement :: [Length] Candles Consecutive Bars Down and close < golden_line and f\n// AutoCloseLong Condition :: [Length] Candles ConsecutiveBarsDownStop and close > golden_line and c\n// AutoCloseShort Condition :: [Length] Candles ConsecutiveBarsUpStop and close < golden_line and cl\n// ====== For ADAPTIVE you can customize your ALL MA [FAST, SLOW, MID-TERM, LONG-TERM] For Your Stat\n///////////For Example Hook Alert Command ////////////\n// Just Easy Command >> :: {{strategy.order.alert_message}}\n// Or Other Json You Should Edit Command Like This Example\n// {\"ex\":\"'bnfuture'\",\"side\": \"AutoLong\", \"$16.333\", \"symbol\": \"{{ticker}}\", \"passphrase\": \"1234\",\"l\n// {\"ex\":\"'bnfuture'\",\"side\": \"AutoShort\", \"$16.333\", \"symbol\": \"{{ticker}}\", \"passphrase\": \"1234\",\"\n//////////////////////////////////////////////////////\n//@version=5\nstrategy(\"X48 - Strategy | ADAPTIVE CONSECUTIVE + TP/SL | V.1\", overlay=true, default_qty_type\n//================ SPOT MODE ==============\nGRSPT = \"=== \ud83c\udf40\ud83c\udf40\ud83c\udf40 SPOT MODE \ud83c\udf40\ud83c\udf40\ud83c\udf40 ===\"\nSpot_MODE = input.bool(defval = false, title = \"\ud83c\udf40 SPOT MODE\", group = GRSPT)\nAuto_Stop = input.bool(defval = true, title = \"\ud83c\udf75 AUTO TP/SL\", group = \"CONSECUTIVE-SETTING\"\nconsecutiveBarsUp = input(defval = 3, title = \"BarsUp-Length\", group = \"CONSECUTIVE-SETTING\"\nconsecutiveBarsDown = input(defval = 3, title = \"BarsDown-Length\", group = \"CONSECUTIVE-SETTING\"\nconsecutiveBarsUpStop = input(defval = 2, title = \"BarsStopUp-Length\", group = \"CONSECUTIVE-STOP\"\nconsecutiveBarsDownStop = input(defval = 2, title = \"BarsStopDown-Length\", group =\n////////////////////////////////////////////////////////////////////////////////////\nGRMAC = '===\ud83d\udcaf\ud83d\udcaf\ud83d\udcaf4\ufe0f\u20e3 Multi MA SETTING 4\ufe0f\u20e3\ud83d\udcaf\ud83d\udcaf\ud83d\udcaf==='\n/////////// Normal Setting ////////////////\nsrcstrategy = input(close, title='\ud83d\udcaf4\ufe0f\u20e3 Source Multi MA', group = GRMAC, tooltip = 'Normal Line = Close \\nSmooth Line = ohlc4'\n///////////// EMA/SMA SETTING /////////////\npricestrategy = request.security(syminfo.tickerid, timeframe.period, srcstrategy)\nma1strategy = input(8, title='\ud83d\udcaf4\ufe0f\u20e3 Fast MA Length', group = GRMAC, inline = '12')\ntype1strategy = input.string('EMA', 'Fast MA Type', options=['SMA', 'EMA', 'WMA', \nma3strategy = input(32, title='\ud83d\udcaf4\ufe0f\u20e3 Slow MA Length', group = GRMAC, inline = '13')\ntype3strategy = input.string('EMA', 'Slow MA Type', options=['SMA', 'EMA', 'WMA', \nma4strategy = input(50, title='\ud83d\udcaf4\ufe0f\u20e3 Mid MA Length', group = GRMAC, inline = '14')\ntype4strategy = input.string('EMA', 'Mid MA Type', options=['SMA', 'EMA', 'WMA', 'HMA'\nma5strategy = input(200, title='\ud83d\udcaf4\ufe0f\u20e3 Long MA Length', group = GRMAC, inline = '15')\ntype5strategy = input.string('EMA', 'Long MA Type', options=['SMA', 'EMA', 'WMA', \nprice1strategy = switch type1strategy\n    \"EMA\" => ta.ema(pricestrategy, ma1strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma1strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma1strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma1strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma1strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma1strategy)\n        price3strategy = switch type3strategy\n    \"EMA\" => ta.ema(pricestrategy, ma3strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma3strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma3strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma3strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma3strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma3strategy)\nprice4strategy = switch type4strategy\n    \"EMA\" => ta.ema(pricestrategy, ma4strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma4strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma4strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma4strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma4strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma4strategy)\nprice5strategy = switch type5strategy\n    \"EMA\" => ta.ema(pricestrategy, ma5strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma5strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma5strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma5strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma5strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma5strategy)\nfast_plot = input.bool(defval = true, title = \"MA FAST\", group = \"PLOT\", inline = \nslow_plot = input.bool(defval = true, title = \"MA SLOW\", group = \"PLOT\", inline = \ndeath_plot = input.bool(defval = true, title = \"MID MA\", group = \"PLOT\", inline = \ngolden_plot = input.bool(defval = true, title = \"LONG MA\", group = \"PLOT\", inline \nprice = close\nups = 0.0\nups := price > price[1] ? nz(ups[1]) + 1 : 0\ndns = 0.0\ndns := price < price[1] ? nz(dns[1]) + 1 : 0\ngolden_line = price5strategy\ndeath_line = price4strategy\nfast_line = price1strategy\nslow_line = price3strategy\nplot(golden_plot ? golden_line : na, title = \"Golden Line\", color =  color.white,\nplot(death_plot ? death_line : na, \"Death Line\", color =  color.yellow, linewidth\nplot(fast_plot ? fast_line : na, \"Death Line\", color =  color.blue, linewidth = 1\nplot(slow_plot ? slow_line : na, \"Death Line\", color =  color.red, linewidth = 1)\nfastUpdeath = ta.crossunder(fast_line, death_line)\nfastDowndeath = ta.crossover(fast_line, death_line)\n//=============== TAKE PROFIT and STOP LOSS by % =================\ntpsl(percent) =>\n    strategy.position_avg_price * percent / 100 / syminfo.mintick\nGR4 = \"=====\ud83c\udd98\ud83c\udd98\ud83c\udd98 TAKE PROFIT & STOP LOSS BY [%] \ud83c\udd98\ud83c\udd98\ud83c\udd98=====\"\nGRH = \"\ud83c\udfaf\ud83c\udfaf\ud83c\udfaf TakeProfit & StopLoss MODE \ud83c\udfaf\ud83c\udfaf\ud83c\udfaf\"\nmode= input.bool(title=\"\ud83c\udd98 Take Profit & Stop Loss By Percent (%)\", defval=true, group\nlengthBO = input.int(title=\"1\ufe0f\u20e3 Length BreakOut\", minval=1, maxval=1000, defval=5, \nBOTrail_MODE = input.bool(defval = false, title = \"\ud83c\udd7e\ufe0f CALLBACK Trailing Stop [Low Profit But More \ntriling_BO = input.float(title = \"\ud83c\udd7e\ufe0f BreakOut Trailing CALLBACK [%]\", defval = 25, \nplotcolor = input.bool(defval = false, title = '\ud83c\udd91 ATR Trailing Stop', group = GRH)\nupBound = ta.highest(high, lengthBO)\ndownBound = ta.lowest(low, lengthBO)\nSL_LongBO = (close < (upBound-((upBound*triling_BO)/100)))\nSL_ShortBO = (close > (downBound+((downBound*triling_BO)/100)))\ntp_l = tpsl(input.float(99999, title='\ud83c\udd98 TP [LONG] %', group=GR4))\ntp_s = tpsl(input.float(20, title='\ud83c\udd98 TP [SHORT] %', group=GR4))\nsl = tpsl(input.float(5, title='\ud83c\udd98 Stop Loss %', group=GR4))\nGRT = \"=====\ud83c\udd91\ud83c\udd91\ud83c\udd91 ATR TRAILING STOP \ud83c\udd91\ud83c\udd91\ud83c\udd91=====\"\n/////////notes////////////////////////////////////////\n// This is based on the ATR trailing stop indicator //\n// width addition of two levels of stops and        //\n// different interpretation.                        //\n// This is a fast-reacting system and is better     //\n// suited for higher volatility markets             //\n//////////////////////////////////////////////////////\n // Fast Trail //\nAP1 = input.int(5, '\ud83c\udd91 Fast ATR period', group = GRT)  // ATR Period\nAF1 = input.float(0.5, '\ud83c\udd91 Fast ATR multiplier', group = GRT)  // ATR Factor\nSL1 = AF1 * ta.atr(AP1)  // Stop Loss\nTrail1 = 0.0\niff_1 = close > nz(Trail1[1], 0) ? close - SL1 : close + SL1\niff_2 = close < nz(Trail1[1], 0) and close[1] < nz(Trail1[1], 0) ? math.min(nz(Trail1\nTrail1 := close > nz(Trail1[1], 0) and close[1] > nz(Trail1[1], 0) ? math.max(nz(Trail1\n// Slow Trail //\nAP2 = input.int(10, '\ud83c\udd91 Slow ATR period', group = GRT)  // ATR Period\nAF2 = input.float(2, '\ud83c\udd91 Slow ATR multiplier', group = GRT)  // ATR Factor\nSL2 = AF2 * ta.atr(AP2)  // Stop Loss\nTrail2 = 0.0\niff_3 = close > nz(Trail2[1], 0) ? close - SL2 : close + SL2\niff_4 = close < nz(Trail2[1], 0) and close[1] < nz(Trail2[1], 0) ? math.min(nz(Trail2\nTrail2 := close > nz(Trail2[1], 0) and close[1] > nz(Trail2[1], 0) ? math.max(nz(Trail2\nBuyLong = ta.crossover(Trail1, Trail2)\nSellShort = ta.crossunder(Trail1, Trail2)\nTS1 = plot(plotcolor ? Trail1 : na, 'Fast Trail', style=plot.style_line, color=Trail1\nTS2 = plot(plotcolor ? Trail2 : na, 'Slow Trail', style=plot.style_line, color=Trail1\nif plotcolor == true\n    if BuyLong and strategy.position_size < 0\n        strategy.close('Short', qty_percent = 100, comment = \"\ud83d\udea8ATR TL\ud83d\udea8\")\n    if SellShort and strategy.position_size > 0\n        strategy.close('Long', qty_percent = 100, comment = \"\ud83d\udea8ATR TL\ud83d\udea8\")\ncalcStopLossPrice(OffsetPts) =>\n    if strategy.position_size > 0\n        strategy.position_avg_price - OffsetPts * syminfo.mintick\n    else if strategy.position_size < 0\n        strategy.position_avg_price + OffsetPts * syminfo.mintick\n    else\n        na\nvar stoploss = 0.\nvar takeprofit = 0.\nif mode == true\n    if (strategy.position_size > 0)\n        stoploss := calcStopLossPrice(sl)\n        takeprofit := tp_l\n    if (strategy.position_size < 0)\n        stoploss := calcStopLossPrice(sl)\n        takeprofit := tp_s\n    else if strategy.position_size == 0\n        stoploss := na\n        takeprofit := na\n////////////////////////////////////////////////////////////////////////////////////////////////////\nText_Alert_Future = '{{strategy.order.alert_message}}'\ncopy_Fu = input( defval= Text_Alert_Future ,    title=\"Alert Message for BOT\", inline\npassphrase = input.string(defval='1234', title ='Bot Pass',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nleveragex  = input.int(125,title='leverage',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nlongcommand = input.string(defval='AutoLong', title = 'Bot Long Command',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nshortcommand = input.string(defval='AutoShort', title = 'Bot Short Command',group=\nmarkettype = input.string(defval='bnfuture', title = 'Future/Spot Command',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \n//////////////// Strategy Alert //////////////////////\n//////// For Use Bot Can Change This Command By Your Self /////////////////////\nstring Alert_OpenLong       = '{\"ex\":\"'+markettype+'\",\"side\": \"'+longcommand+'\", \"@{{strategy.order.contracts}}\", \"symbol\": \"{{\nstring Alert_OpenShort      = '{\"ex\":\"'+markettype+'\",\"side\": \"'+shortcommand+'\", \"@{{strategy.order.contracts}}\", \"symbol\": \"{{\n//string Alert_LongTP         = '{\"ex\":\"bnfuture\",\"side\": \"CloseLong\", \"amount\": \"@{{strategy.order.\n//string Alert_ShortTP        = '{\"ex\":\"bnfuture\",\"side\": \"CloseShort\", \"amount\": \"@{{strategy.order\n//var message_closelong       = '{\"ex\":\"bnfuture\",\"side\": \"CloseLong\", \"amount\": \"%100\", \"symbol\": \"\n//var message_closeshort      = '{\"ex\":\"bnfuture\",\"side\": \"CloseShort\", \"amount\": \"%100\", \"symbol\": \nstring Alert_StopLosslong   = '{\"ex\":\"'+markettype+'\",\"side\": \"CloseLong\", \"amount\": \"%100\", \"symbol\"\nstring Alert_StopLossshort  = '{\"ex\":\"'+markettype+'\",\"side\": \"CloseShort\", \"amount\": \"%100\", \"symbol\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////// INPUT BACKTEST RANGE ////////////////////////////////////////////////////\nvar string BTR1         = '\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INPUT BACKTEST TIME RANGE \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550'\ni_startTime             = input.time(defval = timestamp(\"01 Jan 1945 00:00 +0000\")\ni_endTime               = input.time(defval = timestamp(\"01 Jan 2074 23:59 +0000\")\nif time >= i_startTime and time <= i_endTime\n    if Spot_MODE == false\n        if (ups >= consecutiveBarsUp) and close > golden_line and fast_line > golden_line\n            strategy.entry(\"Long\", strategy.long, comment=\"\ud83c\udf19\", alert_message = Alert_OpenLong\n        if (dns >= consecutiveBarsDown) and close < golden_line and fast_line < golden_line\n            strategy.entry(\"Short\", strategy.short, comment=\"\ud83d\udc7b\", alert_message = Alert_OpenShort\n        if Auto_Stop == true\n            if (dns >= consecutiveBarsDownStop) and close > golden_line and close[\n                strategy.close(\"Long\", qty_percent = 100, comment = \"\ud83d\udd14AUTO\ud83d\udd14\", alert_message\n            if (ups >= consecutiveBarsUp) and close < golden_line and close[2] > death_line\n                strategy.close(\"Short\", qty_percent = 100, comment = \"\ud83d\udd14AUTO\ud83d\udd14\", alert_message\n    if Spot_MODE == true\n        if (ups >= consecutiveBarsUp) and close > golden_line and fast_line > golden_line\n            strategy.entry(\"Long\", strategy.long, comment=\"\ud83c\udf19\", alert_message = Alert_OpenLong\n                if Auto_Stop == true\n            if (dns >= consecutiveBarsDownStop) and close > golden_line and close[\n                strategy.close(\"Long\", qty_percent = 100, comment = \"\ud83d\udd14AUTO\ud83d\udd14\", alert_message\nif mode == true\n    if Spot_MODE == false\n        if tp_l > 0 and sl > 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , profit = takeprofit, \n        if tp_l > 0 and sl <= 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , profit = takeprofit, \n        if tp_l <= 0 and sl > 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , stop = stoploss, comment_loss\n        if tp_s > 0 and sl > 0 and strategy.position_size < 0\n            strategy.exit(\"Exit\",'Short', qty_percent = 100, profit = takeprofit, \n        if tp_s > 0 and sl <= 0 and strategy.position_size < 0\n            strategy.exit(\"Exit\",'Short', qty_percent = 100, profit = takeprofit, \n        if tp_s <= 0 and sl > 0 and strategy.position_size < 0\n            strategy.exit(\"Exit\",'Short', qty_percent = 100, stop = stoploss, comment_loss\n    if Spot_MODE == true\n        if tp_l > 0 and sl > 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , profit = takeprofit, \n        if tp_l > 0 and sl <= 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , profit = takeprofit, \n        if tp_l <= 0 and sl > 0 and strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , loss = stoploss, comment_loss\nif BOTrail_MODE == true\n    if Spot_MODE == false\n        if SL_LongBO and strategy.position_size > 0\n            strategy.close(\"Long\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\", alert_message\n        if SL_ShortBO and strategy.position_size < 0\n            strategy.close(\"Short\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\", alert_message\n    if Spot_MODE == true\n        if SL_LongBO and strategy.position_size > 0\n            strategy.close(\"Long\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\", alert_message\n//===================== \u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49  library =========================\nimport X4815162342/X48_LibaryStrategyStatus/2 as fuLi \n//\u0e41\u0e2a\u0e14\u0e07\u0e1c\u0e25 Backtest\nshow_Net = input.bool(true,'Monitor Profit&Loss', inline = 'Lnet', group = '= PNL MONITOR SETTING ='\nposition_ = input.string('bottom_center','Position', options = ['top_right','middle_right'\nsize_i = input.string('auto','size', options = ['auto','tiny','small','normal'] , \ncolor_Net = input.color( color.blue,\"\" , inline = 'Lnet')\nfuLi.NetProfit_Show(show_Net , position_ , size_i,  color_Net )"}]}
{"messages": [{"role": "user", "content": "This script calculates the fair value of gold, which is set as an input parameter. It then gets the current price of gold and calculates the gap between the price and the fair value. If the gap is positive, it enters a long trade, and if it's negative, it enters a short trade. The script also uses proper risk management techniques by setting a stop loss and take profit for each trade. The plot() function is used to display the fair value and gap on the chart. Please note that this is just an example script, and you should customize it based on your specific trading strategy and criteria. It's also important to backtest your strategy and refine it before using it with real money."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Gold Fair Value Gap Entry\", overlay=true)\n// Define the fair value\nfairValue = input.float(title=\"Fair Value\", defval=1800.00, step=0.01)\n// Get the current price and calculate the gap\nprice = request.security(\"XAUUSD\", timeframe.period, close)\ngap = price - fairValue\n// Enter long and short trades based on the gap\nif (gap > 0)\n    strategy.entry(\"Long\", strategy.long)\nif (gap < 0)\n    strategy.entry(\"Short\", strategy.short)\n// Use proper risk management techniques\nstopLoss = input.float(title=\"Stop Loss\", defval=1.0, step=0.1)\ntakeProfit = input.float(title=\"Take Profit\", defval=2.0, step=0.1)\nstrategy.exit(\"Exit Long\", \"Long\", stop=close * (1 - stopLoss / 100), limit=close *\nstrategy.exit(\"Exit Short\", \"Short\", stop=close * (1 + stopLoss / 100), limit=close\n// Plot the fair value and gap\nplot(fairValue, color= color.blue, style=plot.style_line)\nplot(price, color= color.black)\nplot(gap, color=price > fairValue ?  color.green :  color.red)"}]}
{"messages": [{"role": "user", "content": "The Bollinger Bands - Breakout Strategy is a trend-following optimized for short-term trading in the crypto market. This strategy employs the Bollinger Bands, a widely recognized technical indicator, as its primary instrument for pinpointing potential trades. It is capable of executing both long and short positions, depending on whether the market is in a spot or futures, and is particularly effective in trending markets. The strategy boasts a high degree of configurability, allowing users to set the Bollinger Bands period and deviation, trend filter, volatility filter, trade direction filter, rate of change filter, and date filter. Furthermore, it offers options for Take Profit, Stop Loss, and Trailing Stop for both long and short positions, ensuring a comprehensive risk management approach. The inclusion of a maximum intraday loss feature adds another layer of protection, making this strategy a valuable tool for traders seeking a professional and adaptable trading system. Name: Bollinger Bands - Breakout Strategy  Category: Trend Follower based on Bollinger Bands  Operating mode: Long and Short on Futures or Long on Spot  Trade duration: Intraday  Timeframe: 2H, 3H, 4H, 5H  Market: Crypto Suggested usage: Trending Markets Entry: When the price crosses above or below the Bollinger Bands  Exit: Opposite Cross or Profit target, Trailing stop or Stop loss  Configuration:  - Bollinger Bands period and deviation  - Trend Filter  - Volatility Filter  - Trade direction filter - Rate of Change filter - Date Filter (for backtesting purposes)  - Take Profit, Stop Loss and Trailing Stop for long and short positions  - Risk Management: Max Intraday Loss Backtesting: \u2043 Exchange: BINANCE \u2043 Pair: BTCUSDT.P \u2043 Timeframe: 4H \u2043 Fee: 0.025% \u2043 Slippage: 1 - Initial Capital: 10000 USDT - Position sizing: 10% of Equity - Start : 2019-09-19 (Out Of Sample from 2022-12-23) - Bar magnifier: on Credits:  - LucF of Pine Coders for f_security function to avoid repainting using security.   - QuantNomad for Monthly Table. Disclaimer: Risk Management is crucial, so adjust stop loss to your comfort level. A tight stop loss can help minimise potential losses. Use at your own risk.  How you or we can improve? Source code is open so share your ideas!  Leave a comment and smash the boost button!  Thanks for your attention, happy to support the TradingView community."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Bollinger Bands - Breakout Strategy\",overlay=true, \n         initial_capital=10000, \n         default_qty_type=strategy.percent_of_equity, default_qty_value=10,\n         slippage=1, backtest_fill_limits_assumption=1, use_bar_magnifier=true,\n         commission_type=strategy.commission.percent, commission_value=0.025\n         )\n// Define the length of the Bollinger Bands\nbbLengthInput = input.int (15,title=\"Length\", group=\"Bollinger Bands\", inline=\"BB\"\nbbDevInput = input.float (2.0,title=\"StdDev\", group=\"Bollinger Bands\", inline=\"BB\"\n// Define the settings for the Trend Filter\ntrendFilterInput = input.bool(false, title=\"Above/Below\", group = \"Trend Filter\", \ntrendFilterPeriodInput = input(223,title=\"\", group = \"Trend Filter\", inline=\"Trend\"\ntrendFilterType = input.string (title=\"\", defval=\"EMA\",options=[\"EMA\",\"SMA\",\"RMA\",\nvolatilityFilterInput = input.bool(true,title=\"StdDev\", group = \"Volatility Filter\"\nvolatilityFilterStDevLength = input(15,title=\"\",group = \"Volatility Filter\", inline\nvolatilityStDevMaLength = input(15,title=\">MA\",group = \"Volatility Filter\", inline\n// ROC Filter\n// f_security function by LucF for PineCoders available here: https://www.tradingview.com/script/cyPWY96u-How-to\nf_security(_sym, _res, _src, _rep) => request.security(_sym, _res, _src[not _rep and\nhigh_daily = f_security(syminfo.tickerid, \"D\", high, false)\nroc_enable = input.bool(false, \"\", group=\"ROC Filter from CloseD\", inline=\"roc\")\nroc_threshold = input.float(1, \"Treshold\", step=0.5, group=\"ROC Filter from CloseD\"\nclosed = f_security(syminfo.tickerid,\"1D\",close, false)\nroc_filter= roc_enable ? (close-closed)/closed*100  > roc_threshold : true\n// Trade Direction Filter\ntradeDirectionInput = input.string(\"Auto\",options=[\"Auto\", \"Long&Short\",\"Long Only\"\ntradeDirection = switch tradeDirectionInput\n    \"Auto\" => str.contains(str.lower(syminfo.description), \"perp\") or str.contains\n    \"Long&Short\" => strategy.direction.all\n    \"Long Only\" => strategy.direction.long\n    \"Short Only\" => strategy.direction.short\n    => strategy.direction.all\nstrategy.risk.allow_entry_in(tradeDirection)\n// Calculate and plot the Bollinger Bands\n[bbMiddle, bbUpper, bbLower] = ta.bb (close, bbLengthInput, bbDevInput)\nplot(bbMiddle, \"Basis\", color= color.orange)\nbbUpperPlot = plot(bbUpper, \"Upper\", color= color.blue)\nbbLowerrPlot = plot(bbLower, \"Lower\", color= color.blue)\nfill(bbUpperPlot, bbLowerrPlot, title = \"Background\", color= color.new(color.blue\n// Calculate and view Trend Filter\nfloat tradeConditionMa = switch trendFilterType\n    \"EMA\" => ta.ema(close, trendFilterPeriodInput)\n    \"SMA\" => ta.sma(close, trendFilterPeriodInput)\n    \"RMA\" => ta.rma(close, trendFilterPeriodInput)\n    \"WMA\" => ta.wma(close, trendFilterPeriodInput)\n    // Default used when the three first cases do not match.\n    => ta.wma(close, trendFilterPeriodInput)\ntrendConditionLong  = trendFilterInput ? close > tradeConditionMa : true\ntrendConditionShort = trendFilterInput ? close < tradeConditionMa : true\nplot(trendFilterInput ? tradeConditionMa : na, color= color.yellow)\n// Calculate and view Volatility Filter\nstdDevClose = ta.stdev(close,volatilityFilterStDevLength)\nvolatilityCondition = volatilityFilterInput ? stdDevClose > ta.sma(stdDevClose,volatilityStDevMaLength\nbbLowerCrossUnder =  ta.crossunder(close, bbLower)\nbbUpperCrossOver =  ta.crossover(close, bbUpper)\nbgcolor(volatilityCondition ? na :  color.new(color.red, 95))\n// Date Filter\nstart = input.time(timestamp(\"2017-01-01\"), \"Start\", group=\"Date Filter\")\nfinish = input.time(timestamp(\"2050-01-01\"), \"End\", group=\"Date Filter\")\ndate_filter = time >= start and time <= finish ? true : false\n// Entry and Exit Conditions\nentryLongCondition = bbUpperCrossOver and trendConditionLong and volatilityCondition\nentryShortCondition = bbLowerCrossUnder and trendConditionShort and volatilityCondition\nexitLongCondition = bbLowerCrossUnder\nexitShortCondition = bbUpperCrossOver\n// Orders\nif entryLongCondition\n    strategy.entry(\"EL\", strategy.long)\nif entryShortCondition\n    strategy.entry(\"ES\", strategy.short)\nif exitLongCondition\n    strategy.close(\"EL\")\nif exitShortCondition\n    strategy.close(\"ES\")\n// Long SL/TP/TS\nxl_ts_percent      = input.float(2,step=0.5, title= \"TS\", group=\"Exit Long\", inline\nxl_to_percent      = input.float(0.5, step=0.5, title= \"TO\", group=\"Exit Long\", inline\nxl_ts_tick = xl_ts_percent * close/syminfo.mintick/100\nxl_to_tick = xl_to_percent * close/syminfo.mintick/100\nxl_sl_percent      = input.float (2, step=0.5, title=\"SL\",group=\"Exit Long\", inline\nxl_tp_percent      = input.float(9, step=0.5, title=\"TP\",group=\"Exit Long\", inline\nxl_sl_price = strategy.position_avg_price * (1-xl_sl_percent/100)\nxl_tp_price = strategy.position_avg_price * (1+xl_tp_percent/100)\nstrategy.exit(\"XL+SL/TP\", \"EL\", stop=xl_sl_price, limit=xl_tp_price, trail_points=\n// Short SL/TP/TS\nxs_ts_percent      = input.float(2,step=0.5, title= \"TS\",group=\"Exit Short\", inline\nxs_to_percent      = input.float(0.5, step=0.5, title= \"TO\",group=\"Exit Short\", inline\nxs_ts_tick = xs_ts_percent * close/syminfo.mintick/100\nxs_to_tick = xs_to_percent * close/syminfo.mintick/100\nxs_sl_percent      = input.float (2, step=0.5, title=\"SL\",group=\"Exit Short\", inline\nxs_tp_percent      = input.float(9, step=0.5, title=\"TP\",group=\"Exit Short\",  inline\nxs_sl_price = strategy.position_avg_price * (1+xs_sl_percent/100)\nxs_tp_price = strategy.position_avg_price * (1-xs_tp_percent/100)\nstrategy.exit(\"XS+SL/TP\", \"ES\", stop=xs_sl_price, limit=xs_tp_price, trail_points=\nmax_intraday_loss = input.int(10, title=\"Max Intraday Loss (Percent)\", group=\"Risk Management\"\nstrategy.risk.max_intraday_loss(max_intraday_loss, strategy.percent_of_equity)\n// Monthly Returns table, modified from QuantNomad. Please put calc_on_every_tick = true to plot it.\nmonthly_table(int results_prec, bool results_dark) =>\n    new_month = month(time) != month(time[1])\n    new_year  = year(time)  != year(time[1])\n        eq = strategy.equity\n        bar_pnl = eq / eq[1] - 1\n        cur_month_pnl = 0.0\n    cur_year_pnl  = 0.0\n        // Current Monthly P&L\n    cur_month_pnl := new_month ? 0.0 : \n                     (1 + cur_month_pnl[1]) * (1 + bar_pnl) - 1 \n        // Current Yearly P&L\n    cur_year_pnl := new_year ? 0.0 : \n                     (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1  \n        // Arrays to store Yearly and Monthly P&Ls\n    var month_pnl  = array.new_float(0)\n    var month_time = array.new_int(0)\n        var year_pnl  = array.new_float(0)\n    var year_time = array.new_int(0)\n        last_computed = false\n        if (not na(cur_month_pnl[1]) and (new_month or barstate.islast))\n        if (last_computed[1])\n            array.pop(month_pnl)\n            array.pop(month_time)\n                    array.push(month_pnl , cur_month_pnl[1])\n        array.push(month_time, time[1])\n        if (not na(cur_year_pnl[1]) and (new_year or barstate.islast))\n        if (last_computed[1])\n            array.pop(year_pnl)\n            array.pop(year_time)\n                    array.push(year_pnl , cur_year_pnl[1])\n        array.push(year_time, time[1])\n        last_computed := barstate.islast ? true : nz(last_computed[1])\n        // Monthly P&L Table    \n    var monthly_table = table(na)\n        cell_hr_bg_color = results_dark ?  #0F0F0F :  #F5F5F5\n    cell_hr_text_color = results_dark ?  #D3D3D3 :  #555555\n    cell_border_color = results_dark ?  #000000 :  #FFFFFF\n    // ell_hr_bg_color = results_dark ? #0F0F0F : #F5F5F5\n    // cell_hr_text_color = results_dark ? #D3D3D3 : #555555\n    // cell_border_color = results_dark ? #000000 : #FFFFFF\n    if (barstate.islast)\n        monthly_table := table.new(position.bottom_right, columns = 14, rows = array.size\n            table.cell(monthly_table, 0,  0, syminfo.tickerid + \" \" + timeframe.period\n        table.cell(monthly_table, 1,  0, \"Jan\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 2,  0, \"Feb\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 3,  0, \"Mar\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 4,  0, \"Apr\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 5,  0, \"May\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 6,  0, \"Jun\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 7,  0, \"Jul\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 8,  0, \"Aug\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 9,  0, \"Sep\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 10, 0, \"Oct\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 11, 0, \"Nov\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 12, 0, \"Dec\",  text_color=cell_hr_text_color, bgcolor\n        table.cell(monthly_table, 13, 0, \"Year\", text_color=cell_hr_text_color, bgcolor\n            for yi = 0 to array.size(year_pnl) - 1\n            table.cell(monthly_table, 0,  yi + 1, str.tostring(year(array.get(year_time\n                        y_color = array.get(year_pnl, yi) > 0 ?  color.lime :  array.get(year_pnl\n            table.cell(monthly_table, 13, yi + 1, str.tostring(math.round(array.get\n                    for mi = 0 to array.size(month_time) - 1\n            m_row   = year(array.get(month_time, mi))  - year(array.get(year_time,\n            m_col   = month(array.get(month_time, mi)) \n            m_color = array.get(month_pnl, mi) > 0 ?  color.lime : array.get(month_pnl\n                        table.cell(monthly_table, m_col, m_row, str.tostring(math.round(array.get\nresults_prec = input(2, title = \"Precision\", group=\"Results Table\")\nresults_dark = input.bool(defval=true, title=\"Dark Mode\", group=\"Results Table\")\nmonthly_table(results_prec, results_dark)"}]}
{"messages": [{"role": "user", "content": "The script is an advanced technical analysis tool specifically designed for trading in financial markets, with a particular focus on the BankNifty market. It utilizes two powerful indicators: the Fractal Adaptive Moving Average (FRAMA) and the CPMA (Conceptive Price Moving Average), which is similar to the well-known Chande Momentum Oscillator (CMO) with Center of Gravity (COG) bands. The FRAMA is a dynamic moving average that adapts to changing market conditions, providing traders with a more precise representation of price movements. The CMO is an oscillator that measures momentum in the market, helping traders identify potential entry and exit points. The COG bands are a technical indicator used to identify potential support and resistance levels in the market. Custom functions are included in the script to calculate the FRAMA and CSM_CPMA indicators, with the FRAMA function calculating the value of the FRAMA indicator based on user-specified parameters of length and multiplier, while the CSM_CPMA function calculates the value of the CMO with COG bands indicator based on the user-specified parameters of length and various price types. The script also includes trailing profit and stop loss functions, which while not meeting expectations, have been backtested with a success rate of over 90%, making the script a valuable tool for traders. Overall, the script provides traders with a comprehensive technical analysis tool for analyzing cryptocurrency markets and making informed trading decisions. Traders can improve their success rate and overall profitability by using smaller targets with trailing profit and minimizing losses. Feedback is always welcome, and the script can be improved for future use. Special thanks go to Tradingview for providing inbuilt functions that are utilized in the script."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 chhagansinghmeena\n//@version=5\nstrategy(\"FRAMA & CPMA Strategy [CSM]\", shorttitle = \"CSM's => FRAMA + CPMA\", overlay\nimport chhagansinghmeena/BankNifty_CSM/3 as CM\nsrc = input.source(title = \"FRAMA Source\", defval = close, group = \"Requirements\")\nlength = input.int(title='FRAMA Length', defval=21, minval=1, maxval=200, group = \nfracDim = input.float(title='Fractal Dimension', defval=0.8, minval=0.1, maxval=2.0\nCPMA_length = input.int(title='CPMA Length', defval=21, minval=1, maxval=200, group\nenableEngulfingFilter = input.bool(title = \"Enable Engulfing Candle Filter\", defval\nlongTakeProfit = input.float(10, 'Long Take Profit Amount', minval=0.05, step=0.05\nshortTakeProfit = input.float(10, 'Short Take Profit Amount', minval=0.05, step=0.05\ntrailingTakeProfit = input.float(0.5, 'Trailing Take Profit Amount', minval=0.01, \nLossstratA = input.float(defval=100, minval=0, maxval=10000, title=\"Stop Loss\", step\nstart = input.time(title='Start Date', defval=timestamp('01 Jan 2023 03:30 +0000')\nfinish = input.time(title='End Date', defval=timestamp('1 Jan 2099 15:30 +0000'), \nwindow() =>\n    time >= start and time <= finish ? true : false\n// Get various price types\n[Open, price, High, Low , HL2, HLC3, HLCC4, OHLC4 ] = request.security(syminfo.tickerid\n//Get CPMA from Library\nCPMA = CM.CSM_CPMA(length = CPMA_length, price = price, HL2 = HL2, Open = Open , High\n//Get FRAMA from Library\nFRAMA = CM.frama_Calculation(src = src, length = length, mult = fracDim)\nplot(CPMA, color= color.orange, linewidth=2, title=\"CPMA\")\nplot(FRAMA, color= color.blue, linewidth=2, title=\"FRAMA\")\n// Detect bullish and bearish engulfing patterns\nbullishEngulfing = CM.candlepatternbullish()\nbearishEngulfing = CM.candlepatternbearish()\nlongCondition = (ta.cross(close, FRAMA) and close > FRAMA) or (ta.cross(close, CPMA\nshortCondition = (ta.cross(close, FRAMA) and close < FRAMA) or (ta.cross(close, CPMA\nSignal = 0\nif enableEngulfingFilter\n    longCondition := bullishEngulfing and (longCondition or ta.crossover(FRAMA, CPMA\n    shortCondition := bearishEngulfing and (shortCondition or ta.crossunder(FRAMA,\nelse \n    Signal := longCondition  ? 1 : shortCondition  ? -1 : nz(Signal[1])\n    isDifferentSignalType = ta.change(Signal)  \n    longCondition := longCondition and isDifferentSignalType\n    shortCondition := shortCondition and isDifferentSignalType\nlongTakeProfitPerc = longTakeProfit/close\nshortTakeProfitPerc = shortTakeProfit/close\ntrailingTakeProfitPerc =  trailingTakeProfit == 0.01 ? syminfo.mintick/close : trailingTakeProfit\nbool longIsActive = longCondition or strategy.position_size > 0\nbool shortIsActive = shortCondition or strategy.position_size < 0\nlongIsActive := longCondition or strategy.position_size > 0\nshortIsActive := shortCondition or strategy.position_size < 0\n//Long Stop Loss added\nfloat longStopLossprice = na\nlongStopLossprice := if longIsActive \n    if longCondition and not (strategy.opentrades.size(strategy.opentrades - 1) > \n        low - LossstratA\n    else\n        nz(longStopLossprice[1], low - LossstratA)\nelse\n    na\n //Long Take Profir Added\nfloat longTakeProfitPrice = na\nlongTakeProfitPrice := if longIsActive \n    if longCondition and not (strategy.position_size > 0)\n        close * (1 + longTakeProfitPerc)\n    else\n        nz(longTakeProfitPrice[1], high * (1 - longTakeProfitPerc))\nelse\n    na\n//Short StopLoss added\nfloat shortStopLossprice = na\nshortStopLossprice := if shortIsActive \n    if shortCondition and not (strategy.position_size < 0)\n        high + LossstratA\n    else\n        nz(shortStopLossprice[1], high + LossstratA)\nelse\n    na\n//Short Take profit added\nfloat shortTakeProfitPrice = na\nshortTakeProfitPrice := if shortIsActive \n    if shortCondition and not (strategy.position_size < 0)\n        close * (1 - shortTakeProfitPerc)\n    else\n        nz(shortTakeProfitPrice[1], close * (1 - shortTakeProfitPrice))\nelse\n    na\n float longTrailingTakeProfitStepTicks = longTakeProfitPrice * trailingTakeProfitPerc\nfloat shortTrailingTakeProfitStepTicks = shortTakeProfitPrice * trailingTakeProfitPerc\nif window()\n    switch\n        longCondition=> strategy.entry(\"Long\",strategy.long)\n        shortCondition=> strategy.entry(\"Short\", strategy.short)\n    strategy.exit(id = 'Long TP/SL', from_entry = 'Long', trail_price = longTakeProfitPrice\n    strategy.exit(id = 'Short TP/SL', from_entry = 'Short', trail_price = shortTakeProfitPrice"}]}
{"messages": [{"role": "user", "content": "The strategy is designed to trade on the Stochastic RSI indicator crossover signals. Below are all of the trading conditions:  -When the Stochastic RSI crosses above 30, a long position is entered. -When the Stochastic RSI crosses below 70, a short position is entered. -The strategy also includes two additional conditions for entry: -Long entries must have a positive spread value between the 9 period simple moving average and the 21 period simple moving average. -Short entries must have a negative spread value between the 9 period simple moving average and the 21 period simple moving average. -Long entries must also be below the volume-weighted average price. -Short entries must also be above the volume-weighted average price. -The strategy includes stop loss and take profit orders for risk management: -A stop loss of 20 ticks is placed for both long and short trades. -A take profit of 25 ticks is placed for both long and short trades."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thedoggwalker\n//@version=4\nstrategy(\"Stochastic RSI Strategy\", overlay=true)\n// Stochastic RSI\nlength = input(14, title=\"Length\")\nsrc = input(close, title=\"Source\")\nsmoothK = input(3, title=\"K\")\nsmoothD = input(3, title=\"D\")\nrsiValue = rsi(src, length)\nhighestRSI = highest(rsiValue, length)\nlowestRSI = lowest(rsiValue, length)\nk = (rsiValue - lowestRSI) / (highestRSI - lowestRSI) * 100\nd = sma(k, smoothD)\n// Moving averages\nmaShort = sma(close, 9)\nmaLong = sma(close, 21)\n// Spread between moving averages\nspread = maShort - maLong\n// VWAP\nvwapValue = vwap(hlc3)\n// Entry conditions\nlongCondition = crossover(k, 30) and spread > 0 and close < vwapValue\nshortCondition = crossunder(k, 70) and spread < 0 and close > vwapValue\n// Entry orders\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n// Exit orders\nlongStopLoss = close - 20 * syminfo.mintick\nlongTakeProfit = close + 25 * syminfo.mintick\nstrategy.exit(\"Exit Long\", \"Long\", stop=longStopLoss, limit=longTakeProfit)\nshortStopLoss = close + 20 * syminfo.mintick\nshortTakeProfit = close - 25 * syminfo.mintick\nstrategy.exit(\"Exit Short\", \"Short\", stop=shortStopLoss, limit=shortTakeProfit)"}]}
{"messages": [{"role": "user", "content": "This strategy is an adaptive price channel strategy based on the Average True Range (ATR) indicator and the Average Directional Index (ADX). It aims to identify sideways markets and trends in the price movements and make trades accordingly. The strategy uses a length parameter for the ATR and ADX indicators, which determines the length of the calculation for these indicators. The strategy also uses an ATR multiplier, which is multiplied by the ATR to determine the upper and lower bounds of the price channel. The first step of the strategy is to calculate the highest high (HH) and lowest low (LL) over the specified length. The ATR is also calculated over the same length. Then the strategy calculates the positive directional indicator (+DI) and negative directional indicator (-DI) based on the up and down moves in the price, and uses these to calculate the ADX. If the ADX is less than 25, the market is considered to be in a sideways phase. In this case, if the price closes above the upper bound of the price channel (HH - ATR multiplier * ATR), the strategy enters a long position, and if the price closes below the lower bound of the price channel (LL + ATR multiplier * ATR), the strategy enters a short position. If the ADX is greater than or equal to 25 and the +DI is greater than the -DI, the market is considered to be in a bullish phase. In this case, if the price closes above the upper bound of the price channel, the strategy enters a long position. If the ADX is greater than or equal to 25 and the +DI is less than the -DI, the market is considered to be in a bearish phase. In this case, if the price closes below the lower bound of the price channel, the strategy enters a short position. The strategy exits a position after a certain number of bars have passed since the entry, as specified by the exit_length input. In summary, this strategy attempts to trade in accordance with the prevailing market conditions by identifying sideways markets and trends and making trades based on price movements within a dynamically-adjusted price channel. This strategy takes a read on the market and either takes a channel strategy or trades volatility based on current trend. Works well on 2, 3 ,4, 12 hour for BTC.  It\u2019s my first attempt and creating a strategy.  I am very interested in constructive criticism.  I will look into better risk management, maybe a trailing stop loss. Other suggestions welcome.  This is my first attempt at a strategy. Here are the settings I used.  Inputs Length 20 Exit 10 ATR 3.2 Dates I picked when I got into Crypto Properties Capital 1000 Order size 2 Contracts Pyramiding 1 Commission .05"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Adaptive Price Channel Strategy\", overlay=true)\nlength = input(20, title=\"Length\")\nexit_length = input(10, title=\"Exit After X Periods\")\natr_multiplier = input(3.2, title=\"ATR Multiplier\")\nstartDate = input.time(defval = timestamp(\"2019-01-15T08:15:15+00:00\"), title = \"Start Date\"\nendDate = input.time(defval = timestamp(\"2023-04-01T08:15:00+00:00\"), title = \"End Date\"\nhh = ta.highest(high, length)\nll = ta.lowest(low, length)\natr = ta.atr(length)\n// calculate +DI and -DI\nupMove = high - high[1]\ndownMove = low[1] - low\nplusDM = na(upMove[1]) ? na : (upMove > downMove and upMove > 0 ? upMove : 0)\nminusDM = na(downMove[1]) ? na : (downMove > upMove and downMove > 0 ? downMove : 0\nplusDI = ta.rma(plusDM, length) / atr * 100\nminusDI = ta.rma(minusDM, length) / atr * 100\n// calculate ADX\ndx = math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100\nadx = ta.rma(dx, length)\nvar int barSinceEntry = na\nif (not na(close[length]) and time >= startDate and time <= endDate)\n    if (adx < 25) // Sideways market\n        if (close > hh - atr_multiplier * atr)\n            strategy.entry(\"PChLE\", strategy.long, comment=\"PChLE\")\n            barSinceEntry := 0\n        else if (close < ll + atr_multiplier * atr)\n            strategy.entry(\"PChSE\", strategy.short, comment=\"PChSE\")\n            barSinceEntry := 0\n    else if (adx >= 25 and plusDI > minusDI) // Bullish market\n        if (close > hh - atr_multiplier * atr)\n            strategy.entry(\"PChLE\", strategy.long, comment=\"PChLE\")\n            barSinceEntry := 0\n    else if (adx >= 25 and plusDI < minusDI) // Bearish market\n        if (close < ll + atr_multiplier * atr)\n            strategy.entry(\"PChSE\", strategy.short, comment=\"PChSE\")\n            barSinceEntry := 0\nif (na(barSinceEntry))\n    barSinceEntry := barSinceEntry[1] + 1\nelse if (barSinceEntry >= exit_length)\n    strategy.close(\"PChLE\")\n    strategy.close(\"PChSE\")\n    barSinceEntry := na\nplot(hh, title=\"Highest High\", color= color.green, linewidth=2)\nplot(ll, title=\"Lowest Low\", color= color.red, linewidth=2)"}]}
{"messages": [{"role": "user", "content": "Are you looking for a reliable and profitable algorithmic trading strategy for TradingView? If so, you might be interested in our Supertrend basic strategy, which is based on three powerful indicators: Supertrend (ATR), RSI and EMA. Supertrend is a trend-following indicator that helps you identify the direction and strength of the market. It also gives you clear signals for entry and exit points based on price movements. RSI is a momentum indicator that measures the speed and change of price movements. It helps you filter out false signals and avoid overbought or oversold conditions. EMA is a moving average indicator that smooths out price fluctuations and shows you the long-term trend of the market. It helps you confirm the validity of your trades and avoid trading against the trend. Our Supertrend basic strategy combines these three indicators to give you a simple yet effective way to trade any market. Here's how it works: - For long trades, you enter when the price is above Supertrend and pulls back below it (the low of the candle crosses Supertrend) and then rebounds above it (the high of the next candle goes above the pullback candle). You exit when the price closes below Supertrend or when you reach your target profit or stop loss. - For short trades, you enter when the price is below Supertrend and pulls back above it (the high of the candle crosses Supertrend) and then drops below it (the low of the next candle goes below the pullback candle). You exit when the price closes above Supertrend or when you reach your target profit or stop loss. - You can also use RSI and EMA filters to improve your results. For long trades, you only enter if RSI is above 50 and price is above 200 EMA. For short trades, you only enter if RSI is below 50 and price is below 200 EMA. - You can set your stop loss and target profit as a percentage of your entry price or based on other criteria. You can also adjust the parameters of each indicator according to your preferences and risk tolerance. Our Supertrend basic strategy is easy to use and has been tested on various markets and time frames. It can help you capture consistent profits while minimizing your losses."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 JS_TechTrading\n//@version=5\nstrategy(\"Supertrend\", overlay=true,default_qty_type =strategy.percent_of_equity,default_qty_value\n// group string////\nvar string group_text000=\"Choose Strategy\"\nvar string group_text0=\"Supertrend Settings\"\nvar string group_text0000=\"Ema Settings\"\nvar string group_text00=\"Rsi Settings\"\nvar string group_text1=\"Backtest Period\"\nvar string group_text2=\"Trade Direction\"\n// var string group_text3=\"Quantity Settings\"\nvar string group_text4=\"Sl/Tp Settings\"\n////////////////////\noption_ch=input.string('Pullback',title = \"Type Of Strategy\",options =['Pullback',\n//atr period input supertrend \natrPeriod = input(10, \"ATR Length\",group = group_text0)\nfactor = input.float(3.0, \"Factor\", step = 0.01,group=group_text0)\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color =  color.green,\ndownTrend = plot(direction < 0? na : supertrend, \"Down Trend\", color =  color.red\nfill(bodyMiddle, upTrend,  color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend,  color.new(color.red, 90), fillgaps=false)\nlong=direction < 0 ? supertrend : na\nshort=direction < 0? na : supertrend\nlongpos=false\nshortpos=false\nlongpos :=long?true :short?false:longpos[1]\nshortpos:=short?true:long?false:shortpos[1]\nfin_pullbuy= (ta.crossunder(low[1],long) and long and high>high[1])\nfin_pullsell=(ta.crossover(high[1],short) and short and low<low[1]) \n//Ema 1\non_ma=input.bool(true,\"Ema Condition On/Off\",group=group_text0000)\nma_len= input.int(200, minval=1, title=\"Ema Length\",group = group_text0000)\nma_src = input.source(close, title=\"Ema Source\",group = group_text0000)\nma_out = ta.ema(ma_src, ma_len)\nma_buy=on_ma?close>ma_out?true:false:true\nma_sell=on_ma?close<ma_out?true:false:true\n// rsi indicator and condition\n// Get user input\nen_rsi    = input.bool(true,\"Rsi Condition On/Off\",group = group_text00)\nrsiSource = input(title='RSI Source', defval=close,group = group_text00)\nrsiLength = input(title='RSI Length', defval=14,group = group_text00)\nrsiOverbought = input(title='RSI BUY Level', defval=50,group = group_text00)\nrsiOversold   = input(title='RSI SELL Level', defval=50,group = group_text00)\n// Get RSI value\nrsiValue = ta.rsi(rsiSource, rsiLength)\nrsi_buy=en_rsi?rsiValue>=rsiOverbought ?true:false:true\nrsi_sell=en_rsi?rsiValue<=rsiOversold?true:false:true\n// final condition\nbuy_cond=option_ch=='Simple'?long and not(longpos[1]) and rsi_buy and ma_buy:option_ch\nsell_cond=option_ch=='Simple'?short and not(shortpos[1]) and rsi_sell and ma_sell:\n//backtest engine\nstart = input.time(timestamp('2005-01-01'), title='Start calculations from',group=\nend=input.time(timestamp('2045-03-01'), title='End calculations',group=group_text1\ntime_cond = time >= start and time<=end\n// Make input option to configure trade direction\ntradeDirection = input.string(title='Trade Direction', options=['Long', 'Short', 'Both'\n// Translate input into trading conditions\nlongOK  = (tradeDirection == \"Long\") or (tradeDirection == \"Both\")\nshortOK = (tradeDirection == \"Short\") or (tradeDirection == \"Both\")\n// strategy start\nif buy_cond and longOK and time_cond and strategy.position_size==0\n    strategy.entry('long',direction = strategy.long)\nif sell_cond and shortOK and time_cond and strategy.position_size==0\n    strategy.entry('short',direction =strategy.short)\n// fixed percentage based stop loss and take profit \n// User Options to Change Inputs (%)\nstopPer = input.float(1.0,step=0.10, title='Stop Loss %',group =group_text4) / 100\ntakePer = input.float(1.0,step =0.10, title='Take Profit %',group =group_text4) / \n// Determine where you've entered and in what direction\nlongStop  = strategy.position_avg_price * (1 - stopPer)\nshortStop = strategy.position_avg_price * (1 + stopPer)\nshortTake = strategy.position_avg_price * (1 - takePer)\nlongTake  = strategy.position_avg_price * (1 + takePer)\nif strategy.position_size > 0\n    strategy.exit(id='Close Long',stop=longStop, limit=longTake)\nif strategy.position_size < 0\n    strategy.exit(id='Close Short',stop=shortStop, limit=shortTake)\n//PLOT FIXED SLTP LINE\nplot(strategy.position_size > 0 ? longStop : na, style=plot.style_linebr, color= \nplot(strategy.position_size < 0 ? shortStop :na, style=plot.style_linebr, color= \nplot(strategy.position_size > 0 ? longTake : na, style=plot.style_linebr, color= \nplot(strategy.position_size < 0 ? shortTake : na, style=plot.style_linebr, color= \n//"}]}
{"messages": [{"role": "user", "content": "In this strategy, we define the high and low of the previous candle, and then check whether the current candle's high or low is higher or lower than the previous candle's high or low, respectively. If there's a new high, we enter a long position, and if there's a new low, we enter a short position. We also set exit conditions to close the position if the price drops below the previous low or rises above the previous high. Please note that this is a simple example and should not be used as a standalone trading strategy. It is important to conduct thorough backtesting and consider other factors such as risk management before implementing any trading strategy."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Price Action Trading Strategy\")\n// Define the high and low of the previous candle\nprevHigh = high[1]\nprevLow = low[1]\n// Check if the current candle's high is higher than the previous candle's high\nnewHigh = high > prevHigh\n// Check if the current candle's low is lower than the previous candle's low\nnewLow = low < prevLow\n// Enter long if there's a new high\nif newHigh\n    strategy.entry(\"Long\", strategy.long)\n// Enter short if there's a new low\nif newLow\n    strategy.entry(\"Short\", strategy.short)\n    // Exit long if the price drops below the previous low\nif low < prevLow and strategy.position_size > 0\n    strategy.close(\"Long\")\n    // Exit short if the price rises above the previous high\nif high > prevHigh and strategy.position_size < 0\n    strategy.close(\"Short\")"}]}
{"messages": [{"role": "user", "content": "This Pine Script code is a trading strategy that uses several indicators such as Fisher Transform (FTR), On-Balance Volume (OBV), Relative Strength Index (RSI), and a Weighted Moving Average (WMA). The strategy generates buy and sell signals based on the conditions of these indicators. The Fisher Transform function is a technical indicator that uses past prices to determine whether the current market is bullish or bearish. The Fisher Transform function takes in four multipliers and a length parameter. The four multipliers are used to calculate four Fisher Transform values, and these values are used in combination to determine if the market is bullish or bearish. The Weighted Moving Average (WMA) is a technical indicator that smooths out the price data by giving more weight to the most recent prices. The Relative Strength Index (RSI) is a momentum indicator that measures the strength of a security's price action. The RSI ranges from 0 to 100 and is typically used to identify overbought or oversold conditions in the market. The On-Balance Volume (OBV) is a technical indicator that uses volume to predict changes in the stock price. OBV values are calculated by adding volume on up days and subtracting volume on down days. The strategy uses the Fisher Transform values to generate buy and sell signals when all four Fisher Transform values change color. It also uses the WMA to determine if the trend is bullish or bearish, the OBV to confirm the trend, and the RSI to filter out false signals. The red and green triangular arrows attempt to indicate that the trend is bullish or bearish and should not be traded against in the opposite direction. This helps with my FOMO :)  All comments welcome! The script should not be relied upon alone, there are no stop loss or take profit filters. The best results have been back-tested using Tradingview on the 45m - 3 hour timeframes."}, {"role": "assistant", "content": "//@version=5\n//author Sdover0123\nstrategy(title='FTR, WMA, OBV & RSI Strat', shorttitle='FTR WMA, OBV, RSI',overlay\nLen = input.int(10, minval=1, group =\"Fisher Transform\")\nmult1 = input.int(1, minval=1, group =\"Fisher Transform\")\nmult2 = input.int(2, minval=1, group =\"Fisher Transform\")\nmult3 = input.int(4, minval=1, group =\"Fisher Transform\")\nmult4 = input.int(8, minval=1, group =\"Fisher Transform\")\nfish(Length, timeMultiplier) =>\n    var nValue1 = 0.0\n    var nValue2 = 0.0\n    var nFish = 0.0\n    xHL2 = hl2\n    xMaxH = ta.highest(xHL2, Length * timeMultiplier)\n    xMinL = ta.lowest(xHL2, Length * timeMultiplier)\n    nValue1 := 0.33 * 2 * ((xHL2 - xMinL) / (xMaxH - xMinL) - 0.5) + 0.67 * nz(nValue1\n    if nValue1 > .99\n        nValue2 := .999\n        nValue2\n    else if nValue1 < -.99\n        nValue2 := -.999\n        nValue2\n    else\n        nValue2 := nValue1\n        nValue2\n    nFish := 0.5 * math.log((1 + nValue2) / (1 - nValue2)) + 0.5 * nz(nFish[1])\n    nFish\nFisher1 = fish(Len, mult1)\nFisher2 = fish(Len, mult2)\nFisher4 = fish(Len, mult3)\nFisher8 = fish(Len, mult4)\nrsiLength = input.int(14, minval=1, group =\"Moving Averages\")\nrsiVal = (ta.rsi(close, rsiLength) - 50) / 10\navg = strategy.position_avg_price\nwma(source, length) =>\n    sum = 0.0\n    for i = 0 to length - 1\n        sum := sum + source[i] * (length - i)\n    wma = sum / (length * (length + 1) / 2)\n    wma\nwmaLength = input.int(10, \"WMA Length\", minval=1, group =\"Moving Averages\")\nwmaClose = wma(close, wmaLength)\n// Determine if WMA is bullish or bearish\nisWmaBullish = wmaClose > wmaClose[1]\nisWmaBearish = wmaClose < wmaClose[1]\n//OBV \nsrc = close\nlength = input.int(20, title=\"OBV Length\", group=\"On-Balance Volume\")\nobv1(src) =>\n    change_1 = ta.change(src)\n    ta.cum(ta.change(src) > 0 ? volume : change_1 < 0 ? -volume : 0 * volume)*0.01\nos = obv1(src)\nobv_osc = os - ta.ema(os, length)\nobc_color = (obv_osc > 0 ?  color.rgb(0, 255, 8) :  color.rgb(255, 0, 0))\nplot(obv_osc, color=obc_color, style=plot.style_line, title='OBV-Points', linewidth\nplot(obv_osc, color= color.new(#b2b5be, 70), title='OBV', style=plot.style_area)\nobvBullFilter = input.float(0.1, minval = 0, maxval = 5, step = 0.01, title =\"OBV Bullish minimum value\"\nobvBearFilter = input.float(-0.1, minval = -5, maxval = 0, step = 0.01, title =\"OBV Bearish minimum value\"\nobvBull = obv_osc > obvBullFilter\nobvBear = obv_osc < obvBearFilter\n// Add buy/sell signals\nReversalFilterDown = input.float(-0.7, 'Reversal Down TP Filter', -4, 4, step = 0.01\nReversalFilterUp = input.float(0.7, 'Reversal Up TP Filter', -4, 4, step = 0.01, group\nRSILevelBuyFilter = input.float(1.66, 'RSI Level Buy Filter', -4, 4, step = 0.01, \nRSILevelSellFilter = input.float(1, 'RSI Level Sell Filter', -4, 4, step = 0.01, group\n//buys - if breaking out and all Fisher are green and RSI filter value is met \nbuySignal = Fisher1 > Fisher1[1] and Fisher2 > Fisher2[1] and Fisher4 > Fisher4[1]\nReversalUp = Fisher1 > Fisher1[1] and Fisher2 > Fisher2[1] and Fisher4 > Fisher4[1\n//sells - if breaking down and all Fisher are green and RSI filter value is met \nsellSignal = Fisher1 < Fisher1[1] and Fisher2 < Fisher2[1] and Fisher4 < Fisher4[1\nReversalDown = Fisher1 < Fisher1[1] and Fisher2 < Fisher2[1] and Fisher4 < Fisher4\n// Buy and Sell conditions\nif buySignal and time>timestamp(2022, 06, 01, 09, 30) and barstate.isconfirmed\n    strategy.close(\"Sell\", comment = \"Close Short\")\n    strategy.entry(\"Buy\", strategy.long, comment = \"Long\")\nif sellSignal and time>timestamp(2022, 06, 01, 09, 30) and barstate.isconfirmed\n    strategy.close(\"Buy\", comment = \"Close Long\")\n    strategy.entry(\"Sell\", strategy.short, comment = \"Short\")\nif ReversalDown\n    strategy.close(\"Buy\", comment = \"Close Long\")\nif ReversalUp\n    strategy.close(\"Sell\", comment = \"Close Short\")\n//Plotting\n//Fisher\nplot(Fisher1, color=Fisher1 > nz(Fisher1[1]) ?  color.green :  color.rgb(255, 0,\nplot(Fisher2, color=Fisher2 > nz(Fisher2[1]) ?  color.green :  color.rgb(255, 0,\nplot(Fisher4, color=Fisher4 > nz(Fisher4[1]) ?  #008000 :  #b60000, title='Fisher TF:1'\nplot(Fisher8, color=Fisher8 > nz(Fisher8[1]) ?  #004f00 :  #b60000, title='Fisher TF:1'\n//RSI\nplot(rsiVal, color=rsiVal < 0 ?  color.purple :  color.yellow, linewidth=2, title\n//WMA\nplot(isWmaBullish ? -2 : na, color= color.rgb(76, 175, 79, 20), linewidth=3, style\nplot(isWmaBearish ? -2 : na, color= color.rgb(255, 82, 82, 20), linewidth=3, style\n//Buy/Sell Signals\nplotshape(buySignal, title='Buy Signal', location=location.bottom, color= color.new\nplotshape(sellSignal, title='Sell Signal', location=location.top, color= color.new\n//Orientation\nhline(RSILevelBuyFilter, color= color.rgb(25, 36, 99, 20), linestyle=hline.style_dotted\nhline(RSILevelSellFilter, color= color.rgb(111, 27, 27, 20), linestyle=hline.style_dotted\nhline(0, color= color.rgb(181, 166, 144, 39), linestyle=hline.style_dashed, linewidth\nhline(1.5, color= color.rgb(217, 219, 220, 50), linestyle=hline.style_dotted, linewidth\nhline(-1.5, color= color.rgb(217, 219, 220, 50), linestyle=hline.style_dotted, linewidth"}]}
{"messages": [{"role": "user", "content": "The \"Volatility Range Breakout Strategy\" uses deviations of high-low volatility to determine bullish and bearish breakouts. HOW IT WORKS  The volatility function uses the high-low range of a lookback period, divided by the average of that range, to determine the likelihood that price will break in a specific direction.  High and low ranges are determined by the relative volatility compared to the current closing price. The high range, for example, is the (volatility * close) added to the close, the low range is this value subtracted by the close.  A volatility-weighted moving average is taken of these high and low ranges to form high and low bands.  Finally, breakouts are identified once the price closes above or below these bands. An upwards breakout (bullish) occurs when the price breaks above the upper band, while a downwards breakout (bearish) occurs when the price breaks below the lower band. Positions can be closed either by when the price falls out of its current band (\"Range Crossover\" in settings under 'Exit Type') or when the price falls below or above the volatility MA (default because this allows us to catch trends for longer).  INPUTS/SETTINGS The AVERAGE LENGTH is the period for the volatility MA and the weighted volatility bands. The VOLATILITY LENGTH is how far the lookback should be for highs/lows for the volatility calculation. Enjoy! Let me know if you have any questions."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 wbburgin\n//@version=5\nstrategy(\"Volatility Range Breakout Strategy [wbburgin]\", shorttitle = \"VRB Strategy [wbburgin]\"\n pyramiding=20,max_bars_back=2000,initial_capital=10000)\nwma(float priceType,int length,float weight) =>\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to length - 1\n        norm := norm + weight\n        sum := sum + priceType[i] * weight\n    sum / norm\n// This definition of volatility uses the high-low range divided by the average of that range.\nvolatility(source,length) =>\n    h = ta.highest(source,length)\n    l = ta.lowest(source,length)\n    vx = 2 * (h - l) / (h + l)\n    vx\nvm1 = input.int(100,\"Average Length\")\nvolLen = input.int(100,\"Volatility Length\")\nvsrc = input.source(close,\"Volatility Source\")\ncross_type = input.source(close,\"Exit Source\")\nexit_type = input.string(\"Volatility MA\",options=[\"Volatility MA\",\"Range Crossover\"\nvolatility = volatility(vsrc,volLen)\nhighband1 = close + (close * volatility)\nlowband1 = close - (close * volatility)\nhb1 = wma(highband1,vm1,volatility)\nlb1 = wma(lowband1,vm1,volatility)\nhlavg = math.avg(hb1,lb1)\nupcross = ta.crossover(high,hb1)    //Crossing over the high band of historical volati\ndncross = ta.crossunder(low,lb1)    //Crossing under the low band of historical volati\nvlong = upcross\nvshort = dncross\nvlong_exit = switch\n    exit_type == \"Volatility MA\" => ta.crossunder(cross_type,hlavg)\n    exit_type == \"Range Crossover\" => ta.crossunder(cross_type,hb1)\nvshort_exit = switch\n    exit_type == \"Volatility MA\" => ta.crossover(cross_type,hlavg)\n    exit_type == \"Range Crossover\" => ta.crossover(cross_type,lb1)\nif vlong\n    strategy.entry(\"Long\",strategy.long)\nif vlong_exit\n    strategy.close(\"Long\")\nif vshort\n    strategy.entry(\"Short\",strategy.short)\nif vshort_exit\n    strategy.close(\"Short\")\nplot(hlavg,color= color.white,title=\"Weighted Volatility Moving Average\")\nt = plot(hb1,color= color.new(color.red,50),title=\"Volatility Reversal Band - Top\"\nb = plot(lb1,color= color.new(color.green,50),title=\"Volatility Reversal Band - Bottom\"\nalertcondition(vlong,\"Volatility Long Entry Signal\")\nalertcondition(vlong_exit,\"Volatility Long Exit Signal\")\nalertcondition(vshort,\"Volatility Short Entry Signal\")\nalertcondition(vshort_exit,\"Volatility Short Exit Signal\")\nfill(t,b,color= color.new(color.aqua,90))"}]}
{"messages": [{"role": "user", "content": "Yesterday\u2019s High Breakout it is a trading system based on the analysis of yesterday's highs, it works in trend-following mode therefore it opens a long position at the breakout of yesterday's highs even if they occur several times in one day. There are several methods for exiting a trade, each with its own unique strategy. The first method involves setting Take-Profit and Stop-Loss percentages, while the second utilizes a trailing-stop with a specified offset value. The third method calls for a conditional exit when the candle closes below a reference EMA.  Additionally, operational filters can be applied based on the volatility of the currency pair, such as calculating the percentage change from the opening or incorporating a gap to the previous day's high levels. These filters help to anticipate or delay entry into the market, mitigating the risk of false breakouts.  In the specific case of NULS, a 9% Take-Profit and a 3% Stop-Loss were set, with an activated trailing-stop percentage. To postpone entry and avoid false breakouts, a 1% gap was added to the price of yesterday's highs. Name: Yesterday's High Breakout - Trend Follower Strategy  Author: @tumiza999 Category: Trend Follower, Breakout of Yesterday's High.  Operating mode: Spot or Futures (only long).  Trade duration: Intraday.  Timeframe: 30M, 1H, 2H, 4H Market: Crypto Suggested usage: Short-term trading, when the market is in trend and it is showing high volatility.  Entry: When there is a breakout of Yesterday's High.  Exit: Profit target or Trailing stop, Stop loss or Crossunder EMA.  Configuration:  - Gap to anticipate or postpone the entry before or after the identified level  - Rate of Change for Entry Condition - Take Profit, Stop Loss and Trailing Stop  - EMA length  Backtesting: \u2043 Exchange: BINANCE \u2043 Pair: NULSUSDT \u2043 Timeframe: 2H \u2043 Fee: 0.075% \u2043 Slippage: 1 - Initial Capital: 10000 USDT - Position sizing: 10% of Equity - Start : 2018-07-26 (Out Of Sample from 2022-12-23) - Bar magnifier: on Credits: LucF for Pine Coders (f_security function to avoid repainting using security) Disclaimer: Risk Management is crucial, so adjust stop loss to your comfort level. A tight stop loss can help minimise potential losses. Use at your own risk. How you or we can improve? Source code is open so share your ideas! Leave a comment and smash the boost button! Thanks for your attention, happy to support the TradingView community."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Creative Commons Attribution-NonCommercial-ShareA\n// \u00a9 TheSocialCryptoClub\n//@version=5\nstrategy(\"Yesterday's High\", overlay=true, pyramiding = 1,\n         initial_capital=10000, \n         default_qty_type=strategy.percent_of_equity, default_qty_value=10,\n         slippage=1, backtest_fill_limits_assumption=1, use_bar_magnifier=true,\n         commission_type=strategy.commission.percent, commission_value=0.075\n         )\n// -----------------------------------------------------------------------------\n// ROC Filter\n// -----------------------------------------------------------------------------\n// f_security function by LucF for PineCoders available here: https://www.tradingview.com/script/cyPWY96u-How-to\nf_security(_sym, _res, _src, _rep) => request.security(_sym, _res, _src[not _rep and\nhigh_daily = f_security(syminfo.tickerid, \"D\", high, false)\nroc_enable = input.bool(false, \"\", group=\"ROC Filter from CloseD\", inline=\"roc\")\nroc_threshold = input.float(1, \"Treshold\", step=0.5, group=\"ROC Filter from CloseD\"\nclosed = f_security(syminfo.tickerid,\"1D\",close, false)\nroc_filter= roc_enable ? (close-closed)/closed*100  > roc_threshold  : true\n// -----------------------------------------------------------------------------\n// Trigger Point \n// -----------------------------------------------------------------------------\nopen_session = ta.change(time('D'))\nprice_session = ta.valuewhen(open_session, open, 0)\ntf_session = timeframe.multiplier <= 60\nbgcolor(open_session and tf_session ? color.new(color.blue,80):na, title = \"Session\"\nfirst_bar = 0\nif open_session\n    first_bar := bar_index\nvar max_today = 0.0\nvar min_today = 0.0\nvar high_daily1 = 0.0\nvar low_daily1 = 0.0\nvar today_open = 0.0\nif first_bar\n    high_daily1 := max_today\n    low_daily1 := min_today\n    today_open := open\n    max_today := high\n    min_today := low\nif high >= max_today\n    max_today := high\nif low < min_today\n    min_today := low\nsame_day  = today_open == today_open[1]\nplot( timeframe.multiplier <= 240 and same_day ? high_daily1 : na, color=  color.yellow\nplot( timeframe.multiplier <= 240 and same_day ? low_daily1 : na, color=  #E8000D\n// -----------------------------------------------------------------------------\n// Strategy settings \n// -----------------------------------------------------------------------------\nGap = input.float(1,\"Gap%\", step=0.5, tooltip=\"Gap di entrata su entry_price -n anticipa entrata\nGap2 = (high_daily1 * Gap)/100\nsl  = input.float(3, \"Stop-loss\", step= 0.5,  group = \"Entry\")\ntp  = input.float(9, \"Take-profit\", step= 0.5, group = \"Entry\")\nstop_loss_price = strategy.position_avg_price * (1-sl/100)\ntake_price = strategy.position_avg_price * (1+tp/100)\nsl_trl = input.float(2, \"Trailing-stop\", step = 0.5, tooltip = \"Attiva trailing stop dopo che ha raggiunto...\"\nAtrl= input.float(1, \"Offset Trailing\", step=0.5,tooltip = \"Distanza dal prezzo\", \nstop_trl_price_cond = sl_trl * high/syminfo.mintick/100\nstop_trl_price_offset_cond = Atrl * high/syminfo.mintick/100\nstop_tick = sl * high/syminfo.mintick/100\nprofit_tick = tp * high/syminfo.mintick/100\nmess_buy = \"buy\"\nmess_sell = \"sell\"\n// -----------------------------------------------------------------------------\n// Entry - Exit - Close\n// -----------------------------------------------------------------------------\nif close < high_daily1 and roc_filter\n    strategy.entry(\"Entry\", strategy.long, stop = high_daily1 + (Gap2), alert_message\nts_n  = input.bool(true, \"Trailing-stop\", tooltip = \"Attiva o disattiva trailing-stop\"\nclose_ema = input.bool(false, \"Close EMA\", tooltip = \"Attiva o disattiva chiusura su EMA\"\nlen1 = input.int(10, \"EMA length\", step=1, group = \"Trailing Stop Settings\")\nma1 = ta.ema(close, len1)\nplot(ma1, title='EMA', color= color.new(color.yellow, 0))\nif ts_n == true\n    strategy.exit(\"Trailing-Stop\",\"Entry\",loss= stop_tick, stop= stop_loss_price, \nelse\n    strategy.exit(\"TP-SL\", \"Entry\",loss= stop_tick, stop=stop_loss_price, limit= take_price\nif close_ema == true and ta.crossunder(close,ma1)\n    strategy.close(\"Entry\",comment = \"Close\" , alert_message = mess_sell)"}]}
{"messages": [{"role": "user", "content": "The purpose of this script is to spot 4 hour pivots that indicate ~30 trading day swings. As VIX starts to drop options trading will get more boring and as we get back on the bull and can benefit from swing trading strategy. Swing trading doesn't make a whole lot of sense when VIX is above 28. Seems to get best results on 4 hour chart for this one. This indicator spots a go long opportunity when the 5 ema crosses the 13 ema on the 4 hour along with the RSI > 50 and the ADX > 20 and Stoichastic values (smoothed line < 80 or line < 90) and close > last candle close and the True Range < 6. It also spots uses a couple different means to determine when to exit the trade. Sell condition is primarily when the 13 ema crosses the 5 ema and the MACD line crosses below the signal line and the smoothed Stoichastic appears oversold (greater than 60) and slop of RSI < -.2. Stop Losses and Take Profits are configurable in Inputs along with ability to include short trades plus other MACD and Stoichastic settings. If a stop loss is encountered the trade will close. Also once twice the expected move is encountered partial profits will taken and stop losses and take profits will be re-established based on most recent close. Also a VIX above 28 will trigger any open positions to close. If trying to use this for something other than SPXL it is best to update stop losses and take profit percentages and check backtest results to ensure proper levels have been selected and the script gives satisfactory results."}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"SPY 4 Hour Swing Trader\", initial_capital=800000, default_qty_type\n//The purpose of this script is to spot 4 hour pivots that indicate ~30 trading day swings.\n//As VIX starts to drop options trading will get more boring and as we get back on the bull and can \n//swing trading strategy. Swing trading doesn't make a whole lot of sense when VIX is above 28\n//Seems to get best results on 4 hour chart for this one.\n//This indicator spots a go long opportunity when the 5 ema crosses the 13 ema on the 4 hour along w\n//the ADX > 20 and Stoichastic values (smoothed line < 80 or line < 90) and close > last candle clos\n// the True Range < 6. It also spots uses a couple different means to determine when to exit the tra\n//Sell condition is primarily when the 13 ema crosses the 5 ema and the MACD line crosses below the \n//line and the smoothed Stoichastic appears oversold (greater than 60) and slop of RSI < -.2.\n//Stop Losses and Take Profits are configurable in Inputs along with ability to include short trades\n//other MACD and Stoichastic settings. If a stop loss is encountered the trade will close.\n//Also once twice the expected move is encountered partial profits will taken and stop losses and ta\n//will be re-established based on most recent close. Also a VIX above 28 will trigger any open posit\n//If trying to use this for something other than SPXL it is best to update stop losses and take prof\n//percentages and check backtest results to ensure proper levels have been selected and the script g\n// Initialize variables\nvar float long_entry_price = na\nvar float stop_loss = na\nvar float take_profit = na\nvar float twoxtake_profit = na\n// Inputs\noption_SL_P = input.float(0.10, \"Input Stop Loss Percentage (0.1 = 10%)\")\noption_TP_P = input.float(0.10, \"Input Take Profit Percentage (0.1 = 10%)\")\npp = input.int(75, \"Partial Profit Percentage in whole numbers (75 is 75%)\")\nema5 = input.int(5, \"Fast EMA Period\", minval=1)\nema13 = input.int(13, \"Slow EMA Period\", minval=1)\nrsi_length = input.int(14, \"RSI Length\", minval=1)\nmacd_fast_length = input.int(12, \"MACD Fast Length\", minval=1)\nmacd_slow_length = input.int(26, \"MACD Slow Length\", minval=1)\nmacd_signal_length = input.int(9, \"MACD Signal Length\", minval=1)\nlen = input.int(14, title=\"ADX Length\", minval=1)\nlength = input.int(14, \"Stochastic Length\")\nsmoothK = input.int(3, \"Stoicastic Smooth K\")\nsrc = input(close, \"Stoicastic Source\")\n// Calculating EMA \nema_13 = ta.ema(close, ema13)\nema_5 = ta.ema(close, ema5)\n// Calculate RSI\nrsi = ta.rsi(close, rsi_length)\nsmooth_rsi = ta.ema(rsi, 5)\n// Calculate MACD\n[macd_line, signal_line, _] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length\n// Calculate the True Range\ntr = ta.tr(true)\n// Calculate slope of MACD line\nrsiSlope = (smooth_rsi - smooth_rsi[3]) / (bar_index - bar_index[3])\n// Calculate the Directional Movement\nup = ta.change(high)\ndown = -ta.change(low)\nplusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\nminusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n// Calculate the Smoothed Directional Movement\nplusDI = 100 * ta.ema(plusDM, len) / ta.ema(tr, len)\nminusDI = 100 * ta.ema(minusDM, len) / ta.ema(tr, len)\n// Calculate the Directional Index (DX)\nDX = 100 * math.abs(plusDI - minusDI) / (plusDI + minusDI)\n// Calculate the ADX\nadx = ta.ema(DX, len)\n//Stochastic Calculation\nhighestHigh = ta.highest(src, length)\nlowestLow = ta.lowest(src, length)\nk = 100 * ((src - lowestLow) / (highestHigh - lowestLow))\nd = ta.sma(k, smoothK)\n// Determine current VIX\nvixClose = request.security(\"VIX\", timeframe.period, close[3])\n//plot(vixClose, title=\"VIX Close\", color=color.red)\n// Buy and Sell Conditions\nbuy_condition = ta.crossover(ema_5 , ema_13) and rsi > 50 and adx > 20 and (d < 80\nsell_condition = ema_13 > ema_5 and macd_line < signal_line and rsiSlope < -.2 and\n// Plotting indicators\nplot(ema_13, color= color.orange, title=\"Slow EMA Period\")\nplot(ema_5, color= color.blue, title=\"Fast EMA Period\")\n// Executing trades\nif buy_condition and strategy.position_size == 0 and barstate.isconfirmed\n    strategy.entry(\"Pivot Up\", strategy.long, alert_message = \"Pivoting Up\")\n    long_entry_price := close\n    stop_loss := long_entry_price - (option_SL_P * close)\n    take_profit := long_entry_price + (option_TP_P * close)\n    twoxtake_profit := long_entry_price + (2 * option_TP_P * close)\nif vixClose > 28 and strategy.position_size > 0 and barstate.isconfirmed\n    if close < long_entry_price and close < close[1] and barstate.isconfirmed\n        strategy.close(\"Pivot Up\", \"Exit Longs High VIX\")\n    else\n        stop_loss := long_entry_price\nif strategy.position_size > 0 and barstate.isconfirmed\n    if close < stop_loss and barstate.isconfirmed\n        strategy.close(\"Pivot Up\", \"Exit Longs Stopped\")\n    else if sell_condition and barstate.isconfirmed\n        strategy.close(\"Pivot Up\", \"Exit Longs Sell Condition Met\")\n    else if close >= twoxtake_profit and (close < close[2]) and barstate.isconfirmed\n        stop_loss := close - (.5*option_TP_P*close)\n        take_profit := close + (.5*option_TP_P*close)\n        strategy.exit(\"Exit Partial Longs\", \"Pivot Up\", stop=stop_loss, limit = take_profit"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added ADX Slope to hold on to trending trades longer before taking partial profits Tweaked Stochastic from 60 to 70 in order to initiate sell later (waiting for more of an overbought condition)                                                    Release Notes:                                                    Added alert messages to strategies so when alerts appear they can be more descriptive and show message indicating what action to take. Add the following code to your alert: {{ticker}} @ {{time}} {{strategy.order.action}} {{strategy.order.alert_message}}"}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"SPY 1 Hour Swing Trader\", initial_capital=300000, default_qty_type\n//The purpose of this script is to spot 1 hour pivots that indicate ~5 to 6 trading day swings.\n//Results indicate that swings are held approximately 5 to 6 trading days on average, over the last \n//This indicator spots a go long opportunity when the 5 ema crosses the 13 ema on the 1 hour along w\n//It also spots uses a couple different means to determine when to exit the trade. Sell condition is\n//primarily when the 13 ema crosses the 5 ema and the MACD line crosses below the signal line and\n//the smoothed Stochastic appears oversold (greater than 70). Stop Losses and Take Profits are confi\n//in Inputs along with ability to include short trades plus other MACD and Stochastic settings.\n//If a stop loss is encountered the trade will close. Also once twice the expected move is encounter\n//partial profits will taken and stop losses and take profits will be re-established based on most r\n//Once long trades are exited, short trades will be initiated if recent conditions appeared oversold\n//input option for short trading is enabled. If trying to use this for something other than SPXL it \n//to update stop losses and take profit percentages and check backtest results to ensure proper leve\n//been selected and the script gives satisfactory results.\n// Initialize variables\nvar float long_entry_price = na\nvar float short_entry_price = na\nvar float stop_loss = na\nvar float take_profit = na\nvar float twoxtake_profit = na\nvar float short_stop_loss = na\nvar float short_take_profit = na\nvar float short_twoxtake_profit = na\nvar int startshort = 0\n// Inputs\nshort = input.bool(true, \"Include Short Trades!\")\noption_SL_P = input.float(0.02, \"Input Stop Loss Percentage (0.02 = 2%)\")\noption_TP_P = input.float(0.03, \"Input Take Profit Percentage (0.03 = 3%)\")\npp = input.int(50, \"Partial Profit Percentage in whole numbers (50 is 50%)\")\nema5 = input.int(5, \"Fast EMA Period\", minval=1)\nema13 = input.int(13, \"Slow EMA Period\", minval=1)\nrsi_length = input.int(14, \"RSI Length\", minval=1)\nmacd_fast_length = input.int(8, \"MACD Fast Length\", minval=1)\nmacd_slow_length = input.int(21, \"MACD Slow Length\", minval=1)\nmacd_signal_length = input.int(5, \"MACD Signal Length\", minval=1)\nlen = input.int(14, title=\"ADX Length\", minval=1)\nlength = input.int(14, \"Stochastic Length\")\nsmoothK = input.int(3, \"Stoicastic Smooth K\")\nsrc = input(close, \"Stoicastic Source\")\n// Calculating EMA \nema_13 = ta.ema(close, ema13)\nema_5 = ta.ema(close, ema5)\n// Calculate RSI\nrsi = ta.rsi(close, rsi_length)\nsmooth_rsi = ta.ema(rsi, 5)\n// Calculate MACD\n[macd_line, signal_line, _] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length\n// Calculate the True Range\ntr = ta.tr(true)\n// Calculate slope of MACD line\nrsiSlope = (smooth_rsi - smooth_rsi[3]) / (bar_index - bar_index[3])\n// Calculate the Directional Movement\nup = ta.change(high)\ndown = -ta.change(low)\nplusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\nminusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n// Calculate the Smoothed Directional Movement\nplusDI = 100 * ta.ema(plusDM, len) / ta.ema(tr, len)\nminusDI = 100 * ta.ema(minusDM, len) / ta.ema(tr, len)\n// Calculate the Directional Index (DX)\nDX = 100 * math.abs(plusDI - minusDI) / (plusDI + minusDI)\n// Calculate the ADX\nadx = ta.ema(DX, len)\n// Calculate slope of ADX line\nADXSlope = (adx - adx[3]) / (bar_index - bar_index[3])\n//Stochastic Calculation\nhighestHigh = ta.highest(src, length)\nlowestLow = ta.lowest(src, length)\nk = 100 * ((src - lowestLow) / (highestHigh - lowestLow))\nd = ta.sma(k, smoothK)\n// Determine current VIX\nvixClose = request.security(\"VIX\", timeframe.period, close[3])\n//plot(vixClose, title=\"VIX Close\", color=color.red)\n// Buy and Sell Conditions\nbuy_condition = ta.crossover(ema_5 , ema_13) and rsi > 50\nsell_condition = ema_13 > ema_5 and macd_line < signal_line and (d >70)\n// Plotting indicators\nplot(ema_13, color= color.orange, title=\"Slow EMA Period\")\nplot(ema_5, color= color.blue, title=\"Fast EMA Period\")\n// Executing trades\nif buy_condition and strategy.position_size == 0 and barstate.isconfirmed\n    strategy.entry(\"Pivot Up\", strategy.long, alert_message = \"Pivoting Up\")\n    long_entry_price := close\n    stop_loss := long_entry_price - (option_SL_P * close)\n    take_profit := long_entry_price + (option_TP_P * close)\n    twoxtake_profit := long_entry_price + (2 * option_TP_P * close)\nif strategy.position_size > 0 and barstate.isconfirmed\n    if close < stop_loss and barstate.isconfirmed\n        strategy.close(\"Pivot Up\", \"Exit Longs Stopped\", alert_message = \"Exit Longs Stopped\"\n        if short == 1 \n            startshort := 1\n    else if sell_condition and barstate.isconfirmed\n        if short == 1\n            startshort := 1\n        strategy.close(\"Pivot Up\", \"Exit Longs Sell Condition Met\", alert_message \n    else if close >= twoxtake_profit and ADXSlope < 0 and barstate.isconfirmed\n        stop_loss := close - (.5*option_TP_P*close)\n        take_profit := close + (.5*option_TP_P*close)\n        strategy.exit(\"Exit Partial Longs\", \"Pivot Up\", stop=stop_loss, limit = take_profit\nif startshort == 1\n    if (d[6] > 80) and barstate.isconfirmed\n        strategy.entry(\"Pivot Down\", strategy.short, alert_message = \"Pivoting Down\"\n        short_entry_price := close\n        short_stop_loss := short_entry_price + (option_SL_P * close)\n        short_take_profit := short_entry_price - (option_TP_P * close)\n        short_twoxtake_profit := short_entry_price - (2 * option_TP_P * close)\n        startshort := 0\n    else\n        startshort := 0\nif strategy.position_size < 0 and barstate.isconfirmed\n    if close > short_stop_loss and barstate.isconfirmed\n        strategy.close(\"Pivot Down\", \"Exit Shorts Stopped\" , alert_message = \"Exit Shorts Stopped\"\n    else if close <= short_twoxtake_profit and ADXSlope < 0 and barstate.isconfirmed\n        short_stop_loss := close + (.5*option_TP_P*close)\n        short_take_profit := close - (.5*option_TP_P*close)\n        strategy.exit(\"Exit Partial Shorts\", \"Pivot Down\", stop=short_stop_loss, limit"}]}
{"messages": [{"role": "user", "content": "OVERVIEW: This Risk Reward Calculator strategy can help you maximize your RR value with help of algorithmic trading. INDICATOR: I wanted to setup my trades more easier with this indicator, I didn't want to calculate everytime before orders, with help this indicator we can calculate R:R value, avarage price, stoploss price,  take-profit price, order prices, all position cost and more ... Our strategy is a risk revard calculation indicator that is made easy to use by using visualized lines and panels, and also has algorithmic trading  support. With the help of this indicator, we can quickly and easily calculate our risk reward values and enter the positions. If we want to ensure that our balance grows regularly while trading in the stock market, we need to manage the risks and rewards otherwise we may fall below our initial balance at the end of the day, even if we seem to be winning. What is the Risk-Reward value ? This value is a value that shows how many times the amount of risk we take when entering the position is successful, we will earn.   - For example, you risked $100 while entering the trade, so if your trade stops, you will lose 100 $. Your Risk-Reward(RR) value is 2 means that if your position is successful, you will have 200 $ in your pocket. A trader's success is determined by the amount of R he earns monthly or yearly, not how much money he makes.  What is different in this indicator ? I want to say thank you to \u00a9 EvoCrypto. His Calculator (weighted) \u2013 evo indicator helped me when I was developed my indicator.  I want to explain what I have improved: 1-In this strategy, we can determine the time period in which we want to open our positions. 2-We can open a maximum of 4 positions in the same direction and close our positions at a single level. StopLoss or TakeProfit 3-This indicator, which works in the form of a strategy, shows where our positions have been opened or closed. With the help of this, it helps us to determine our strategy in our future positions more accurately. 4-The most important improvement is that we do not miss our positions with the help of alarms (WEB HOOK). if we want, we receive by quickly connecting all these positions to our robot, the software can enter and exit the position while we are busy. IMPLEMENTATION DETAILS \u2013 SETTINGS: 1 - We can set the start and end dates of the positions we will take. 2- We can set our take profit, stoploss levels. 3- If your trade is stopped, we can determine the amount of the trade that we will lose. 4- We can adjust our entry levels to positions and our position sizes at entry levels. (Sum of positions weight must be 100%) 5- We can receive our positions even if we are busy with the help of algorithmic trading. For this, we must paste our Jshon codes into the fields specified in the settings panel. 6- Finally, we can change the settings we want and don't want to have in our visual elements.  Let's make a LONG side example together We have determined our positions to enter stoploss, take profit and long positions. We did not forget to set the start time of our strategy Our strategy appear on the graph as follows. Our strategy has calculated the total position size, our R-R value, the distance of the current price to the stop and take profit levels, in short, a lot of things we could look visually. Notes: If you're going to connect this bot to an automatic Long or Short direction,  Don\u2019t forget!  you need to Webhook URL,  Don\u2019t miss paste this code to your message window  {{strategy.order.alert_message}} ALSO: If you have any ideas what to add to my work to add more sources or make calculations cooler, feel free to write me."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Baby_whale_to_moon\n// I want to say thank you to \u00a9 EvoCrypto\n//@version=5\nstrategy('Risk Reward Calculator', shorttitle='R:R', overlay=true, max_bars_back =\n//INPUTS -----------------------------------------------------------------------\nstartDate  = input.time(defval=timestamp('1 apr 2023 13:30 +0000'), title='Start_Date'\nendDate = input.time(defval=timestamp('20 oct  2030 13:30 +0000'), title='End_Date'\ninDateRange  = time > startDate  and time < endDate\ntake_profit_level = input.float(0, step=0.1, minval=0, title='Take Profit Price', \nStop_Level = input.float(0, minval=0, step=0.1, title='Stop Loss Price', group = \" ######### \u26a0\ufe0f  STRATEGY RISK SETTINGS \nRisk_Amount = input.float(100, minval=0, step=0.1, title='Risk Amount In Dollar', \nAlert = input.bool(true,title = \"Sum of transactions weight must be 100%\", group =\nPrice_1_val = input.float(0, step=0.1, minval=0, title='Entry Price One', group = \nWeight_1 = input.string('NaN', ' \u2696\ufe0f Weight', options=['NaN', '90 %', '80 %', '\u2022 75 %'\nPrice_2_val = input.float(0, step=0.1, minval=0, title='Entry Price Two', group = \nWeight_2 = input.string('NaN', ' \u2696\ufe0f Weight', options=['NaN', '90 %', '80 %', '\u2022 75 %'\nPrice_3_val = input.float(0, step=0.1, minval=0, title='Entry Price Three', group \nWeight_3 = input.string('NaN', ' \u2696\ufe0f Weight', options=['NaN', '90 %', '80 %', '\u2022 75 %'\nPrice_4_val = input.float(0, step=0.1, minval=0, title='Entry Price Four', group =\nWeight_4 = input.string('NaN', ' \u2696\ufe0f Weight', options=['NaN', '90 %', '80 %', '\u2022 75 %'\nAlert_message_miss = input.bool(true,title = \"DON'T FORGET PASTE YOUR WEBHOOK URL WHEN YOU SET \nLong_message = input(\"\",title = \"Long Entry Code\", group = \"############ \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 \nLong_Exit_message = input(\"\",title = \"Long Stop-Take Profit Code\", group = \"############ \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 \nShort_message = input(\"\",title = \"Short Entry Code\", group = \"############ \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 \nShort_Exit_message = input(\"\",title = \"Short Stop-Take Profit Code\", group = \"############ \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 \nAlert_message = input(\"{{strategy.order.alert_message}}\",title = \"Code When Set Alert\"\nshow_label = input.bool(title='  Show Labels',defval=true, group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \nVisual = input.string('All Timeframes', 'Calculator Visual', options=['All Timeframes'\nLabel_Size = input.string(size.small, 'Label Size', options=[size.tiny, size.small\nShow_Real_Distance = input(true, title='Real-Time Distance In Label', group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \nShow_Stop_Distance = input(true, title='Stop Loss Distance In Label', group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \nShow_Order_Amount = input(true, title='Dollar Order Amount In Label', group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \nShow_Price = input(true, title='Show Price Inputs In Label', group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \nUse_One_Label = input(false, title='Show All Text In One Label', group = \" ############ \ud83c\udfc1  LABEL SETTINGS  \ud83c\udfc1 \n//bgcolor(show_label and inDateRange ? color.rgb(175, 246, 255, 90) : na , title = \"STRATEGY WORK TI\n//TIMEFRAME --------------------------------------------------------------------\nTimeframe = timeframe.isintraday and Visual == 'Intraday Only' or timeframe.isdwm \n//QUALIFIERS -------------------------------------------------------------------\ntake_profit_level_True = Timeframe ? take_profit_level != 0 : na\nStop_True = Timeframe ? Stop_Level != 0 : na\nPrice_1_val_True = Timeframe ? Price_1_val != 0 : na\nPrice_2_val_True = Timeframe ? Price_1_val != 0 and Price_2_val != 0 : na\nPrice_3_val_True = Timeframe ? Price_1_val != 0 and Price_2_val != 0 and Price_3_val\nPrice_4_val_True = Timeframe ? Price_1_val != 0 and Price_2_val != 0 and Price_3_val\nAvg_Price_True = Timeframe ? Price_2_val_True or Price_3_val_True : na\nquantity(dolar) =>\n    if close > 5000 \n        math.round(dolar / close, 3)\n    else if close < 5000 and close > 200\n        math.round(dolar / close, 2)\n    else if close < 200 and close > 50\n        math.round(dolar / close, 1)\n    else if close < 50\n        math.round(dolar / close, 0)\n//PRICE 1 ----------------------------------------------------------------------\nWeight_One_Options = Weight_1 == 'NaN' ? 1 : Weight_1 == '90 %' ? 0.90 : Weight_1 \nWeight_One = Price_1_val * Weight_One_Options\nReal_Price_1_val_Distance = Price_1_val_True and close > Price_1_val ? (close - Price_1_val\n//PRICE 2 ----------------------------------------------------------------------\nWeight_Two_Options = Weight_2 == 'NaN' ? 1 : Weight_2 == '90 %' ? 0.90 : Weight_2 \nWeight_Two = Price_2_val * Weight_Two_Options\nReal_Price_2_val_Distance = Price_2_val_True and close > Price_2_val ? (close - Price_2_val\n//PRICE 3 ----------------------------------------------------------------------\nWeight_Three_Options = Weight_3 == 'NaN' ? 1 : Weight_3 == '90 %' ? 0.90 : Weight_3\nWeight_Three = Price_3_val * Weight_Three_Options\nReal_Price_3_val_Distance = Price_3_val_True and close > Price_3_val ? (close - Price_3_val\n//PRICE 4 ----------------------------------------------------------------------\nWeight_Four_Options = Weight_4 == 'NaN' ? 1 : Weight_4 == '90 %' ? 0.90 : Weight_4\nWeight_Four = Price_4_val * Weight_Four_Options\nReal_Price_4_val_Distance = Price_4_val_True and close > Price_4_val ? (close - Price_4_val\n//AVERAGE PRICE ----------------------------------------------------------------\nAvg_2_True = Weight_1 == 'NaN' and Weight_2 == 'NaN'\nAvg_3_True = Weight_1 == 'NaN' and Weight_2 == 'NaN' and Weight_3 == 'NaN'\nAvg_4_True = Weight_1 == 'NaN' and Weight_2 == 'NaN' and Weight_3 == 'NaN' and Weight_4\nAvg_Price = Price_2_val_True and Avg_2_True and Price_3_val == 0 and Price_4_val ==\nReal_Avg_Price_Distance = Avg_Price_True and close > Avg_Price ? (close - Avg_Price\n//POSITION SETTINGS ------------------------------------------------------------\nReal_Stop_Distance = Stop_True and close > Stop_Level ? (close - Stop_Level) / close\nStop_Distance = Avg_Price != 0 and Stop_True and Avg_Price > Stop_Level ? (Avg_Price\nReal_TP_Distance = take_profit_level_True and close > take_profit_level ? (close -\nTP_Distance = Avg_Price != 0 and take_profit_level_True and Avg_Price > take_profit_level\nPosition_Size = Risk_Amount / Stop_Distance * 100\nOrder_One = Weight_1 != 'NaN' ? Position_Size * Weight_One_Options : Weight_1 == 'NaN'\nOrder_Two = Weight_2 != 'NaN' ? Position_Size * Weight_Two_Options : Weight_2 == 'NaN'\nOrder_Three = Weight_3 != 'NaN' ? Position_Size * Weight_Three_Options : Weight_3 \nOrder_Four = Weight_4 != 'NaN' ? Position_Size * Weight_Four_Options : Weight_4 ==\n//LABEL LOCATIONS --------------------------------------------------------------\nStop_Location = timenow + math.round(ta.change(time) * (Price_3_val_True ? 115 : Price_2_val_True\nPrice_1_val_Location = timenow + math.round(ta.change(time) * 15 )\nPrice_2_val_Location = timenow + math.round(ta.change(time) * 35)\nPrice_3_val_Location = timenow + math.round(ta.change(time) * 55)\nPrice_4_val_Location = timenow + math.round(ta.change(time) * 75)\nAvg_Price_Location = timenow + math.round(ta.change(time) * (Price_3_val_True ? 115\nOne_Label_Location = timenow + math.round(ta.change(time) * 50)\ntake_profit_level_Location = timenow + math.round(ta.change(time) * (Price_3_val_True\n//COLORS -----------------------------------------------------------------------\nStop_Color =  #b71c1c\nPrice_Color =  #0011ff\nLabel_Color =  #2db3fb\nText_Color =  #000000\n//Take Profit PLOT ---------------------------------------------------------------\nTake_Profit_Line = take_profit_level_True ? line.new(x1=startDate, y1=take_profit_level\nline.delete(Take_Profit_Line[1])\nplot(take_profit_level_True ? take_profit_level : na, title='Take Profit', color= \nTake_Profit_Label = Use_One_Label ? na : Avg_Price != 0 and take_profit_level_True\nlabel.delete(Take_Profit_Label[1])\n//STOP LOSS PLOT ---------------------------------------------------------------\nStop_Line = Stop_True ? line.new(x1=startDate, y1=Stop_Level, x2=endDate, y2=Stop_Level\nline.delete(Stop_Line[1])\nplot(Stop_True ? Stop_Level : na, title='Stop Loss', color=color.new(Stop_Color, 100\nStop_Label = Use_One_Label ? na : Avg_Price != 0 and Stop_True and Avg_Price > Stop_Level\nlabel.delete(Stop_Label[1])\n//PRICE 1 PLOT -----------------------------------------------------------------\nPrice_1_val_Line = Price_1_val_True ? line.new(x1=startDate, y1=Price_1_val, x2=endDate\nline.delete(Price_1_val_Line[1])\nplot(Price_1_val_True ? Price_1_val : na, title='Price One', color=color.new(Price_Color\nPrice_1_val_Label = Use_One_Label ? na : Price_1_val_True and close > Price_1_val \nlabel.delete(Price_1_val_Label[1])\n//PRICE 2 PLOT -----------------------------------------------------------------\nPrice_2_val_Line = Price_2_val_True ? line.new(x1=startDate, y1=Price_2_val, x2=endDate\nline.delete(Price_2_val_Line[1])\nplot(Price_2_val_True ? Price_2_val : na, title='Price Two', color=color.new(Price_Color\nPrice_2_val_Label = Use_One_Label ? na : Price_2_val_True and close > Price_2_val \nlabel.delete(Price_2_val_Label[1])\n//PRICE 3 PLOT -----------------------------------------------------------------\nPrice_3_val_Line = Price_3_val_True ? line.new(x1=startDate, y1=Price_3_val, x2=endDate\nline.delete(Price_3_val_Line[1])\nplot(Price_3_val_True ? Price_3_val : na, title='Price Three', color=color.new(Price_Color\nPrice_3_val_Label = Use_One_Label ? na : Price_3_val_True and close > Price_3_val \nlabel.delete(Price_3_val_Label[1])\n//PRICE 4 PLOT -----------------------------------------------------------------\nPrice_4_val_Line = Price_4_val_True ? line.new(x1=startDate, y1=Price_4_val, x2=endDate\nline.delete(Price_4_val_Line[1])\nplot(Price_4_val_True ? Price_4_val : na, title='Price Four', color=color.new(Price_Color\nPrice_4_val_Label = Use_One_Label ? na : Price_4_val_True and close > Price_4_val \nlabel.delete(Price_4_val_Label[1])\n//AVERAGE PRICE PLOT -----------------------------------------------------------\nAvg_Price_Line = Avg_Price_True ? line.new(x1=startDate, y1=Avg_Price, x2=endDate,\nline.delete(Avg_Price_Line[1])\nplot(Avg_Price_True ? Avg_Price : na, title='Average Price', color= color.new(color.yellow\nAvg_Price_Label = Use_One_Label ? na : Avg_Price_True and close > Avg_Price and show_label\nlabel.delete(Avg_Price_Label[1])\n//ONE LABEL --------------------------------------------------------------------\nOne_Label = Use_One_Label and Avg_Price != 0 and Stop_True and Avg_Price > Stop_Level\nlabel.delete(One_Label[1])\n// Strategy entries LONG\nif strategy.opentrades == 0 and inDateRange  and Avg_Price < take_profit_level  and\n    strategy.entry('Long_Open', strategy.long, qty= quantity(Order_One), limit = Price_1_val\nif strategy.opentrades == 1 and inDateRange and Avg_Price < take_profit_level and \n    strategy.entry('Long_Open', strategy.long, qty= quantity(Order_Two), limit = Price_2_val\nif strategy.opentrades == 2 and inDateRange and Avg_Price < take_profit_level and \n    strategy.entry('Long_Open', strategy.long, qty= quantity(Order_Three), limit =\nif strategy.opentrades == 3 and inDateRange and Avg_Price < take_profit_level and \n    strategy.entry('Long_Open', strategy.long, qty= quantity(Order_Four), limit = \n// Strategy entries SHORT\nif strategy.opentrades == 0 and inDateRange  and Avg_Price > take_profit_level  and\n    strategy.entry('Short_Open', strategy.short, qty= quantity(Order_One), limit =\nif strategy.opentrades == 1 and inDateRange and Avg_Price > take_profit_level and \n    strategy.entry('Short_Open', strategy.short, qty= quantity(Order_Two), limit =\nif strategy.opentrades == 2 and inDateRange and Avg_Price > take_profit_level and \n    strategy.entry('Short_Open', strategy.short, qty= quantity(Order_Three), limit\nif strategy.opentrades == 3 and inDateRange and Avg_Price > take_profit_level and \n    strategy.entry('Short_Open', strategy.short, qty= quantity(Order_Four), limit \nif strategy.opentrades > 0 and inDateRange and strategy.position_size > 0 \n    strategy.exit('Long__Close',from_entry = \"Long_Open\", stop=Stop_Level, limit =\nif strategy.opentrades > 0 and inDateRange and strategy.position_size < 0 \n    strategy.exit('Short__Close',from_entry = \"Short_Open\", stop=Stop_Level, limit"}]}
{"messages": [{"role": "user", "content": "Release Notes:                        Compact code Fix qty bug                             Release Notes:                                                    fix close condition bug                                                    Release Notes:                                                    update comment                                                    Release Notes:                                                    Optimization of dynamic-stop calculation method; Simplify the getQty calculation method; Add qty_precision settings;"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Tindtily\n//@version=5\nstrategy(\"Dynamic Stop Loss Demo\",overlay = true,initial_capital = 20000,max_bars_back\n// rsi settings\nlength = input( 14, group=\"rsi settings\" )\noverSold = input( 30, group=\"rsi settings\")\noverBought = input( 70, group=\"rsi settings\" )\n// strategy settings\nrr = input.float(1.5,'Profit and loss ratio',step = 0.1, group = 'strategy settings'\natr_times = input.float(2,'ATR times', step = 0.1, group = 'strategy settings')\nback_test_length = input.int(14, 'Back test length', group = 'strategy settings')\nfirst_tp_qty = input.int(50, 'First take profit qty percent', group = 'strategy settings'\nqty_precision = input.int(2, \"qty precision\", group = \"strategy settings\")\nhighest = ta.highest(high, back_test_length)\nlowest = ta.lowest(low, back_test_length)\nlimit = close\nvrsi = ta.rsi(limit, length)\nco = ta.crossover(vrsi, overSold)\ncu = ta.crossunder(vrsi, overBought)\nlong_cond = co\nshort_cond = cu\nhasFitFirstProfit = false\ncurSize = strategy.position_size\ncurId = strategy.position_entry_name\nisShorting = curSize < 0\nisLonging = curSize > 0\nisOpening = isShorting or isLonging\n// enums\nLONG = \"long\"\nSHORT = \"short\"\ngetStrategyInfoFromId(id)=>\n    info = str.split(id, \"_\")\n    openPrice = float(na)\n    profitPrice = float(na)\n    stopPrice = float(na)\n    entrySize = float(na)\n    if array.size(info) != 0 \n        openPrice := str.tonumber(array.get(info, 1))\n        profitPrice := str.tonumber(array.get(info, 3))\n        stopPrice := str.tonumber(array.get(info, 2))\n        entrySize := str.tonumber(array.get(info, 4))\n    [openPrice, profitPrice, stopPrice, entrySize]\ngetBasicProfit(openPrice, stopPrice) =>\n    openPrice + (openPrice - stopPrice) * rr\ngetStrategyId(prefix, openPrice, stopPrice, profitPrice, size) =>\n    prefix + \"_\" + str.tostring(openPrice) + \"_\" + str.tostring(stopPrice) + \"_\" +\nstartStrategy(direction, openPrice, stopPrice, qty, entryComment) =>\n    prefix = direction\n    profitPrice = getBasicProfit(openPrice, stopPrice)\n    id = getStrategyId(prefix, openPrice, stopPrice, profitPrice, qty * (direction\n    strategy.entry(id, direction == LONG ? strategy.long : strategy.short, comment\ntoOdd(num)=>\n    2 * math.round(num / 2)\ngetQty(limit) =>\n    avaC = strategy.grossprofit - strategy.grossloss + strategy.initial_capital\n    qtyNum = math.round(avaC / limit, qty_precision)\n    qtyTimes = math.pow(10, qty_precision)\n    math.round(toOdd( qtyNum * qtyTimes) / qtyTimes, qty_precision)\ndecimal(number, precision) =>\n    numStr = str.tostring(math.round(number, precision + 1))\n    str.tonumber(str.substring(numStr, 0, str.length(numStr) - 1))\nlongQty = decimal(getQty(limit) , 2)\nshortQty = decimal(getQty(limit) , 2)\ncalculateDynimacStop()=>\n    ATR = atr_times * ta.atr(back_test_length)\n    dynamicLongStop = float(na)\n    dynamicShortStop = float(na)\n    if (close > open)\n        dynamicLongStop := low - ATR\n        if (isLonging)\n            dynamicLongStop := math.max(dynamicLongStop, dynamicLongStop[1])\n    else\n        dynamicLongStop := dynamicLongStop[1]\n    if (close < open)\n        dynamicShortStop := high + ATR\n        if (isShorting)\n            dynamicShortStop := math.min(dynamicShortStop, dynamicShortStop[1])\n    else \n        dynamicShortStop := dynamicShortStop[1]\n    [dynamicLongStop, dynamicShortStop]\n[dynamicLongStop, dynamicShortStop] = calculateDynimacStop()\n[curOpenPrice, curProfitPrice, curStopPrice, curEntrySize] = getStrategyInfoFromId\nhasFitFirstProfit := math.abs(curEntrySize) > math.abs(curSize)\nif isLonging == false and isShorting == false \n    if long_cond and bar_index > back_test_length\n        long_stop = lowest\n        long_profit = getBasicProfit(limit, long_stop)\n        startStrategy(LONG, limit, long_stop, longQty, \"entry long\")\n    if short_cond and bar_index > back_test_length\n        short_stop = highest\n        short_profit = getBasicProfit(limit, short_stop)\n        startStrategy(SHORT, limit, short_stop, longQty, \"entry short\")\nelse\n    if isLonging\n        if hasFitFirstProfit \n            if low < dynamicLongStop \n                strategy.close(curId, comment='stop long dynamic')\n            else if close < curStopPrice\n                strategy.close(curId, comment='stop long at stop')\n            else if low < curOpenPrice\n                strategy.close(curId, comment='stop long at open')\n            else if short_cond\n                short_stop = highest\n                short_profit = getBasicProfit(limit, short_stop)\n                startStrategy(SHORT, limit, short_stop, shortQty, \"entry short\")\n        else \n            if close < curStopPrice\n                strategy.close(curId, comment = 'stop long')\n            if high > curProfitPrice\n                strategy.close(curId, comment = \"take long \" + str.tostring(first_tp_qty\n    if isShorting\n        if hasFitFirstProfit \n            if high > dynamicShortStop\n                strategy.close(curId, comment='stop short dynamic')\n            else if close > curStopPrice\n                strategy.close(curId, comment='stop short at stop')\n            else if high > curOpenPrice\n                strategy.close(curId, comment='stop short at open')\n            else if long_cond\n                long_stop = lowest\n                long_profit = getBasicProfit(limit, long_stop)\n                startStrategy(LONG, limit, long_stop, longQty, \"entry long\")\n        else\n            if close > curStopPrice\n                strategy.close(curId, comment = 'stop short')\n            if low < curProfitPrice \n                strategy.close(curId, comment = \"take short \" + str.tostring(first_tp_qty\n               // plots  \nlstop = isLonging ? curStopPrice : na\nsStop = isShorting ? curStopPrice: na\nlprofit = isLonging ? curProfitPrice :na \nsProfit = isShorting ? curProfitPrice : na \nlopen = isLonging ? curOpenPrice : na\nsopen = isShorting ? curOpenPrice : na \nsDStop = dynamicShortStop\nlDStop = dynamicLongStop\nplot(isOpening?lstop:na, title=\"long stop color\" ,color= color.red,style = plot.style_linebr\nplot(isOpening?lprofit:na,title=\"long profit color\",color= color.green,style = plot.style_linebr\nplot(isOpening?lopen : na,title=\"long open color\", color =  color.silver, style =\nplot(isLonging and hasFitFirstProfit? lDStop: na,title=\"long dynamic stop color\", \nplot(isOpening?sStop:na,title=\"short stop color\" ,color= color.red,style = plot.style_linebr\nplot(isOpening?sProfit:na,title=\"short profit color\" ,color= color.green,style = \nplot(isOpening?sopen : na,title=\"short open color\" , color =  color.silver, style\nplot(isShorting and hasFitFirstProfit? sDStop:na,title=\"short dynamic stop color\""}]}
{"messages": [{"role": "user", "content": "This strategy checks MACDcrossover and RSI crossover. When MACD crosses up or down the signal line, it checks if RSI is crossing back OverSold or OverBought lines, respectively, over the past few candles. The period can be changed by the parameter \"RSI lookback\".  The strategy seems to work better for reversal\u2014still a work in progress."}, {"role": "assistant", "content": "//@version=5\n//based on Range Strat - MACD/RSI \nstrategy(\"MACD/RSI - edited\", \n     overlay=true,\n     default_qty_type=strategy.percent_of_equity,\n     default_qty_value=10, precision=2, initial_capital=100000,\n     pyramiding=2,\n     commission_value=0.05)\n//Backtest date range\nStartDate = input.time(timestamp(\"13 Jun 2022\"), title=\"Start Date\")\nEndDate = input.time(timestamp(\"13 Jun 2024\"), title=\"Start Date\")\ninDateRange = (time >= StartDate) and (time < EndDate)\n// RSI Input Settings\nrsisrc = input(title=\"RSI Source\", defval=close, group=\"RSI Settings\")\nlength = input(title=\"Length\", defval=14, group=\"RSI Settings\" )\noverSold = input(title=\"Over Sold Threshold\", defval=30, group=\"RSI Settings\" )\noverBought = input(title=\"Over Bought Threshold\", defval=70, group=\"RSI Settings\" )\nrsi_lookback = input(title=\"RSI cross lookback period\", defval=7, group=\"RSI Settings\"\n// Calculating RSI\nvrsi = ta.rsi(rsisrc, length)\nco = ta.crossover(vrsi, overSold)\ncu = ta.crossunder(vrsi, overBought)\n// Function looking for a happened condition during lookback period\nf_somethingHappened(_cond, _lookback) =>\n    bool _crossed = false\n    for i = 1 to _lookback\n        if _cond[i]\n            _crossed := true\n    _crossed\ncoCheck = f_somethingHappened(co, rsi_lookback)\ncuCheck = f_somethingHappened(cu, rsi_lookback)\n// MACD Input Settings\nmacdsrc = input(title=\"MACD Source\", defval=close, group=\"MACD Settings\")\nfast_length = input(title=\"Fast Length\", defval=12, group=\"MACD Settings\")\nslow_length = input(title=\"Slow Length\", defval=26, group=\"MACD Settings\")\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nsma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\"SMA\"\nsma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\n// Calculating MACD\nfast_ma = sma_source == \"SMA\" ? ta.sma(macdsrc, fast_length) : ta.ema(macdsrc, fast_length\nslow_ma = sma_source == \"SMA\" ? ta.sma(macdsrc, slow_length) : ta.ema(macdsrc, slow_length\nmacd = fast_ma - slow_ma\nsignal = sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\ndelta = macd - signal\nMACDcrossover = ta.crossover(delta, 0)\nMACDcrossunder = ta.crossunder(delta, 0)\n// Stop Loss Input Settings\nlongLossPerc = input(title=\"Long Stop Loss (%)\", defval=15, group=\"Stop Loss Settings\"\nshortLossPerc = input(title=\"Short Stop Loss (%)\", defval=15, group=\"Stop Loss Settings\"\n// Calculating Stop Loss\nlongStopPrice  = strategy.position_avg_price * (1 - longLossPerc)\nshortStopPrice = strategy.position_avg_price * (1 + shortLossPerc)\n// Strategy Entry\nif (not na(vrsi))\n    if (inDateRange and MACDcrossover and coCheck)\n        strategy.entry(\"LONG\", strategy.long, comment=\"LONG\")\n    if (inDateRange and MACDcrossunder and cuCheck)\n        strategy.entry(\"SHORT\", strategy.short, comment=\"SHORT\")\n// Submit exit orders based on calculated stop loss price\nif (strategy.position_size > 0)\n    strategy.exit(id=\"LONG STOP\", stop=longStopPrice)\nif (strategy.position_size < 0)\n    strategy.exit(id=\"SHORT STOP\", stop=shortStopPrice)"}]}
{"messages": [{"role": "user", "content": "This script was an exercise in learning Pinescript and exploring the futures curve of the VIX in relation to SPY. Was deleted by TV, trying to republish it now with updated parameters for slippage and commission and a more detailed description. \"VIX Futures Spread Strategy\" is a trading strategy that capitalizes on the spread between the 3-month VIX futures (VIX3M) and the spot VIX index. This strategy is based on the idea that the VIX futures spread can serve as a contrarian indicator of market sentiment, with extreme negative spreads potentially signaling oversold conditions and opportunities for long positions. Ordinarily the VIX curve is in contango as futures contracts are priced at a premium to the current spot price and are used to hedge future uncertainty in the market. When the spot price of VIX spikes the curve can invert and enter backwardation; this strategy detects this condition and uses it as a trigger to open a long position in SPY. The spread going negative tends to correlate with excessive fear and uncertainty in the short term while expecting lower volatility in the long term, in this case 3 months out. The strategy is designed to enter a long position when the VIX futures spread is negative and to exit the position when the spread rises above 3 -- when the curve is in contango again. The strategy employs a pyramiding approach, allowing up to 10 additional orders to be placed while the entry condition is met, with each order consisting of 10 contracts. This approach aims to maximize potential profits during periods of favorable market conditions. In this strategy, the VIX futures spread is calculated as the difference between the 3-month VIX futures (VIX3M) and the spot VIX index. The spread is plotted as a histogram on the chart, with the zero line representing no spread, and horizontal lines at 0 and 3 indicating the entry and exit thresholds, respectively. The strategy's backtesting settings use an initial capital of \t\t\t10\t\t,000, a commission of 0.5% per trade, and a maximum of 10 pyramiding orders, and a slippage of 2 ticks. Please note that this strategy is intended for educational purposes and should not be considered as financial advice. Before using this strategy in live trading, make sure to thoroughly test and optimize its parameters to suit your risk tolerance and specific trading conditions."}, {"role": "assistant", "content": "//@version=4\nstrategy(\"VIX Futures Spread Strategy\", overlay=false, pyramiding=10, initial_capital\nspr = security(\"CBOE:VIX3M\", \"W\", hl2) - security(\"TVC:VIX\", \"W\", hl2)\nplot(spr, title=\"VIX 3M - VIX\", color= color.gray, style=plot.style_columns, linewidth\nh2 = hline(0, color= color.green)\nh3 = hline(3, color= color.red)\n// This strategy buys when the VIX futures spread is negative\n// It sells when the VIX futures spread is above 3, but only sells to close a position\nvixSpread = spr\n// Entry rules\nlongCondition = (vixSpread < 0) and (year > 2018) and (barstate.isconfirmed)\nif longCondition\n    strategy.entry(\"Long\", strategy.long, qty=10)\n// Exit rules\nshortCondition = (vixSpread > 3) and strategy.position_size > 0\nif shortCondition\n    strategy.close(\"Long\")"}]}
{"messages": [{"role": "user", "content": "Hello traders. Thanks to the tool I have published, everyone who knows or does not know coding will be able to create strategies and see the results instantly on the screen. Yes it looks very nice :) What does this script do? Thanks to this tool, even if you don't know any coding, you will be able to create your own strategies. You can add and remove indicators. Entrance The first thing you need to do is to set a strategy in your mind. Then you need to adjust the settings of the indicators installed in the system. Please set the indicators first, because later they are forgotten. The screen for entering the parameters of the indicators will be as follows. After entering the parameters there is an important part. In this section, we can adjust the strategy settings. First we choose between which dates we want the strategy to run. We then choose whether we want the strategy results to be displayed in a table or not. We choose how the Terms should be linked together. For example, if you have a condition that is expected to produce more than one receive signal, select whether these conditions are connected to each other with and or with the connector. In this way, you can determine whether all or any of the rules in your strategy should apply. Next, we choose whether our strategy will work in the spot market or in a bidirectional market. Yes, you can design a strategy for both spot and bidirectional trades :)  At the bottom of the above image, we see a screen where we can adjust the stop level and tp level. As a standard, adjustments are made according to the percentage level you enter. However, if you remove the tick next to the percent sign, the previous stop level and the next profit level are determined as much as the value you entered. At the bottom is the trailing stop. When you open the trailing stop, the trailing stop becomes active in your strategy. Very important, when the trailing stop and the stop are active at the same time, the trailing stop value is valid.  \t\tIt's time to design our strategy. Each chapter that begins with an exclamation point is a separate fiction. If you do not mark the Active button, that condition will not be included in the calculation. Direction = It is the direction for which the fiction in this region is valid. We came to the indicator setting screen. Here, there is a screen where we can select two different indicators on the right and left. We choose the first indicator starting with 1. Then we choose from the middle region how we want these two indicators to interact. We choose our second indicator from the place starting with 2. If you want an indicator to interact with any value, tick the box where it says Value and fill in the value in the blank. When Value is ticked, the second indicator does not work."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 only_fibonacci\n//@version=5\nstrategy(\"Strategy Designer\", overlay=true)\n// FUNCTIONS\noperatorReturn(i1,selected,i2)=>\n    switch selected\n        \">\" => i1 > i2\n        \"<\" => i1 < i2\n        \">=\" => i1 >= i2\n        \"<=\" => i1 <= i2\n        \"=\" => i1 == i2\n        \"!=\" => i1 != i2\n        \"CROSS ABOVE\" => ta.crossover(i1, i2)\n        \"CROSS BELOW\" => ta.crossunder(i1,i2)\nmaTypeToMa(maType,maPeriod,src)=>\n    switch maType\n        \"EMA\" => ta.ema(src, maPeriod)\n        \"SMA\" => ta.sma(src, maPeriod)\n        \"RMA\" => ta.rma(src, maPeriod)\n        => ta.wma(src, maPeriod)\n// Indicators\n// ATR\natrLen      = input.int(defval = 14,minval = 1, title = \"ATR Length\", group = \"ATR\"\natr         = ta.atr(atrLen) // ATR\n// BB\nbbMiddle    = input.source(defval = close, title = \"BB Middle\", group = \"BB\")\nbbLen       = input.int(defval = 5, title = \"BB Length\",minval = 1, group = \"BB\")\nbbMult      = input.int(defval = 4, title = \"BB Mult\",minval = 1, group = \"BB\" )\n[middle, upper, lower] = ta.bb(bbMiddle, bbLen, bbMult) // BB\nbbw         = ta.bbw(middle, bbLen, bbMult) // BB Geni\u015flik\n// CCI\ncciSrc      = input.source(defval = close, title = \"CCI Source\", group = \"CCI\")\ncciLen      = input.int(defval = 10, title = \"CCI Len\", minval = 1, group = \"CCI\")\ncci         = ta.cci(cciSrc,cciLen) // CCI\n// MA1\nma1Type = input.string(\"EMA\", \"\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"], group = \nma1Period = input.int(defval = 20, title = \"Period\", minval = 1, group = \"MA 1\", inline\nma1Src = input.source(defval = close, title = \"Source\", group = \"MA 1\", inline = \"2ma1\"\nma1 = maTypeToMa(ma1Type,ma1Period,ma1Src)\n// MA2\nma2Type = input.string(\"EMA\", \"\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"], group = \nma2Period = input.int(defval = 50, title = \"Period\", minval = 1, group = \"MA 2\", inline\nma2Src = input.source(defval = close, title = \"Source\", group = \"MA 2\", inline = \"2ma2\"\nma2 = maTypeToMa(ma2Type,ma2Period,ma1Src)\n// RSI\nrsiSrc = input.source(defval = close, title = \"RSI Source\", group = \"RSI\")\nrsiLen = input.int(defval = 14, title = \"RSI Length\", minval = 1, group = \"RSI\")\nrsi = ta.rsi(rsiSrc,rsiLen)\n// ADX\nlenAdx = input.int(17, minval=1, title=\"DI Length\", group = \"ADX\")\nlensigAdx = input.int(14, title=\"ADX Smoothing\", minval=1, maxval=50, group = \"ADX\"\n[diplus, diminus, adx] = ta.dmi(lenAdx, lensigAdx)\n// MFI\nmfiSrc = input.source(defval = close, title = \"MFI Source\", group = \"MFI\")\nmfiLen = input.int(defval = 14, title = \"MFI Length\", minval = 1, group = \"MFI\")\nmfi = ta.mfi(mfiSrc,mfiLen)\n// MOM\nmomSrc = input.source(defval = close, title = \"MOM Source\", group = \"MOM\")\nmomLen = input.int(defval = 14, title = \"MOM Length\", minval = 1, group = \"MOM\")\nmom = ta.mom(momSrc,momLen)\nindicators(selected)=>\n    switch selected\n        \"MA 1\" => ma1\n        \"MA 2\" => ma2\n        \"ATR\" => atr\n        \"CCI\" => cci\n        \"RSI\" => rsi\n        \"BBW\" => bbw\n        \"ADX\" => adx\n        \"MFI\" => mfi\n        \"MOM\" => mom\n                    position(data)=>\n    switch data\n        \"ABOVE\" => location.abovebar\n        => location.belowbar\nlocation(data)=>\n    switch data\n        \"ABOVE\" => true\n        => false\nstyle(data)=>\n    switch data\n        \"ABOVE\" => shape.labeldown\n        => shape.labelup\n// SETTINGS \n/////////// USE BACKTEST START DATE\nuseFilter = input.bool(true, title=\"USE Backtest at Start Date\", group=\"SETTINGS\")\nbacktestStartDate = input.time(timestamp(\"1 Jan 2011\"),    title=\"Start Date\", group\nbacktestStopDate =  input.time(timestamp(\"2025\"), title=\"Stop Date\", group=\"SETTINGS\"\ninTrade = not useFilter or (time >= backtestStartDate and time <= backtestStopDate\ntableShow = input.bool(defval = true, title = \"Show Table\", group = \"SETTINGS\")\nandORLong = input.string(defval = \"AND\", title = \"BUY/LONG CONNECT\", options = [\"AND\"\nandORShort = input.string(defval = \"AND\", title = \"SELL/SHORT CONNECT\", options = \nfutureOrSpot =  input.string(defval = \"SPOT\", title = \"FUTURE OR SPOT ?\", options \nwillStop = input.bool(defval = false, title = \"STOP\", group = \"SETTINGS\", inline =\nwillStopValue = input.float(defval = 5., title = \"\", group = \"SETTINGS\", inline = \npercentageStop = input.bool(defval = true, title = \"%\", group = \"SETTINGS\", inline\nwillTp = input.bool(defval = false, title = \"TP\", group = \"SETTINGS\", inline = \"TP\"\nwillTpValue = input.float(defval = 5., title = \"\", group = \"SETTINGS\", inline = \"TP\"\npercentageTP = input.bool(defval = true, title = \"%\", group = \"SETTINGS\", inline =\nwillTSL = input.bool(defval = false, title = \"Trailing SL\", group = \"SETTINGS\", inline\nwillTSLValue = input.float(defval = 2., title = \"\", group = \"SETTINGS\", inline = \"TSL\"\npercentageTSL = input.bool(defval = true, title = \"%\", group = \"SETTINGS\", inline \nbuyList = array.new_bool()\nsellList = array.new_bool()\ndetect(status,series,di)=>\n    if status\n        if di == \"BUY/LONG\"\n            array.push(buyList,series)\n        else\n            array.push(sellList,series)\n// CONDITION 1\ns1Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #1 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns1Inline    = \"s1i\"\ns1Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s1Group\ns1Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns1Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns1Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns1Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns1ValueBool = input.bool(defval = false, title = \"VALUE \", group = s1Group, inline\ns1EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s1Group, inline = \"v1\"\ns1Series    = operatorReturn(indicators(s1Left),s1Mid,s1ValueBool ? s1EndRight : indicators\ndetect(s1Status,s1Series,s1Direction)\n// CONDITION 2\ns2Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #2 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns2Inline    = \"s2i\"\ns2Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s2Group\ns2Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns2Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns2Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns2Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns2ValueBool = input.bool(defval = false, title = \"VALUE \", group = s2Group, inline\ns2EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s2Group, inline = \"v2\"\ns2Series    = operatorReturn(indicators(s2Left),s2Mid,s2ValueBool ? s2EndRight : indicators\ndetect(s2Status,s2Series,s2Direction)\ns3Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #3 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns3Inline    = \"s3i\"\ns3Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s3Group\ns3Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns3Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns3Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns3Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns3ValueBool = input.bool(defval = false, title = \"VALUE \", group = s3Group, inline\ns3EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s3Group, inline = \"v3\"\ns3Series    = operatorReturn(indicators(s3Left),s3Mid,s3ValueBool ? s3EndRight : indicators\ndetect(s3Status,s3Series,s3Direction)\ns4Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #4 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns4Inline    = \"s4i\"\ns4Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s4Group\ns4Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns4Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns4Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns4Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns4ValueBool = input.bool(defval = false, title = \"VALUE \", group = s4Group, inline\ns4EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s4Group, inline = \"v3\"\ns4Series    = operatorReturn(indicators(s4Left),s4Mid,s4ValueBool ? s4EndRight : indicators\ndetect(s4Status,s4Series,s4Direction)\ns5Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #5 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns5Inline    = \"s5i\"\ns5Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s5Group\ns5Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns5Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns5Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns5Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns5ValueBool = input.bool(defval = false, title = \"VALUE \", group = s5Group, inline\ns5EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s5Group, inline = \"v3\"\ns5Series    = operatorReturn(indicators(s5Left),s5Mid,s5ValueBool ? s5EndRight : indicators\ndetect(s5Status,s5Series,s5Direction)\ns6Group     = \"\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f CONDITION #6 \u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f\"\ns6Inline    = \"s6i\"\ns6Status    = input.bool(defval = false, title = \"CONDITION Active\", group = s6Group\ns6Direction = input.string(defval = \"BUY/LONG\", title = \"Direction\",options = [\"BUY/LONG\"\ns6Left      = input.string(defval = \"CCI\", title = \"1\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns6Mid       = input.string(defval = \">=\", title = \"\", options = [\">\",\"<\",\">=\",\"<=\"\ns6Right     = input.string(defval = \"CCI\", title = \"2\ufe0f\u20e3\", options = [\"ATR\",\"MA 1\",\"MA 2\"\ns6ValueBool = input.bool(defval = false, title = \"VALUE \", group = s6Group, inline\ns6EndRight  = input.float(defval = 0. , title = \"2\ufe0f\u20e3\", group = s6Group, inline = \"v3\"\ns6Series    = operatorReturn(indicators(s6Left),s6Mid,s6ValueBool ? s6EndRight : indicators\ndetect(s6Status,s6Series,s6Direction)\nif andORLong == \"AND\" ? array.every(buyList) : array.includes(buyList,true) and inTrade\n    strategy.entry(id = \"BUY\", direction = strategy.long)\nif andORShort == \"AND\" ? array.every(sellList) : array.includes(sellList,true) and\n    if futureOrSpot == \"SPOT\"\n        strategy.close(id = \"BUY\")\n    else\n        strategy.entry(id = \"SELL\", direction = strategy.short)\nbuyStop = 0.\nsellStop = 0.\nentry = strategy.position_avg_price\nbuyStop := percentageStop ? entry *(100 - willStopValue) / 100 : entry - willStopValue\nsellStop := percentageStop ? entry *(100 + willStopValue) / 100 : entry + willStopValue\nbuyTp = percentageTP ? entry *(100 + willTpValue) / 100 : entry + willTpValue\nsellTp = percentageTP ? entry *(100 - willTpValue) / 100 : entry - willTpValue\n//////// TSL\ntrailingLongPrice = 0.0\ntrailingShortPrice = 0.0\ntslShortPercent = percentageTSL\ntslLongPercent = percentageTSL\nif strategy.position_size > 0\n    stopValue = percentageTSL ? low * (100 - willTSLValue) / 100 : low - willTSLValue\n    trailingLongPrice := math.max(stopValue, trailingLongPrice[1])\n    else\n    trailingLongPrice:=0\nif strategy.position_size <0\n    stopValue = percentageTSL ? high * (100 + willTSLValue) / 100 : high + willTSLValue\n    trailingShortPrice := math.min(stopValue, trailingShortPrice[1])\n    else\n    trailingShortPrice :=99999\nplot(strategy.position_size > 0 and willTSL ? trailingLongPrice : na , color= color.green\nplot(strategy.position_size < 0  and willTSL ? trailingShortPrice : na , color =  \nstrategy.exit(\"EXIT\", from_entry = \"BUY\", stop = willStop and willTSL ? trailingLongPrice\nstrategy.exit(\"EXIT\", from_entry = \"SELL\", stop = willStop and willTSL ? trailingShortPrice\nif tableShow\n    // COLUMNS\n    var table tablo = table.new(position.top_right,2,7,border_width=4,border_color\n    table.cell(tablo,0,0,bgcolor= color.black,text_color= color.white, text=\"NET PROFIT\"\n    table.cell(tablo,0,1,bgcolor= color.black,text_color= color.white, text=\"TOTAL PROFIT\"\n    table.cell(tablo,0,2,bgcolor= color.black,text_color= color.white, text=\"TOTAL LOSS\"\n    table.cell(tablo,0,3,bgcolor= color.black,text_color= color.white, text=\"PROFIT FACTOR\"\n    table.cell(tablo,0,4,bgcolor= color.black,text_color= color.white, text=\"WIN TRADES\"\n    table.cell(tablo,0,5,bgcolor= color.black,text_color= color.white, text=\"LOSS TRADES\"\n    table.cell(tablo,0,6,bgcolor= color.black,text_color= color.white, text=\"TOTAL NET PROFIT\"\n    // ROWS\n    table.cell(tablo,1,0,bgcolor=strategy.netprofit>0 ?  color.green :  color.red\n    table.cell(tablo,1,1,bgcolor= color.black,text_color= color.white, text=str.tostring\n    table.cell(tablo,1,2,bgcolor= color.black,text_color= color.white, text=str.tostring\n    table.cell(tablo,1,3,bgcolor=strategy.grossprofit / strategy.grossloss >1 ?  \n    table.cell(tablo,1,4,bgcolor= color.black,text_color= color.white, text=str.tostring\n    table.cell(tablo,1,5,bgcolor= color.black,text_color= color.white, text=str.tostring\n    table.cell(tablo,1,6,bgcolor= color.black,text_color= color.white, text=str.tostring"}]}
{"messages": [{"role": "user", "content": "The Triple Dragon System is a technical trading strategy that uses a combination of three different indicators to identify potential buy and sell signals in the market. The three indicators used in this strategy are the Extended Price Volume Trend (EPVT), the Donchian Channels, and the Parabolic SAR. Each of these indicators provides different types of information about the market, and by combining them, we can create a more comprehensive trading system. The EPVT is used to identify potential trend changes and measure the strength of a trend. The Donchian Channels are used to identify the direction of the trend, while the Parabolic SAR is used to provide additional confirmation of trend changes and help determine potential entry and exit points. In this strategy, we first use the EPVT and Donchian Channels to identify the direction of the trend. When the EPVT is above its baseline and the price is above the upper Donchian Channel, it suggests an uptrend. Conversely, when the EPVT is below its baseline and the price is below the lower Donchian Channel, it suggests a downtrend. Once we have identified the trend direction, we use the Parabolic SAR to help determine potential entry and exit points. When the Parabolic SAR is below the price and flips to above the price, it suggests a potential buy signal. Conversely, when the Parabolic SAR is above the price and flips to below the price, it suggests a potential sell signal. To further refine our trading signals, we use multiple timeframes to confirm the trend direction and ensure that we are not entering the market during a period of high volatility. We also use multiple take-profit levels to lock in profits and manage risk. Overall, the Triple Dragon System is a comprehensive technical trading strategy that combines multiple indicators to provide clear entry and exit signals. By using a combination of trend-following and momentum indicators, we can identify potential trading opportunities while minimizing risk. Please note that this strategy is for educational purposes only and should not be taken as financial advice."}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"TRIPLE DRAGON SYSTEM\", overlay=true,default_qty_type = strategy.percent_of_equity\n/////////////// DRAG-ON ///// EMA'S /////////////// \nemar = ta.ema(close,5)\nplot(emar, color= color.blue, title=\"S-Fast EMA\")\n//EMAlengthTRF = input.int(200, minval=1,title = \"EMA Filter\")\n//ematrf = ta.ema(close,EMAlengthTRF)\n//plot(ematrf, \"EMA-TREND FILTER\", color=color.red,linewidth = 4)\n/////////////// 1-DRAG-ON /////EXTENDED PRICE VOLUME TREND /////////////// \nlenght = input(200,\"EPVT - Trend Lenght\")   \nvar cumVol = 0.\ncumVol += nz(volume)\nif barstate.islast and cumVol == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nsrc = close\nvt = ta.cum(ta.change(src)/src[1]*volume)\nupx = ta.highest(vt,lenght)\ndownx = ta.lowest(vt,lenght)\nbasex = (upx +downx)/2\nVTX = vt - basex\n/////////////// 2-DRAG-ON ///// DON TREND /////////////// \nlength = input.int(200, minval=1, title = \"Donchian Lenght\")\nlower = ta.lowest(length)\nupper = ta.highest(length)\nbasis = math.avg(upper, lower)\nupdiff = upper - close\ndowndiff = lower - close\ndontrend = -(updiff + downdiff)   \nxupx = ta.highest(dontrend,length) >0 ? ta.highest(dontrend,length) : 0 \nxdownx = ta.lowest(dontrend,length) < 0 ?ta.lowest(dontrend,length) :0 \nxxbasisxx = math.avg(xdownx, xupx)\ninversedragup = xupx[1]  \ninversedragdown = xdownx[1]  \ninversedragon = (inversedragup+inversedragdown)/2\n/////////////// 3-DRAG-ON ///// SUPER SAR-X /////////////// \nstart = input(0.02)\nincrement = input(0.02)\nmaximum = input(0.8)\nentry_bars = input(1, title='Entry on Nth trend bar')\natr = ta.atr(14)\natr := na(atr) ? ta.tr : atr\npsar = 0.0  // PSAR\naf = 0.0  // Acceleration Factor\ntrend_dir = 0  // Current direction of PSAR\nep = 0.0  // Extreme point\ntrend_bars = 0\nsar_long_to_short = trend_dir[1] == 1 and close <= psar[1]  // PSAR switches from long to short\nsar_short_to_long = trend_dir[1] == -1 and close >= psar[1]  // PSAR switches from short to long\ntrend_change = barstate.isfirst[1] or sar_long_to_short or sar_short_to_long\n// Calculate trend direction\ntrend_dir := barstate.isfirst[1] and close[1] > open[1] ? 1 : barstate.isfirst[1] \ntrend_bars := sar_long_to_short ? -1 : sar_short_to_long ? 1 : trend_dir == 1 ? nz\n// Calculate  Acceleration Factor\naf := trend_change ? start : trend_dir == 1 and high > ep[1] or trend_dir == -1 and\n// Calculate extreme point\nep := trend_change and trend_dir == 1 ? high : trend_change and trend_dir == -1 ? \n// Calculate PSAR\npsar := barstate.isfirst[1] and close[1] > open[1] ? low[1] : barstate.isfirst[1] \n//////////////// MELODY ///////////////////\nVTY = ta.valuewhen(ta.cross(VTX,0),close,0)\n//plot(VTY, color=color.black, title=\"Extended-PVT\")\n//DONTRENDX = ta.valuewhen(ta.cross(dontrend,0),close,0)\n//plot(DONTRENDX, color=color.red, title=\"DONCHIAN TREND\")\nSSARX = ta.valuewhen(ta.cross(psar,close),close,0)\n//plot(SSARX, color=color.black, title=\"SSAR-X\")\nMAXDRAG = math.max(SSARX,VTY)\n//plot(MAXDRAG, color=color.black, title=\"MAX DRAG\")\nMINDRAG = math.min(SSARX,VTY)\n//plot(MINDRAG, color=color.black, title=\"MIN DRAG\")\nBASEDRAG = math.avg(MAXDRAG,MINDRAG)\n//plot(BASEDRAG, color=color.red, title=\"BASE DRAG\")\n/////BUY AND SELL LOGIC ///////////\nDRAGONBUY = (ta.crossover(close,MAXDRAG) or ta.crossover(close,MINDRAG) )\nDRAGONBUYSTOP = (ta.crossunder(close,MAXDRAG) or ta.crossunder(close,MINDRAG)) \nDRAGONBUYPLOT = ta.valuewhen(DRAGONBUY==true,close,0)\nplot(DRAGONBUYPLOT, color= color.red, title=\"BUY LINE\")\nDRAGONSELL = (ta.crossunder(close,MAXDRAG) or ta.crossunder(close,MINDRAG) ) \nDRAGONSELLSTOP = (ta.crossover(close,MAXDRAG) or ta.crossover(close,MINDRAG))\nDRAGONSELLPLOT = ta.valuewhen(DRAGONSELL==true,close,0)\nplot(DRAGONSELLPLOT, color= color.red, title=\"SELL LINE\")\n/////TAKE PROFIT LOGIC ///////////\ntp1 = input.int(5, minval=1,title = \"TP-1\")\ntp2 = input.int(10, minval=1,title = \"TP-2\")\ntp3 = input.int(15, minval=1,title = \"TP-3\")\nTPTAKA1B = DRAGONBUYPLOT*(1+tp1/100)\n//plot(TPTAKA1B, \"BUY-TP1\", color=color.red,linewidth = 1)\nTPTAKA2B = DRAGONBUYPLOT*(1+tp2/100)\n//plot(TPTAKA2B, \"BUY-TP2\", color=color.red,linewidth = 1)\nTPTAKA3B = DRAGONBUYPLOT*(1+tp3/100)\n//plot(TPTAKA3B, \"BUY-TP3\", color=color.red,linewidth = 1)\nTPTAKA1S = DRAGONSELLPLOT*(1-tp1/100)\n//plot(TPTAKA1S, \"SELL-TP1\", color=color.red,linewidth = 1)\nTPTAKA2S = DRAGONSELLPLOT*(1-tp2/100)\n//plot(TPTAKA2S, \"SELL-TP2\", color=color.red,linewidth = 1)\nTPTAKA3S = DRAGONSELLPLOT*(1-tp3/100)\n//plot(TPTAKA3S, \"SELL-TP3\", color=color.red,linewidth = 1)\nBUYTP = ta.crossunder(emar,TPTAKA1B) or ta.crossunder(emar,TPTAKA2B) or ta.crossunder\nSELLTP = ta.crossover(emar,TPTAKA1B) or ta.crossover(emar,TPTAKA2B) or ta.crossover\n/////STRATEGY ///////////\n// Enter condition \nlongCondition = DRAGONBUY==true \nif longCondition\n    strategy.entry('Long', strategy.long, comment = \"ENTER-LONG\")\n// Exit condition \nstrategy.close('Long', when=DRAGONBUYSTOP, comment = \"EXIT-LONG\")\n// Enter condition \nShortCondition = DRAGONSELL  \nif ShortCondition\n    strategy.entry('Short', strategy.short, comment = \"ENTER-SHORT\")\n// Exit condition \nstrategy.close('Short', when=DRAGONSELLSTOP, comment = \"EXIT-SHORT\")\n///// END OF STRATEGY ///////////"}]}
{"messages": [{"role": "user", "content": "Introduction: The Optimized Zhaocaijinbao strategy is a mid and long-term quantitative trading strategy that combines momentum and trend factors. It generates buy and sell signals by using a combination of exponential moving averages, moving averages, volume and slope indicators.  It generates buy signals when the stock is above the 35-day moving average, the trading volume is higher than the 20-day moving average, and the stock is in an upward trend on a weekly timeframe.\"\u62db\u8d22\u8fdb\u5b9d\" is a Chinese phrase that can be translated to \"Attract Wealth and Bring in Treasure\" in English. It is a common expression used to wish for good luck and prosperity in various contexts, such as in business or personal finances. Highlights: The strategy has several special optimizations that make it unique. Firstly, the strategy is optimized for T+1 trading in the Chinese stock market and is only suitable for long positions. The optimizations are also applicable to international stock markets. Secondly, the trend strategy is optimized to only show indicators on the right side and oscillations. This helps to prevent false signals in choppy markets. Thirdly, the strategy uses a risk factor for dynamic position sizing to ensure position sizes are adjusted according to the current net asset value and risk preferences. This helps to lower drawdown risks.  The strategy has good resilience even without using stop loss modules in backtesting, making it suitable for trading hourly, 2-hourly, and daily K-line charts (depending on the stock being traded). We recommend experimenting with backtesting using SSE 1-hour or 2-hour or daily Kline charts. Backtesting outcomes: The strategy was backtested over the period from October 13th, 2005 to April 14th, 2023, using daily candlestick charts for the commodity code SSE:600763, with a currency of CNY and tick size of 0.01. The strategy used an initial capital of 1,000,000 CNY, with order sizes set to 10% equity and a pyramid of 1 order. The strategy also had a Max Position Size of 0.01 and a Risk Factor of 2. Here is a summary of the performance of the trading strategy: Total net profit: 288,577.32 CNY, representing a return of 128.86% Total number of closed trades: 61 Winning trades: 37, representing a win rate of 60.66% Profit factor: 2.415 Largest losing trade: 222,021.46 CNY, representing a loss of 14.08% Average trade: 21,124.22 CNY, representing a return of 3.1% Average holding period for all trades: 12 days Conclusion: In conclusion, the Optimized Zhaocaijinbao strategy is a mid and long-term quantitative trading strategy that combines momentum and trend factors. It is suitable for both Chinese stocks and global stocks. While the Optimized Zhaocaijinbao strategy has performed well in backtesting, it is important to note that past performance is not a guarantee of future results. Traders should conduct their own research and analysis and exercise caution when using any trading strategy."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 fzj20020403\n////@version=5\n//@version=5\nstrategy(\"Optimized Zhaocaijinbao\", overlay=true, margin_long=100, margin_short=0, \n// Define two moving averages\nma6 = ta.sma(close, 6)\nma35 = ta.sma(close, 35)\n// Define buy and sell signal lines\nbuyLine = ta.ema(close, 2)\nsellSlope = (close - close[8]) / 8\nsellLine = sellSlope * 1 + ta.sma(close, 8)\n// Define volume indicator\nvolumeEMA = ta.ema(volume, 20)\n// Define weekly slope factor\nweeklyMa = ta.sma(close, 50)\nweeklySlope = (weeklyMa - weeklyMa[4]) / 4 > 0\n// Generate buy and sell signals\nbuySignal = ta.crossover(buyLine, sellLine) and close > ma35 and volume > volumeEMA\nsellSignal = ta.crossunder(sellLine, buyLine)\n// Define dynamic position sizing factor\nequity = strategy.equity\nmaxPositionSize = equity * input.float(title='Max Position Size (%)', defval=0.01, \nriskFactor = input.float(title='Risk Factor', defval=2.0, minval=0.1, maxval=10.0, \natr = ta.atr(14)\npositionSize = maxPositionSize * riskFactor / atr\n// Define position status\nvar inPosition = false\n// Define buy and sell conditions\nbuyCondition = buySignal and not inPosition\nsellCondition = sellSignal and inPosition\n// Perform buy and sell operations\nif (buyCondition)\n    strategy.entry(\"Long\", strategy.long, qty=positionSize)\n    inPosition := true\nif (sellCondition)\n    strategy.close(\"Long\")\n    inPosition := false\n// Draw vertical line markers for buy and sell signals\nplotshape(buyCondition, style=shape.arrowdown, location=location.belowbar, color= \nplotshape(sellCondition, style=shape.arrowup, location=location.abovebar, color= color.red\n// Draw two moving averages\nplot(ma6, color= color.blue)\nplot(ma35, color= color.orange)\n// Draw volume indicator line\nplot(volumeEMA, color= color.yellow)\n// Define stop loss and take profit\nstopLoss = strategy.position_avg_price * 0.5\ntakeProfit = strategy.position_avg_price * 1.25\nif inPosition\n    strategy.exit(\"Long Stop Loss\", \"Long\", stop=stopLoss)\n    strategy.exit(\"Long Take Profit\", \"Long\", limit=takeProfit)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Removed the precision in the strategy properties, that caused the chart not working in some cases.                                                    Release Notes:                                                    Deleted some obsolete code.                                                    Release Notes:                                                    Added a precision setting. Specifies the number of digits after the floating point of the script's displayed values. If the order sizes are to small and the strategy doesn't generate results, try increasing the precision. The max value is 16.                                                    Release Notes:                                                    Tiny update. Trailing Stop only gets plotted when higher then Take Profit level.                                                    Release Notes:                                                    Fixed a flaw with preventing opening too much orders in a row. The counting of the bars logic was flawed. Now when the position size is bigger then 0 the bar starts counting. The counting resets when a consecutive order opens."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 A3Sh\n//@version=5\n// Strategy that finds potential lows in the price action and spreads the risk by entering multiple \n// The low is detected based on the difference between MTF RSI and EMA based RSI, Moving Average and\n// The size of each next position that is entered is multiplied by the sequential number of the posi\n// Each separate position can exit when a specified take profit is triggered and re-open when detect\n// All positions are closed when the price action crosses over the dynamic blue stop level line.\n// Additionally a take profit / trailing stop and a stop loss can be activated to lower the risk.\n// This strategy combines open-source code developed by fellow Tradingview community members: \n// The Lowfinder code is developed by RafaelZioni\n// https://www.tradingview.com/script/GzKq2RVl-Low-finder/\n// Both the MTF RSI code and the MTF Stochastic code are adapted from the MTFindicators libary writt\n// https://www.tradingview.com/script/UUVWSpXR-MTFindicators/\n// The Stop Level calculation is inspired by the syminfo-mintick tutorial on Kodify.net\n// https://kodify.net/tradingview/info/syminfo-mintick/\nstrategy(\"LowFinder_PyraMider\", \n         overlay=true, pyramiding=99, \n         initial_capital=10000, \n         default_qty_type=strategy.percent_of_equity, \n         default_qty_value=10,\n         commission_type=strategy.commission.percent, \n         commission_value=0.06,\n         slippage=1\n         )\n// Backtest Window\nstart_time   = input.time(defval=timestamp(\"01 April 2021 20:00\"), group = \"Backtest Window\"\nend_time     = input.time(defval=timestamp(\"01 Aug 2030 20:00\"),   group = \"Backtest Window\"\nwindow() => time >= start_time and time <= end_time\n// Inputs\nprec            = input.int    (4,           group = 'Strtaegy Properties',    title\nportfolio_size  = input.float  (100,         group = 'Risk - Portfolio',       title\nleverage        = input.int    (1,           group = 'Risk - Portfolio',       title\nq_mode          = input.string ('multiply',  group = 'Risk - Order Size',      title\nq_mode_m        = input.int    (1,           group = 'Risk - Order Size',      title\nfixed_q         = input.bool   (false,       group = 'Risk - Order Size',      title\namount_q        = input.float  (1,           group = 'Risk - Order Size',      title\nsl_on           = input.bool   (false,       group = 'Risk - Stop Loss',       title\nstopLoss        = input.float  (1.5,         group = 'Risk - Stop Loss',       title\nsl_mode         = input.string ('equity',    group = 'Risk - Stop Loss',       title\nstop_len        = input.int    (100,         group = 'Risk - Stop Level',      title\nstop_deviation  = input.float  (0.3,         group = 'Risk - Stop Level',      title\ncond2_toggle    = input.bool   (true ,       group = 'Risk - Take Profit',     title\ntp_all          = input.float  (1.0,         group = 'Risk - Take Profit',     title\ntp_on           = input.bool   (true,        group = 'Risk - Take Profit',     title\nexit_mode       = input.string ('stoplevel', group = 'Risk - Take Profit',     title\ntakeProfit      = input.float  (10.0,        group = 'Risk - Take Profit',     title\nposCount        = input.int    (12,          group = 'Pyramiding Settings',    title\nnext_entry      = input.float  (0.2,         group = 'Pyramiding Settings',    title\noa_lookback     = input.int    (0,           group = 'Pyramiding Settings',    title\nlen_rsi         = input.int    (5,           group = 'MTF LowFinder Settings', title\nmtf_rsi         = input.int    (1,           group = 'MTF LowFinder Settings', title\nma_length       = input.int    (26,          group = 'MTF LowFinder Settings', title\nnew_entry       = input.float  (0.1,         group = 'MTF LowFinder Settings', title\nma_signal       = input.int    (100,         group = 'Moving Average Filter',  title\nperiodK         = input.int    (14,          group = 'MTF Stochastic Filter',  title\nperiodD         = input.int    (3,           group = 'MTF Stochastic Filter',  title\nsmoothK         = input.int    (3,           group = 'MTF Stochastic Filter',  title\nlower           = input.int    (30,          group = 'MTF Stochastic Filter',  title\nmtf_stoch       = input.int    (10,          group = 'MTF Stochastic Filter',  title\navg_on          = input.bool   (true,        group = 'Plots',                  title\nplot_ma         = input.bool   (false,       group = 'Plots',                  title\nplot_ts         = input.bool   (false,       group = 'Plots',                  title\n// variables //\nvar entry_price     = 0.0    // The entry price of the first entry\nvar iq              = 0.0    // Inititial order quantity before risk calculation\nvar nq              = 0.0    // Updated new quantity after the loop\nvar oq              = 0.0    // Old quantity at the beginning or the loop\nvar q               = 0.0    // Final calculated quantity used as base order size\nvar int order_after = 0      // Candle counter. Prevent opening too much orders in a row\n// Order size calaculations // \n// Order size based on max amount of pyramiding orders or fixed by user input ///\n// Order size calculation based on 'base' mode or ' multiply' mode //\nif fixed_q\n    q := amount_q\nelse if q_mode == 'multiply'\n    iq := (math.abs(strategy.equity * portfolio_size  / posCount) / open) * leverage\n    oq := iq\n    for i = 0 to posCount\n        nq := oq + (iq * ( i/ q_mode_m + 1))\n        oq := nq \n    q := (iq  * posCount /  oq) * iq\nelse\n    q := (math.abs(strategy.equity * portfolio_size  / posCount) / open) * leverage\n// Function to calcaulate final order size based on order size modes and round the result with 1 dec\nquantity_mode(index,string q_mode) =>\n    q_mode == 'base' ? math.round(q,prec) : q_mode == 'multiply' ? math.round(q * \n// LowFinder Calculations //\n// MTF RSI by Peter_O //\nrsi_mtf(float source, simple int mtf,simple int len) =>\n    change_mtf=source-source[mtf]\n    up_mtf = ta.rma(math.max(change_mtf, 0), len*mtf)\n    down_mtf = ta.rma(-math.min(change_mtf, 0), len*mtf)\n    rsi_mtf = down_mtf == 0 ? 100 : up_mtf == 0 ? 0 : 100 - (100 / (1 + up_mtf / down_mtf\n// Lowfinder by RafaelZioni //\nvrsi = rsi_mtf(close,mtf_rsi,len_rsi)\npp=ta.ema(vrsi,ma_length)\ndd=(vrsi-pp)*5\ncc=(vrsi+dd+pp)/2\nlows=ta.crossover(cc,0) \n// MTF Stoch Calcualation // MTF Stoch adapted from  Peter_O //\nstoch_mtfK(source, mtf, len) =>\n    k = ta.sma(ta.stoch(source, high, low, periodK * mtf), smoothK * mtf)\n    stoch_mtfD(source, mtf, len) =>\n    k = ta.sma(ta.stoch(source, high, low, periodK * mtf), smoothK * mtf)\n    d = ta.sma(k, periodD * mtf)\n    mtfK = stoch_mtfK(close, mtf_stoch, periodK)\nmtfD = stoch_mtfD(close, mtf_stoch, periodK)\n// Open next position % below average position price //\nbelow_avg = close < (strategy.position_avg_price * (1 - (next_entry / 100)))\n// Moving Average Filter //\nmoving_average_signal = ta.sma(close, ma_signal)\nplot (plot_ma ? moving_average_signal : na, title = 'Moving Average', color =  color.rgb\n// Buy Signal //\nbuy_signal = lows and close < moving_average_signal and mtfK < lower\n// First Entry % Below lows //\nif buy_signal\n    entry_price := close * (1 - new_entry)\n// Plot Average Price of Position//\nplot (avg_on  ? strategy.position_avg_price : na, title = 'Average Price', style =\n// Take profit per Open Order //\ntake_profit_price = close * takeProfit / 100 / syminfo.mintick\n// Calculate different Stop Level conditions to exit All //\n// Stop Level Caculation //\nstop_long1_level = ta.highest (high, stop_len)[1]  * (1 + stop_deviation)\nstop_long2_level = ta.highest (high, stop_len)[2]  * (1 + stop_deviation)\nstop_long3_level = ta.highest (high, stop_len)[3]  * (1 + stop_deviation)\nstop_long4_level = ta.highest (high, stop_len)[1]  * (1 - 0.008) \n// Stop triggers //\nstop_long1 = ta.crossover(close,stop_long1_level)\nstop_long2 = ta.crossover(close,stop_long2_level)\nstop_long4 = ta.crossunder(close,stop_long4_level)\n// Exit Conditions, cond 1 only Stop Level, cond2 Trailing Stop option //\nexit_condition_1 = close < strategy.position_avg_price ? stop_long1 : close > strategy.position_avg_price\nexit_condition_2 = close < strategy.position_avg_price * (1 + tp_all) ? stop_long2\n                   close > strategy.position_avg_price * (1 + tp_all) ? stop_long4\n                   close < strategy.position_avg_price ? stop_long1 : na\n// Switch between conditions //\nexit_conditions = cond2_toggle ? exit_condition_2 : exit_condition_1\n// Exit when take profit //\nex_m = exit_mode == 'close' ? close : stop_long2_level\ntp_exit = ta.crossover(ex_m, strategy.position_avg_price * (1 + tp_all)) and close\n// Plot stoplevel, take profit level //\nplot_stop_level    = strategy.position_size > 0 ? stop_long2_level : na\nplot_trailing_stop = cond2_toggle and plot_ts and strategy.position_size > 0 and stop_long4_level\nplot(plot_stop_level,    title = 'Stop Level',    style=plot.style_linebr, color =\nplot(plot_trailing_stop, title = 'Trailing Stop', style=plot.style_linebr, color =\nplot_tp_level = cond2_toggle and strategy.position_size > 0 ? strategy.position_avg_price\nplot(plot_tp_level, title = 'Take Profit Level', style=plot.style_linebr, color = \n// Calculate Stop Loss based on equity and average price //\nloss_equity = ((strategy.position_size * strategy.position_avg_price) - (strategy.equity\nloss_avg_price = strategy.position_avg_price * (1 - stopLoss)\nstop_loss = sl_mode == 'avg_price' ? loss_avg_price : loss_equity\nplot(strategy.position_size > 0  and sl_on ? stop_loss : na, title = 'Stop Loss', \n// Counter to prevent opening too much orders in a row. //\nif strategy.position_size > 0 \n    order_after := order_after + 1\n// Enter first position //\nif ta.crossunder(close,entry_price) and window() and strategy.position_size == 0\n    strategy.entry('L_1', strategy.long, qty = math.round(q,prec), comment = '+' +\n// Enter Next Pyramiding Orders //\nif buy_signal and window() and strategy.position_size > 0 and below_avg\n    for i = 1 to strategy.opentrades\n        entry_comment = '+' + str.tostring((quantity_mode(i,q_mode))) // Comment with variable //\n        if strategy.opentrades == i and i < posCount and order_after > oa_lookback\n            entry_price := close\n            entry_id = 'L_' + str.tostring(i + 1) \n            strategy.entry(id = entry_id, direction=strategy.long, limit=entry_price\n            order_after := 0 // Reset counter to prevent opening to much orders in a row.\n// Exit per Order //\nif strategy.opentrades > 0 and window() \n    for i = 0 to strategy.opentrades \n        exit_comment = '-' + str.tostring(strategy.opentrades.size(i))\n        exit_from = 'L_' + str.tostring(i + 1)\n        exit_id = 'Exit_' + str.tostring(i + 1)\n        strategy.exit(id= exit_id, from_entry= exit_from, profit = take_profit_price\n            // Exit All //\nif exit_conditions or (tp_exit and tp_on and cond2_toggle) and window()\n    strategy.close_all('Exit All')\n    entry_price := 0\nif ta.crossunder(close,stop_loss)  and sl_on and window()\n    strategy.close_all('StopLoss')\n    entry_price := 0"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    A lot of things updated according to the original VWAP, EMA and RSI indicator.  A major failure corrected at VWAP anchor"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"VWAP+15EMA with RSI\", overlay=true, calc_on_order_fills = true)\n//Strategy - VWAP + EMA + RSI\n// Inputs\nstop_loss_pct = input.float(0.5, title=\"Stop Loss %\", group = \"Strategy settings\")\ntake_profit_pct = input.float(3.5, title=\"Take Profit %\", group = \"Strategy settings\"\ntrailing_stop_pct = input.float(1, title=\"Trailing Stop %\", group = \"Strategy settings\"\n//Volume Weighted Average Price indicator\nhideonDWM = input(false, title=\"Hide VWAP on 1D or Above\", group=\"VWAP Settings\")\nvar anchor = input.string(defval = \"Session\", title=\"Anchor Period\",\n options=[\"Session\", \"Week\", \"Month\", \"Quarter\", \"Year\", \"Decade\", \"Century\", \"Earnings\"\nvwap_src = input(title = \"Source\", defval = hlc3, group=\"VWAP Settings\")\nvwap_offset = input(0, title=\"Offset\", group=\"VWAP Settings\")\nshowBand_1 = input(true, title=\"\", group=\"Standard Deviation Bands Settings\", inline\nstdevMult_1 = input(2.0, title=\"Bands Multiplier #1\", group=\"Standard Deviation Bands Settings\"\nif barstate.islast and ta.cum(volume) == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nnew_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on\nnew_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on\nnew_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, \nisNewPeriod = switch anchor\n    \"Earnings\"  => not na(new_earnings)\n    \"Dividends\" => not na(new_dividends)\n    \"Splits\"    => not na(new_split)\n    \"Session\"   => timeframe.change(\"D\")\n    \"Week\"      => timeframe.change(\"W\")\n    \"Month\"     => timeframe.change(\"M\")\n    \"Quarter\"   => timeframe.change(\"3M\")\n    \"Year\"      => timeframe.change(\"12M\")\n    \"Decade\"    => timeframe.change(\"12M\") and year % 10 == 0\n    \"Century\"   => timeframe.change(\"12M\") and year % 100 == 0\n    => false\nisEsdAnchor = anchor == \"Earnings\" or anchor == \"Dividends\" or anchor == \"Splits\"\nif na(vwap_src[1]) and not isEsdAnchor\n    isNewPeriod := true\nfloat vwapValue = na\nfloat upperBandValue1 = na\nfloat lowerBandValue1 = na\nif not (hideonDWM and timeframe.isdwm)\n    [_vwap, _stdevUpper, _] = ta.vwap(vwap_src, isNewPeriod, 1)\n    vwapValue := _vwap\n    stdevAbs = _stdevUpper - _vwap\n    upperBandValue1 := _vwap + stdevAbs * stdevMult_1\n    lowerBandValue1 := _vwap - stdevAbs * stdevMult_1\nplot(vwapValue, title=\"VWAP\", color= #2962FF, offset=vwap_offset)\nupperBand_1 = plot(upperBandValue1, title=\"Upper Band #1\", color= color.green, offset\nlowerBand_1 = plot(lowerBandValue1, title=\"Lower Band #1\", color= color.green, offset\nfill(upperBand_1, lowerBand_1, title=\"Bands Fill #1\", color=  color.new(color.green\n//Moving Average Exponential indicator\nema_len = input.int(15, minval=1, title=\"EMA Length\", group = \"EMA settings\")\nema_src = input(close, title=\"EMA Source\", group = \"EMA settings\")\nema_offset = input.int(title=\"EMA Offset\", defval=0, minval=-500, maxval=500, group\nema_out = ta.ema(ema_src, ema_len)\nplot(ema_out, title=\"EMA\", color= color.red, offset=ema_offset)\n//Relative Strength Index indicator\nrsiLengthInput = input.int(14, minval=1, title=\"RSI Length\", group=\"RSI Settings\")\nrsiSourceInput = input.source(close, \"Source\", group=\"RSI Settings\")\nrsi_overbought = input.int(45, title=\"RSI Overbought Level\")\nrsi_value = ta.rsi(rsiSourceInput, rsiLengthInput)\nplotshape(rsi_value > rsi_overbought ? close : na, title=\"RSI Overbought\", style = \n//Strategy - VWAP + EMA + RSI - Continue\n// Entry Condition\nlong_entry = close > vwapValue and close > ema_out and rsi_value > rsi_overbought\n// Exit Conditions\nstop_loss = strategy.position_avg_price * (1 - stop_loss_pct / 100)\ntake_profit = strategy.position_avg_price * (1 + take_profit_pct / 100)\ntrailing_stop = strategy.position_avg_price * (1 - trailing_stop_pct / 100)\n// Submit Orders\nif long_entry and strategy.position_size == 0\n    strategy.entry(\"Long\", strategy.long)\nif strategy.position_size > 0\n    strategy.exit(\"TP/SL\", \"Long\", profit = take_profit, stop = stop_loss, trail_offset"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Changed the default values of some parameters to better ones.                                                    Release Notes:                                                    I added another EMA line to determine the direction of the market, corrected some inaccuracies in the code."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 boftei\n//@version=5\nstrategy(\"Boftei's Strategy\", overlay=false, pyramiding=1, default_qty_type= strategy.percent_of_equity\nstrat_dir_input = input.string(\"all\", \"strategy direction\", options=[\"long\", \"short\"\nstrat_dir_value = strat_dir_input == \"long\" ? strategy.direction.long : strat_dir_input\nstrategy.risk.allow_entry_in(strat_dir_value)\n//////////////////////////////////////////////////////////////////////\n//DATA\ntestStartYear = input(2005, \"Backtest Start Year\")\ntestStartMonth = input(7, \"Backtest Start Month\")\ntestStartDay = input(16, \"Backtest Start Day\")\ntestPeriodStart = timestamp(testStartYear,testStartMonth,testStartDay,0,0)\n//Stop date if you want to use a specific range of dates\ntestStopYear = input(2030, \"Backtest Stop Year\")\ntestStopMonth = input(12, \"Backtest Stop Month\")\ntestStopDay = input(30, \"Backtest Stop Day\")\ntestPeriodStop = timestamp(testStopYear,testStopMonth,testStopDay,0,0)\ntestPeriod() =>\n    time >= testPeriodStart and time <= testPeriodStop ? true : false\n//////////////////////////////////////////////////////////////////////\nsell = input.float(0.0065, \"sell level\")\nbuy = input.float(0, \"buy level\")\nlong1 = input.float(-0.493, \"long retry - too low\")\nlong2 = input.float(2.2, \"long close up\")\nlong3 = input.float(-1.5, \"long close down\")\nshort1 = input.float(0.8, \"short retry - too high\")\nshort2 = input.float(-5, \"dead - close the short\")\n///< botvenko script\nnn = input(60, \"Histogram Period\")\nfloat x = 0\nfloat z = 0\nfloat k = 0\ny = math.log(close[0]) - math.log(close[nn])\nif y>0\n    x := y\nelse\n    k := y\n//---------------------------------------------\n        plot(y > 0 ? x: 0, color =  color.green, linewidth = 4)\nplot(y <= 0 ? k: 0, color =  color.maroon, linewidth = 4)\nplot(y, color =  color.yellow, linewidth = 1)\nco = ta.crossover(y, buy)\ncu = ta.crossunder(y, sell)\nretry_long = ta.crossunder(y, long1)\ndeadline_long_up = ta.crossover(y, long2)\ndeadline_long_down = ta.crossunder(y, long3)\nretry_short = ta.crossover(y, short1)\ndeadline_short = ta.crossunder(y, short2)\nhline(buy, title='buy', color= color.green, linestyle=hline.style_dotted, linewidth\nhline(0, title='zero', color= color.white, linestyle=hline.style_dotted, linewidth\nhline(sell, title='sell', color= color.red, linestyle=hline.style_dotted, linewidth\nhline(long1, title='long retry', color= color.blue, linestyle=hline.style_dotted,\nhline(long2, title='overbought', color= color.teal, linestyle=hline.style_dotted,\nhline(long3, title='oversold', color= color.maroon, linestyle=hline.style_dotted,\nhline(short1, title='short retry', color= color.purple, linestyle=hline.style_dotted\nhline(short2, title='too low to short - an asset may die', color= color.navy, linestyle\n////////////////////////////////////////////////////////////EMAprotectionBLOCK\nema_21 = ta.ema(close, 21)\nema_55 = ta.ema(close, 55)\nema_89 = ta.ema(close, 89)\nema_144 = ta.ema(close, 144)\nema_233 = ta.ema(close, 233)\n//ema_377 = ta.ema(close, 377)\nlong_st = ema_21>ema_55 and ema_55>ema_89 and ema_89>ema_144 and ema_144>ema_233// and ema_233>ema_377\nshort_st = ema_21<ema_55 and ema_55<ema_89 and ema_89<ema_144 and ema_144<ema_233// and ema_233<ema_377 \ng_v = long_st == true?3:0\nr_v = short_st == true?-2:0\ny_v = long_st != true and short_st != true?2:0\nplot(math.log(ema_21), color =  color.new(#ffaf5e, 50))\nplot(math.log(ema_55), color =  color.new(#b9ff5e, 50))\nplot(math.log(ema_89), color =  color.new(#5eff81, 50))\nplot(math.log(ema_144), color =  color.new(#5effe4, 50))\nplot(math.log(ema_233), color =  color.new(#5e9fff, 50))\n//plot(math.log(ema_377), color = color.new(#af5eff, 50))\nplot(long_st == true?3:0, color =  color.new(color.green, 65), linewidth = 5)\nplot(short_st == true?-2:0, color =  color.new(color.red, 65), linewidth = 5)\nplot(long_st != true and short_st != true?2:0, color =  color.new(color.yellow, 65\n////////////////////////////////////////////////////////////EMAprotectionBLOCK\nif (co and testPeriod() and (g_v == 3 or y_v == 2))\n    strategy.close(\"OH BRO\", comment = \"EXIT-SHORT\")\n    strategy.close(\"OH DUDE\", comment = \"EXIT-SHORT\")\n    strategy.entry(\"OH DAMN\", strategy.long, comment=\"ENTER-LONG 'co'\")\nif (retry_long and testPeriod() and (g_v == 3 or y_v == 2))\n    strategy.close(\"OH DAMN\", comment = \"EXIT-LONG\")\n    strategy.entry(\"OH BRUH\", strategy.long, comment=\"ENTER-LONG 'retry_long'\")\n    if (cu and testPeriod() and (r_v == -2 or y_v == 2))\n    strategy.close(\"OH DAMN\", comment = \"EXIT-LONG\")\n    strategy.close(\"OH BRUH\", comment = \"EXIT-LONG\")\n    strategy.entry(\"OH BRO\", strategy.short, comment=\"ENTER-SHORT 'cu'\")\nif (retry_short and testPeriod() and (r_v == -2 or y_v == 2))\n    strategy.close(\"OH BRO\", comment = \"EXIT-SHORT\")\n    strategy.entry(\"OH DUDE\", strategy.short, comment=\"ENTER-SHORT 'retry_short'\")\n        if (deadline_long_up and testPeriod() or r_v == -2 and testPeriod())\n    strategy.close(\"OH DAMN\", comment = \"EXIT-LONG 'deadline_long_up'\")\n    strategy.close(\"OH BRUH\", comment = \"EXIT-LONG 'deadline_long_up'\")\nif (deadline_long_down and testPeriod())\n    strategy.close(\"OH DAMN\", comment = \"EXIT-LONG 'deadline_long_down'\")\n    strategy.close(\"OH BRUH\", comment = \"EXIT-LONG 'deadline_long_down'\")\nif (deadline_short and testPeriod() or g_v == 3 and testPeriod())\n    strategy.close(\"OH BRO\", comment = \"EXIT-SHORT 'deadline_short'\")\n    strategy.close(\"OH DUDE\", comment = \"EXIT-SHORT 'deadline_short'\")\n    // (you can use strategy.close_all(comment = \"close all entries\") here)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Bug related with Adding/withdrawing money function was solved. However, calculation could not be perfect in lowertimeframes. I am still looking for a solution for this."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \n// Please, visit the main script that strategy is based in :) Machine Learning: Lorentzian Classific\n// Indicator developed by \u00a9jdehorty\n// Strategy devoleped by \u00a9StrategiesForEVeryone\n// @version=5\nstrategy('Machine Learning: Lorentzian Classification', 'Lorentzian Classification Strategy'\nimport jdehorty/MLExtensions/2 as ml\nimport jdehorty/KernelFunctions/2 as kernels\ninitial_message = input.bool(defval = true, title = \"Show initial message\", group \nif barstate.islast and initial_message\n    label.new(bar_index, 0, \"Please, read the entire post \" + \"\\nfor a better understanding.\"\n// ======================\n// ==== Custom Types ====\n// ======================\n// This section uses PineScript's new Type syntax to define important data structures\n// used throughout the script.\ntype Settings\n    float source\n    int neighborsCount\n    int maxBarsBack\n    int featureCount\n    int colorCompression\n    bool showExits\n    bool useDynamicExits\ntype Label\n    int long\n    int short\n    int neutral\ntype FeatureArrays\n    array<float> f1\n    array<float> f2\n    array<float> f3\n    array<float> f4\n    array<float> f5\ntype FeatureSeries\n    float f1\n    float f2\n    float f3\n    float f4\n    float f5\ntype MLModel\n    int firstBarIndex\n    array<int> trainingLabels\n    int loopSize\n    float lastDistance\n    array<float> distancesArray\n    array<int> predictionsArray\n    int prediction\ntype FilterSettings \n    bool useVolatilityFilter\n    bool useRegimeFilter\n    bool useAdxFilter\n    float regimeThreshold\n    int adxThreshold\ntype Filter\n    bool volatility\n    bool regime\n    bool adx \n// ==========================\n// ==== Helper Functions ====\n// ==========================\nseries_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>\n    switch feature_string\n        \"RSI\" => ml.n_rsi(_close, f_paramA, f_paramB)\n        \"WT\" => ml.n_wt(_hlc3, f_paramA, f_paramB)\n        \"CCI\" => ml.n_cci(_close, f_paramA, f_paramB)\n        \"ADX\" => ml.n_adx(_high, _low, _close, f_paramA)\nget_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays\n    switch featureCount\n        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i)\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)\n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)\n             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)\n             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)\n        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i)\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)\n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)\n             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)\n        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i)\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)\n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)\n        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i)\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)\n// ================  \n// ==== Inputs ==== \n// ================ \n// Settings Object: General User-Defined Inputs\nSettings settings = \n Settings.new(\n   input.source(title='Source', defval=close, group=\"General Settings\", tooltip=\"Source of the input data\"\n   input.int(title='Neighbors Count', defval=8, group=\"General Settings\", minval=1\n   input.int(title=\"Max Bars Back\", defval=2000, group=\"General Settings\", tooltip\n   input.int(title=\"Feature Count\", defval=5, group=\"Feature Engineering\", minval=\n   input.int(title=\"Color Compression\", defval=1, group=\"General Settings\", minval\n   input.bool(title=\"Show Default Exits\", defval=false, group=\"General Settings\", \n   input.bool(title=\"Use Dynamic Exits\", defval=false, group=\"General Settings\", tooltip\n )\n   // Trade Stats Settings\n// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting.\n// showTradeStats = input.bool(false, 'Show Trade Stats', tooltip='Displays the trade stats for a gi\n// useWorstCase = input.bool(false, \"Use Worst Case Estimates\", tooltip=\"Whether to use the worst ca\n// Settings object for user-defined settings\nFilterSettings filterSettings =\n FilterSettings.new(\n   input.bool(title=\"Use Volatility Filter\", defval=true, tooltip=\"Whether to use the volatility filter.\"\n   input.bool(title=\"Use Regime Filter\", defval=true, group=\"Filters\", inline=\"regime\"\n   input.bool(title=\"Use ADX Filter\", defval=false, group=\"Filters\", inline=\"adx\")\n   input.float(title=\"Threshold\", defval=-0.1, minval=-10, maxval=10, step=0.1, tooltip\n   input.int(title=\"Threshold\", defval=20, minval=0, maxval=100, step=1, tooltip=\"Whether to use the ADX filter. Threshold for dete\n )\n// Filter object for filtering the ML predictions\nFilter filter =\n Filter.new(\n   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), \n   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter\n   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.\n  )\n// Feature Variables: User-Defined Inputs for calculating Feature Series. \nf1_string = input.string(title=\"Feature 1\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval\nf1_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 1.\"\nf1_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 2 (if applicab\nf2_string = input.string(title=\"Feature 2\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval\nf2_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 2.\"\nf2_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 2 (if applicab\nf3_string = input.string(title=\"Feature 3\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval\nf3_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 3.\"\nf3_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 3 (if applicab\nf4_string = input.string(title=\"Feature 4\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval\nf4_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 4.\"\nf4_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 4 (if applicab\nf5_string = input.string(title=\"Feature 5\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval\nf5_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 5.\"\nf5_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 5 (if applicab\n// FeatureSeries Object: Calculated Feature Series based on Feature Variables\nfeatureSeries = \n FeatureSeries.new(\n   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1\n   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 \n   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3\n   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4\n   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5\n )\n// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML\n// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization a\nvar f1Array = array.new_float()\nvar f2Array = array.new_float()\nvar f3Array = array.new_float()\nvar f4Array = array.new_float()\nvar f5Array = array.new_float()\narray.push(f1Array, featureSeries.f1)\narray.push(f2Array, featureSeries.f2)\narray.push(f3Array, featureSeries.f3)\narray.push(f4Array, featureSeries.f4)\narray.push(f5Array, featureSeries.f5)\n// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object\nfeatureArrays = \n FeatureArrays.new(\n  f1Array, // f1\n  f2Array, // f2\n  f3Array, // f3\n  f4Array, // f4\n  f5Array  // f5\n )\n// Label Object: Used for classifying historical data as training data for the ML Model\nLabel direction_s = \n Label.new(\n   long=1, \n   short=-1, \n   neutral=0\n  )\n// Derived from General Settings\nmaxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings\n// EMA Settings \nuseEmaFilter = input.bool(title=\"Use EMA Filter\", defval=false, group=\"Filters\", inline\nemaPeriod = input.int(title=\"Period\", defval=200, minval=1, step=1, group=\"Filters\"\nisEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true\nisEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true\nuseSmaFilter = input.bool(title=\"Use SMA Filter\", defval=false, group=\"Filters\", inline\nsmaPeriod = input.int(title=\"Period\", defval=200, minval=1, step=1, group=\"Filters\"\nisSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true\nisSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true\n// Nadaraya-Watson Kernel Regression Settings\nuseKernelFilter = input.bool(true, \"Trade with Kernel\", group=\"Kernel Settings\", inline\nshowKernelEstimate = input.bool(false, \"Show Kernel Estimate\", group=\"Kernel Settings\"\nuseKernelSmoothing = input.bool(false, \"Enhance Kernel Smoothing\", tooltip=\"Uses a crossover based mechanism to smoothen kern\nh = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This \nr = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value \nx = input.int(25, \"Regression Level\", tooltip='Bar index on which to start regression. Controls \nlag = input.int(2, \"Lag\", tooltip=\"Lag for crossover detection. Lower values result \n// Display Settings\nshowBarColors = input.bool(false, \"Show Bar Colors\", tooltip=\"Whether to show the bar colors.\"\nshowBarPredictions = input.bool(defval = false, title = \"Show Bar Prediction Values\"\nuseAtrOffset = input.bool(defval = false, title = \"Use ATR Offset\", tooltip = \"Will use the ATR offset instead of the bar predic\nbarPredictionsOffset = input.float(0, \"Bar Prediction Offset\", minval=0, tooltip=\"The offset of the bar predictions as a percentage\n// =================================\n// ==== Next Bar Classification ====\n// =================================\n// This model specializes specifically in predicting the direction_s of price action over the course\n// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other\nsrc = settings.source\ny_train_series = src[4] < src[0] ? direction_s.short : src[4] > src[0] ? direction_s\nvar y_train_array = array.new_int(0)\n// Variables used for ML Logic\nvar predictions = array.new_float(0)\nvar prediction = 0.\nvar signal = direction_s.neutral\nvar distances = array.new_float(0)\narray.push(y_train_array, y_train_series)\n// =========================\n// ====  Core ML Logic  ====\n// =========================\nlastDistance = -1.0\nsize = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)\nsizeLoop = math.min(settings.maxBarsBack-1, size)\nif bar_index >= maxBarsBackIndex //{\n    for i = 0 to sizeLoop //{\n        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays\n        if d >= lastDistance and i%4 //{\n            lastDistance := d            \n            array.push(distances, d)\n            array.push(predictions, math.round(array.get(y_train_array, i)))\n            if array.size(predictions) > settings.neighborsCount //{\n                lastDistance := array.get(distances, math.round(settings.neighborsCount\n                array.shift(distances)\n                array.shift(predictions)\n            //}\n        //}\n    //}\n    prediction := array.sum(predictions)\n//}\n// ============================\n// ==== Prediction Filters ====\n// ============================\n// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions\nfilter_all = filter.volatility and filter.regime and filter.adx\n// Filtered Signal: The model's prediction of future price movement direction_s with user-defined fi\nsignal := prediction > 0 and filter_all ? direction_s.long : prediction < 0 and filter_all\n// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars\nvar int barsHeld = 0\nbarsHeld := ta.change(signal) ? 0 : barsHeld + 1\nisHeldFourBars = barsHeld == 4\nisHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4\n// Fractal Filters: Derived from relative ============ Appearance ============s of signals in a give\nisDifferentSignalType = ta.change(signal)\nisEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal\nisBuySignal = signal == direction_s.long and isEmaUptrend and isSmaUptrend\nisSellSignal = signal == direction_s.short and isEmaDowntrend and isSmaDowntrend\nisLastSignalBuy = signal[4] == direction_s.long and isEmaUptrend[4] and isSmaUptrend\nisLastSignalSell = signal[4] == direction_s.short and isEmaDowntrend[4] and isSmaDowntrend\nisNewBuySignal = isBuySignal and isDifferentSignalType\nisNewSellSignal = isSellSignal and isDifferentSignalType\n// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational \n// For more information on this technique refer to my other open source indicator located here: \n// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting\nc_green =  color.new(#009988, 20)\nc_red =  color.new(#CC3311, 20)\ntransparent =  color.new(#000000, 100)\nyhat1 = kernels.rationalQuadratic(settings.source, h, r, x)\nyhat2 = kernels.gaussian(settings.source, h-lag, x)\nkernelEstimate = yhat1\n// Kernel Rates of Change\nbool wasBearishRate = yhat1[2] > yhat1[1]\nbool wasBullishRate = yhat1[2] < yhat1[1]\nbool isBearishRate = yhat1[1] > yhat1\nbool isBullishRate = yhat1[1] < yhat1\nisBearishChange = isBearishRate and wasBullishRate\nisBullishChange = isBullishRate and wasBearishRate\n// Kernel Crossovers\nbool isBullishCrossAlert = ta.crossover(yhat2, yhat1)\nbool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) \nbool isBullishSmooth = yhat2 >= yhat1\nbool isBearishSmooth = yhat2 <= yhat1\n// Kernel Colors\ncolor colorByCross = isBullishSmooth ? c_green : c_red\ncolor colorByRate = isBullishRate ? c_green : c_red\ncolor plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate\nplot(kernelEstimate, color=plotColor, linewidth=2, title=\"Kernel Regression Estimate\"\n// Alert Variables\nbool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange\nbool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange\n// Bullish and Bearish Filters based on Kernel\nisBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate\nisBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate\n// ===========================\n// ==== Entries and Exits ====\n// ===========================\n// Entry Conditions: Booleans for ML Model Position Entries\nstartLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend\nstartShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend\n// Dynamic Exit Conditions: Booleans for ML Model Position Exits based on Fractal Filters and Kernel\nlastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade\nlastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade\nbarsSinceRedEntry = ta.barssince(startShortTrade)\nbarsSinceRedExit = ta.barssince(alertBullish)\nbarsSinceGreenEntry = ta.barssince(startLongTrade)\nbarsSinceGreenExit = ta.barssince(alertBearish)\nisValidShortExit = barsSinceRedExit > barsSinceRedEntry\nisValidLongExit = barsSinceGreenExit > barsSinceGreenEntry\nendLongTradeDynamic = (isBearishChange and isValidLongExit[1])\nendShortTradeDynamic = (isBullishChange and isValidShortExit[1])\n// Fixed Exit Conditions: Booleans for ML Model Position Exits based on a Bar-Count Filters\nendLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars\nendShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars\nisDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing\nendLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic\nendShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic\n// =========================\n// ==== Plotting Labels ====\n// =========================\n// Note: These will not repaint once the most recent bar has fully closed. By default, signals appea\n//plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green\n//plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-p\n//plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absol\n//plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.abso\n// ================\n// ==== Alerts ====\n// ================ \n// Separate Alerts for Entries and Exits\n//alertcondition(startLongTrade, title='Open Long \u25b2', message='LDC Open Long \u25b2 | {{ticker}}@{{close}} | ({{interval}})')\n//alertcondition(endLongTrade, title='Close Long \u25b2', message='LDC Close Long \u25b2 | {{ticker}}@{{close}} | ({{interval}})')\n//alertcondition(startShortTrade, title='Open Short \u25bc', message='LDC Open Short  | \n//alertcondition(endShortTrade, title='Close Short \u25bc', message='LDC Close Short \u25bc | \n//\n//// Combined Alerts for Entries and Exits\n//alertcondition(startShortTrade or startLongTrade, title='Open Position \u25b2\u25bc', message='LDC Open Position \u25b2\u25bc | \n//alertcondition(endShortTrade or endLongTrade, title='Close Position \u25b2\u25bc', message='LDC Close \n//\n//// Kernel Estimate Alerts\n//alertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC \n//alertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC \n// =========================\n// ==== Display Signals ==== \n// =========================\natrSpaced = useAtrOffset ? ta.atr(1) : na\ncompressionFactor = settings.neighborsCount / settings.colorCompression\nc_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor,  \nc_label = showBarPredictions ? c_pred : na\nc_bars = showBarColors ? color.new(c_pred, 50) : na\nx_val = bar_index\ny_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction\nlabel.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price,  color.new\nbarcolor(showBarColors ? color.new(c_pred, 50) : na)\n// =================================================================================================\n// ====================================== Strategy code ============================================\n// ------ Inputs for calculating our amount position --------\ninitial_actual_capital = input.float(defval=10000, title = \"Enter initial/current capital\"\nrisk_c = input.float(2.5, '% account risk per trade', step=1, group = \"============ Position amount calculator =========\n// ------ Date filter ---------\ninitial_date = input.time(title=\"Initial date\", defval=timestamp(\"10 Feb 2014 13:30 +0000\"\nfinal_date   = input.time(title=\"Final date\", defval=timestamp(\"01 Jan 2030 19:30 +0000\"\ndateFilter(int st, int et) => time >= st and time <= et\ncolorDate = input.bool(defval=false, title=\"Date background\", tooltip = \"Add color to the period of time of the strategy t\nbgcolor(colorDate and dateFilter(initial_date, final_date) ? color.new( color.blue\ndate = dateFilter(initial_date, final_date)\n// ------ Session limits ------\ntimeSession = input.session(title=\"Time session\", defval=\"0000-2400\", group=\"============ Time filter ============ \"\ncolorBG     = input.bool(title=\"Session background\", defval=false, tooltip = \"Add color to session time background\"\ninSession(sess) => na(time(timeframe.period, sess + ':1234567')) == false\nbgcolor(inSession(timeSession) and colorBG ?  color.rgb(0, 38, 255, 84) : na)\n// =================================================================================================\n// ------------ Super Trend ----------\natrPeriod = input(9, \"ATR Length SuperTrend\", group = \"========= Super Trend filter ==========\"\nfactor = input.float(2.5, \"Factor SuperTrend\", step = 0.05, group = \"========= Super Trend filter ==========\"\n[supertrend, direction_supertrend] = ta.supertrend(factor, atrPeriod)\nshow_supertrend = input.bool(defval = false, title=\"Show supertrend ?\", group = \"============ Appearance ============\"\nbodyMiddle = plot(show_supertrend ? ((open + close) / 2) : na, display=display.none\nupTrend = plot(show_supertrend and direction_supertrend < 0 ? supertrend : na, \"Up Trend\"\ndownTrend = plot(show_supertrend and direction_supertrend > 0 ? supertrend : na, \"Down Trend\"\nfill(bodyMiddle, upTrend,  color.new(color.green, 95), fillgaps=false, title = \"Supertrend background\"\nfill(bodyMiddle, downTrend,  color.new(color.red, 95), fillgaps=false, title = \"Supertrend background\"\nup_trend_plot = direction_supertrend < 0\ndown_trend_plot = direction_supertrend > 0\n// ----------- Ema ----------------------\nema = input.int(200, title='Ema length', minval=1, maxval=500, group = \"============ Trend ============\"\nema200 = ta.ema(close, ema)\nbullish = close > ema200\nbearish = close < ema200\nshow_ema = input.bool(defval=true, title=\"Show ema ?\", group = \"============ Appearance ============\"\nplot(show_ema ? ema200 : na, title = \"Ema\", color= color.white, linewidth=2, display\n// =================================================================================================\n// -------------- Atr stop loss by garethyeo (modified) -----------------\nsource_atr = input(close, title='Source', group = \"================== Stop loss ==================\"\nlength_atr = input.int(14, minval=1, title='Period', group = \"================== Stop loss ==================\"\nmultiplier = input.float(1.5, minval=0.1, step=0.1, title='Atr multiplier', group \nshow_stoploss = input.bool(defval = true, title = \"Show stop loss ?\", group = \"============ Appearance ============\"\nvar float shortStopLoss = na\nvar float longStopLoss = na \nvar float atr_past_candle_long = na\nvar float atr_past_candle_short = na\ncandle_of_stoploss = input.string(defval = \"Current candle\", title = \"Stop loss source for atr stoploss\"\nif candle_of_stoploss == \"Current candle\"\n    shortStopLoss := source_atr + ta.atr(length_atr) * multiplier\n    longStopLoss := source_atr - ta.atr(length_atr) * multiplier\nif candle_of_stoploss == \"Past candle\"\n    shortStopLoss := close[1] + ta.atr(length_atr)[1] * multiplier[1]\n    longStopLoss := close[1] - ta.atr(length_atr)[1] * multiplier[1]\n// --------- Stop loss based in last swing high/low --------\nhigh_bars = input.int(defval = 10, title = \"Highest price bars: \", group = \"================== Stop loss ==================\"\nlow_bars = input.int(defval = 10, title = \"Lowest price bars: \", group = \"================== Stop loss ==================\"\nstop_high = ta.highest(high, high_bars)\nstop_low = ta.lowest(low, low_bars)\n// --------- Stop loss source selection ---------------\nstoploss_type = input.string(defval = \"Atr stop loss\", title = \"General stop loss source\"\nif stoploss_type == \"Atr stop loss\"\n    shortStopLoss := source_atr + ta.atr(length_atr) * multiplier\n    longStopLoss := source_atr - ta.atr(length_atr) * multiplier\nif candle_of_stoploss == \"Past candle\" and stoploss_type == \"Atr stop loss\"\n    shortStopLoss := close[1] + ta.atr(length_atr)[1] * multiplier[1]\n    longStopLoss := close[1] - ta.atr(length_atr)[1] * multiplier[1]\nif stoploss_type == \"Swing high/low\"\n    shortStopLoss := stop_high\n    longStopLoss := stop_low\n// ======================================== Add/withdraw money frequently (>>>Beta<<<) =============\n// Declare some variables =========================================================\nvar initial_capital = strategy.initial_capital \nvar initial_capital_a = strategy.initial_capital \nvar initial_capital_w = strategy.initial_capital \nvar float capital_added = 0\nvar float balance = strategy.initial_capital\nvar prev_month = 0 \nvar float amount = 0 \nvar add_frequency = 0  \nvar withdraw_frequency = 0 \n// Choose how often the strategy adds money ========================================================\nadd_money_frequency = input.string(\"Monthly\", title = \"Choose how often would you add money\"\namount_to_add = input.float(defval = 10, title = \"How much you want to add ?\", group\nif add_money_frequency == \"Monthly\"\n    add_frequency := month\nif add_money_frequency == \"Weekly\"\n    add_frequency := weekofyear\nif add_money_frequency == \"Daily\"\n    add_frequency := dayofweek\nif add_money_frequency == \"Yearly\"\n    add_frequency := year\n// Choose if you want to add money or not ====================================\nadd_money = input.string(\"No\", title = \"Add money from time to time ?\", options = \nif add_frequency != add_frequency[1] and add_money == \"Yes\" and date\n    initial_capital_a += amount_to_add\n    initial_capital += amount_to_add\n    balance := strategy.netprofit + initial_capital\n// Choose how often the strategy withdraws money ===================================================\namount_to_withdraw = input.string(\"Fixed\", title = \"Withdraw based in fixed amounts or percentage of \namount_for_withdraw = input.float(defval = 2, title = \"How much you want to withdraw (fixed amount) ?\"\nwithdraw_money_frequency = input.string(\"Monthly\", title = \"Choose how often would you withdraw money\"\n// We use this for being able to choose the frequency of withdrawing money:\nif withdraw_money_frequency == \"Monthly\"\n    withdraw_frequency := month\nif withdraw_money_frequency == \"Weekly\"\n    withdraw_frequency := weekofyear\nif withdraw_money_frequency == \"Daily\"\n    withdraw_frequency := dayofweek\nif withdraw_money_frequency == \"Yearly\"\n    withdraw_frequency := year\n// Choose if you want to withdraw money or not =============================\nwithdraw_money = input.string(\"No\", title = \"Withdraw money from time to time ?\", \npercentage_of_earnings = input.float(10, title = \"Percentage of earnings\", group =\n// Percentage of earnings:\nif withdraw_frequency != withdraw_frequency[1] and withdraw_money == \"Yes\" and amount_to_withdraw\n    initial_capital_w -= strategy.netprofit * (percentage_of_earnings / 100)\n    initial_capital -=  strategy.netprofit * (percentage_of_earnings / 100)\n    balance := strategy.netprofit + initial_capital\n// Fixed amount:\nif withdraw_frequency != withdraw_frequency[1] and withdraw_money == \"Yes\" and amount_to_withdraw\n    initial_capital_w -= amount_for_withdraw\n    initial_capital -= amount_for_withdraw\n    balance := strategy.netprofit + initial_capital\n// Logic \nif withdraw_money == \"Yes\" and add_money == \"No\" \n    amount := balance    \nif withdraw_money ==\"Yes\" and add_money ==\"Yes\" \n    amount := balance   \nif withdraw_money == \"No\" and add_money == \"Yes\"\n    amount := balance   \nif withdraw_money == \"No\" and add_money == \"No\"\n    amount := strategy.equity\n// =================================================================================================\n// ------------- Money management --------------\nstrategy_contracts = amount / close\ndistance_sl_long = -1 * (longStopLoss - close) / close\ndistance_sl_short = (shortStopLoss - close) / close\nrisk = input.float(2.5, '% Account risk per trade for backtesting', step=1, group \nlong_amount = strategy_contracts * (risk / 100) / distance_sl_long\nshort_amount = strategy_contracts * (risk / 100) / distance_sl_short\nleverage=input.bool(defval=true, title=\"Use leverage for backtesting ?\", group = \"============ Risk management for trades =========\nif not leverage and long_amount>strategy_contracts\n    long_amount:=amount/close\nif not leverage and short_amount>strategy_contracts\n    short_amount:=amount/close\n// ---- Fixed amounts ----\nfixed_amounts = input.bool(defval = false, title = \"Fixed amounts ?\", group = \"============ Risk management for trades =========\nfixed_amount_input = input.float(defval = 1000, title = \"Fixed amount in usd\", group\nif fixed_amounts \n    long_amount := fixed_amount_input / close\n    short_amount := fixed_amount_input / close\n// ---------- Risk management ---------------\nrisk_reward_breakeven_long= input.float(title=\"Risk/reward for breakeven long\", defval\nrisk_reward_take_profit_long= input.float(title=\"Risk/reward for take profit long\"\nrisk_reward_breakeven_short= input.float(title=\"Risk/reward for break even short\",\nrisk_reward_take_profit_short= input.float(title=\"Risk/reward for take profit short\"\ntp_percent=input.float(title=\"% of trade for first take profit\", defval=50, step=5\n// =================================================================================================\n// ------------ Trade conditions ---------------\n// Entry Conditions: Booleans for ML Model Position Entries\n//startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend\n//startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend\n//endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTrad\n//endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortT\n//bullish := close > ema200\n//bearish := close < ema200\nbought = strategy.position_size > 0\nsold = strategy.position_size < 0\nbuy  = startLongTrade\nsell = startShortTrade\nvar float total_commissions_value = 0\nvar float commission_value_l = 0\nvar float commission_value_s = 0\nvar float sl_long = na\nvar float sl_short = na \nvar float be_long = na\nvar float be_short = na\nvar float tp_long = na\nvar float tp_short = na\nvar int totaltrades = 0\nclose_withsupertrend = input.bool(defval = true, title = \"Close positions with supertrend ?\"\ncloseshort_supertrend=ta.crossover(close, supertrend)\ncloselong_supertrend=ta.crossunder(close, supertrend)\nif not bought\n    be_long:=na\n    sl_long:=na\n    tp_long:=na\nif not sold\n    be_short:=na\n    sl_short:=na\n    tp_short:=na\nlong_positions = input.bool(defval = true, title = \"Long positions ?\", group = \"============ Positions management ============\"\nshort_positions = input.bool(defval = true, title = \"Short positions ?\", group = \"============ Positions management ============\"\nuse_takeprofit = input.bool(defval = true, title = \"Use take profit ?\", group = \"============ Risk management for trades =========\nuse_breakeven = input.bool(defval = true, title = \"Use break even ?\", group = \"============ Risk management for trades =========\nclose_only_tp = input.bool(defval = false, title = \"Close just with take profit ?\"\nema_filter_long = input.bool(defval = true, title = \"Ema filter for long positions ?\"\nema_filter_short = input.bool(defval = true, title = \"Ema filter for short positions ?\"\ncommission_percent = input.float(0.03, title = \"Commission value in %\", group = \"============ Positions management ============\"\nif fixed_amounts\n    commission_value_l := (close * (long_amount) * (commission_percent/100))\n    commission_value_s := (close * (short_amount) * (commission_percent/100))\nif not fixed_amounts\n    commission_value_l := (close * ((strategy_contracts * (risk / 100)) / distance_sl_long\n    commission_value_s := (close * ((strategy_contracts * (risk / 100)) / distance_sl_short\n// ======================= Strategy ================================================================\n// Long position with take profit\nif not bought and buy and date and long_positions and inSession(timeSession) and use_takeprofit\n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    tp_long:=close+(long_stoploss_distance*risk_reward_take_profit_long)\n    total_commissions_value += commission_value_l\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long and use_breakeven\n    sl_long := strategy.position_avg_price\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0 and not close_only_tp or bought and closelong_supertrend\n    strategy.close(\"L\", comment=\"CL\")\n    balance := balance + strategy.openprofit\n// Long position without take profit\nif not bought and buy and date and long_positions and inSession(timeSession) and not\n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    total_commissions_value += commission_value_l\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long and use_breakeven\n    sl_long := strategy.position_avg_price\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0\n    strategy.close(\"L\", comment=\"CL\")\n    balance := balance + strategy.openprofit\n// Short position with take profit\nif not sold and sell and date and short_positions and inSession(timeSession) and use_takeprofit\n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    tp_short:=((short_stoploss_distance*risk_reward_take_profit_short)-close)*-1\n    total_commissions_value += commission_value_s\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short and use_breakeven\n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short) \nif sold and buy and strategy.openprofit>0 and not close_only_tp or sold and closeshort_supertrend\n    strategy.close(\"S\", comment=\"CS\") \n    balance := balance + strategy.openprofit\n// Short position without take profit\nif not sold and sell and date and short_positions and inSession(timeSession) and not\n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    total_commissions_value += commission_value_s\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short and use_breakeven\n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)   \nif sold and buy and strategy.openprofit>0\n    strategy.close(\"S\", comment=\"CS\") \n    balance := balance + strategy.openprofit\n// =================================================================================================\n// Long position with ema filter \n// With take profit\nif not bought and buy and date and long_positions and inSession(timeSession) and use_takeprofit\n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    tp_long:=close+(long_stoploss_distance*risk_reward_take_profit_long)\n    total_commissions_value += commission_value_l\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long and use_breakeven\n    sl_long := strategy.position_avg_price\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0 and not close_only_tp or bought and closelong_supertrend\n    strategy.close(\"L\", comment=\"CL\")\n    balance := balance + strategy.openprofit\n// Without take profit\nif not bought and buy and date and long_positions and inSession(timeSession) and bullish\n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    total_commissions_value += commission_value_l\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long and use_breakeven\n    sl_long := strategy.position_avg_price\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0\n    strategy.close(\"L\", comment=\"CL\")\n    balance := balance + strategy.openprofit\n// Short positon with ema filter \n// With take profit\nif not sold and sell and date and short_positions and inSession(timeSession) and use_takeprofit\n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    tp_short:=((short_stoploss_distance*risk_reward_take_profit_short)-close)*-1\n    total_commissions_value += commission_value_s\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short and use_breakeven\n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short) \nif sold and buy and strategy.openprofit>0 and not close_only_tp or sold and closeshort_supertrend\n    strategy.close(\"S\", comment=\"CS\") \n    balance := balance + strategy.openprofit\n// Without take profit\nif not sold and sell and date and short_positions and inSession(timeSession) and bearish\n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    total_commissions_value += commission_value_s\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short and use_breakeven\n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)   \nif sold and buy and strategy.openprofit>0\n    strategy.close(\"S\", comment=\"CS\") \n    balance := balance + strategy.openprofit\n// =================================================================================================\n// ---------- Draw positions and signals on chart (strategy as an indicator) -------------\nif high>tp_long\n    tp_long:=na\nif low<tp_short\n    tp_short:=na\nif high>be_long\n    be_long:=na\nif low<be_short\n    be_short:=na\nshow_position_on_chart = input.bool(defval=true, title=\"Draw position on chart ?\",\nposition_price = plot(show_position_on_chart? strategy.position_avg_price : na, style\nsl_long_price = plot(show_position_on_chart and bought ? sl_long : na, style = plot.style_linebr\nsl_short_price = plot(show_position_on_chart and sold ? sl_short : na, style = plot.style_linebr\ntp_long_price = plot(bought and show_position_on_chart and use_takeprofit? tp_long\ntp_short_price = plot(sold and show_position_on_chart and use_takeprofit? tp_short\nbreakeven_long = plot(bought and high<be_long and show_position_on_chart and use_breakeven\nbreakeven_short = plot(sold and low>be_short and show_position_on_chart and use_breakeven\nshow_tpbe_on_chart = input.bool(defval=true, title=\"Draw first take profit/breakeven price on chart ?\nlong_stoploss_distance = close - longStopLoss\nshort_stoploss_distance=shortStopLoss - close\nbe_long_plot = close + long_stoploss_distance * risk_reward_breakeven_long\nbe_short_plot =((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\ntp_long_plot = close+(long_stoploss_distance*risk_reward_take_profit_long)\ntp_short_plot = ((short_stoploss_distance*risk_reward_take_profit_short)-close)*-1\nplot(show_tpbe_on_chart and buy and use_breakeven and bullish and ema_filter_long \nplot(show_tpbe_on_chart and sell and use_breakeven and bearish and ema_filter_short\nplot(show_tpbe_on_chart and buy and use_takeprofit and bullish and ema_filter_long\nplot(show_tpbe_on_chart and sell and use_takeprofit and bearish and ema_filter_short\nplot(show_stoploss and buy and bullish and ema_filter_long or show_stoploss and buy\nplot(show_stoploss and sell and bearish and ema_filter_short or show_stoploss and \nposition_profit_long = plot(bought and show_position_on_chart and strategy.openprofit\nposition_profit_short = plot(sold and show_position_on_chart and strategy.openprofit\nfill(plot1 = position_price, plot2 = position_profit_long, color =  color.new(#4cd350\nfill(plot1 = position_price, plot2 = position_profit_short, color =  color.new(#4cd350\nfill(plot1 = position_price, plot2 = sl_long_price, color =  color.new(color.red,\nfill(plot1 = position_price, plot2 = sl_short_price, color =  color.new(color.red\nfill(plot1 = position_price, plot2 = tp_long_price, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = tp_short_price, color =  color.new(color.green\nshow_signals = input.bool(defval=true, title=\"Show signals on chart ?\", group = \"============ Appearance ============\"\nplotshape(show_signals and buy and bullish and ema_filter_long or show_signals and\nplotshape(show_signals and sell and bearish and ema_filter_long or show_signals and\nplotshape(show_signals and closelong_supertrend and close_withsupertrend and bought\nplotshape(show_signals and closeshort_supertrend and close_withsupertrend and sold\n// =================================================================================================\n// --------------- Positions amount calculator  -------------\ncontracts_amount_c = initial_actual_capital / close\ndistance_sl_long_c = -1 * (longStopLoss - close) / close \ndistance_sl_short_c = (shortStopLoss - close) / close\nlong_amount_c = close * (contracts_amount_c * (risk_c / 100) / distance_sl_long_c)\nshort_amount_c = close * (contracts_amount_c * (risk_c / 100) / distance_sl_short_c\nlong_amount_lev = close * (contracts_amount_c * (risk_c / 100) / distance_sl_long_c\nshort_amount_lev = close * (contracts_amount_c * (risk_c / 100) / distance_sl_short_c\nleverage_for_calculator=input.bool(defval=true, title=\"Use leverage ?\", group = \"============ Position amount calculator =========\nif not leverage_for_calculator and long_amount_lev>initial_actual_capital\n    long_amount_lev:=initial_actual_capital\nif not leverage_for_calculator and short_amount_lev>initial_actual_capital\n    short_amount_lev:=initial_actual_capital\nplot(buy and leverage_for_calculator ? long_amount_c : na, color =  color.rgb(255\nplot(sell and leverage_for_calculator ? short_amount_c : na, color =  color.rgb(255\nplot(buy and not leverage_for_calculator ? long_amount_lev : na, color =  color.rgb\nplot(sell and not leverage_for_calculator ? short_amount_lev : na, color =  color.rgb\n// =================================================================================================\n// ===================== Drawing stats about add and withdraw money frequently and others on chart =\nif not bought and buy and date and not ema_filter_long\n    totaltrades += 1\nif not sold and sell and date and not ema_filter_short\n    totaltrades += 1\nif not bought and buy and date and bearish and ema_filter_long\n    totaltrades += 0\nif not sold and sell and date and bullish and ema_filter_short\n    totaltrades += 0\nif not bought and buy and date and bullish and ema_filter_long\n    totaltrades += 1\nif not sold and sell and date and bearish and ema_filter_short\n    totaltrades += 1\ntotal_money_added = initial_capital_a - strategy.initial_capital\ntotal_money_withdrawn = initial_capital_w - strategy.initial_capital\nfinal_money = total_money_added + strategy.netprofit + strategy.initial_capital - \n// plot(commission_value_l, color = color.rgb(59, 245, 255), display = display.all - display.pane)\n// plot(commission_value_s, color = color.rgb(59, 245, 255), display = display.all - display.pane)\n// plot(total_commissions_value, color = color.rgb(252, 59, 255), display = display.all - display.pa\n// plot(total_trades/2, color = color.rgb(59, 245, 255), display = display.all - display.pane)\n// plot(final_money, color = color.yellow, display = display.all - display.pane)\n// plot(total_money_added, color = color.blue, display = display.all - display.pane)\n// plot(total_money_withdrawn, color = color.red, display = display.all - display.pane)\n// plot(strategy.netprofit, color = color.green, display = display.all - display.pane)\ntruncate(_number, _decimalPlaces) =>\n    _factor = math.pow(10, _decimalPlaces)\n    int(_number * _factor) / _factor\ndraw_stats = input.bool(true, \"Show stats from add/withdraw money frequently ?\", group\n// Prepare stats table \nvar table testTable = table.new(position.top_right, 5, 2, border_width=2, frame_color\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor,_size,_tooltip\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n    // Draw stats table\nvar bgcolor =  color.new(#2f5cda, 50)\nvar bgcolor2 =  color.new(color.green, 50)\nvar bgcolor3 =  color.new(color.red,50)\nif draw_stats\n    if barstate.islastconfirmedhistory\n        f_fillCell(testTable, 0, 0, \"Final/current money:\", \"$\" + str.tostring(truncate\n        f_fillCell(testTable, 0, 1, \"Total money added:\", \"$\" + str.tostring(truncate\n        f_fillCell(testTable, 1, 0, \"Total money withdrawn:\", \"$\" + str.tostring(truncate\n        f_fillCell(testTable, 1, 1, \"Total return:\", \"$\" + str.tostring(truncate(strategy.netprofit\n        f_fillCell(testTable, 2, 0, \"Total trades:\", \"\" + str.tostring(truncate(totaltrades\n        f_fillCell(testTable, 2, 1, \"Total commissions value:\", \"\" + str.tostring(\n// ===================================================================== :D"}]}
{"messages": [{"role": "user", "content": "This is a simple strategy script based on Bollinger Bands pullbacks. The strategy is simple, as follows: For LONGS: At the close of any candle, it check to see if this candle is an UP candle where the low broke below the lower Bollinger Band. If so, we call this the trigger candle. For the next bar, we issue a BUY signal if the price breaks above the high of the trigger candle. The stoploss is the low of the trigger candle. We take profit when the price goes above the middle Bollinger Band (the mean/average line). For SHORTS: At the close of any candle, it check to see if this candle is an DOWN candle where the high broke above the upper Bollinger Band. If so, we call this the trigger candle. For the next bar, we issue a SELL signal if the price breaks below the low of the trigger candle. The stoploss is the high of the trigger candle. We take profit when the price goes below the middle Bollinger Band (the mean/average line)."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 westofpluto\n//@version=5\nstrategy(\"BBPullback\", overlay=true, margin_long=100, margin_short=100,process_orders_on_close\nTAKE_PROFIT_HILO = 0\nTAKE_PROFIT_CLOSE = 1\nTAKE_PROFIT_BB = 2\nOPTION0 = \"high crosses MA\"\nOPTION1 = \"closes beyond MA\"\nOPTION2 = \"high crosses opposite band\"\ntpoption=input.string(OPTION0,title=\"Take Proft trigger\",options=[OPTION0,OPTION1,\ni_from = input.time(defval = timestamp(\"23 Feb 2023 00:00 +0000\"), title = \"From\")\ni_thru = input.time(defval = timestamp(\"09 Apr 2023 00:00 +0000\"), title = \"Thru\")\nvar take_profit_option=TAKE_PROFIT_HILO\nif tpoption == OPTION0\n    take_profit_option := TAKE_PROFIT_HILO\nelse if tpoption == OPTION1\n    take_profit_option := TAKE_PROFIT_CLOSE\nelse\n    take_profit_option := TAKE_PROFIT_BB\n//\n// COMPUTE BOLLINGER BANDS INTERNALLY    \n//\nsource = close\nlength = 20\nmult = 2.0\nbasis = ta.sma(source, length)\ndev = mult * ta.stdev(source, length)\nupperBBValue = basis + dev\nlowerBBValue = basis - dev\nNO_SETUP = 0\nBB_BREAK_DOWN = 1\nRETRACE_BAR_UP = 2\nPENDING_ENTRY_LONG = 3\nENTRY_LONG = 4\nBB_BREAK_UP = 5\nRETRACE_BAR_DOWN = 6\nPENDING_ENTRY_SHORT = 7\nENTRY_SHORT = 8\nID_STATE = 0\nID_BUY_ENTRY = 0\nID_SELL_ENTRY = 1\nID_BUY_STOPLOSS = 2\nID_SELL_STOPLOSS = 3\nID_SWING_HIGH = 4\nID_SWING_LOW = 5\nLARGE_NUMBER = 99999999.9\nvar state = NO_SETUP\nvar buy_entry_price = 0.0\nvar sell_entry_price = 0.0\nvar buy_stoploss_price = 0.0\nvar sell_stoploss_price = 0.0\nvar swing_low = LARGE_NUMBER\nvar swing_high = 0.0\nvar themax = 0.0\nvar themin = 99999999.0\n//global_float = array.new_bool(1)\n//array.set(global_bool,ID_TRENDMODEON,trendMode)\nglobal_int = array.new_int(1)\narray.set(global_int,ID_STATE,state)\nglobal_float = array.new_float(6)\narray.set(global_float,ID_BUY_ENTRY,buy_entry_price)\narray.set(global_float,ID_SELL_ENTRY,sell_entry_price)\narray.set(global_float,ID_BUY_STOPLOSS,buy_stoploss_price)\narray.set(global_float,ID_SELL_STOPLOSS,sell_stoploss_price)\narray.set(global_float,ID_SWING_HIGH,swing_high)\narray.set(global_float,ID_SWING_LOW,swing_low)\n//\n// Main code starts here, executes every bar\n//\ndateok() => \n    time >= i_from and time <= i_thru \nminval(x, y) =>\n    (x < y ? x : y)\nmaxval(x, y) =>\n    (x > y ? x : y)\nIsFlat() =>\n    strategy.position_size == 0\nHasPosition() =>\n    strategy.position_size != 0\nPullbackCandleLong() =>\n    close >= open or low > low[1]\nPullbackCandleShort() =>\n    close <= open or high < high[1]\nisUpCandle() =>\n    close >= open\nisDownCandle() =>\n    open > close\nStateInTrade() =>\n    array.get(global_int,ID_STATE) == ENTRY_LONG or array.get(global_int,ID_STATE)\nStatePendingLong() =>\n    array.get(global_int,ID_STATE) == PENDING_ENTRY_LONG\nStatePendingShort() =>\n    array.get(global_int,ID_STATE) == PENDING_ENTRY_SHORT\nStateInLongTrade() =>\n    array.get(global_int,ID_STATE) == ENTRY_LONG\nStateInShortTrade() =>\n    array.get(global_int,ID_STATE) == ENTRY_SHORT\nLongTakeProfitHigh() =>\n    high > basis\nShortTakeProfitLow() =>\n    low < basis\nLongTakeProfitClose() =>\n    close > basis\nShortTakeProfitClose() =>\n    close < basis\nLongTakeProfitBB() =>\n    high > upperBBValue\nShortTakeProfitBB() =>\n    low < lowerBBValue\nLongTakeProfitHit() =>\n    if take_profit_option == TAKE_PROFIT_HILO\n        LongTakeProfitHigh()\n    else if take_profit_option == TAKE_PROFIT_CLOSE\n        LongTakeProfitClose()\n    else\n        LongTakeProfitBB()\nShortTakeProfitHit() =>\n    if take_profit_option == TAKE_PROFIT_HILO\n        ShortTakeProfitLow()\n    else if take_profit_option == TAKE_PROFIT_CLOSE\n        ShortTakeProfitClose()\n    else\n        ShortTakeProfitBB()\nLongTriggerCondition() =>\n    if (dateok() and isUpCandle() and minval(open,close) < lowerBBValue and high <\n        true\n    else\n        false\nShortTriggerCondition() =>\n    if (dateok() and isDownCandle() and maxval(open,close) > upperBBValue and low \n        true\n    else\n        false\nif (HasPosition() and StatePendingLong())\n    array.set(global_int,ID_STATE,ENTRY_LONG)\nelse if (HasPosition() and StatePendingShort())\n    array.set(global_int,ID_STATE,ENTRY_SHORT)\nelse if (IsFlat() and StateInTrade()) \n    array.set(global_int,ID_STATE,NO_SETUP)\n//\n// If an order didn't trigger this bar then cancel it\n//\nvar cancel_long=false\nvar cancel_short=false\nif IsFlat()\n    if (array.get(global_int,ID_STATE) == PENDING_ENTRY_LONG)\n        cancel_long := true\n        strategy.cancel(\"Enter Long\")\n        array.set(global_int,ID_STATE,NO_SETUP)\n    else if (array.get(global_int,ID_STATE) == PENDING_ENTRY_SHORT)\n        cancel_short := true\n        strategy.cancel(\"Enter Short\")\n        array.set(global_int,ID_STATE,NO_SETUP)\n//\n// Trading logic long\n//\nif IsFlat()\n    if (array.get(global_int,ID_STATE) == NO_SETUP) \n        if (LongTriggerCondition()) \n            //array.set(global_int,ID_STATE,BB_BREAK_DOWN)\n            array.set(global_float,ID_BUY_ENTRY,high)\n            if (cancel_long) \n                array.set(global_float,ID_SWING_LOW,minval(low,array.get(global_float\n            else\n                array.set(global_float,ID_SWING_LOW,low)\n                        array.set(global_float,ID_SWING_HIGH,0.0)\n            //array.set(global_float,ID_BUY_STOPLOSS,array.get(global_float,ID_SWING_LOW))\n            array.set(global_float,ID_BUY_STOPLOSS,low)\n            strategy.entry(\"Enter Long\", strategy.long,stop=array.get(global_float\n            array.set(global_int,ID_STATE,PENDING_ENTRY_LONG)\n            strategy.exit(\"Stop Out\",from_entry=\"Enter Long\",stop=array.get(global_float\n    else if (array.get(global_int,ID_STATE) == BB_BREAK_DOWN) \n        if (PullbackCandleLong())\n            array.set(global_float,ID_BUY_ENTRY,high)\n            array.set(global_float,ID_BUY_STOPLOSS,low)\n            strategy.entry(\"Enter Long\", strategy.long,stop=array.get(global_float\n            array.set(global_int,ID_STATE,PENDING_ENTRY_LONG)\n    else if (array.get(global_int,ID_STATE) == PENDING_ENTRY_LONG) \n        strategy.cancel(\"Enter Long\")\n        array.set(global_int,ID_STATE,NO_SETUP)\n//if (array.get(global_int,ID_STATE) == PENDING_ENTRY_LONG) \n//    strategy.exit(\"Stop Out\",from_entry=\"Enter Long\",stop=array.get(global_float,ID_BUY_STOPLOSS))\n//\n// Trading logic short\n//\nif IsFlat()\n    if (array.get(global_int,ID_STATE) == NO_SETUP) \n        if (ShortTriggerCondition())\n            //array.set(global_int,ID_STATE,BB_BREAK_UP)\n            array.set(global_float,ID_SELL_ENTRY,low)\n            if (cancel_short) \n                array.set(global_float,ID_SWING_HIGH,maxval(high,array.get(global_float\n            else\n                array.set(global_float,ID_SWING_HIGH,high)\n            array.set(global_float,ID_SWING_LOW,LARGE_NUMBER)\n            //array.set(global_float,ID_SELL_STOPLOSS,array.get(global_float,ID_SWING_HIGH))\n            array.set(global_float,ID_SELL_STOPLOSS,high)\n            strategy.entry(\"Enter Short\", strategy.short,stop=array.get(global_float\n            array.set(global_int,ID_STATE,PENDING_ENTRY_SHORT)\n            strategy.exit(\"Stop Out\",from_entry=\"Enter Short\",stop=array.get(global_float\n    else if (array.get(global_int,ID_STATE) == BB_BREAK_UP)\n        if (PullbackCandleShort())\n            //array.set(global_int,ID_STATE,RETRACE_BAR_DOWN)\n            array.set(global_float,ID_SELL_ENTRY,low)\n            array.set(global_float,ID_SELL_STOPLOSS,high)\n            strategy.entry(\"Enter Short\", strategy.short,stop=array.get(global_float\n            array.set(global_int,ID_STATE,PENDING_ENTRY_SHORT)\n    else if (array.get(global_int,ID_STATE) == PENDING_ENTRY_SHORT) \n        strategy.cancel(\"Enter Short\")\n        array.set(global_int,ID_STATE,NO_SETUP)\n//if (array.get(global_int,ID_STATE) == PENDING_ENTRY_SHORT) \n//    strategy.exit(\"Stop Out\",from_entry=\"Enter Short\",stop=array.get(global_float,ID_SELL_STOPLOSS\nif StateInLongTrade()\n    if (LongTakeProfitHit()) \n        strategy.close(\"Enter Long\",comment=\"Take Profit\")\n        array.set(global_int,ID_STATE,NO_SETUP)\nelse if StateInShortTrade()\n    if (ShortTakeProfitHit())\n        strategy.close(\"Enter Short\",comment=\"Take Profit\")\n        array.set(global_int,ID_STATE,NO_SETUP)\nstate := array.get(global_int,ID_STATE)\nbuy_entry_price := array.get(global_float,ID_BUY_ENTRY)\nsell_entry_price := array.get(global_float,ID_SELL_ENTRY)\nbuy_stoploss_price := array.get(global_float,ID_BUY_STOPLOSS)\nsell_stoploss_price := array.get(global_float,ID_SELL_STOPLOSS)\nthemin := minval(open,close)\nthemax := maxval(open,close)\nplotchar(state, \"State\", \"\", location = location.top)\nplotchar(themin, \"TheMin\", \"\", location = location.top)\nplotchar(themax, \"TheMax\", \"\", location = location.top)\nplotchar(upperBBValue, \"UpperBB\", \"\", location = location.top)\nplotchar(lowerBBValue, \"LowerBB\", \"\", location = location.top)\nplotchar(buy_stoploss_price, \"buy stoploss\", \"\", location = location.top)\nplotchar(sell_stoploss_price, \"sell stoploss\", \"\", location = location.top)\nswing_low := array.get(global_float,ID_SWING_LOW)\nplotchar(swing_low, \"SwingLow\", \"\", location = location.top)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                        Debugging Strategy Update: - The software update resulted in no change in strategy.  - I rewrote some code and we don't get any suggestion or error anymore                                                    Release Notes:                        Strategy Update:  What changed in this update ? - Users will now be able to open transactions in the direction they want,  - For example, users who want to do DCA in a falling market can only choose the LONG direction and automatically lower their average and sell automatically when the price is on the rise.  - In the other situation, users can open and close their transactions in parts by choosing the SHORT direction in the extremely rising market.  - If the price is in the consolidation phase, they can choose the BOTH direction and earn money from the small rises and falls of the price.                                                    Release Notes:                        Small Update: I encountered an error while trading automatically. If the quantities we receive are too small, we encounter an error in the stock market. To avoid this situation, I added a code snippet that automatically adjusts the amount of product we buy according to price conditions.                                                    Release Notes:                                                    First of all I want to say thank you my Indian friends Abdul and Sunny for their ideas. What changed in this update ?  1 - Firstly who want to use stop loss then they should activate button \"Use StopLoss\" 2-We can CLOSE our grid bot after stop loss. With button \"Close Bot After Stop Loss\" With help of this option were are not constantly open and stop our positions when the price very close on the range high or range low region.  People who want to use this feature could activate this button while setting up their bots and avoid being stopped repeatedly. 3-For users who want to use stop loss, we have considered range high and range low levels by default, but some users may want to set stop levels above range high or below range low. IF users want to enter their own levels, they need to DEactivate the \"Use Stop Loss Where HIGH and LOW GRID PRICE\" button and then enter the desired levels. Let's make two examples together First example Second example                             Release Notes:                        First of all, I want to say thank you to my Polish friend Greg for his ideas and helps.  What changed in this update ? 1 - I added to table to show us \"Open Positions\", \"Open profit\", \"Total trades\", \"Total profit\", \"Current equity\" (With the help of this table, we can quickly check the features shown in the table while setting our strategy.) 2- We can open and close table with button \"Show Table\" 3 - We can change location of table 4 - We can change size of table"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 lovealgotrading\n// First of all I want to say thank you to \u00a9 thequantscience. \n//@version=5\nstrategy(\n     title = 'AUTOMATIC GRID BOT STRATEGY [lovealgotrading]', \n     overlay = true,\n     commission_type = strategy.commission.percent, \n     commission_value = 0.075, \n     pyramiding = 20,\n     default_qty_type = strategy.percent_of_equity,\n     close_entries_rule = 'ANY',\n     initial_capital = 1000\n     )\n/////////////////////////////// ALGORITHM BACKTEST SOURCE CODE ////////////////////////////////////\nstartDate  = input.time(defval=timestamp('1 nov 2022 13:30 +0000'), title='Start_Date'\nendDate = input.time(defval=timestamp('20 oct  2030 13:30 +0000'), title='End_Date'\ninDateRange  = time > startDate  and time < endDate\nhigh_price = input.price(\n      defval = 0.00, \n      title = 'Range High price: ',\n      group = \" ############## \u27a1\ufe0f HIGH GRID PRICE  \u2b05\ufe0f ############ \", \n      confirm = true,\n      tooltip = \"Top grid price.\"\n      )\nlow_price = input.price(\n      defval = 0.00, \n      title = 'Range Low price: ',\n      group = \" ############## \u27a1\ufe0f LOW GRID PRICE  \u2b05\ufe0f ############# \", \n      confirm = true,\n      tooltip = \"Bottom grid price.\"\n      )\n// ###########################################################################################\ntrade_direction = input.string(title='Trade Direction', group = \" ##############\ud83c\udfaf TRADE DIRECTION \ud83c\udfaf############# \n// ###########################################################################################\nuse_stop = input.bool(defval = false , title = \"Use StopLoss\", group = \" ############# \u26d4\ufe0f Strategy STOP Settings \u26d4\ufe0f \nclose_bot_after_stop = input.bool(defval = false , title = \"Close Bot After Stop Loss\"\nstop_close_all = \"\"\nif stop_close_all[1] != \"\" and close_bot_after_stop\n    stop_close_all := \"DONT\"\nuse_stop_default = input.bool(defval = true , title = \"Use StopLoss Where HIGH and LOW GRID PRICE\"\nhigh_price_stop = input.price(\n      defval = 99999, \n      title = 'High STOP Price: ',\n      group =  \" ############# \u26d4\ufe0f Strategy STOP Settings \u26d4\ufe0f ############ \", \n      confirm = false,\n      tooltip = \"Top STOP price.\"\n      )\nlow_price_stop = input.price(\n      defval = 0.00, \n      title = 'Low STOP Price: ',\n      group =  \" ############# \u26d4\ufe0f Strategy STOP Settings \u26d4\ufe0f ############ \", \n      confirm = false,\n      tooltip = \"Bottom STOP price.\"\n      )\nif use_stop_default \n    high_price_stop := high_price\n    low_price_stop := low_price\n// ###########################################################################################\ndolar = input.int(defval = 100, title = \"$ Per Position\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 \n// ###########################################################################################\nLong_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\nLong_Exit_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\nLong_Stop_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\nShort_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\nShort_Exit_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\nShort_Stop_message = input(\"\", group = \" ############# \ud83e\udd16 ALGO TRADE ALERTS \ud83e\udd16 ############ \"\n// ###########################################################################################\nfloat qty_new = dolar / close \nif close > 5000 \n    qty_new :=  math.round(dolar / close, 3)\nelse if close < 5000 and close > 200\n    qty_new :=  math.round(dolar / close, 2)\nelse if close < 200 and close > 50\n    qty_new :=  math.round(dolar / close, 1)\nelse if close < 50\n    qty_new :=  math.round(dolar / close, 0)\n// ###########################################################################################\nten_grid = input.bool(\n     defval = false,\n     title = \"10 grid levels\",\n     group = \" ############ GRID CONFIGURATION ############ \",\n     tooltip = \"10 grid levels\",\n     confirm = true\n     )\ntewnty_grid = input.bool(\n     defval = true,\n     title = \"20 grid levels\",\n     group = \" ############ GRID CONFIGURATION ############ \",\n     tooltip = \"20 grid levels\",\n     confirm = true\n     )\n// ###########################################################################################\nshow_stop_res = input.bool(true, title = \"Show Stop Price\",group = \" ############# \ud83d\udcc8 Graphics Settings \ud83d\udcc8 \nshow_grid_level_bg = input.bool(true, title = \"Show Grid Levels BG\",group = \" ############# \ud83d\udcc8 Graphics Settings \ud83d\udcc8 \n// ###########################################################################################\ngrid_range = high_price - low_price\npercent_change = ((high_price - low_price) / low_price) * (1.00 / 9.00)\nvar float grid_1 = 0\nvar float grid_2 = 0\nvar float grid_3 = 0\nvar float grid_4 = 0\nvar float grid_5 = 0\nvar float grid_6 = 0\nvar float grid_7 = 0\nvar float grid_8 = 0\nvar float grid_9 = 0\nvar float grid_10 = 0\nvar float grid_11 = 0\nvar float grid_12 = 0\nvar float grid_13 = 0\nvar float grid_14 = 0\nvar float grid_15 = 0\nvar float grid_16 = 0\nvar float grid_17 = 0\nvar float grid_18 = 0\nvar float grid_19 = 0\nvar float grid_20 = 0\nvar float factor = 0 \nlong_1 = false\nlong_2 = false\nlong_3 = false\nlong_4 = false\nlong_5 = false\nlong_6 = false\nlong_7 = false\nlong_8 = false\nlong_9 = false\nlong_10 = false\nshort_1 = false\nshort_2 = false\nshort_3 = false\nshort_4 = false\nshort_5 = false\nshort_6 = false\nshort_7 = false\nshort_8 = false\nshort_9 = false\nshort_10 = false\nif ten_grid == true\n    percent_change := ((high_price - low_price) / low_price) * (1.00 / 9.00)\n    factor := grid_range / 9\n    grid_1 := (high_price) \n    grid_2 := (high_price - (factor * 1)) \n    grid_3 := (high_price - (factor * 2)) \n    grid_4 := (high_price - (factor * 3)) \n    grid_5 := (high_price - (factor * 4)) \n    grid_6 := (high_price - (factor * 5)) \n    grid_7 := (high_price - (factor * 6)) \n    grid_8 := (high_price - (factor * 7)) \n    grid_9 := (high_price - (factor * 8))\n    grid_10 := (low_price)\n    long_1 := ta.crossunder(close, ((grid_5+grid_6)/2)) \n    long_2 := ta.crossunder(close, ((grid_6+grid_7)/2)) \n    long_3 := ta.crossunder(close, ((grid_7+grid_8)/2)) \n    long_4 := ta.crossunder(close, ((grid_8+grid_9)/2)) \n    long_5 := ta.crossunder(close, ((grid_9+grid_10)/2)) \n    short_1 := ta.crossover(close, ((grid_6+grid_5)/2))\n    short_2 := ta.crossover(close, ((grid_5+grid_4)/2))\n    short_3 := ta.crossover(close, ((grid_4+grid_3)/2))\n    short_4 := ta.crossover(close, ((grid_3+grid_2)/2))\n    short_5 := ta.crossover(close, ((grid_2+grid_1)/2))\nif tewnty_grid == true\n    percent_change := ((high_price - low_price) / low_price) * (1.00 / 19.00)\n    factor := grid_range / 19\n    grid_1 := (high_price) \n    grid_2 := (high_price - (factor * 1)) \n    grid_3 := (high_price - (factor * 2)) \n    grid_4 := (high_price - (factor * 3)) \n    grid_5 := (high_price - (factor * 4)) \n    grid_6 := (high_price - (factor * 5)) \n    grid_7 := (high_price - (factor * 6)) \n    grid_8 := (high_price - (factor * 7)) \n    grid_9 := (high_price - (factor * 8)) \n    grid_10 := (high_price - (factor * 9)) \n    grid_11 := (high_price - (factor * 10)) \n    grid_12 := (high_price - (factor * 11)) \n    grid_13 := (high_price - (factor * 12)) \n    grid_14 := (high_price - (factor * 13)) \n    grid_15 := (high_price - (factor * 14)) \n    grid_16 := (high_price - (factor * 15)) \n    grid_17 := (high_price - (factor * 16)) \n    grid_18 := (high_price - (factor * 17)) \n    grid_19 := (high_price - (factor * 18))\n    grid_20 := (low_price)\n    long_1 := close < ((grid_10+grid_11)/2)\n    long_2 := close < ((grid_11+grid_12)/2)\n    long_3 := close < ((grid_12+grid_13)/2)\n    long_4 := close < ((grid_13+grid_14)/2)\n    long_5 := close < ((grid_14+grid_15)/2) \n    long_6 := close < ((grid_15+grid_16)/2) \n    long_7 := close < ((grid_16+grid_17)/2) \n    long_8 := close < ((grid_17+grid_18)/2) \n    long_9 := close < ((grid_18+grid_19)/2) \n    long_10 := close < ((grid_19+grid_20)/2) \n    short_10 := close >((grid_1+grid_2)/2)\n    short_9 := close >((grid_2+grid_3)/2)\n    short_8 := close >((grid_3+grid_4)/2)\n    short_7 := close >((grid_4+grid_5)/2)\n    short_6 := close >((grid_5+grid_6)/2)\n    short_5 := close >((grid_6+grid_7)/2)\n    short_4 := close >((grid_7+grid_8)/2)\n    short_3 := close >((grid_8+grid_9)/2)\n    short_2 := close >((grid_9+grid_10)/2)\n    short_1 := close > ((grid_10+grid_11)/2)\n// ###########################################################################################\n// ###########################################################################################\nif ten_grid and ( trade_direction == 'LONG' or trade_direction == 'BOTH')\n    if long_1 and strategy.opentrades == 0  and inDateRange  and stop_close_all ==\n        strategy.entry(id = \"L_1\",  direction =   strategy.long,alert_message = Long_message\n             if strategy.opentrades == 1 \n        strategy.exit(id = \"E_1\",from_entry = \"L_1\", qty_percent = 100,alert_message\n               if long_2 and strategy.opentrades == 1  and inDateRange    and stop_close_all \n        strategy.entry(id = \"L_2\",   direction =   strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 2\n        strategy.exit(id = \"E_2\",from_entry = \"L_2\", qty_percent = 100,alert_message\n               if long_3 and strategy.opentrades == 2  and inDateRange  and stop_close_all ==\n        strategy.entry(id = \"L_3\",  direction =   strategy.long,alert_message = Long_message\n                        if strategy.opentrades == 3\n        strategy.exit(id = \"E_3\",from_entry = \"L_3\", qty_percent = 100,alert_message\n                if long_4 and strategy.opentrades == 3  and inDateRange    and stop_close_all \n        strategy.entry(id = \"L_4\",  direction =   strategy.long,alert_message = Long_message\n                                    if strategy.opentrades == 4\n        strategy.exit(id = \"E_4\",from_entry = \"L_4\", qty_percent = 100,alert_message\n                if long_5 and strategy.opentrades == 4  and inDateRange  and stop_close_all ==\n        strategy.entry(id = \"L_5\",   direction =   strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 5\n        strategy.exit(id = \"E_5\",from_entry = \"L_5\", qty_percent = 100,alert_message\n    // ###########################################################################################\nif ten_grid and ( trade_direction == 'SHORT' or trade_direction == 'BOTH')\n    if short_1 and strategy.opentrades == 0  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_1\",  direction =  strategy.short,alert_message = Short_message\n                            if strategy.opentrades == 1\n        strategy.exit(id = \"ES_1\",from_entry = \"S_1\", qty_percent = 100,alert_message\n                if short_2 and strategy.opentrades == 1  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_2\",direction =  strategy.short,alert_message = Short_message\n                                if strategy.opentrades == 2\n        strategy.exit(id = \"ES_2\",from_entry = \"S_2\", qty_percent = 100,alert_message\n                if short_3 and strategy.opentrades == 2  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_3\",   direction =  strategy.short,alert_message = Short_message\n                                   if strategy.opentrades == 3 \n        strategy.exit(id = \"ES_3\",from_entry = \"S_3\", qty_percent = 100,alert_message\n                if short_4 and strategy.opentrades == 3  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_4\",   direction =  strategy.short,alert_message = Short_message\n                                        if strategy.opentrades == 4 \n        strategy.exit(id = \"ES_4\",from_entry = \"S_4\", qty_percent = 100,alert_message\n                if short_5 and strategy.opentrades == 4  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_5\",  direction =  strategy.short,alert_message = Short_message\n                        if strategy.opentrades == 5 \n        strategy.exit(id = \"ES_5\",from_entry = \"S_5\", qty_percent = 100,alert_message\n    // ###########################################################################################\n// ###########################################################################################\nlong_exit_price = str.tostring(math.round_to_mintick(close*(1+percent_change)))\nshort_exit_price = str.tostring(math.round_to_mintick(close*(1-percent_change))) \nif  tewnty_grid and close > low_price and ( trade_direction == 'LONG' or trade_direction\n    if long_1 and strategy.opentrades == 0  and inDateRange  and stop_close_all ==\n        strategy.entry(id = \"L_1\",  direction =  strategy.long,alert_message = Long_message\n             if strategy.opentrades == 1 \n        strategy.exit(id = \"E_1\",from_entry = \"L_1\", qty_percent = 100,alert_message\n               if long_2 and strategy.opentrades == 1  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_2\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 2\n        strategy.exit(id = \"E_2\",from_entry = \"L_2\", qty_percent = 100,alert_message\n               if long_3 and strategy.opentrades == 2  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_3\",  direction =  strategy.long,alert_message = Long_message\n                        if strategy.opentrades == 3\n        strategy.exit(id = \"E_3\",from_entry = \"L_3\", qty_percent = 100,alert_message\n                if long_4 and strategy.opentrades == 3  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_4\",  direction =  strategy.long,alert_message = Long_message\n                                    if strategy.opentrades == 4\n        strategy.exit(id = \"E_4\",from_entry = \"L_4\", qty_percent = 100,alert_message\n                if long_5 and strategy.opentrades == 4  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_5\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 5\n        strategy.exit(id = \"E_5\",from_entry = \"L_5\", qty_percent = 100,alert_message\n        if long_6 and strategy.opentrades == 5  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_6\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 6\n        strategy.exit(id = \"E_6\",from_entry = \"L_6\", qty_percent = 100,alert_message\n        if long_7 and strategy.opentrades == 6  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_7\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 7\n        strategy.exit(id = \"E_7\",from_entry = \"L_7\", qty_percent = 100,alert_message\n        if long_8 and strategy.opentrades == 7  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_8\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 8\n        strategy.exit(id = \"E_8\",from_entry = \"L_8\", qty_percent = 100,alert_message\n        if long_9 and strategy.opentrades == 8  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_9\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 9\n        strategy.exit(id = \"E_9\",from_entry = \"L_9\", qty_percent = 100,alert_message\n                         if long_10 and strategy.opentrades == 9  and inDateRange   and close < strategy.opentrades.entry_price\n        strategy.entry(id = \"L_10\",   direction =  strategy.long,alert_message = Long_message\n                       if strategy.opentrades == 10\n        strategy.exit(id = \"E_10\",from_entry = \"L_10\", qty_percent = 100,alert_message\n// ##### STOP LOSS CODES  #####\nif  use_stop and   low < low_price_stop and strategy.position_size > 0\n    strategy.close_all(alert_message =Long_Stop_message, immediately = true)\n    stop_close_all := \"DONT\"\n// ###########################################################################################\nif tewnty_grid and close < high_price and ( trade_direction == 'SHORT' or trade_direction\n    if short_1 and strategy.opentrades == 0  and inDateRange   and stop_close_all \n        strategy.entry(id = \"S_1\",  direction =  strategy.short,alert_message = Short_message\n                        if strategy.opentrades == 1\n        strategy.exit(id = \"ES_1\",from_entry = \"S_1\", qty_percent = 100,alert_message\n                if short_2 and strategy.opentrades == 1  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_2\",direction =  strategy.short,alert_message = Short_message\n                                       if strategy.opentrades == 2\n        strategy.exit(id = \"ES_2\",from_entry = \"S_2\", qty_percent = 100,alert_message\n                if short_3 and strategy.opentrades == 2  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_3\",   direction =  strategy.short,alert_message = Short_message\n                                    if strategy.opentrades == 3 \n        strategy.exit(id = \"ES_3\",from_entry = \"S_3\", qty_percent = 100,alert_message\n                if short_4 and strategy.opentrades == 3  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_4\",   direction =  strategy.short,alert_message = Short_message\n                                        if strategy.opentrades == 4 \n        strategy.exit(id = \"ES_4\",from_entry = \"S_4\", qty_percent = 100,alert_message\n                if short_5 and strategy.opentrades == 4  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_5\",  direction =  strategy.short,alert_message = Short_message\n                        if strategy.opentrades == 5 \n        strategy.exit(id = \"ES_5\",from_entry = \"S_5\", qty_percent = 100,alert_message\n            if short_6 and strategy.opentrades == 5  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_6\",  direction =  strategy.short,alert_message = Short_message\n                        if strategy.opentrades == 6 \n        strategy.exit(id = \"ES_6\",from_entry = \"S_6\", qty_percent = 100,alert_message\n            if short_7 and strategy.opentrades == 6  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_7\",  direction =  strategy.short,alert_message = Short_message\n    if strategy.opentrades == 7 \n        strategy.exit(id = \"ES_7\",from_entry = \"S_7\", qty_percent = 100,alert_message\n           if short_8 and strategy.opentrades == 7  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_8\",  direction =  strategy.short,alert_message = Short_message\n    if strategy.opentrades == 8 \n        strategy.exit(id = \"ES_8\",from_entry = \"S_8\", qty_percent = 100,alert_message\n        if short_9 and strategy.opentrades == 8  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_9\",  direction =  strategy.short,alert_message = Short_message\n    if strategy.opentrades == 9 \n        strategy.exit(id = \"ES_9\",from_entry = \"S_9\", qty_percent = 100,alert_message\n        if short_10 and strategy.opentrades == 9  and inDateRange   and close > strategy.opentrades.entry_price\n        strategy.entry(id = \"S_10\",  direction =  strategy.short,alert_message = Short_message\n    if strategy.opentrades == 10\n        strategy.exit(id = \"ES_10\",from_entry = \"S_10\", qty_percent = 100,alert_message\n// ###########################################################################################\nif  use_stop and  high > high_price_stop and strategy.position_size < 0\n    strategy.close_all(alert_message =Short_Stop_message, immediately = true)\n    stop_close_all := \"DONT\"\nbgcolor(stop_close_all == \"DONT\" and stop_close_all[1] != \"DONT\" ?  color.rgb(255\n//// ########################################################################\n// Plot Functions\nplot(strategy.position_size < 0 ? strategy.opentrades.entry_price(strategy.opentrades\nplot(strategy.position_size > 0 ? strategy.opentrades.entry_price(strategy.opentrades\nplot(inDateRange ? high_price_stop : na, color=  color.rgb(255, 37, 37), linewidth\nplot(inDateRange ? low_price_stop : na, color=  color.rgb(255, 34, 37), linewidth\nplot(inDateRange ? high_price : na, color=  color.rgb(0, 0, 0), linewidth =3 )\nplot(inDateRange ? low_price : na, color=  color.rgb(255, 255, 255), linewidth =3\nplot(inDateRange ? (high_price + low_price) / 2 : na , color=  color.rgb(0, 68, 255\n// ###########################################################################################\nvar float new_ten_grid_1 = na \nvar float new_ten_grid_2 = na \nvar float new_ten_grid_3 = na \nvar float new_ten_grid_4 = na \nvar float new_ten_grid_5 = na \nvar float new_ten_grid_6 = na \nvar float new_ten_grid_7 = na \nvar float new_ten_grid_8 = na \nvar float new_ten_grid_9 = na \nvar float new_ten_grid_10 = na \nif ten_grid == true and show_grid_level_bg and inDateRange \n    new_ten_grid_1 := grid_1\n    new_ten_grid_2 := grid_2\n    new_ten_grid_3 := grid_3\n    new_ten_grid_4 := grid_4\n    new_ten_grid_5 := grid_5\n    new_ten_grid_6 := grid_6\n    new_ten_grid_7 := grid_7\n    new_ten_grid_8 := grid_8\n    new_ten_grid_9 := grid_9\n    new_ten_grid_10 := grid_10\nelse if ten_grid == false\n    new_ten_grid_1 := na\n    new_ten_grid_2 := na\n    new_ten_grid_3 := na\n    new_ten_grid_4 := na\n    new_ten_grid_5 := na\n    new_ten_grid_6 := na\n    new_ten_grid_7 := na\n    new_ten_grid_8 := na\n    new_ten_grid_9 := na\n    new_ten_grid_10 := na\nfill(plot(inDateRange ? new_ten_grid_1 : na , color =  color.new(color.green, 90)\n     plot(inDateRange ? new_ten_grid_2 : na , color =  color.new(color.green, 90)\n         color =  color.new(color.green, 90))\nfill(plot(inDateRange ?  new_ten_grid_2 : na , color =  color.new(color.green, 85\n     plot(inDateRange ? new_ten_grid_3 : na , color =  color.new(color.green, 85)\n         color =  color.new(color.green, 85))\nfill(plot(inDateRange ? new_ten_grid_3 : na , color =  color.new(color.green, 80)\n     plot(inDateRange ? new_ten_grid_4 : na , color =  color.new(color.green, 80)\n         color =  color.new(color.green, 80))\nfill(plot(inDateRange ? new_ten_grid_4 : na , color =  color.new(color.green, 70)\n     plot(inDateRange ? new_ten_grid_5 : na , color =  color.new(color.green, 70)\n         color =  color.new(color.green, 70))\nfill(plot(inDateRange ?  new_ten_grid_5 : na , color =  color.new(color.green, 60\n     plot(inDateRange ? new_ten_grid_6 : na, color =  color.new(color.green, 60))\n         color =  color.new(color.green, 60))\nfill(plot(inDateRange ? new_ten_grid_6 : na, color =  color.new(color.red, 60)), \n     plot(inDateRange ? new_ten_grid_7 : na, color =  color.new(color.red, 60)), \n         color =  color.new(color.red, 60))\nfill(plot(inDateRange ? new_ten_grid_7 : na, color =  color.new(color.red, 70)), \n     plot(inDateRange ? new_ten_grid_8 : na, color =  color.new(color.red, 70)), \n         color =  color.new(color.red, 70))\nfill(plot(inDateRange ? new_ten_grid_8 : na, color =  color.new(color.red, 80)), \n     plot(inDateRange ? new_ten_grid_9 : na, color =  color.new(color.red, 80)), \n         color =  color.new(color.red, 80))\nfill(plot(inDateRange ? new_ten_grid_9 : na, color =  color.new(color.red, 85)), \n     plot(inDateRange ? new_ten_grid_10 : na, color =  color.new(color.red, 85)),\n         color =  color.new(color.red, 85))\n// // ###########################################################################################\nvar float new_twenty_grid_1 = na \nvar float new_twenty_grid_2 = na \nvar float new_twenty_grid_3 = na \nvar float new_twenty_grid_4 = na \nvar float new_twenty_grid_5 = na \nvar float new_twenty_grid_6 = na \nvar float new_twenty_grid_7 = na \nvar float new_twenty_grid_8 = na \nvar float new_twenty_grid_9 = na \nvar float new_twenty_grid_10 = na \nvar float new_twenty_grid_11 = na \nvar float new_twenty_grid_12 = na \nvar float new_twenty_grid_13 = na \nvar float new_twenty_grid_14 = na \nvar float new_twenty_grid_15 = na \nvar float new_twenty_grid_16 = na \nvar float new_twenty_grid_17 = na \nvar float new_twenty_grid_18 = na \nvar float new_twenty_grid_19 = na \nvar float new_twenty_grid_20 = na \nif tewnty_grid == true and show_grid_level_bg and inDateRange \n    new_twenty_grid_1 := grid_1\n    new_twenty_grid_2 := grid_2\n    new_twenty_grid_3 := grid_3\n    new_twenty_grid_4 := grid_4\n    new_twenty_grid_5 := grid_5\n    new_twenty_grid_6 := grid_6\n    new_twenty_grid_7 := grid_7\n    new_twenty_grid_8 := grid_8\n    new_twenty_grid_9 := grid_9\n    new_twenty_grid_10 := grid_10\n    new_twenty_grid_11 := grid_11\n    new_twenty_grid_12 := grid_12\n    new_twenty_grid_13 := grid_13\n    new_twenty_grid_14 := grid_14\n    new_twenty_grid_15 := grid_15\n    new_twenty_grid_16 := grid_16\n    new_twenty_grid_17 := grid_17\n    new_twenty_grid_18 := grid_18\n    new_twenty_grid_19 := grid_19\n    new_twenty_grid_20 := grid_20\nelse if tewnty_grid == false\n    new_twenty_grid_1 := na\n    new_twenty_grid_2 := na\n    new_twenty_grid_3 := na\n    new_twenty_grid_4 := na\n    new_twenty_grid_5 := na\n    new_twenty_grid_6 := na\n    new_twenty_grid_7 := na\n    new_twenty_grid_8 := na\n    new_twenty_grid_9 := na\n    new_twenty_grid_10 := na\n    new_twenty_grid_11 := na\n    new_twenty_grid_12 := na\n    new_twenty_grid_13 := na\n    new_twenty_grid_14 := na\n    new_twenty_grid_15 := na\n    new_twenty_grid_16 := na\n    new_twenty_grid_17 := na\n    new_twenty_grid_18 := na\n    new_twenty_grid_19 := na\n    new_twenty_grid_20 := na\nfill(plot(inDateRange ? new_twenty_grid_1 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_2 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 90))\nfill(plot(inDateRange ? new_twenty_grid_2 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_3 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 85))\nfill(plot(inDateRange ? new_twenty_grid_3 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_4 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 80))\nfill(plot(inDateRange ? new_twenty_grid_4 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_5 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 70))\nfill(plot(inDateRange ? new_twenty_grid_5 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_6 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 60))\nfill(plot(inDateRange ? new_twenty_grid_6 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_7 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 60))\nfill(plot(inDateRange ? new_twenty_grid_7 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_8 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 70))\nfill(plot(inDateRange ? new_twenty_grid_8 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_9 : na , color =  color.new(color.green, \n         color =  color.new(color.green, 80))\nfill(plot(inDateRange ? new_twenty_grid_9 : na , color =  color.new(color.green, \n     plot(inDateRange ? new_twenty_grid_10 : na , color =  color.new(color.green,\n         color =  color.new(color.green, 85))\nfill(plot(inDateRange ? new_twenty_grid_10 : na , color =  color.new(color.red, 90\n     plot(inDateRange ? new_twenty_grid_11 : na , color =  color.new(color.red, 90\n         color =  color.new(color.red, 90))\nfill(plot(inDateRange ? new_twenty_grid_11 : na , color =  color.new(color.red, 85\n     plot(inDateRange ? new_twenty_grid_12 : na , color =  color.new(color.red, 85\n         color =  color.new(color.red, 85))\nfill(plot(inDateRange ? new_twenty_grid_12 : na , color =  color.new(color.red, 80\n     plot(inDateRange ? new_twenty_grid_13 : na , color =  color.new(color.red, 80\n         color =  color.new(color.red, 80))\nfill(plot(inDateRange ? new_twenty_grid_13 : na , color =  color.new(color.red, 70\n     plot(inDateRange ? new_twenty_grid_14 : na , color =  color.new(color.red, 70\n         color =  color.new(color.red, 70))\nfill(plot(inDateRange ? new_twenty_grid_14 : na , color =  color.new(color.red, 60\n     plot(inDateRange ? new_twenty_grid_15 : na , color =  color.new(color.red, 60\n         color =  color.new(color.red, 60))\nfill(plot(inDateRange ? new_twenty_grid_15 : na , color =  color.new(color.red, 60\n     plot(inDateRange ? new_twenty_grid_16 : na , color =  color.new(color.red, 60\n         color =  color.new(color.red, 60))\nfill(plot(inDateRange ? new_twenty_grid_16 : na , color =  color.new(color.red, 70\n     plot(inDateRange ? new_twenty_grid_17 : na , color =  color.new(color.red, 70\n         color =  color.new(color.red, 70))\nfill(plot(inDateRange ? new_twenty_grid_17 : na , color =  color.new(color.red, 80\n     plot(inDateRange ? new_twenty_grid_18 : na , color =  color.new(color.red, 80\n         color =  color.new(color.red, 80))\nfill(plot(inDateRange ? new_twenty_grid_18 : na , color =  color.new(color.red, 85\n     plot(inDateRange ? new_twenty_grid_19 : na , color =  color.new(color.red, 85\n         color =  color.new(color.red, 85))\nfill(plot(inDateRange ? new_twenty_grid_19 : na , color =  color.new(color.red, 85\n     plot(inDateRange ? new_twenty_grid_20 : na , color =  color.new(color.red, 85\n         color =  color.new(color.red, 85))\n// // ###########################################################################################\n//###############################################################################################\n//------------------------------Table\n//###############################################################################################\nshowDashboard     = input.bool(true, \"Show Table\", group=\" ############# \ud83d\udd33 TABLE Settings \ud83d\udd33 ############ \nlocationDashboard = input.string(\"Top Right\", \"Table Location\", [\"Top Right\", \"Middle Right\"\nsizeDashboard     = input.string(\"Normal\", \"Table Size\", [\"Large\", \"Normal\", \"Small\"\nvar dashboard_loc  = locationDashboard == \"Top Right\" ? position.top_right : locationDashboard\nvar dashboard_size = sizeDashboard == \"Large\" ? size.large : sizeDashboard == \"Normal\"\nif showDashboard\n    var myTable =  table.new(position = dashboard_loc, columns = 5, rows = 2,bgcolor\n    table.cell(table_id = myTable, column = 0, row = 0, text = \"Open positions\"      \n    table.cell(table_id = myTable, column = 1, row = 0, text = \"Open profit\"         \n    table.cell(table_id = myTable, column = 2, row = 0, text = \"Total trades\"        \n    table.cell(table_id = myTable, column = 3, row = 0, text = \"Total profit\"        \n    table.cell(table_id = myTable, column = 4, row = 0, text = \"Current equity\"      \n    table.cell(table_id = myTable, column = 0, row = 1, text =       str.tostring(\n    table.cell(table_id = myTable, column = 1, row = 1, text = \"$\" + str.tostring(\n    table.cell(table_id = myTable, column = 2, row = 1, text =       str.tostring(\n    table.cell(table_id = myTable, column = 3, row = 1, text = \"$\" + str.tostring(\n    table.cell(table_id = myTable, column = 4, row = 1, text = \"$\" + str.tostring("}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Updates: Added Date Range Settings Added Mean Reversion Mode Only (Removal of Trend Filter MA) Added Long Only Mode Standard Position Size set to 100% of equity and no pyramiding"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Moving Average Trap\", overlay=true, pyramiding=0, default_qty_value=100, \n      default_qty_type=strategy.percent_of_equity)\n//Configure backtest date range\nuseDateFilter = input.bool(true, title=\"Filter Date Range of Backtest\",\n     group=\"Backtest Time Period\")\nbacktestStartDate = input.time(timestamp(\"1 Jan 1962\"), \n     title=\"Start Date\", group=\"Backtest Time Period\",\n     tooltip=\"This start date is in the time zone of the exchange \" + \n     \"where the chart's instrument trades. It doesn't use the time \" + \n     \"zone of the chart or of your computer.\")\nbacktestEndDate = input.time(timestamp(\"1 Jan 2023\"),\n     title=\"End Date\", group=\"Backtest Time Period\",\n     tooltip=\"This end date is in the time zone of the exchange \" + \n     \"where the chart's instrument trades. It doesn't use the time \" + \n     \"zone of the chart or of your computer.\")\n//Check if current bar falls inside the date range\ninTradeWindow = not useDateFilter or (time >= backtestStartDate and\n     time < backtestEndDate)\n//Choose if the strategy should be backtested in long only mode\nLongOnly = input.bool(false, \"Long Only Mode\")\n//Set Moving Average Periods\nflength = input.int(title=\"Fast MA Period\", minval=1, maxval=2000, defval=3)\nllength = input.int(title=\"Slower MA Period\", minval=1, maxval=2000, defval=5)\nsslength = input.int(title=\"Slowest MA Period\", minval=1, maxval=2000, defval=8)\ntlength = input.int(title=\"Trend Filter MA Period. 0 = No Filter\", minval=0, maxval\n//Create moving averages\nssma = ta.sma(close, sslength)\nfma = ta.sma(close, flength)\nsma = ta.sma(close, llength)\ntma = tlength != 0 ? ta.sma(close, tlength) : 0\n//Make Trend MA invisible if period is set to 0\nttransp = tlength != 0 ? 0 : 100\n//Show MAs on chart\nplot(fma, color= color.red)\nplot(sma, color= color.white)\nplot(ssma, color= color.green)\nplot(tma, color= color.rgb(100, 25, 80, ttransp), linewidth=2)\n//Define entry and exit criteria\nshort = tlength != 0 ? (fma > sma and sma > ssma) and (close < tma and LongOnly == \nlong = tlength != 0 ? (fma < sma and sma < ssma) and close > tma : fma < sma and sma\ncloseshort = fma < sma and sma < ssma\ncloselong = fma > sma and sma > ssma\n//Trigger entries and exits based on defined criteria\nif long and inTradeWindow\n     strategy.entry(\"long\", strategy.long)\nif closelong\n     strategy.close(\"long\")\nif short and inTradeWindow\n     strategy.entry(\"short\", strategy.short)\nif closeshort\n     strategy.close(\"short\")"}]}
{"messages": [{"role": "user", "content": "\u2689 \uff2f\uff36\uff25\uff32\uff36\uff29\uff25\uff37 \u2689 One of the best Systems for Backtesting your Strategies. Incredibly flexible, simple, fast and feature-rich system \u2014 will solve most of your queries without much effort. Many systems for setting StopLoss, TakeProfit, Risk Management and advanced Filters.  All you need to do is plug in your indicator and start Backtesting . I intentionally left the option to use my System on Full Power before you load your indicator into it. The system uses the built-in simple and popular moving average crossover signal for this purpose. (EMA 50 & 200). Also Highly Recommend that you Fully use ALL of the features of this system so that you understand how they work before you ask questions. Also tried to leave TIPS for each feature everywhere, read Tips, activate them and see how they work. But before you use this system, I Recommend you to read the following description in Full.  \u2014\u2014\u2014\u2014\u2014\u2014 How to connect your indicator in 2 steps: Adapt your indicator by adding only 2 lines of code and then connect it to this Backtesting System. Step 1 \u2014 Create your connector, For doing so: \u2002\u2002\u2002\u2002\u2022 1 \u2014 Find or create in your indicator where are the conditions printing the Long-Buy and Short-Sell signals. \u2002\u2002\u2002\u2002\u2022 2 \u2014 Create an additional plot as below I'm giving an example with a Two moving averages cross. Please replicate the same methodology for your indicator wether it's a MACD, RSI , Pivots, or whatever indicator with Clear Buy and Sell conditions. //@version=5indicator('Moving Average Cross', overlay = true)MA200 = ta.\ud835\ude8e\ud835\ude96\ud835\ude8a(close, 200)MA50  = ta.\ud835\ude8e\ud835\ude96\ud835\ude8a(close, 50)// Generate Buy and Sell conditionsbuy  = ta.crossover  (MA200, MA50)sell = ta.crossunder (MA200, MA50)plot(MA200, color=color.green)plot(MA50 , color=color.red  )bgcolor(color = buy ? color.green : sell ? color.red : na, title='SIGNALS')// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 SIGNAL FOR SYSTEM \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014Signal = buy ? +1 : sell ? -1 : 0plot(Signal, title='\ud83d\udd0cConnector\ud83d\udd0c', display = display.none)// \u2014\u2014\u2014\u2014\u2014\u2014 \ud83d\udd25 The Backtesting System expects the value to be exactly +1 for the \ud835\ude8b\ud835\ude9e\ud835\ude95\ud835\ude95\ud835\ude92\ud835\ude9c\ud835\ude91 signal, and -1 for the \ud835\ude8b\ud835\ude8e\ud835\ude8a\ud835\ude9b\ud835\ude92\ud835\ude9c\ud835\ude91 signalBasically, I identified my Buy & Sell conditions in the code and added this at the bottom of my indicator code Now you can connect your indicator to the Backtesting System using the Step 2 Step 2 \u2014 Connect the connector \u2002\u2002\u2002\u2002\u2022 1 \u2014 Add your updated indicator to a TradingView chart and Add the Backtesting System as well to the SAME chart \u2002\u2002\u2002\u2002\u2022 2 \u2014 Open the Backtesting System settings and in the External Source field select your \ud83d\udd0cConnector\ud83d\udd0c (which comes from your indicator) _______________________________ \u2002\u2689 \uff2d\uff21\uff29\uff2e\u2002\u2002\uff33\uff25\uff34\uff34\uff29\uff2e\uff27\uff33 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e \ud835\udc04\ud835\udc31\ud835\udc2d\ud835\udc1e\ud835\udc2b\ud835\udc27\ud835\udc1a\ud835\udc25 \ud835\udc12\ud835\udc28\ud835\udc2e\ud835\udc2b\ud835\udc1c\ud835\udc1e \u2014 Select your indicator. Add your indicator by following the 2 steps described above and select it in the menu. To familiarize yourself with the system until you select your indicator, you will have an in-built strategy of crossing the two moving EMA's of 50 and 200. Long Deals \u2014 Enable/Disable Long Deals. Short Deals \u2014 Enable/Disable Short Deals. Wait End Deal \u2014 Enable/Disable waiting for a trade to close at Stop Loss/Take Profit. Until the trade closes on the Stop Loss or Take Profit, no new trade will open. Reverse Deals \u2014 To force the opening of a trade in the opposite direction. ReEntry Deal \u2014 Automatically open the same new deal after the deal is closed. ReOpen Deal \u2014 Reopen the trade if the same signal is received. For example, if you are already in the long and a new signal is received in the long, the trade will reopen. * Does not work if Wait End Deal is enabled. \ud835\udc13\ud835\udc1a\ud835\udc24\ud835\udc1e \ud835\udc0f\ud835\udc2b\ud835\udc28\ud835\udc1f\ud835\udc22\ud835\udc2d: None \u2014 Disables take profit. Useful if you only want to use dynamic stoplosses such as MA, Fast-Trailing, ATR Trail. FIXED \uff05 \u2014 Fixed take profit in percent. FIXED \uff04 \u2014 Fixed Take in Money. ATR \u2014 Fixed Take based on ATR.  R:R \u2014 Fixed Take based on the size of your stop loss. For example, if your stop is 10% and R:R=1, then the Take would be 10%. R:R=3 Take would be 30%, etc. HH / LL \u2014 Fixed Take based on the previous maximum/minimum (extremum). \ud835\udc12\ud835\udc2d\ud835\udc28\ud835\udc29 \ud835\udc0b\ud835\udc28\ud835\udc2c\ud835\udc2c: None \u2014 Disables Stop Loss. Useful if you want to work without a stop loss. *Be careful if Wait End Deal is enabled, the trade may not close for a long time until it reaches the Take. FIXED \uff05 \u2014 Fixed Stop in percent. FIXED \uff04 \u2014 Fixed Stop in Money. TRAILING \u2014 Dynamic Trailing Stop like on the stock exchanges. FAST TRAIL \u2014 Dynamic Fast Trailing Stop moves immediately in profit and stays in place if the price stands still or the price moves in loss. ATR \u2014 Fixed Stop based on the ATR.  ATR TRAIL \u2014 Dynamic Trailing Stop based on the ATR. LO / HI \u2014 A Fixed Stop based on the last Maximum/Minimum extemum. Allows you to place a stop just behind or above the low/high candle. MA \u2014 Dynamic Stop based on selected Moving Average. * You will have 8 types of MA (EMA, SMA, HMA, etc.) to choose from, but you can easily add dozens of other MAs, which makes this type of stop incredibly flexible. Add \uff05 \u2014 If true, then with the \"\ud835\udde6\ud835\ude01\ud835\uddfc\ud835\uddfd\u2002\uff05\" parameter you can add percentages to any of the current SL. Can be especially useful when using Stop - \ud835\uddd4\ud835\udde7\ud835\udde5 or \ud835\udde0\ud835\uddd4 or \ud835\udddf\ud835\udde2/\ud835\udddb\ud835\udddc. For example with \ud835\udddf\ud835\udde2/\ud835\udddb\ud835\udddc to put a stop for the last High/Low and add 0.5% additional Stoploss. Fixed R:R \u2014 If the stop loss is Dynamic (Trailing or MA) then if R:R true can also be made Dynamic * Use it carefully, the function is experimental. _________________________________________ \u2002\u2689 \uff34\uff21\uff2b\uff25\u2003\uff30\uff32\uff2f\uff26\uff29\uff34\u2003\uff2c\uff25\uff36\uff25\uff2c\uff33 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e \t\tA unique method of constructing intermediate Take Profit Levels will allow you to select up to 5 intermediate Take Profit Levels and one intermediate Stop Loss. Intermediate Take Profit Levels are perfectly calculated into 5 equal parts in the form of levels from the entry point to the final Take Profit target.  All you need to do is to choose the necessary levels for fixing and how much you want to fix at each level as a percentage. For example, TP 3 will always be exactly between the entry point and the Take Profit target. And the value of TP 3 = 50 will close 50% of the amount of the remaining size of the position. Note: all intermediate SL/TP are closed from the remaining position amount and not from the initial position size, as TV does by default. SL 0 Position \u2014 works in the same way as TP 1-5 but it's Stop. With this parameter you can set the position where the intermediate stop will be set. Breakeven on TP \u2014 When activated, it allows you to put the stop loss at Breakeven after the selected TP is reached. For this function to work as it should - you need to activate an intermediate Take. For example, if TP 3 is activated and Breakeven on TP = 3, then after the price reaches this level, the Stop loss will go to Breakeven. \u2002\u2002\u2002* This function will not work with Dynamic Stoplosses, because it simply does not make sense. CoolDown # Bars \u2014 When activated, allows you to add a delay before a new trade is opened. A new trade after CoolDown will not be opened until # bars pass and a new signal appears. _____________________________ \u2002\u2689 \uff34\uff29\uff2d\uff25\u2002\u2002\uff26\uff29\uff2c\uff34\uff25\uff32\uff33 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e Powerful time filter code that allows you to filter data based on specific time zones, dates, and session days. This code is ideal for those who need to analyze data from different time zones and weed out irrelevant data. With Time Filter, you can easily set the starting and ending time zones by which you want to filter the data. You can also set a start and end date for your data and choose which days of the week to include in the analysis. In addition, you can specify start and end times for a specific session, allowing you to focus your analysis on specific time periods. \t\t_________________________________ \u2002\u2689 \uff33\uff29\uff27\uff2e\uff21\uff2c\u2002\u2002\uff26\uff29\uff2c\uff34\uff25\uff32\uff33 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e Signal Filters \u2014 allows you to easily customize and optimize your trading strategies based on 10 filters.  Each filter is designed to help you weed out inaccurate signals to minimize your risks. Let's take a look at their features: \t\t__________________________________ \u2002\u2689 \uff32\uff29\uff33\uff2b\u2002\u2002\uff2d\uff21\uff2e\uff21\uff27\uff25\uff2d\uff25\uff2e\uff34 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e Risk management tools that allow you to set the maximum number of losing trades in a row, a limit on the number of trades per day or week and other filters. Loss Streak \u2014 Set Max number of consecutive loss trades. Win Streak \u2014 Max Winning Streak Length. Row Loss InDay \u2014 Max of consecutive days with a loss in a row. DrawDown \uff05 \u2014 Max DrawDown (in % of strategy equity). InDay Loss \uff05 \u2014 Set Max Intraday Loss. Daily Trades \u2014 Limit the number of MAX trades per day. Weekly Trades \u2014 Limit the number of MAX trades per week. \u2002\u2002\u2002\u2002* \ud83e\udc45  I would Not Recommend using these functions without understanding how they work. Order Size \u2014 Position Size \u2002\u2002\u2002\u2002\u2022 NONE \u2014 Use the default position size settings in Tab \"Properties\". \u2002\u2002\u2002\u2002\u2022 EQUITY \u2014 The amount of the allowed position as a percentage of the initial capital. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2022 Use Net Profit \u2014 On/Off the use of profit in the following trades. *Only works if the type is EQUITY. \u2002\u2002\u2002\u2002\u2022 SIZE \u2014 The size of the allowed position in monetary terms. \u2002\u2002\u2002\u2002\u2022 Contracts \u2014 The size of the allowed position in the contracts. 1 \u0421ontract = \u0421urrent price. ________________ \u2002\u2689 \uff2e\uff2f\uff34\uff25\uff33 \u2689 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e It is important to note that I have never worked with Backtesting and the functions associated with them before.  It took me about a month of slow work to build this system. I want to say Big Thanks: \u2002\u2002\u2002\u2002\u2022 The PineScripters\ud83c\udf32 group in Telegram, the guys suggested how to implement some features. Especially @allanster \u2002\u2002\u2002\u2002\u2022 Thanks to all those people who share their developments for free on TV and not only.  \u2002\u2002\u2002\u2002\u2022 I also thank myself for not giving up and finishing the project, and not trying to monetize the system by selling it. * Although I really want the money :) I tried hard to make it as fast and convenient as possible for everyone who will use my code. That's why I didn't use any libraries and dozens of heavy functions, and I managed to fit in 8+-functions for the whole code. Absolutely every block of code I tried to make full-fledged modular, that it was easy to import/edit for myself (you). I have abused the Ternary Pine operator a little (a lot) so that the code was as compact as possible.  Nevertheless, I tried very hard to keep my code very understandable even for beginners. At last I managed to write 500 lines of code, making it one of the fastest and most feature-rich systems out there. I hope everyone enjoys my work. Put comments and write likes."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// @HALDRO Project\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n//@version=5\nstrategy('*Backtesting System',\n         overlay           = true,\n         initial_capital   = 10000,\n         commission_value  = 0.04,\n         default_qty_value = 10,\n         slippage          = 1,\n         pyramiding        = 0,\n         max_lines_count   = 500,\n         max_labels_count  = 500,\n         currency          = currency.USD,\n         default_qty_type  = strategy.percent_of_equity)\nMA(string _maType, float _maSource, simple int _maLength) =>\n    float ma = switch _maType\n        'ALMA' => ta.alma (_maSource, _maLength, 0.85, 6)\n        'EMA'  => ta.ema  (_maSource, _maLength)\n        'HMA'  => ta.hma  (_maSource, _maLength)\n        'RMA'  => ta.rma  (_maSource, _maLength)\n        'SMA'  => ta.sma  (_maSource, _maLength)\n        'VWMA' => ta.vwma (_maSource, _maLength)\n        'WMA'  => ta.wma  (_maSource, _maLength)\n    ma\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014 ToolTips\nTText_source_    = '\ud835\udc04\ud835\udc31\ud835\udc2d\ud835\udc1e\ud835\udc2b\ud835\udc27\ud835\udc1a\ud835\udc25\u2002\ud835\udc12\ud835\udc28\ud835\udc2e\ud835\udc2b\ud835\udc1c\ud835\udc1e\u2002\u2796\u200aHere you must select your Indicator, having previously connected \nTTreversesignal  = '\ud835\udc16\ud835\udc1a\ud835\udc22\ud835\udc2d\u2002\ud835\udc04\ud835\udc27\ud835\udc1d\u2002\ud835\udc03\ud835\udc1e\ud835\udc1a\ud835\udc25\u2002\u2796 Enable/Disable waiting for a trade to close at Stop Loss/Take Profit. \n                 + '\ud835\udc11\ud835\udc1e\ud835\udc2f\ud835\udc1e\ud835\udc2b\ud835\udc2c\ud835\udc1e\u2002\ud835\udc03\ud835\udc1e\ud835\udc1a\ud835\udc25\ud835\udc2c\u2002\u2796 If true strategy will go in the opposite direction from the signal.'\nTTreOpenDeal     = '\ud835\udc11\ud835\udc1e\ud835\udc04\ud835\udc27\ud835\udc2d\ud835\udc2b\ud835\udc32\u2002\ud835\udc03\ud835\udc1e\ud835\udc1a\ud835\udc25\u2002\u2796 If true trade was long and  SL/TP was reached then go long again and vice \n                 + '\ud835\udc11\ud835\udc1e\ud835\udc0e\ud835\udc29\ud835\udc1e\ud835\udc27\u2002\ud835\udc03\ud835\udc1e\ud835\udc1a\ud835\udc25\u2002\u2796 If true and Wait End Deal is false then in case you are in a Long position \nTTslType         = '\ud835\udc05\ud835\udc08\ud835\udc17\ud835\udc04\ud835\udc03\u2002\uff05\u2002\u2796 Fixed SL/TP in percent. \\n'\n                 + '\ud835\udc05\ud835\udc08\ud835\udc17\ud835\udc04\ud835\udc03\u2002\uff04\u2002\u2796 Fixed SL/TP in cash. \\n'\n                 + '\ud835\udc13\ud835\udc11\ud835\udc00\ud835\udc08\ud835\udc0b\ud835\udc08\ud835\udc0d\ud835\udc06\u2002\u2796 Trailing stop in \uff05 like on exchanges. Regulated by the \"\ud835\udde7\ud835\uddff\ud835\uddee\ud835\uddf6\ud835\uddf9\ud835\uddf6\ud835\uddfb\ud835\uddf4\u2002\uff05\" \n                 + '\ud835\udc05\ud835\udc00\ud835\udc12\ud835\udc13\u2002\ud835\udc13\ud835\udc11\ud835\udc00\ud835\udc08\ud835\udc0b\u2002\u2796 If in a long, it immediately follows the price when it rises \n                 + '\ud835\udc00\ud835\udc13\ud835\udc11\u2002\u2796 Fixed TP/SL depending on the current ATR. It is regulated by the \"\ud835\uddd4\ud835\udde7\ud835\udde5\u2002\ud835\udde3\ud835\uddf2\ud835\uddff\ud835\uddf6\ud835\uddfc\ud835\uddf1\" \n                 + '\ud835\uddd4\ud835\udde7\ud835\udde5\u2002\ud835\udc13\ud835\udc11\ud835\udc00\ud835\udc08\ud835\udc0b\u2002\u2796 Trailing Stop calculated on the basis of the ATR. It is regulated by the \n                 + '\ud835\udde5:\ud835\udde5\u2002\u2796 Risk Reward sets the TP depending on the size of the SL. For example, if SL is \uff04100, and \n                 + '\ud835\udc07\ud835\udc07\u2002/\u2002\ud835\udc0b\ud835\udc0b\u2002\u2796 Searches for the last Extremum (High/Low) for the specified number of bars and \n                 + '\ud835\udc0b\ud835\udc0e\u2002/\u2002\ud835\udc07\ud835\udc08\u2002\u2796 Sets the SL for High/Low candles. \"\ud835\udddf\ud835\udde2/\ud835\udddb\ud835\udddc\" = 1 Sets the SL for the last High/Low. \n                 + '\ud835\udc0c\ud835\udc00\u2002\u2796 Movieng Average SL. A very diverse type of SL.'\n// \u2014\u2014\u2014\u2014\u2014\u2014 Main Inputs\ngroupset         = '\u27a4\u2002\uff2d\uff21\uff29\uff2e\u2002\u2002\uff33\uff25\uff34\uff34\uff29\uff2e\uff27\uff33'\next_source_      = input.source (close,       '\u2002\ud835\udc04\ud835\udc31\ud835\udc2d\ud835\udc1e\ud835\udc2b\ud835\udc27\ud835\udc1a\ud835\udc25\u2002\ud835\udc12\ud835\udc28\ud835\udc2e\ud835\udc2b\ud835\udc1c\ud835\udc1e\u200a\u200a',    group=groupset\nbullDeal         = input.bool   (true,        '\u2002Long Deals\u2002\u2002\u2002\u2002',      group=groupset\nbearDeal         = input.bool   (true,        '\u2002Short Deals',         group=groupset\nwaitEndDeal      = input.bool   (true,        '\u2002Wait End Deal\u2002',      group=groupset\nreversesignal    = input.bool   (false,       '\u2002Reverse Deals',       group=groupset\nreEntryDeal      = input.bool   (false,       '\u2002ReEntry Deal\u2002\u2002',      group=groupset\nreOpenDeal       = input.bool   (false,       '\u2002ReOpen Deal',         group=groupset\ntpType           = input.string ('R:R',       '\u2002\ud835\udc13\ud835\udc1a\ud835\udc24\ud835\udc1e\u2002\ud835\udc0f\ud835\udc2b\ud835\udc28\ud835\udc1f\ud835\udc22\ud835\udc2d\ufffd',        group=groupset\nslType           = input.string ('ATR',       '\u2002\ud835\udc12\ud835\udc2d\ud835\udc28\ud835\udc29\u2002\ud835\udc0b\ud835\udc28\ud835\udc2c\ud835\udc2c\u200a',          group=groupset\ngrouptakes       = '\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2003\u2003\u27a4\u2002\uff34\uff41\uff4b\uff45\u2003\uff30\uff52\uff4f\uff46\uff49\uff54\u2003\uff2c\uff45\uff56\uff45\uff4c\uff53'\nontake1          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u00b9',                  group=grouptakes\nqtake1           = input.int    (20,          '\ufffd',                   group=grouptakes\nontake2          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u00b2',                  group=grouptakes\nqtake2           = input.int    (20,          '\ufffd',                   group=grouptakes\nontake3          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u00b3',                  group=grouptakes\nqtake3           = input.int    (50,          '\ufffd',                   group=grouptakes\nontake4          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u2074',                  group=grouptakes\nqtake4           = input.int    (25,          '\ufffd',                   group=grouptakes\nontake5          = input.bool   (false,       '\ud83c\uddf9\ud83c\uddf5\u2075\u200a',                 group=grouptakes\nqtake5           = input.int    (25,          '\ufffd',                   group=grouptakes\nonstop0          = input.bool   (false,       '\ud83c\uddf8\ud83c\uddf1\u2070\u200a',                 group=grouptakes\nqstop0           = input.int    (30,          '\ufffd',                   group=grouptakes\n// Example Connector\n//Signal = buy ? +1 : sell ? -1 : 0\n//plot(Signal, \"\ud83d\udd0cConnector\ud83d\udd0c\", display = display.none)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Variables Initialisation\next_source = nz(ext_source_)\nbull = ext_source == +1 // +1 is bull signal\nbear = ext_source == -1 // -1 is bear signal\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DATE RANGE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \ngrouptime             = '\u27a4\u2002\uff34\uff29\uff2d\uff25\u2002\u2002\uff26\uff29\uff2c\uff34\uff25\uff32\uff33'\nsrc_timezone          = input.string ('Exchange',      'Timezones Src->Dst',    group\ndst_timezone          = input.string ('Exchange',      '->',                    group\nusefromDate           = input.bool   (true,            'Srart From\u2003',           group\nfromDate              = input.time   (timestamp('01 Jan 2020 00:00'), '',       group\nusetoDate             = input.bool   (false,           'End To\u2002\u2002\u2002\u2002\u2002\u200a\u2004',         group\ntoDate                = input.time   (timestamp('01 Jul 2025 00:00'), '',       group\nuseSessionDay         = input.bool   (false,           'Session Days',          group\nmon                   = input.bool   (true,            'Mon',                   group\ntue                   = input.bool   (true,            'Tue',                   group\nwed                   = input.bool   (true,            'Wed',                   group\nthu                   = input.bool   (true,            'Thu',                   group\nfri                   = input.bool   (true,            'Fri',                   group\nsat                   = input.bool   (false,           'Sat',                   group\nsun                   = input.bool   (false,           'Sun',                   group\nuseSessionStart       = input.bool   (false,           'Session Start',         group\nsessionStartHour      = input.int    (12,              '',                      group\nsessionStartMinute    = input.int    (00,              ':',                     group\nuseSessionEnd         = input.bool   (false,           'Session End\u2002',          group\nsessionEndHour        = input.int    (20,              '',                      group\nsessionEndMinute      = input.int    (00,              ':',                     group\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \nex_timezone(simple string tz) =>\n    switch tz\n        'Exchange' => syminfo.timezone\n        => tz    \nif_in_date_range(simple bool usefromDate, simple int fromDate, simple bool usetoDate\n    var src_tz     = ex_timezone(src_timezone)\n    var dst_tz     = ex_timezone(dst_timezone)\n    var fromDateTz = timestamp(src_tz, year(fromDate, dst_tz), month(fromDate, dst_tz\n    var toDateTz   = timestamp(src_tz, year(toDate, dst_tz), month(toDate, dst_tz)\n    (usefromDate ? t >= fromDateTz : true) and (usetoDate ? t < toDateTz : true)\nif_in_session(simple bool useSessionStart, simple int sessionStartHour, simple int\n    var one_day = 86400000\n    var utc_tz  = 'UTC'\n    var src_tz  = ex_timezone(src_timezone)\n    var dst_tz  = ex_timezone(dst_timezone)\n    start_hr    = sessionStartHour   + (hour(t, dst_tz)   - hour(t, src_tz))\n    start_min   = sessionStartMinute + (minute(t, dst_tz) - minute(t, src_tz))\n    end_hr      = sessionEndHour     + (hour(t, dst_tz)   - hour(t, src_tz))\n    end_min     = sessionEndMinute   + (minute(t, dst_tz) - minute(t, src_tz))\n    time_start_session   = timestamp(dst_tz, year(t, src_tz), month(t, src_tz), dayofmonth\n    time_end_session     = timestamp(dst_tz, year(t, src_tz), month(t, src_tz), dayofmonth\n    var bool isOvernight = time_start_session >= time_end_session\n    // in overnight sessions increase end time by one day\n    if (useSessionStart and useSessionEnd and isOvernight)\n        time_end_session := time_end_session + one_day\n    isSessionDay = switch dayofweek(t, src_tz)\n        dayofweek.monday    => mon\n        dayofweek.tuesday   => tue\n        dayofweek.wednesday => wed\n        dayofweek.thursday  => thu\n        dayofweek.friday    => fri\n        dayofweek.saturday  => sat\n        dayofweek.sunday    => sun\n        => false\n    (useSessionDay ? isSessionDay : true) and (useSessionStart ? t >= time_start_session\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \nbool dateFilterApproval     = if_in_date_range(usefromDate, fromDate, usetoDate, toDate\nbool sessionFilterApproval  = if_in_session(useSessionStart, sessionStartHour, sessionStartMinute\nbool timeFilterApproval     = dateFilterApproval and sessionFilterApproval\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Signal Filters \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \ngroupsignal           = '\u27a4\u2002\uff33\uff29\uff27\uff2e\uff21\uff2c\u2002\u2002\uff26\uff29\uff2c\uff34\uff25\uff32\uff33'\nFilterType1           = input.bool   (false,           '1. ADX',                                           \nFilterType1Len        = input.int    (17,              '',                                                 \nFilterType1Smt        = input.int    (14,              '',                                                 \nFilterType1Tresh      = input.int    (20,              '',                                                 \nFilterType2           = input.bool   (false,           '2. MACD',                                          \nFilterType2Len1       = input.int    (12,              '',                                                 \nFilterType2Len2       = input.int    (26,              '',                                                 \nFilterType2Len3       = input.int    (9,               '',                                                 \nFilterType3           = input.bool   (false,           '3. Bar direction=Trade direction'\nFilterType4           = input.bool   (false,           '4. Rising Volume',                                 \nFilterType5           = input.bool   (false,           '5. Rising/Falling MA',                             \nFilterType5Len        = input.int    (50,              'Length',                                           \nFilterType5Bars       = input.int    (1,               'Bars',                                             \nFilterType6           = input.bool   (false,           '6. High/Low Filter',                               \nFilterType6Bars       = input.int    (10,              'Lookback',                                         \nFilterType7           = input.bool   (false,           '7. Maximum close change (\uff05) allowed on entry'\nFilterType7IncPct     = input.float  (10.0,            '',                                                 \nFilterType8           = input.bool   (false,           '8. Minimum close change (\uff05) allowed on entry'\nFilterType8IncPct     = input.float  (1.0,             '',                                                 \nFilterType9           = input.bool   (false,           '9. RSI OS/OB',                                     \nFilterType9Len        = input.int    (20,              '',                                                 \nFilterType9OS         = input.int    (25,              '',                                                 \nFilterType9OB         = input.int    (75,              '',                                                 \nFilterType10          = input.bool   (false,           '10. MA',                                           \nFilterType10MAType    = input.string ('SMA',           '',                                                 \nFilterType10Len       = input.int    (200,             '',                                                 \n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 1: ADX\n[dip, dim, adx] = ta.dmi(FilterType1Len, FilterType1Smt)\nFilter1Long     = FilterType1 ? adx < FilterType1Tresh : true\nFilter1Short    = Filter1Long\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 2: MACD Hist\n_macdLine       = FilterType2 ? nz(MA('EMA', close, FilterType2Len1) - MA('EMA', close\n_macdSignal     = FilterType2 ? nz(MA('EMA', _macdLine, FilterType2Len3)) : 0.\n_macdHist       = FilterType2 ? _macdLine - _macdSignal : 0.\nFilter2Long     = FilterType2 ? _macdHist > 0 : true\nFilter2Short    = FilterType2 ? _macdHist < 0 : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 3: Bar direction\nFilter3Long     = FilterType3 ? close > open : true\nFilter3Short    = FilterType3 ? close < open : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 4: Rising volume\nFilter4Long     = FilterType4 ? ta.rising(volume, 1) : true\nFilter4Short    = Filter4Long\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 5: Rising/Falling MA\nFilter5Ma       = FilterType5 ? nz(MA('SMA', close, FilterType5Len)) : 0\nFilter5Long     = FilterType5 ? ta.rising(Filter5Ma, FilterType5Bars) : true\nFilter5Short    = FilterType5 ? ta.falling(Filter5Ma, FilterType5Bars) : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 6: Check high & close filter\nFilter6Long     = FilterType6 ? high >= ta.highest(high, FilterType6Bars) : true\nFilter6Short    = FilterType6 ? low <= ta.lowest(low, FilterType6Bars) : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 7: Maximum delta with previous close allowed at entry\nFilter7Long     = FilterType7 ? close < close[1] * (1 + FilterType7IncPct / 100) :\nFilter7Short    = FilterType7 ? close > close[1] * (1 - FilterType7IncPct / 100) :\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 8: Minimum delta with previous close allowed at entry\nFilter8Long     = FilterType8 ? close > close[1] * (1 + FilterType8IncPct / 100) :\nFilter8Short    = FilterType8 ? close < close[1] * (1 - FilterType8IncPct / 100) :\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 9: RSI OS/OB\nRsi             = FilterType9 ? ta.rsi(close, FilterType9Len) : 0\nRsiOB           = Rsi > FilterType9OB\nRsiOS           = Rsi < FilterType9OS\nFilter9Long     = FilterType9 ? not RsiOB : true\nFilter9Short    = FilterType9 ? not RsiOS : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Filter 10: Moving Average\nFilter10Ma      = FilterType10 ? MA(FilterType10MAType, close, FilterType10Len) : \nFilter10Long    = FilterType10 ? close > Filter10Ma : true\nFilter10Short   = FilterType10 ? close < Filter10Ma : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Assemble Filters\nFilterLongOK    = Filter1Long and Filter2Long and Filter3Long and Filter4Long and \n and Filter6Long and Filter7Long and Filter8Long and Filter9Long and Filter10Long\nFilterShortOK   = Filter1Short and Filter2Short and Filter3Short and Filter4Short \n and Filter6Short and Filter7Short and Filter8Short and Filter9Short and Filter10Short\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Risk Managment \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \ngrouprisk               = '\u27a4\u2002\uff32\uff29\uff33\uff2b\u2002\u2002\uff2d\uff21\uff2e\uff21\uff27\uff25\uff2d\uff25\uff2e\uff34'\nsetmaxLosingStreak      = input.bool   (false,           '',                   group\nmaxLosingStreak         = input.int    (15,              'Loss Streak\u2002\u2002\u2002',     group\nsetmaxWinStreak         = input.bool   (false,           '',                   group\nmaxWinStreak            = input.int    (15,              'Win Streak\u2002\u2002\u2002',      group\nsetmaxLosingDaysStreak  = input.bool   (false,           '',                   group\nmaxLosingDaysStreak     = input.int    (3,               'Row Loss InDay',     group\nsetMaxDrawdown          = input.bool   (false,           '',                   group\nmaxPercDd               = input.int    (10,              'DrawDown \uff05',        group\nsetMaxIntradayLoss      = input.bool   (false,           '',                   group\nmaxIntradayLoss         = input.int    (3,               'InDay Loss \uff05\u2002',     group\nsetNumberDailyTrades    = input.bool   (false,           '',                   group\nmaxDailyTrades          = input.int    (10,              'Daily Trades\u2002\u2002',     group\nsetNumberWeeklyTrades   = input.bool   (false,           '',                   group\nmaxWeeklyTrades         = input.int    (50,              'Weekly Trades',      group\nQTYMethod               = input.string ('EQUITY',        '\u2002\u2002\u2002\u2002\u2002Order Size',    group\nuseNetProfit            = input.bool   (true,            'Use Net Profit',     group\nriskPerc                = input.int    (10,              '\ud83c\uddea\ud83c\uddf6\ud83c\uddfa\ud83c\uddee\ud83c\uddf9\ud83c\uddfe',              group\nriskSize                = input.int    (1000,            '\ud83c\uddf8\ud83c\uddee\ud83c\uddff\ud83c\uddea',                group\nriskCntr                = input.int    (1,               '\ud83c\udde8\ud83c\uddf4\ud83c\uddf3\ud83c\uddf9\ud83c\uddf7\ud83c\udde6\ud83c\udde8\ud83c\uddf9\ud83c\uddf8',           group\n// \u2014\u2014\u2014\u2014\u2014\u2014 Order Size\neqty = switch QTYMethod\n    'NONE'      => na\n    'EQUITY'    => riskPerc / close\n    'SIZE'      => riskSize / close\n    'CONTRACTS' => riskCntr\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014 Intraday Loss \uff05\ncondintradayloss = setMaxIntradayLoss ? maxIntradayLoss : 100\nstrategy.risk.max_intraday_loss(value=condintradayloss, type=strategy.percent_of_equity\n// \u2014\u2014\u2014\u2014\u2014\u2014 Max Drawdown \uff05\ncondmaxdrawdown = setMaxDrawdown ? maxPercDd : 100\nstrategy.risk.max_drawdown(value=condmaxdrawdown, type=strategy.percent_of_equity)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Daily trades calculation\ntradesIntradayCount = setNumberDailyTrades ? maxDailyTrades : 1000\nstrategy.risk.max_intraday_filled_orders(count=tradesIntradayCount)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Weekly trades calculation\ntradesLastWeek = 0\ntradesLastWeek := dayofweek == dayofweek.monday and dayofweek != dayofweek[1] ? strategy.closedtrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate number of trades this week\nweeklyTrades = strategy.closedtrades + strategy.opentrades - tradesLastWeek\nokToTradeWeekly = setNumberWeeklyTrades ? weeklyTrades < maxWeeklyTrades : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Consecutive loss days in a row\ncountConsLossDays = setmaxLosingDaysStreak ? maxLosingDaysStreak : 1000\nstrategy.risk.max_cons_loss_days(countConsLossDays)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate the total losing streaks\nnewLoss = strategy.losstrades > strategy.losstrades[1] and strategy.wintrades == strategy.wintrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Determine current losing streak length\nstreakLossLen = 0\nstreakLossLen := newLoss ? nz(streakLossLen[1]) + 1 : strategy.wintrades > strategy.wintrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Check if losing streak is under max allowed\nokToTradeLossStreak = setmaxLosingStreak ? streakLossLen < maxLosingStreak : true\n// \u2014\u2014\u2014\u2014\u2014\u2014 Calculate the total winning streaks\nnewWin = strategy.wintrades > strategy.wintrades[1] and strategy.losstrades == strategy.losstrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Figure out current winning streak length\nstreakWinLen = 0\nstreakWinLen := newWin ? nz(streakWinLen[1]) + 1 : strategy.losstrades > strategy.losstrades\n// \u2014\u2014\u2014\u2014\u2014\u2014 Check if winning streak is under max allowed\nokToTradeWinStreak = setmaxWinStreak ? streakWinLen < maxWinStreak : true\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 STRATEGY \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \npercentTP    = input.float  (4.5,             '\u2002Profit \uff05\u2002\u2002\u2002\u2002',            group=groupset\npercentSL    = input.float  (1.5,             '\u2002Stop \uff05\u2002\u2002',                group=groupset\nmoneyTP      = input.float  (333,             '\u2002Profit \uff04\u2002\u2002\u2002\u2002',            group=groupset\nmoneySL      = input.float  (100,             '\u2002Stop \uff04\u2002\u2002',                group=groupset\nATRLen       = input.int    (40,              '\u2002ATR Period\u2002\u2002',             group=groupset\nATRMult      = input.float  (4,               '\u2002Multiplier',               group=groupset\ntrailPerc    = input.float  (3,               '\u2002Trailing \uff05\u2002\u2002',            group=groupset\nriskReward   = input.float  (2,               '\u2002R:R\u2002\u2002\u2002\u20021:',                group=groupset\nfixedRR      = input.bool   (true,            ' Fixed RR',                 group=groupset\nHHLL         = input.int    (200,             '\u2002HH / LL\u2003\u2002\u2002',               group=groupset\nLoHi         = input.int    (5,               '\u2002\u2002LO / HI\u2003',                group=groupset\naddPerc      = input.bool   (false,           ' Add \uff05',                   group=groupset\nmaStopType   = input.string ('SMA',           '\u2002MA Stop',                  group=groupset\nmaStopLen    = input.int    (15,              '\u2002Len',                      group=groupset\nmaPerc       = input.float  (1.5,             '\u2002Step',                     group=groupset\nbullcolor    = input.color  ( #00bbd49a,     'Colors: \u2002FG',               group=grouptakes\nbearcolor    = input.color  ( #c2185c9a,     '',                          group=grouptakes\nbullcolorb   = input.color  ( #00bbd426,     'BG',                        group=grouptakes\nbearcolorb   = input.color  ( #c2185c27,     '',                          group=grouptakes\nTipLvl       = input.string ('\u2014\u2014\u2934\u2014\u2934\u2014\u2934',     '\ud835\udc13\ud835\udc08\ud835\udc0f\u2002\ud835\udc05\ud835\udc28\ud835\udc2b\u2002\ud835\udc13\ud835\udc0f',                group=grouptakes\nslNumber     = input.int    (3,               '\u2002SL 0 Position',            group=grouptakes\nontpBE       = input.bool   (false,           '',                          group=grouptakes\ntpBEnumber   = input.int    (3,               'Breakeven on TP',           group=grouptakes\nbarCoolDwn   = input.int    (0,               '\u2002CoolDown # Bars',          group=grouptakes\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014 Trade variables\nentry        = strategy.position_avg_price\nsizePos      = strategy.position_size\ninLong       = sizePos > 0\ninShort      = sizePos < 0\ninTrade      = inLong or inShort\ninPos        = (inLong and not inShort[1]) or (inShort and not inLong[1])\nvar ID       = 'TradeID'\nvar tpPrice  = float(na)\nvar slPrice  = float(na)\n// \u2014\u2014\u2014\u2014\u2014\u2014 Signal\nbull        := ext_source_ == close ? ta.crossover (ta.ema(close, 50), ta.ema(close\nbear        := ext_source_ == close ? ta.crossunder(ta.ema(close, 50), ta.ema(close\nbull        := reversesignal ? bear : bull\nbear        := reversesignal ? bull : bear\n// \u2014\u2014\u2014\u2014\u2014\u2014 Entry solutions\ndirection    = 0\ndirectionL   = bull and (nz(direction[1]) == 0 or nz(direction[1]) == -1)\ndirectionS   = bear and (nz(direction[1]) == 0 or nz(direction[1]) == +1)\ndirection   := directionL ? +1 : directionS ? -1 : (reEntryDeal ? direction[1] : direction\ncheckCoolDwn = barCoolDwn >0 ? not inTrade[barCoolDwn] : true\nOkToTrade    = timeFilterApproval and okToTradeLossStreak and okToTradeWinStreak and\ngoLong       = ( waitEndDeal ? not inTrade and direction==+1 : direction==+1 ) and\ngoShort      = ( waitEndDeal ? not inTrade and direction==-1 : direction==-1 ) and\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \nDynamicStops = (slType == 'TRAILING' or slType == 'FAST TRAIL' or slType == 'ATR TRAIL'\n// \u2014\u2014\u2014\u2014\u2014\u2014 Fixed SL/TP\nif tpType == 'FIXED \uff05'\n    tpPrice := inLong and not inTrade[1] ? entry * (1 + percentTP/100) : inShort and\nif slType == 'FIXED \uff05'\n    slPrice := inLong and not inTrade[1] ? entry * (1 - percentSL/100) : inShort and\n// \u2014\u2014\u2014\u2014\u2014\u2014 Money SL/TP\nif tpType == 'FIXED \uff04'\n    tpPrice := inLong and not inTrade[1] ? entry + (moneyTP / math.abs(sizePos)) :\nif slType == 'FIXED \uff04'\n    slPrice := inLong and not inTrade[1] ? entry - (moneySL / math.abs(sizePos)) :\n// \u2014\u2014\u2014\u2014\u2014\u2014 Trailing Stop\nif slType == 'TRAILING'\n    StopL    = 0., StopS = 0.\n    StopL   := inLong  ? math.max(close * (1 - trailPerc/100), StopL[1]) : 0\n    StopS   := inShort ? math.min(close * (1 + trailPerc/100), StopS[1]) : 999999\n    slPrice := inLong  ? StopL : inShort ? StopS : slPrice\n// \u2014\u2014\u2014\u2014\u2014\u2014 Fast Trailing Stop\nif slType == 'FAST TRAIL'\n    var stop = float(na)\n    stop    := inLong and not inTrade[1] ? entry * (1 - trailPerc/100) : inShort and\n    stop    := inLong and close > close[1] ? stop + (close - close[1]) : inShort and\n    slPrice := stop\n// \u2014\u2014\u2014\u2014\u2014\u2014 ATR Fixed\nStopATR      = ta.atr(ATRLen) * ATRMult\nif tpType == 'ATR'\n    tpPrice := inLong and not inTrade[1] ? entry + StopATR : inShort and not inTrade\nif slType == 'ATR'\n    slPrice := inLong and not inTrade[1] ? entry - StopATR : inShort and not inTrade\n// \u2014\u2014\u2014\u2014\u2014\u2014 ATR Trail Stop\nif slType == 'ATR TRAIL'\n    StopL    = 0., StopS = 0.\n    StopL   := inLong  ? math.max(close - StopATR, StopL[1]) : 0\n    StopS   := inShort ? math.min(close + StopATR, StopS[1]) : 999999\n    slPrice := inLong  ? StopL : inShort ? StopS : slPrice\n// \u2014\u2014\u2014\u2014\u2014\u2014 LO / HI Stop\nif slType == 'LO / HI'\n    HiStop   = ta.highest(high, LoHi)\n    LoStop   = ta.lowest (low,  LoHi)\n    slPrice := inLong and not inTrade[1] ? LoStop : inShort and not inTrade[1] ? HiStop\n// \u2014\u2014\u2014\u2014\u2014\u2014 HH / LL Take\nif tpType == 'HH / LL'\n    HiStop   = ta.highest(high, HHLL)\n    LoStop   = ta.lowest (low,  HHLL)\n    tpPrice := inLong and not inTrade[1] ? HiStop : inShort and not inTrade[1] ? LoStop\n// \u2014\u2014\u2014\u2014\u2014\u2014 MA's Stops\nif slType == 'MA'\n    maSType  = MA(maStopType, close, maStopLen)\n    Stop     = maSType * (maPerc / 100)\n    slPrice := inLong  ? math.max(nz(slPrice[1], 0), maSType - Stop) : inShort ? math.min\n// \u2014\u2014\u2014\u2014\u2014\u2014 Risk Reward Take\nif tpType == 'R:R'\n    check    = fixedRR ? not inTrade[1] : true\n    tpPrice := inLong and check ? entry + (entry - slPrice) * riskReward : inShort\n// \u2014\u2014\u2014\u2014\u2014\u2014 Add Percents to SL\nif addPerc\n    check    = DynamicStops ? true : not inTrade[1]\n    slPrice := inLong and check ? slPrice * (1 - percentSL/100) : inShort and check\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014 TPSL's\nTypeStop = tpType != 'None' or slType == 'FIXED \uff05' or slType == 'FIXED \uff04' or slType\nBuildLeveles(take, nTake) => // Creating Intermediate Levels of the SL/TP - by shifting the current TP/SL to the entry level\n    nTakes = 6\n    var offset = float(na)\n    offset := not inPos[1] ? (entry - take) : offset\n    xentry = take + offset\n    levels = array.new_float()\n    for i = 1 to nTakes - 1\n        array.push(levels, xentry + (take - xentry) * i / (nTakes))\n    result = nTake >= 0 and nTake <= nTakes ? array.get(levels, nTake) : na\nCheckLevels(lvl, isTake) => // Check if the SL/TP is reached \n    var float level = na\n    if isTake and ((inLong and high >= lvl) or (inShort and low <= lvl))\n        level := entry\n    if not isTake and ((inLong and low <= lvl) or (inShort and high >= lvl))\n        level := entry\n    if not inTrade\n        level := na\n    level\n// \u2014\u2014\u2014\u2014\u2014\u2014 Get and Check Levels\nstop0 = tpType != 'None' ? BuildLeveles(slPrice, slNumber-1) : slPrice , checkStop0\ntake1 = BuildLeveles(TypeStop ? tpPrice : slPrice, 0)                  , checkTake1\ntake2 = BuildLeveles(TypeStop ? tpPrice : slPrice, 1)                  , checkTake2\ntake3 = BuildLeveles(TypeStop ? tpPrice : slPrice, 2)                  , checkTake3\ntake4 = BuildLeveles(TypeStop ? tpPrice : slPrice, 3)                  , checkTake4\ntake5 = BuildLeveles(TypeStop ? tpPrice : slPrice, 4)                  , checkTake5\n// \u2014\u2014\u2014\u2014\u2014\u2014 Move Stop to Breakeven\nslbecheck = (tpBEnumber==1 and ontake1) or (tpBEnumber==2 and ontake2) or (tpBEnumber\nif ontpBE and slbecheck and not DynamicStops\n    slbe     = TypeStop ? CheckLevels(BuildLeveles(tpPrice, tpBEnumber-1), true) :\n    slPrice := slbe > 0 ? slbe : slPrice\n    stop0   := slPrice == entry ? slPrice : stop0\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n// \u2014\u2014\u2014\u2014\u2014\u2014 Entry's\neqty(qty) => QTYMethod=='EQUITY' ? qty / 100 * (strategy.initial_capital + (useNetProfit\nif goLong \n    ID := 'Long'\n    if reOpenDeal and inLong and goLong  \n        strategy.close(ID, comment='reOpen')\n    strategy.entry(ID, strategy.long,  qty=eqty(eqty), comment=ID, alert_message=ID\nif goShort\n    ID := 'Short'\n    if reOpenDeal and inShort and goShort\n        strategy.close(ID, comment='reOpen')\n    strategy.entry(ID, strategy.short, qty=eqty(eqty), comment=ID, alert_message=ID\n// \u2014\u2014\u2014\u2014\u2014\u2014 Exit's\nqty(perc) => math.abs(sizePos*perc/100)\nif inTrade\n    strategy.exit('End_0', onstop0 ? ID : 'na', qty=qty(qstop0), limit=tpPrice,                    \n    strategy.exit('End_1', ontake1 ? ID : 'na', qty=qty(qtake1), limit=TypeStop ? \n    strategy.exit('End_2', ontake2 ? ID : 'na', qty=qty(qtake2), limit=TypeStop ? \n    strategy.exit('End_3', ontake3 ? ID : 'na', qty=qty(qtake3), limit=TypeStop ? \n    strategy.exit('End_4', ontake4 ? ID : 'na', qty=qty(qtake4), limit=TypeStop ? \n    strategy.exit('End_5', ontake5 ? ID : 'na', qty=qty(qtake5), limit=TypeStop ? \n    strategy.exit('End_6',           ID,                         limit=tpPrice,                    \n// =================================================================================================\n// Plotting and Debugging\n// =================================================================================================\nplotColx = inLong ? bullcolor  : inShort ? bearcolor  : na\nplotColy = inLong ? bullcolorb : inShort ? bearcolorb : na\ntpcolor  = tpType != 'None' ? bullcolor : plotColx\ntp = plot(inPos ? tpPrice : na, 'Take', color=tpType != 'None' ? bullcolor : plotColx\nsl = plot(inPos ? slPrice : na, 'Stop', color=tpType != 'None' ? bearcolor : plotColx\nen = plot(TypeStop ? (inLong and slPrice > entry or inShort and slPrice < entry ? \nfill(tp, en, color=TypeStop ? bullcolorb : plotColy, editable=false)\nfill(sl, en, color=TypeStop ? bearcolorb : plotColy, editable=false)\nplotchar(inPos and not inPos[1]? tpPrice : na, 'Take Start', color=tpType != 'None'\nplotchar(inPos and not inPos[1]? slPrice : na, 'Stop Start', color=tpType != 'None'\nplot(inPos and ontake1 and not checkTake1[1] ? take1 : na, 'TP 1', color=tpcolor,   \nplot(inPos and ontake2 and not checkTake2[1] ? take2 : na, 'TP 2', color=tpcolor,   \nplot(inPos and ontake3 and not checkTake3[1] ? take3 : na, 'TP 3', color=tpcolor,   \nplot(inPos and ontake4 and not checkTake4[1] ? take4 : na, 'TP 4', color=tpcolor,   \nplot(inPos and ontake5 and not checkTake5[1] ? take5 : na, 'TP 5', color=tpcolor,   \nplot(inPos and onstop0 and not checkStop0[1] ? stop0 : na, 'SL 0', color=bearcolor\nplot(ext_source_ == close ? ta.ema(close, 50)  : na, 'MA 1', color= #ffeb3b93, editable\nplot(ext_source_ == close ? ta.ema(close, 200) : na, 'MA 2', color= #ffeb3b93, editable\n//plotchar(goLong  and not inPos, 'goLong' , char='\u271f', size=size.tiny, location=location.belowbar, color=#4caf4f )\n//plotchar(goShort and not inPos, 'goShort', char='\u271f', size=size.tiny, location=location.abovebar, color=#ff5252 )\n// Panel\n//var table panel = table.new(position = position.bottom_right, columns = 2, rows = 1, bgcolor = #36\n//table.cell(panel, 1, 0, text=str.tostring(0), text_color = #ffa726, bgcolor = #363A45)\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added a new option so we're able to change the location of the portfolio table, for both personal taste and being able to use weekly/monthly returns also. Besides, changed the \"Active ROI\" cell so instead of showing return of current position divided by the whole portfolio, it'll show returns of current position. Which was my initial intention, but somehow it slipped through. Should be ok now.                                                    Release Notes:                                                    Set a default comission value as 0.02% (usual level for futures on crypto exchanges), so you'll see a real performance instead of these unrealistic ones. Moved the code for the date filter down, so the options don't show above the indicator inputs. Just a matter of personal taste. Added a supertrend filter by default, just one with default settings, you can add the input function to filter it.                                                    Release Notes:                                                    Fixed a minor typo in group string"}, {"role": "assistant", "content": "//@version=5\n//@Sweetz on TradingView. Contact me if you have any question or suggestion.\n//This template hasn't been designed to be used with pyramiding.\nstrategy(title='Strategy Template', overlay=true, initial_capital=1000, default_qty_type\n//SIGNALS SETTINGS\nsignalSwitcher = input.string(defval=\"Both\", title=\"Enable signals\", options=[\"Both\"\nbool signalLongs = (signalSwitcher == \"Longs\") or (signalSwitcher == \"Both\")\nbool signalShorts = (signalSwitcher == \"Shorts\") or (signalSwitcher == \"Both\")\nlong_StopLossType = input.string(title=\"Stop Loss Type: (L)\", defval=\"Simple\", options\nbool long_SL_Simple = long_StopLossType == \"Simple\"\nbool long_SL_BreakEven1 = long_StopLossType == \"Break Even 1\"\nbool long_SL_BreakEven2 = long_StopLossType == \"Break Even 2\"\nbool long_SL_BreakEven3 = long_StopLossType == \"Break Even 3\"\nbool long_SL_BreakEven4 = long_StopLossType == \"Break Even 4\"\nbool long_SL_Scaling = long_StopLossType == \"Scaling\"\nbool long_SL_Any = long_StopLossType != \"Disabled\"\nlong_TakeProfitType = input.string(title=\"Take Profit Type: (L)\", defval=\"Percentage\"\nbool long_TP_Percentage = long_TakeProfitType == \"Percentage\"\nbool long_TP_Ratio = long_TakeProfitType == \"Risk/Reward Ratio\"\nlong_numberOrders = input.int(defval = 5, title = \"Number of Orders: (L)\", options\nbool numberLongs_one = long_numberOrders >= 1\nbool numberLongs_two = long_numberOrders >= 2\nbool numberLongs_three = long_numberOrders >= 3\nbool numberLongs_four = long_numberOrders >= 4\nbool numberLongs_five = long_numberOrders == 5\nshort_StopLossType = input.string(title=\"(S)\", defval=\"Simple\", options=[\"Disabled\"\nbool short_SL_Simple = short_StopLossType == \"Simple\"\nbool short_SL_BreakEven1 = short_StopLossType == \"Break Even 1\" \nbool short_SL_BreakEven2 = short_StopLossType == \"Break Even 2\"\nbool short_SL_BreakEven3 = short_StopLossType == \"Break Even 3\"\nbool short_SL_BreakEven4 = short_StopLossType == \"Break Even 4\"\nbool short_SL_Scaling = short_StopLossType == \"Scaling\"\nbool short_SL_Any = short_StopLossType != \"Disabled\"\nshort_TakeProfitType = input.string(title=\"(S)\", defval=\"Percentage\", options=[\"Disabled\"\nbool short_TP_Percentage = short_TakeProfitType == \"Percentage\"\nbool short_TP_Ratio = short_TakeProfitType == \"Risk/Reward Ratio\"\nshort_numberOrders = input.int(defval = 5, title = \"(S)\", options=[1, 2, 3, 4, 5],\nbool numberShorts_one = short_numberOrders >= 1\nbool numberShorts_two = short_numberOrders >= 2\nbool numberShorts_three = short_numberOrders >= 3\nbool numberShorts_four = short_numberOrders >= 4\nbool numberShorts_five = short_numberOrders == 5\npos_RideFree = input.bool(false, title=\"[TP] Ride Free\", tooltip=\"If true, the last order (if more than 1 is set) w\nsetLeverage = input.int(defval = 10, title = 'Position Leverage', minval = 1, maxval\nmax_acceptedLoss = input.float(defval = 10, title = 'Maximum Accepted Loss %', minval\namount_per_trade = input.int(10,title='Equity % per trade',minval = 1, maxval = 100\nleveraged_size = strategy.equity * setLeverage  / close * amount_per_trade\n//SHOW SETTINGS\nshow_TP_SL_lines = input.string(title=\"Show TP/SL lines\", defval=\"Entry+TP+SL\", options\nbool i_show_Entry = (show_TP_SL_lines == \"Entry+TP+SL\") or (show_TP_SL_lines == \"Entry+SL\"\nbool i_show_TPLevels = (show_TP_SL_lines == \"Entry+TP+SL\")\nbool i_show_CurrentSL = (show_TP_SL_lines == \"Entry+TP+SL\") or (show_TP_SL_lines ==\n//TAKING PROFIT ENTRIES\nTP1Level = input.float(defval = 30, title = \"TP1: %\", group=\"Taking Profit Levels\"\nTP2Level = input.float(defval = 60, title = \"TP2: %\", group=\"Taking Profit Levels\"\nTP3Level = input.float(defval = 90, title = \"TP3: %\", group=\"Taking Profit Levels\"\nTP4Level = input.float(defval = 120, title = \"TP4: %\", group=\"Taking Profit Levels\"\nTP5Level = input.float(defval = 150, title = \"TP5: %\", group=\"Taking Profit Levels\"\nTP1Ratio = input.float(defval = 1.0, title = \"Ratio\", group=\"Taking Profit Levels\"\nTP2Ratio = input.float(defval = 2.0, title = \"Ratio\", group=\"Taking Profit Levels\"\nTP3Ratio = input.float(defval = 3.0, title = \"Ratio\", group=\"Taking Profit Levels\"\nTP4Ratio = input.float(defval = 4.0, title = \"Ratio\", group=\"Taking Profit Levels\"\nTP5Ratio = input.float(defval = 5.0, title = \"Ratio\", group=\"Taking Profit Levels\"\n//INPUT SETTINGS====================================================================================\n//Here you would add input functions for your strategy calculation \nlenght_fast = input(12, group = \"Indicator Settings\")\nlenght_slow = input(27, group = \"Indicator Settings\")\n//SUPERTREND===================================\nST_Filter = input.bool(false, \"SuperTrend Filter\", group = \"Indicator Settings\")\natrPeriod = 10\nfactor = 3.0\nST_Filter_Show = input.bool(false, \"Show SuperTrend\", group = \"Indicator Settings\"\n//INDICATORS========================================================================================\n//Here you would add the code of every indicator or formula that introduces conditions for positions\ntest_fast = ta.sma(close, lenght_fast)\ntest_slow = ta.sma(close, lenght_slow)\nbullish=ta.crossover(test_fast,test_slow)\nbearish=ta.crossunder(test_fast,test_slow)\n//SUPERTREND FILTER------------------------------\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n//STRATEGY =========================================================================================\nSPRtrend_condition_L = close > supertrend\nSPRtrend_condition_S = close < supertrend\n//And here I usually add those conditions or group of conditions that trigger an Open Long/Short Sig\nlong = bullish\nshort = bearish\n//Detonators\nopenLongSignal = not ST_Filter ? long : long and SPRtrend_condition_L                   \nopenShortSignal = not ST_Filter ? short : short and SPRtrend_condition_S                \ncloseLongSignal = openShortSignal\ncloseShortSignal = openLongSignal\nbool isActiveLong = (openLongSignal or strategy.position_size > 0) and not closeLongSignal\nbool isActiveShort = (openShortSignal or strategy.position_size < 0) and not closeShortSignal\n//---DATE RANGE FILTER SETTINGS---//                                                                \ndateFilter = input.string(defval=\"No\", title=\"Range required?\", options=[ \"Automatic\"\nbool autoFilter = (dateFilter == \"Automatic\")\nbool manualFilter = (dateFilter == \"Manual input\")\nnumberDivisions = input.int(defval = 10, minval = 1, maxval = 10, title = \"Number of divisions\"\nrangeStart = input.int(defval = 0, minval = 0, maxval = 9, title = \"Start->Finish\"\nrangeFinish = input.int(defval = 10, minval = 1, maxval = 10, title = \"\", group=\"Time range settings\"\nrangePlotError = (rangeStart > rangeFinish) or (rangeFinish > numberDivisions) or \nif rangePlotError and barstate.islast   //This will warn of wrong settings\n    label.new(bar_index + 30, close, \"WALKFORWARD WRONG SETTINGS\", color =  #ff000080\n//\nvar int firstTime = na\nif barstate.isfirst\n    firstTime := time\ndateFirst = (math.round((last_bar_time-firstTime)/numberDivisions) * rangeStart) +\ndateLast = (math.round((last_bar_time-firstTime)/numberDivisions) * rangeFinish) +\ninRange_auto = time >= dateFirst and time <= dateLast and autoFilter\n//Manual date filter\nrangeStart_manual = input.time(timestamp(\"01 Jan 2000 00:00:00\"), \"Manual range: Start\"\nrangeFinish_manual = input.time(timestamp(\"01 Jan 2030 00:00:00\"), \"Manual range: Finish\"\ninRange_manual = time >= rangeStart_manual and time <= rangeFinish_manual and manualFilter\ninRange_both = not autoFilter and not manualFilter ? true : inRange_auto or inRange_manual\n//LONG ARRAYS, TP AND SL LOGIC =====================================================================\nfloat LongStopLossLevel = na\nfloat longTP1L = na\nfloat longTP2L = na\nfloat longTP3L = na\nfloat longTP4L = na\nfloat longTP5L = na\nlong_starting_level = (strategy.position_size < 0 ? close : strategy.position_size\nif long_TP_Percentage\n    longTP1L := (1 + TP1Level) * long_starting_level\n    longTP2L := (1 + TP2Level) * long_starting_level\n    longTP3L := (1 + TP3Level) * long_starting_level\n    longTP4L := (1 + TP4Level) * long_starting_level\n    longTP5L := (1 + TP5Level) * long_starting_level\nif long_TP_Ratio\n    if long_SL_Any\n        Simple_SL_Diff = math.abs(long_starting_level - long_starting_level * (1 -\n        longTP1L := long_starting_level + Simple_SL_Diff * TP1Ratio\n        longTP2L := long_starting_level + Simple_SL_Diff * TP2Ratio\n        longTP3L := long_starting_level + Simple_SL_Diff * TP3Ratio\n        longTP4L := long_starting_level + Simple_SL_Diff * TP4Ratio\n        longTP5L := long_starting_level + Simple_SL_Diff * TP5Ratio\nbool longTP1hit = high >= longTP1L\nbool longTP2hit = high >= longTP2L\nbool longTP3hit = high >= longTP3L\nbool longTP4hit = high >= longTP4L\nbool longTP5hit = high >= longTP5L\nif isActiveLong\n    if long_SL_Simple\n        LongStopLossLevel := long_starting_level * (1 - max_acceptedLoss)\n    if long_SL_Scaling\n        if openLongSignal and not (strategy.position_size > 0)\n            LongStopLossLevel := close * (1 - max_acceptedLoss)\n        else\n            longSteppedStopLoss = longTP5hit ? longTP4L : longTP4hit ? longTP3L : \n            LongStopLossLevel := math.max(longSteppedStopLoss, nz(LongStopLossLevel\n    if long_SL_BreakEven1\n        if openLongSignal and not (strategy.position_size > 0)\n            LongStopLossLevel := close * (1 - max_acceptedLoss)\n        else\n            longBEStopLoss = longTP1hit ? strategy.position_avg_price : long_starting_level\n            LongStopLossLevel := math.max(longBEStopLoss, nz(LongStopLossLevel[1])\n    if long_SL_BreakEven2\n        if openLongSignal and not (strategy.position_size > 0)\n            LongStopLossLevel := close * (1 - max_acceptedLoss)\n        else\n            longBEStopLoss = longTP2hit ? strategy.position_avg_price : longTP1hit\n            LongStopLossLevel := math.max(longBEStopLoss, nz(LongStopLossLevel[1])\n    if long_SL_BreakEven3\n        if openLongSignal and not (strategy.position_size > 0)\n            LongStopLossLevel := close * (1 - max_acceptedLoss)\n        else\n            longBEStopLoss = longTP3hit ? strategy.position_avg_price : longTP2hit\n            LongStopLossLevel := math.max(longBEStopLoss, nz(LongStopLossLevel[1])\n    if long_SL_BreakEven4\n        if openLongSignal and not (strategy.position_size > 0)\n            LongStopLossLevel := close * (1 - max_acceptedLoss)\n        else\n            longBEStopLoss = longTP4hit ? strategy.position_avg_price : longTP3hit\n            LongStopLossLevel := math.max(longBEStopLoss, nz(LongStopLossLevel[1])\nbool longSLHIT = low < LongStopLossLevel\n//SHORT ARRAYS, TP AND SL LOGIC ====================================================================\nfloat ShortStopLossLevel = na\nfloat shortTP1L = na\nfloat shortTP2L = na\nfloat shortTP3L = na\nfloat shortTP4L = na\nfloat shortTP5L = na\nshort_starting_level = (strategy.position_size > 0 ? close : strategy.position_size\nif short_TP_Percentage\n    shortTP1L := (1 - TP1Level) * short_starting_level\n    shortTP2L := (1 - TP2Level) * short_starting_level\n    shortTP3L := (1 - TP3Level) * short_starting_level\n    shortTP4L := (1 - TP4Level) * short_starting_level\n    shortTP5L := (1 - TP5Level) * short_starting_level\nif short_TP_Ratio\n    if short_SL_Any\n        Simple_SL_Diff = math.abs(short_starting_level - short_starting_level * (1\n        shortTP1L := short_starting_level - Simple_SL_Diff * TP1Ratio\n        shortTP2L := short_starting_level - Simple_SL_Diff * TP2Ratio\n        shortTP3L := short_starting_level - Simple_SL_Diff * TP3Ratio\n        shortTP4L := short_starting_level - Simple_SL_Diff * TP4Ratio\n        shortTP5L := short_starting_level - Simple_SL_Diff * TP5Ratio\nbool shortTP1hit = low <= shortTP1L\nbool shortTP2hit = low <= shortTP2L\nbool shortTP3hit = low <= shortTP3L\nbool shortTP4hit = low <= shortTP4L\nbool shortTP5hit = low <= shortTP5L\nif isActiveShort\n    if short_SL_Simple\n        ShortStopLossLevel := short_starting_level * (1 + max_acceptedLoss)\n    if short_SL_Scaling\n        if openShortSignal and not (strategy.position_size < 0)\n            ShortStopLossLevel := close * (1 + max_acceptedLoss)\n        else\n            shortSteppedStopLoss = shortTP5hit ? shortTP4L : shortTP4hit ? shortTP3L\n            ShortStopLossLevel := math.min(shortSteppedStopLoss, nz(ShortStopLossLevel\n    if short_SL_BreakEven1\n        if openShortSignal and not (strategy.position_size < 0)\n            ShortStopLossLevel := close * (1 + max_acceptedLoss)\n        else\n            shortBEStopLoss = shortTP1hit ? strategy.position_avg_price : short_starting_level\n            ShortStopLossLevel := math.min(shortBEStopLoss, nz(ShortStopLossLevel[\n    if short_SL_BreakEven2\n        if openShortSignal and not (strategy.position_size < 0)\n            ShortStopLossLevel := close * (1 + max_acceptedLoss)\n        else\n            shortBEStopLoss = shortTP2hit ? strategy.position_avg_price : shortTP1hit\n            ShortStopLossLevel := math.min(shortBEStopLoss, nz(ShortStopLossLevel[\n    if short_SL_BreakEven3\n        if openShortSignal and not (strategy.position_size < 0)\n            ShortStopLossLevel := close * (1 + max_acceptedLoss)\n        else\n            shortBEStopLoss = shortTP3hit ? strategy.position_avg_price : shortTP2hit\n            ShortStopLossLevel := math.min(shortBEStopLoss, nz(ShortStopLossLevel[\n    if short_SL_BreakEven4\n        if openShortSignal and not (strategy.position_size < 0)\n            ShortStopLossLevel := close * (1 + max_acceptedLoss)\n        else\n            shortBEStopLoss = shortTP4hit ? strategy.position_avg_price : shortTP3hit\n            ShortStopLossLevel := math.min(shortBEStopLoss, nz(ShortStopLossLevel[\nbool shortSLHIT = high > ShortStopLossLevel\n//LONG AND SHORT LINES PLOTS    ====================================================================\n//--TP LINES PLOT--//\nfloat plotEntry = na\nif isActiveLong and inRange_both and i_show_Entry\n    if strategy.position_size < 0\n        plotEntry := close\n    else\n        if strategy.position_size >= 0\n            plotEntry := strategy.position_avg_price\nif isActiveShort and inRange_both and i_show_Entry\n    if strategy.position_size > 0\n        plotEntry := close\n    else\n        if strategy.position_size <= 0\n            plotEntry := strategy.position_avg_price\nfloat plotSL = na\nif isActiveLong and inRange_both and i_show_CurrentSL and strategy.position_size >\n    plotSL := LongStopLossLevel\nif isActiveShort and inRange_both and i_show_CurrentSL and strategy.position_size \n    plotSL := ShortStopLossLevel\nfloat plotTP1 = na\nif isActiveLong and inRange_both and i_show_TPLevels and strategy.position_size > \n    plotTP1 := longTP1L\nif isActiveShort and inRange_both and i_show_TPLevels and strategy.position_size <\n    plotTP1 := shortTP1L\nfloat plotTP2 = na\nif isActiveLong and inRange_both and i_show_TPLevels and strategy.position_size > \n    plotTP2 := longTP2L\nif isActiveShort and inRange_both and i_show_TPLevels and strategy.position_size <\n    plotTP2 := shortTP2L\nfloat plotTP3 = na\nif isActiveLong and inRange_both and i_show_TPLevels and strategy.position_size > \n    plotTP3 := longTP3L\nif isActiveShort and inRange_both and i_show_TPLevels and strategy.position_size <\n    plotTP3 := shortTP3L\nfloat plotTP4 = na\nif isActiveLong and inRange_both and i_show_TPLevels and strategy.position_size > \n    plotTP4 := longTP4L\nif isActiveShort and inRange_both and i_show_TPLevels and strategy.position_size <\n    plotTP4 := shortTP4L\nfloat plotTP5 = na\nif isActiveLong and inRange_both and i_show_TPLevels and strategy.position_size > \n    plotTP5 := longTP5L\nif isActiveShort and inRange_both and i_show_TPLevels and strategy.position_size <\n    plotTP5 := shortTP5L\n//\nplot(plotEntry, title = 'Entry Price', color =  #FFFFFF, linewidth = 1, style = plot.style_cross\nplot(plotSL, 'StopLoss Price', color = isActiveLong ?  #0044ff : isActiveShort ? \nplot(plotTP1, title = 'TP 1', color =  #00e2ff80, linewidth = 1, style = plot.style_linebr\nplot(plotTP2, title = 'TP 2', color =  #0bff0080, linewidth = 1, style = plot.style_linebr\nplot(plotTP3, title = 'TP 3', color =  #ffe50080, linewidth = 1, style = plot.style_linebr\nplot(plotTP4, title = 'TP 4', color =  #ff780080, linewidth = 1, style = plot.style_linebr\nplot(plotTP5, title = 'TP 5', color =  #ff000080, linewidth = 1, style = plot.style_linebr\nbodyMiddle = plot(ST_Filter_Show ? (open + close) / 2 : na, display=display.none)\nupTrnd = plot(direction < 0 and ST_Filter_Show ? supertrend : na, \"+ SuperTrend\", \ndnTrnd = plot(direction > 0 and ST_Filter_Show ? supertrend : na, \"- SuperTrend\", \nfill(bodyMiddle, upTrnd,  color.new(color.green, 95), fillgaps=false, title = \"Bullish SuperTrend\"\nfill(bodyMiddle, dnTrnd,  color.new(color.red, 95), fillgaps=false, title = \"Bearish SuperTrend\"\nbgcolor(autoFilter and inRange_auto and not rangePlotError ?  #00ff0008 : autoFilter\n//BACKTESTING   ====================================================================================\n// LONG ORDERS  ============================\norder_quantity_longs = numberLongs_five ? 20 : numberLongs_four ? 25 : numberLongs_three\nlongTPhit_last = numberLongs_five ? longTP5hit : numberLongs_four ? longTP4hit : numberLongs_three\nif signalLongs and inRange_both\n    if (not pos_RideFree ? closeLongSignal or longTPhit_last : closeLongSignal )\n        strategy.close(id = \"Long\", alert_message = 'Long(' + syminfo.ticker + '): Closed position'\n    if openLongSignal\n        strategy.entry(id = \"Long\", direction = strategy.long, alert_message = 'Long('\n    if isActiveLong\n        strategy.exit(id = \"Long Scaling TP1\", from_entry = \"Long\", stop = LongStopLossLevel\n        if numberLongs_two\n            strategy.exit(id = \"Long Scaling TP2\", from_entry = \"Long\", stop = LongStopLossLevel\n        if numberLongs_three\n            strategy.exit(id = \"Long Scaling TP3\", from_entry = \"Long\", stop = LongStopLossLevel\n        if numberLongs_four\n            strategy.exit(id = \"Long Scaling TP4\", from_entry = \"Long\", stop = LongStopLossLevel\n        if numberLongs_five\n            strategy.exit(id = \"Long Scaling TP5\", from_entry = \"Long\", stop = LongStopLossLevel\n// SHORT ORDERS ============================\norder_quantity_shorts = numberShorts_five ? 20 : numberShorts_four ? 25 : numberShorts_three\nshortTPhit_last = numberShorts_five ? shortTP5hit : numberShorts_four ? shortTP4hit\nif signalShorts and inRange_both\n    if (not pos_RideFree ? closeShortSignal or shortTPhit_last : closeShortSignal \n        strategy.close(id = \"Short\", alert_message = 'Short(' + syminfo.ticker + '): Closed position'\n    if openShortSignal\n        strategy.entry(id = \"Short\", direction = strategy.short, alert_message = 'Short('\n    if isActiveShort\n        strategy.exit(id = \"Short Scaling TP1\", from_entry = \"Short\", stop = ShortStopLossLevel\n        if numberShorts_two\n            strategy.exit(id = \"Short Scaling TP2\", from_entry = \"Short\", stop = ShortStopLossLevel\n        if numberShorts_three\n            strategy.exit(id = \"Short Scaling TP3\", from_entry = \"Short\", stop = ShortStopLossLevel\n        if numberShorts_four\n            strategy.exit(id = \"Short Scaling TP4\", from_entry = \"Short\", stop = ShortStopLossLevel\n        if numberShorts_five\n            strategy.exit(id = \"Short Scaling TP5\", from_entry = \"Short\", stop = ShortStopLossLevel\n//\nplotshape(strategy.position_size <= 0 ? openLongSignal : na, style=shape.triangleup\nplotshape(strategy.position_size >= 0 ? openShortSignal : na, style=shape.triangledown\n// # ========================================================================= #\n// #                   |   Portfolio table |\n// # ========================================================================= #\ntable_initial_capital = strategy.initial_capital\ntable_net_profit = strategy.netprofit\ntable_realised_balance = strategy.initial_capital + strategy.netprofit\ntable_open_profit = strategy.openprofit\ntable_equity = strategy.equity\ntable_position_size = math.abs(strategy.position_size) / setLeverage\ntable_avg_price = nz(strategy.position_avg_price)\ntable_position_cost = table_position_size * table_avg_price\ntable_cash = strategy.initial_capital + strategy.netprofit - table_position_size *\ntable_position_ROI = nz(table_open_profit / table_position_cost) * 100\nshow_PF_table = input.string(defval=\"Normal\", title=\"Portfolio table\", options=[\"Large\"\nbool PF_table_size_tiny = show_PF_table == \"Tiny\"\nbool PF_table_size_small = show_PF_table == \"Small\"\nbool PF_table_size_normal = show_PF_table == \"Normal\"\nbool PF_table_size_large = show_PF_table == \"Large\"\nbool PF_table_shown = show_PF_table != \"Disabled\"\nPF_table_location = input.string(defval=\"Top right\", title=\" \", options=[\"Top mid\"\nstring PF_table_loc = PF_table_location == \"Top mid\" ? position.top_center : PF_table_location\nvar table portfolio_table = PF_table_shown ? table.new(PF_table_loc, 4, 5, border_width\nftable(_table_id, _column, _row, _text, _bgcolor) =>\n    table.cell(_table_id, _column, _row, _text, 0, 0,  color.black, text.align_right\nftable(portfolio_table, 0, 0, 'Equity: ',  #9598a1)\nftable(portfolio_table, 1, 0, str.tostring(table_equity, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 0, 1, 'Open Profit: ',  #9598a1)\nftable(portfolio_table, 1, 1, str.tostring(table_open_profit, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 0, 2, 'Realised Balance: ',  #9598a1)\nftable(portfolio_table, 1, 2, str.tostring(table_realised_balance, '#.##') + ' ' +\nftable(portfolio_table, 0, 3, 'Net Profit: ',  #9598a1)\nftable(portfolio_table, 1, 3, str.tostring(table_net_profit, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 0, 4, 'Initial Capital: ',  #9598a1)\nftable(portfolio_table, 1, 4, str.tostring(table_initial_capital, '#.##') + ' ' + \nftable(portfolio_table, 2, 0, 'Cash: ',  #9598a1)\nftable(portfolio_table, 3, 0, str.tostring(table_cash, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 2, 1, 'Position Cost: ',  #9598a1)\nftable(portfolio_table, 3, 1, str.tostring(table_position_cost, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 2, 2, 'Position Size: ',  #9598a1)\nftable(portfolio_table, 3, 2, str.tostring(table_position_size, '#.####') + ' ' + \nftable(portfolio_table, 2, 3, 'Average Price: ',  #9598a1)\nftable(portfolio_table, 3, 3, str.tostring(table_avg_price, '#.##') + ' ' + syminfo.currency\nftable(portfolio_table, 2, 4, 'Position ROI: ',  #9598a1)\nftable(portfolio_table, 3, 4, str.tostring(table_position_ROI, '#.##') + ' %', table_position_ROI\n// # ========================================================================= #\n// #                   |   Returns table |                                          Modified version\n// # ========================================================================= #\nTableReturnsSetting = input.string(defval=\"Disabled\", title=\"Table performance setting\"\nbool TableWeekly = TableReturnsSetting == \"Weekly\"\nbool TableMonthly = TableReturnsSetting == \"Monthly\"\nprec      = 2\nnew_week = weekofyear(time) != weekofyear(time[1])\nnew_month = month(time) != month(time[1])\nnew_year = year(time) != year(time[1])\neq = strategy.equity\nbar_pnl = eq / eq[1] - 1\ncur_week_pnl = 0.0\ncur_month_pnl = 0.0\ncur_year_pnl = 0.0\ncur_week_pnl := new_week ? 0.0 : (1 + cur_week_pnl[1]) * (1 + bar_pnl) - 1\ncur_month_pnl := new_month ? 0.0 : (1 + cur_month_pnl[1]) * (1 + bar_pnl) - 1\ncur_year_pnl := new_year ? 0.0 : (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1\nvar week_pnl = array.new_float(0)\nvar week_time = array.new_int(0)\nvar month_pnl = array.new_float(0)\nvar month_time = array.new_int(0)\nvar year_pnl = array.new_float(0)\nvar year_time = array.new_int(0)\nlast_computed = false\nif not na(cur_week_pnl[1]) and (new_week or barstate.islast)\n    if last_computed[1]\n        array.pop(week_pnl)\n        array.pop(week_time)\n    array.push(week_pnl, cur_week_pnl[1])\n    array.push(week_time, time[1])\nif not na(cur_month_pnl[1]) and (new_month or barstate.islast)\n    if last_computed[1]\n        array.pop(month_pnl)\n        array.pop(month_time)\n    array.push(month_pnl, cur_month_pnl[1])\n    array.push(month_time, time[1])\nif not na(cur_year_pnl[1]) and (new_year or barstate.islast)\n    if last_computed[1]\n        array.pop(year_pnl)\n        array.pop(year_time)\n    array.push(year_pnl, cur_year_pnl[1])\n    array.push(year_time, time[1])\nlast_computed := barstate.islast ? true : nz(last_computed[1])\n// Weekly P&L Table\ntable_size = size.tiny\nvar weekly_table = table(na)\nif array.size(year_pnl) > 0 and TableWeekly\n    weekly_table := table.new(position.bottom_right, \n                 columns=56, rows=array.size(year_pnl) * 3 + 5, border_width=1)\n    table.cell(weekly_table, 0, 0,  'Perf', \n                 bgcolor =  #999999, text_size= table_size)\n    for numW = 1 to 53 by 1\n        table.cell(weekly_table, numW, 0,  str.tostring(numW), \n                 bgcolor=  #999999, text_size= table_size)\n    table.cell(weekly_table, 54, 0, ' ',    \n                 bgcolor =  #999999, text_size= table_size)\n    table.cell(weekly_table, 55, 0, 'Year', \n                 bgcolor =  #999999, text_size= table_size)\n    max_abs_y = math.max(math.abs(array.max(year_pnl)), math.abs(array.min(year_pnl\n    max_abs_m = math.max(math.abs(array.max(week_pnl)), math.abs(array.min(week_pnl\n    for yi = 0 to array.size(year_pnl) - 1 by 1\n        table.cell(weekly_table, 0,  yi + 1,\n                 str.tostring(year(array.get(year_time, yi))), \n                 bgcolor= #cccccc, text_size=table_size)\n        table.cell(weekly_table, 53, yi + 1, ' ',   \n                 bgcolor= #999999, text_size=table_size)\n        table.cell(weekly_table, 54, yi + 1, ' ',   \n                 bgcolor= #999999, text_size=table_size)\n        y_color = array.get(year_pnl, yi) == 0 ?  #e6b996 : array.get(year_pnl, yi\n        table.cell(weekly_table, 55, yi + 1, \n                 str.tostring(math.round(array.get(year_pnl, yi) * 100, prec)), \n                 bgcolor=y_color, text_size=table_size)\n    int iw_row= na\n    int iw_col= na\n    for wi = 0 to array.size(week_time) - 2 by 1\n        w_row   = year(array.get(week_time, wi)) - year(array.get(year_time, 0)) +\n        w_col   = weekofyear(array.get(week_time, wi))\n        w_color = array.get(week_pnl, wi) == 0 ?  #e6b996 : array.get(week_pnl, wi\n        if iw_row + 1 == w_row and iw_col + 1 == w_col\n            table.cell(weekly_table, w_col, w_row-1,\n                 str.tostring(math.round(array.get(week_pnl, wi) * 100, prec)), \n                 bgcolor=w_color, text_size=table_size)\n        else\n            table.cell(weekly_table, w_col, w_row,\n                 str.tostring(math.round(array.get(week_pnl, wi) * 100, prec)), \n                 bgcolor=w_color, text_size=table_size)\n        iw_row:= w_row\n        iw_col:= w_col\n// Monthly P&L Table    \nvar monthly_table = table(na)\nif barstate.islast and TableMonthly\n    monthly_table := table.new(position.bottom_right, columns=14, rows=array.size(\n    table.cell(monthly_table, 0, 0, '', bgcolor= #cccccc)\n    table.cell(monthly_table, 1, 0, 'Jan', bgcolor= #cccccc)\n    table.cell(monthly_table, 2, 0, 'Feb', bgcolor= #cccccc)\n    table.cell(monthly_table, 3, 0, 'Mar', bgcolor= #cccccc)\n    table.cell(monthly_table, 4, 0, 'Apr', bgcolor= #cccccc)\n    table.cell(monthly_table, 5, 0, 'May', bgcolor= #cccccc)\n    table.cell(monthly_table, 6, 0, 'Jun', bgcolor= #cccccc)\n    table.cell(monthly_table, 7, 0, 'Jul', bgcolor= #cccccc)\n    table.cell(monthly_table, 8, 0, 'Aug', bgcolor= #cccccc)\n    table.cell(monthly_table, 9, 0, 'Sep', bgcolor= #cccccc)\n    table.cell(monthly_table, 10, 0, 'Oct', bgcolor= #cccccc)\n    table.cell(monthly_table, 11, 0, 'Nov', bgcolor= #cccccc)\n    table.cell(monthly_table, 12, 0, 'Dec', bgcolor= #cccccc)\n    table.cell(monthly_table, 13, 0, 'Year', bgcolor= #999999)\n    for yi = 0 to array.size(year_pnl) - 1 by 1\n        table.cell(monthly_table, 0, yi + 1, str.tostring(year(array.get(year_time\n        y_color = array.get(year_pnl, yi) > 0 ?  #4caf50 :  #ff5252\n        table.cell(monthly_table, 13, yi + 1, str.tostring(math.round(array.get(year_pnl\n    for mi = 0 to array.size(month_time) - 1 by 1\n        m_row = year(array.get(month_time, mi)) - year(array.get(year_time, 0)) + \n        m_col = month(array.get(month_time, mi))\n        m_color = array.get(month_pnl, mi) > 0 ?  #4caf50 :  #ff5252\n        table.cell(monthly_table, m_col, m_row, str.tostring(math.round(array.get(\n//\n// # ========================================================================= #\n// #                   |   Support and Resistance Bands |                           Volume based S/R\n// # ========================================================================= #\nint lengthSR = 20\nchange = volume / volume[1] - 1\nstdev = ta.stdev(change, lengthSR)\ndifference = change / stdev[1]\nfloat Treshold = 5\nzero = 0\nsignalSR = math.abs(difference)\nleveluphi = ta.valuewhen(signalSR > Treshold, high[1], 0)\nleveluplo = ta.valuewhen(signalSR > Treshold, low[1], 0)\nplotSRareas = input.bool(true, \"Enable Volume S/R\",group = \"Extra settings\")\np1 = plot(plotSRareas ? leveluphi : na, style=plot.style_circles, color= #ffffff80\np2 = plot(plotSRareas ? leveluplo : na, style=plot.style_circles, color= #ffffff80\nfill(p1, p2, color= #ffffff1a, title = \"Volume S/R Bands\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Update define correctly property and multiple any zone.                                                    Release Notes:                                                    Update chart                                                    Release Notes:                                                    Update chart                                                    Release Notes:                                                    Update chart"}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"Grospector DCA V.3\", shorttitle=\"GDCA V.3\",precision=7, overlay=true\n//------------------------------ MA ------------------------------\nlen = input.int(title=\"MA Period\", defval=365*4)\nstrongLen = input.int(title=\"Strong Period from MA Period\", defval=365)\nshortMulti = input.float(title=\"Short Multi\", defval=3)\nstrongSellMulti = input.float(title=\"Strong Sell Multi\", defval=4)\nsellMulti = input.float(title=\"Sell Multi\", defval=2.5)\nbuyMulti = input.float(title=\"Buy Multi\", defval=1) \nstrongBuyMulti = input.float(title=\"Strong Buy Multi\", defval=0.8) \nlongMulti = input.float(title=\"Long Multi\", defval=0.3)\nprice = input.source(title=\"Price\", defval=close)\nlabelSwitch = input.bool(title='Turn on assistive text', defval=true)\nzoneSwitch = input.int(title='Turn on assistive zone',tooltip=\"1 = all, 2 = chart only, 3 = data only,4 = none\"\npredictFuturePrice = input.bool(title='Turn on predict future price', defval=true)\nDCA = input.int(title=\"DCA Plan (USD)\",defval=1000)\nWaitingDCA = input.float(title=\"Waiting DCA (USD)\",defval=0)\nInvested = input.int(title=\"Invested (USD)\",defval=0)\nstrategySwitch = input.bool(title='Turn on strategy', defval=true)\nseperateDayOfMonth = input.int(title='Seperate day of month',tooltip=\"0 = none, 1-31 day\"\nuseReserve = input.bool(title='Turn on use reserve', defval=true)\nuseDerivative = input.bool(title='Turn on use derivative', defval=true)\nuseHalving = input.bool(title='Turn on use halvings', defval=true)\nextendHalfOfHalving = input.int(title='Extend half of halving date', defval=200,minval\nStartShortZone = input.int(title=\"Start Short Zone %\",defval=100)\nEndShortZone = input.int(title=\"Start Short Zone %\",defval=0,minval=0)\nStartSellZone = input.int(title=\"Start Sell Zone %\",defval=100,minval=0,maxval=100\nEndSellZone = input.int(title=\"End Sell Zone %\",defval=0,minval=0,maxval=100)\nStartNormalZone = input.int(title=\"Start Normal Zone %\",defval=0,minval=0,maxval=100\nEndNormalZone = input.int(title=\"End Normal Zone %\",defval=100,minval=0,maxval=100\nStartBuyZone = input.int(title=\"Start Buy Zone %\",defval=100,minval=0)\nEndBuyZone = input.int(title=\"End Buy Zone %\",defval=200,minval=0)\nStartLongZone = input.int(title=\"Start Long Zone %\",defval=0,minval=0)\nEndLongZone = input.int(title=\"End Long Zone %\",defval=100,minval=0)\nbgcolor(dayofmonth == seperateDayOfMonth ?  color.new(color.red, 70) : na,display\nbar = barstate.isnew\nlast_bar = barstate.islastconfirmedhistory\n//Sell\nlenSell = len\nsrcSell = price\noffsetSell = 0\nmaSell = ta.sma(srcSell*sellMulti, lenSell)\ndisplayZone = zoneSwitch == 1?display.all:zoneSwitch == 2?display.pane:zoneSwitch \nderivertiveDisplayZone = useDerivative ? displayZone:display.none\nplot(maSell, color= #f23645, title=\"Strong Sell\", offset=offsetSell, linewidth=3,\n//Strong Sell\noffsetStrongSell = 0\nmaStrongSell = ta.sma(maSell*strongSellMulti, strongLen)\nplot(maStrongSell, color= #b22833, title=\"Sell\", offset=offsetStrongSell, linewidth\n//Short\nmaShort = maStrongSell * shortMulti\nplot(maShort, color= #801922, title=\"Short\", linewidth=6,display=derivertiveDisplayZone\n//Buy\nlenBuy = len\nsrcBuy = price\noffsetBuy = 0\nmaBuy = ta.sma(srcBuy*buyMulti, lenBuy)\nplot(maBuy, color= color.green, title=\"Buy\", offset=offsetBuy, linewidth=3,display\n//Strong Buy\nlenStrongBuy = strongLen\noffsetStrongBuy = 0\nmaStrongBuy = ta.sma(maBuy*strongBuyMulti, lenStrongBuy)\nplot(maStrongBuy, color= #1b5e20, title=\"Strong Buy\", offset=offsetStrongBuy,linewidth\n//Long\nmaLong = maStrongBuy * longMulti\nplot(maLong, color= #00332a, title=\"Long\", linewidth=6,display=derivertiveDisplayZone\n//index \nindexDerivertive = 0\nindexDerivertive := maLong > 0 or maShort > 0 ? indexDerivertive[1]+1 : 0\nindexStrong = 0\nindexStrong := maStrongBuy > 0 or maStrongSell > 0 ? indexStrong[1]+1 : 0\nindex = 0\nindex := maBuy > 0 or maSell > 0 ? index[1]+1 : 0\n//channel\nhigherSell = maSell > maStrongSell ? maSell : maStrongSell\nlowerSell = maSell < maStrongSell ? maSell : maStrongSell\nhigherBuy = maBuy > maStrongBuy ? maBuy : maStrongBuy\nlowerBuy = maBuy < maStrongBuy ? maBuy : maStrongBuy\ngapShort = (maShort - higherSell)/10\ngapSell = (higherSell - lowerSell)/10\ngapNormal = (lowerSell - higherBuy)/10\ngapBuy = (higherBuy - maStrongBuy)/10\ngapLong = (maStrongBuy - maLong)/10\nchannelShort1 = maShort - (gapShort*1)\nchannelShort2 = maShort - (gapShort*2)\nchannelShort3 = maShort - (gapShort*3)\nchannelShort4 = maShort - (gapShort*4)\nchannelShort5 = maShort - (gapShort*5)\nchannelShort6 = maShort - (gapShort*6)\nchannelShort7 = maShort - (gapShort*7)\nchannelShort8 = maShort - (gapShort*8)\nchannelShort9 = maShort - (gapShort*9)\nchannelShort10 = maShort - (gapShort*10)\nplot(channelShort1, color= #801922, title=\"Strong Short Channel 1\", linewidth=1,display\nplot(channelShort2, color= #801922, title=\"Strong Short Channel 2\", linewidth=1,display\nplot(channelShort3, color= #801922, title=\"Strong Short Channel 3\", linewidth=1,display\nplot(channelShort4, color= #801922, title=\"Strong Short Channel 4\", linewidth=1,display\nplot(channelShort5, color= #801922, title=\"Strong Short Channel 5\", linewidth=1,display\nplot(channelShort6, color= #801922, title=\"Strong Short Channel 6\", linewidth=1,display\nplot(channelShort7, color= #801922, title=\"Strong Short Channel 7\", linewidth=1,display\nplot(channelShort8, color= #801922, title=\"Strong Short Channel 8\", linewidth=1,display\nplot(channelShort9, color= #801922, title=\"Strong Short Channel 9\", linewidth=1,display\nplot(channelShort10, color= #801922, title=\"Strong Short Channel 10\", linewidth=1\nchannelSell1 = higherSell - (gapSell*1)\nchannelSell2 = higherSell - (gapSell*2)\nchannelSell3 = higherSell - (gapSell*3)\nchannelSell4 = higherSell - (gapSell*4)\nchannelSell5 = higherSell - (gapSell*5)\nchannelSell6 = higherSell - (gapSell*6)\nchannelSell7 = higherSell - (gapSell*7)\nchannelSell8 = higherSell - (gapSell*8)\nchannelSell9 = higherSell - (gapSell*9)\nchannelSell10 = higherSell - (gapSell*10)\nplot(channelSell1, color= #b22833, title=\"Strong Sell Channel 1\", linewidth=1,display\nplot(channelSell2, color= #b22833, title=\"Strong Sell Channel 2\", linewidth=1,display\nplot(channelSell3, color= #b22833, title=\"Strong Sell Channel 3\", linewidth=1,display\nplot(channelSell4, color= #b22833, title=\"Strong Sell Channel 4\", linewidth=1,display\nplot(channelSell5, color= #b22833, title=\"Strong Sell Channel 5\", linewidth=1,display\nplot(channelSell6, color= #b22833, title=\"Strong Sell Channel 6\", linewidth=1,display\nplot(channelSell7, color= #b22833, title=\"Strong Sell Channel 7\", linewidth=1,display\nplot(channelSell8, color= #b22833, title=\"Strong Sell Channel 8\", linewidth=1,display\nplot(channelSell9, color= #b22833, title=\"Strong Sell Channel 9\", linewidth=1,display\nplot(channelSell10, color= #b22833, title=\"Strong Sell Channel 10\", linewidth=1,display\nchannelNormal1 = lowerSell - (gapNormal*1) \nchannelNormal2 = lowerSell - (gapNormal*2)\nchannelNormal3 = lowerSell - (gapNormal*3)\nchannelNormal4 = lowerSell - (gapNormal*4)\nchannelNormal5 = lowerSell - (gapNormal*5)\nchannelNormal6 = lowerSell - (gapNormal*6)\nchannelNormal7 = lowerSell - (gapNormal*7)\nchannelNormal8 = lowerSell - (gapNormal*8)\nchannelNormal9 = lowerSell - (gapNormal*9)\nchannelNormal10 = lowerSell - (gapNormal*10)\nplot(channelNormal1, color= #f57f17, title=\"Normal Channel 1\", linewidth=1,display\nplot(channelNormal2, color= #f57f17, title=\"Normal Channel 2\", linewidth=1,display\nplot(channelNormal3, color= #f57f17, title=\"Normal Channel 3\", linewidth=1,display\nplot(channelNormal4, color= #f57f17, title=\"Normal Channel 4\", linewidth=1,display\nplot(channelNormal5, color= #f57f17, title=\"Normal Channel 5\", linewidth=1,display\nplot(channelNormal6, color= #f57f17, title=\"Normal Channel 6\", linewidth=1,display\nplot(channelNormal7, color= #f57f17, title=\"Normal Channel 7\", linewidth=1,display\nplot(channelNormal8, color= #f57f17, title=\"Normal Channel 8\", linewidth=1,display\nplot(channelNormal9, color= #f57f17, title=\"Normal Channel 9\", linewidth=1,display\nplot(channelNormal10, color= #f57f17, title=\"Normal Channel 10\", linewidth=1,display\nchannelBuy1 = higherBuy - (gapBuy*1)\nchannelBuy2 = higherBuy - (gapBuy*2)\nchannelBuy3 = higherBuy - (gapBuy*3)\nchannelBuy4 = higherBuy - (gapBuy*4)\nchannelBuy5 = higherBuy - (gapBuy*5)\nchannelBuy6 = higherBuy - (gapBuy*6)\nchannelBuy7 = higherBuy - (gapBuy*7)\nchannelBuy8 = higherBuy - (gapBuy*8)\nchannelBuy9 = higherBuy - (gapBuy*9)\nchannelBuy10 = higherBuy - (gapBuy*10)\nplot(channelBuy1, color= #1b5e20, title=\"Strong Buy Channel 1\", linewidth=1,display\nplot(channelBuy2, color= #1b5e20, title=\"Strong Buy Channel 2\", linewidth=1,display\nplot(channelBuy3, color= #1b5e20, title=\"Strong Buy Channel 3\", linewidth=1,display\nplot(channelBuy4, color= #1b5e20, title=\"Strong Buy Channel 4\", linewidth=1,display\nplot(channelBuy5, color= #1b5e20, title=\"Strong Buy Channel 5\", linewidth=1,display\nplot(channelBuy6, color= #1b5e20, title=\"Strong Buy Channel 6\", linewidth=1,display\nplot(channelBuy7, color= #1b5e20, title=\"Strong Buy Channel 7\", linewidth=1,display\nplot(channelBuy8, color= #1b5e20, title=\"Strong Buy Channel 8\", linewidth=1,display\nplot(channelBuy9, color= #1b5e20, title=\"Strong Buy Channel 9\", linewidth=1,display\nplot(channelBuy10, color= #1b5e20, title=\"Strong Buy Channel 10\", linewidth=1,display\nchannelLong1 = maStrongBuy - (gapLong*1)\nchannelLong2 = maStrongBuy - (gapLong*2)\nchannelLong3 = maStrongBuy - (gapLong*3)\nchannelLong4 = maStrongBuy - (gapLong*4)\nchannelLong5 = maStrongBuy - (gapLong*5)\nchannelLong6 = maStrongBuy - (gapLong*6)\nchannelLong7 = maStrongBuy - (gapLong*7)\nchannelLong8 = maStrongBuy - (gapLong*8)\nchannelLong9 = maStrongBuy - (gapLong*9)\nchannelLong10 = maStrongBuy - (gapLong*10)\nplot(channelLong1, color= #00332a, title=\"Strong Long Channel 1\", linewidth=1,display\nplot(channelLong2, color= #00332a, title=\"Strong Long Channel 2\", linewidth=1,display\nplot(channelLong3, color= #00332a, title=\"Strong Long Channel 3\", linewidth=1,display\nplot(channelLong4, color= #00332a, title=\"Strong Long Channel 4\", linewidth=1,display\nplot(channelLong5, color= #00332a, title=\"Strong Long Channel 5\", linewidth=1,display\nplot(channelLong6, color= #00332a, title=\"Strong Long Channel 6\", linewidth=1,display\nplot(channelLong7, color= #00332a, title=\"Strong Long Channel 7\", linewidth=1,display\nplot(channelLong8, color= #00332a, title=\"Strong Long Channel 8\", linewidth=1,display\nplot(channelLong9, color= #00332a, title=\"Strong Long Channel 9\", linewidth=1,display\nplot(channelLong10, color= #00332a, title=\"Strong Long Channel 10\", linewidth=1,display\n//--------------------------------------------------------------------------------------------------\n//------------------------------------------ Calculate ---------------------------------------------\nshort = price > higherSell \nsell = price > lowerSell and price < higherSell\nhalfBuy = price < lowerSell and price > higherBuy \nbuy = price < higherBuy and price > lowerBuy\nlong = price < lowerBuy\npercent = 0\npercentPeriodOfZoneShort = math.abs(StartShortZone - EndShortZone)/10\npercentPeriodOfZoneSell = math.abs(StartSellZone - EndSellZone)/10\npercentPeriodOfZoneNormal = math.abs(StartNormalZone - EndNormalZone)/10\npercentPeriodOfZoneBuy = math.abs(StartBuyZone - EndBuyZone)/10\npercentPeriodOfZoneLong = math.abs(StartLongZone - EndLongZone)/10\nif(short)\n    percent := price > channelShort1 ? StartShortZone-(percentPeriodOfZoneShort*1)\n              price > channelShort2 ? StartShortZone-(percentPeriodOfZoneShort*2) \n              price > channelShort3 ? StartShortZone-(percentPeriodOfZoneShort*3) \n              price > channelShort4 ? StartShortZone-(percentPeriodOfZoneShort*4) \n              price > channelShort5 ? StartShortZone-(percentPeriodOfZoneShort*5) \n              price > channelShort6 ? StartShortZone-(percentPeriodOfZoneShort*6) \n              price > channelShort7 ? StartShortZone-(percentPeriodOfZoneShort*7) \n              price > channelShort8 ? StartShortZone-(percentPeriodOfZoneShort*8) \n              price > channelShort9 ? StartShortZone-(percentPeriodOfZoneShort*9) \n              StartShortZone-(percentPeriodOfZoneShort*10)\nelse if(sell)\n    percent := price > channelSell1 ? StartSellZone-(percentPeriodOfZoneSell*1) :\n              price > channelSell2 ? StartSellZone-(percentPeriodOfZoneSell*2) : \n              price > channelSell3 ? StartSellZone-(percentPeriodOfZoneSell*3) : \n              price > channelSell4 ? StartSellZone-(percentPeriodOfZoneSell*4) : \n              price > channelSell5 ? StartSellZone-(percentPeriodOfZoneSell*5) : \n              price > channelSell6 ? StartSellZone-(percentPeriodOfZoneSell*6) : \n              price > channelSell7 ? StartSellZone-(percentPeriodOfZoneSell*7) : \n              price > channelSell8 ? StartSellZone-(percentPeriodOfZoneSell*8) : \n              price > channelSell9 ? StartSellZone-(percentPeriodOfZoneSell*9) : \n              StartSellZone-(percentPeriodOfZoneSell*10)\nelse if(halfBuy)\n    percent := price > channelNormal1 ? StartNormalZone+(percentPeriodOfZoneNormal\n              price > channelNormal2 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal3 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal4 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal5 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal6 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal7 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal8 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              price > channelNormal9 ? StartNormalZone+(percentPeriodOfZoneNormal*\n              StartNormalZone+(percentPeriodOfZoneNormal*10)\nelse if(buy)\n    percent := price > channelBuy1 ? StartBuyZone+(percentPeriodOfZoneBuy*1) :\n              price > channelBuy2 ? StartBuyZone+(percentPeriodOfZoneBuy*2) : \n              price > channelBuy3 ? StartBuyZone+(percentPeriodOfZoneBuy*3) : \n              price > channelBuy4 ? StartBuyZone+(percentPeriodOfZoneBuy*4) : \n              price > channelBuy5 ? StartBuyZone+(percentPeriodOfZoneBuy*5) : \n              price > channelBuy6 ? StartBuyZone+(percentPeriodOfZoneBuy*6) : \n              price > channelBuy7 ? StartBuyZone+(percentPeriodOfZoneBuy*7) : \n              price > channelBuy8 ? StartBuyZone+(percentPeriodOfZoneBuy*8) : \n              price > channelBuy9 ? StartBuyZone+(percentPeriodOfZoneBuy*9) :\n              StartBuyZone+(percentPeriodOfZoneBuy*10)\nelse if(long)\n    percent := price > channelLong1 ? StartLongZone+(percentPeriodOfZoneLong*1) :\n              price > channelLong2 ? StartLongZone+(percentPeriodOfZoneLong*2) : \n              price > channelLong3 ? StartLongZone+(percentPeriodOfZoneLong*3) : \n              price > channelLong4 ? StartLongZone+(percentPeriodOfZoneLong*4) : \n              price > channelLong5 ? StartLongZone+(percentPeriodOfZoneLong*5) : \n              price > channelLong6 ? StartLongZone+(percentPeriodOfZoneLong*6) : \n              price > channelLong7 ? StartLongZone+(percentPeriodOfZoneLong*7) : \n              price > channelLong8 ? StartLongZone+(percentPeriodOfZoneLong*8) : \n              price > channelLong9 ? StartLongZone+(percentPeriodOfZoneLong*9) :\n              StartLongZone+(percentPeriodOfZoneLong*10)\n//--------------------------------------------------------------------------------------------------\n//-------------------------------------------- Display ---------------------------------------------\nlabeltcolor =  color.white\ntextLabel = buy ? 'Buy' : halfBuy ? \"Normal Buy\" : long ? \"Long\" : sell ? \"Sell\" :\nlabelcolor = buy ?  color.green : halfBuy ?  color.orange : long ?  color.green\nreserve = 0.0\nreserve := barstate.isfirst ? WaitingDCA : reserve[1]\namountBuy = 0.0\namountSell = 0.0\nif(percent > 100)\n    amountBuy := (useReserve ? (reserve*(percent - 100)/100) : 0) + (DCA*100/100)\nelse\n    amountBuy := (DCA*percent/100)\nif(percent < 0)\n    amountSell := ((Invested*(percent)/100))/price\nelse\n    amountSell := (Invested*(percent)/100)/price\n    currency = buy ? syminfo.currency : halfBuy ? syminfo.currency : long ? syminfo.currency\ntextAmount = buy or halfBuy or long ? str.format(\"+{0}\",amountBuy) : str.format(\"-{0}\"\nwaitingAmount = amountBuy < DCA ? (DCA - amountBuy) : reserve > amountBuy ? (reserve\nwaitingOperator = percent > 100 ? \"\" : \"+\"\ntextWaitingAmount = buy or halfBuy or long ? str.format(\"{0}{1}\",waitingOperator,waitingAmount\nvar table panelTable = table.new(position.bottom_right, 5, 5, border_width=1)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \" \" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\nvar bgPanelColor =  color.new(color.black,0)\nif labelSwitch\n    // Update table\n    f_fillCell(panelTable, 0, 0, \"Zone:\", textLabel, bgPanelColor, labelcolor)\n    f_fillCell(panelTable, 0, 1, \"Percent:\", str.tostring(percent) + \" %\", bgPanelColor\n    f_fillCell(panelTable, 0, 2, \"Amount:\", textAmount +\" \"+ currency, bgPanelColor\n    f_fillCell(panelTable, 0, 3, \"Waiting Amount:\", textWaitingAmount  +\" \"+ syminfo.currency\n    f_fillCell(panelTable, 0, 4, \"Reserve:\", str.tostring(reserve)  +\" \"+ syminfo.currency\n//--------------------------------------------------------------------------------------------------\n//------------------------------------------ Strategy ----------------------------------------------\nqty = 0.0\nshortSize = 0.0\nshortSize := barstate.isfirst ? 0.0:shortSize[1]\nlongSize = 0.0\nlongSize := barstate.isfirst ? 0.0:longSize[1]\n//Calculate QTY and Waiting DCA\nif(buy)\n    qty := amountBuy/price\n    reserve := percent > 100 and useReserve ? reserve * (percent-100)/100 : reserve\nelse if(halfBuy)\n    qty := amountBuy/price\n    reserve := percent > 100 and useReserve ? reserve * (percent-100)/100 : reserve\nelse if(sell)\n    qty := strategy.position_size > 0 ? strategy.position_size * percent/100 : 0\nelse if(short)\n    qty := (DCA/price) * percent/100\nelse if(long)\n    qty := (DCA/price) * percent/100\n// plot(reserve,title=\"reserve\",display=display.data_window)\n// plot(qty,title=\"qty\",display=display.data_window)\n// plot(percent,title=\"percent\",display=display.data_window)\n// plot(amountBuy/price,title=\"amountBuy\",display=display.data_window)\n// plot(waitingAmount,title=\"waiting amount\",display=display.data_window)\n// plot(price,title=\"price\",display=display.data_window)\n// plot(indexStrong,title=\"indexStrong\",display=display.data_window)\n//Order\nif(strategySwitch and qty > 0)\n    if(bar and buy)\n        strategy.order(str.format(\"DCA Buy {0}% = {1} {2}\",percent,qty,syminfo.basecurrency\n    else if(bar and halfBuy)\n        strategy.order(str.format(\"DCA Normal {0}% = {1} {2}\",percent,qty,syminfo.basecurrency\n    else if(bar and sell)\n        strategy.order(str.format(\"DCA Sell {0}% = {1} {2}\",percent,qty,syminfo.basecurrency\n            if(useDerivative)\n        if(bar and short)\n            strategy.order(str.format(\"DCA Short {0}% = {1} {2}\",percent,qty,syminfo.basecurrency\n        if(bar and long)\n            strategy.order(str.format(\"DCA Long {0}% = {1} {2}\",percent,qty,syminfo.basecurrency\n            //Exit Derivative\nif(strategySwitch and useDerivative)\n    if(bar and halfBuy and shortSize > 0)\n        strategy.order(str.format(\"Exit Short\",percent,shortSize,syminfo.basecurrency\n        shortSize := 0\n    if(bar and halfBuy and longSize > 0)\n        strategy.order(str.format(\"Exit Long\",percent,longSize,syminfo.basecurrency\n        longSize := 0\n        //END\nif(last_bar)       \n    //strategy.close_all()\n    if(predictFuturePrice)\n        line.new(bar_index-indexStrong, maStrongSell[indexStrong > 0 ? indexStrong\n        line.new(bar_index-index, maSell[index > 0 ? index-1 : 0], bar_index, maSell\n        line.new(bar_index-index, maBuy[index > 0 ? index-1 : 0], bar_index, maBuy\n        line.new(bar_index-indexStrong, maStrongBuy[indexStrong > 0 ? indexStrong-1\n        if(useDerivative)\n            line.new(bar_index-indexDerivertive, maShort[indexDerivertive > 0 ? indexDerivertive\n            line.new(bar_index-indexDerivertive, maLong[indexDerivertive > 0 ? indexDerivertive\n// HALVINGS\nDT = 24*60*60*1000\nrh1 = timestamp(2012,11,28,0,0)\nrh2 = timestamp(2016,7,9,0,0)\nrh3 = timestamp(2020,4,30,0,0)\nrh4 = timestamp(2024,11,14,0,0) // predict future\nrh5 = timestamp(2028,5,3,0,0) // predict future\nrh1_range = time >= rh1 - 3*(DT) and time <= rh1 + 3*(DT)\nrh2_range = time >= rh2 - 3*(DT) and time <= rh2 + 3*(DT)\nrh3_range = time >= rh3 - 3*(DT) and time <= rh3 + 3*(DT)\nrh4_range = time >= rh4 - 3*(DT) and time <= rh4 + 3*(DT)\nbgcolor(rh1_range and useHalving ?  color.red : na)\nbgcolor(rh2_range and useHalving ?  color.red : na)\nbgcolor(rh3_range and useHalving ?  color.red : na)\nbgcolor(rh4_range and useHalving ?  color.red : na)\nhalfrh_1 = (rh2 + rh1)*0.5 + extendHalfOfHalving*(DT)\nhalfrh_2 = (rh3 + rh2)*0.5 + extendHalfOfHalving*(DT)\nhalfrh_3 = (rh4 + rh3)*0.5 + extendHalfOfHalving*(DT)\nhalfrh_4 = (rh5 + rh4)*0.5 + extendHalfOfHalving*(DT)\nhalfrh1_range = time >= halfrh_1 - 3*(DT) and time <= halfrh_1 + 3*(DT)\nhalfrh2_range = time >= halfrh_2 - 3*(DT) and time <= halfrh_2 + 3*(DT)\nhalfrh3_range = time >= halfrh_3 - 3*(DT) and time <= halfrh_3 + 3*(DT)\nhalfrh4_range = time >= halfrh_4 - 3*(DT) and time <= halfrh_4 + 3*(DT)\nbgcolor(halfrh1_range and useHalving ?  color.yellow : na)\nbgcolor(halfrh2_range and useHalving ?  color.yellow : na)\nbgcolor(halfrh3_range and useHalving ?  color.yellow : na)\n//bgcolor(halfh4_range and useHalving ? color.yellow : na)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Altered to align with Tradingview's method of non-repainting, see the link inside the script.                                                    Release Notes:                                                    Added another way to prevent repaint. The \"Manual Calculation\" will use the multiple between your current timeframe and your higher timeframes to calculate the RSI. Compare it with tradingview's default RSI - it is practically the same! I set this new RSI setting as default. It should not repaint at ALL now because all higher TF RSI's are being calculated from the group up using timeframe multiples.                                                    Release Notes:                                                    Added short capabilities.                                                    Release Notes:                                                    Added timeframes above 4 hours to the manual calculation method.                                                    Release Notes:                                                    Changed tooltip message.                                                    Release Notes:                                                    Updated strat settings.                                                    Release Notes:                                                    I didn't have the input for the ema actually link to the ema calculation. Now it does.                                                    Release Notes:                                                    Option to go both long and short vs. just long is now in settings (for those in the comments wondering about changing the code).                                                    Release Notes:                                                    Added title to short trades."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 wbburgin\n//@version=5\nstrategy(\"MTF Layered RSI - Bitcoin Bot [wbburgin]\",overlay=false, initial_capital\nlength = input.int(7,\"RSI Length\",group=\"Config\")\ntf2 = input.timeframe(\"3\",title=\"HT 1\",group=\"Config\")\ntf3 = input.timeframe(\"5\",title=\"HT 2\",group=\"Config\")\nob = input.int(80,\"Overbought Level\",group=\"Config\")\nos = input.int(20,\"Oversold Level\",group=\"Config\")\ncalcType = input.string(\"Manual Calculation\",options=[\"Security Function\",\"Manual Calculation\"\n tooltip=\"Manual calculation is a way to stop repaint without using request.security().\"\nuse200ma = input.bool(false,\"Use EMA Filter\",group=\"Risk Management\")\nemaLen = input.int(200,\"EMA Length\",group=\"Risk Management\")\nstoploss = input.bool(false,\"Use % Stop Loss\",group=\"Risk Management\")\nstoplosspercent = input.float(0.5,title=\"Stop Loss (%)\",group=\"Risk Management\")\ntradeType = input.string(\"Long-only\",options=[\"Long-only\",\"Long and Short\"],title=\nrsi = ta.rsi(close,length)\n// Security RSI Calculation ________________________________________________________________________\nindexHighTF = barstate.isrealtime ? 1 : 0\nindexCurrTF = barstate.isrealtime ? 0 : 1\nrsi2_sec = request.security(syminfo.tickerid, tf2, rsi[indexHighTF])[indexCurrTF]\nrsi3_sec = request.security(syminfo.tickerid, tf3, rsi[indexHighTF])[indexCurrTF]\n//Aligns with Tradingview's method of non-repainting: https://www.tradingview.com/pine-script-docs/en/v5\n// Manual RSI Calculation __________________________________________________________________________\ncurrentTF = timeframe.period\ntf_to_int(timeframe)=> \n    switch\n        timeframe == \"1S\" => 1\n        timeframe == \"5S\" => 5\n        timeframe == \"10S\"=> 10\n        timeframe == \"15S\"=> 15\n        timeframe == \"30S\"=> 30\n        timeframe == \"1\"  => 60\n        timeframe == \"3\"  => 180\n        timeframe == \"5\"  => 300\n        timeframe == \"15\" => 900\n        timeframe == \"30\" => 1800\n        timeframe == \"45\" => 2700\n        timeframe == \"60\" => 3600 // 1 hour\n        timeframe == \"120\"=> 7200 // 2 hours\n        timeframe == \"180\"=> 10800 // 3 hours\n        timeframe == \"240\"=> 14400 // 4 hours\n        timeframe == \"480\"=> 28800 // 8 hours\n        timeframe == \"720\"=> 43200 // 12 hours\n        timeframe == \"D\"  => 86400 // 1 day\n        timeframe == \"W\"  => 604800 // 1 week\n        timeframe == \"M\"  => 2595000 // 1 month\nct_int = tf_to_int(currentTF)\nht1_int = tf_to_int(tf2)\nht2_int = tf_to_int(tf3)\nht1_mult = int(ht1_int / ct_int)\nht2_mult = int(ht2_int / ct_int)\nmanualRSI(time_mult, len)=>\n    htclose = close\n    u = math.max(htclose - htclose[time_mult], 0) // upward ta.change\n    d = math.max(htclose[time_mult] - htclose, 0) // downward ta.change\n    rs = ta.rma(u, len * time_mult) / ta.rma(d, len * time_mult)\n    res = 100 - 100 / (1 + rs)\n    res\nrsi2_man = manualRSI(ht1_mult, length)\nrsi3_man = manualRSI(ht2_mult, length)\nrsi2 = calcType == \"Security Function\" ? rsi2_sec : rsi2_man\nrsi3 = calcType == \"Security Function\" ? rsi3_sec : rsi3_man\nplot(rsi,color= color.yellow,title=\"RSI Current TF\")\nplot(rsi2,color= color.new(color.yellow,50),title=\"RSI HT1\")\nplot(rsi3,color= color.new(color.yellow,75),title=\"RSI HT2\")\nlm=hline(os,title=\"Oversold\")\nhm=hline(ob,title=\"Overbought\")\nfill(hm,lm,color= color.new(color.blue,95))\n// Long Settings\nhtCross = (ta.crossover(rsi2,os) and rsi3>os and rsi>os) \n or (ta.crossover(rsi3,os) and rsi2>os and rsi>os)\nbuySig = (ta.crossover(rsi,os) and rsi2 < os and rsi3 < os) or htCross\nsellSig = ta.crossunder(rsi,ob)\n// Short Settings\nhtCross_short = (ta.crossunder(rsi2,ob) and rsi3<ob and rsi<ob) or (ta.crossunder(\nshortEntry = (ta.crossunder(rsi,ob) and rsi2 > ob and rsi3 > ob) or htCross_short\nshortExit = ta.crossover(rsi,os)\n//Risk Settings\nema200 = ta.ema(close,emaLen)\nfilter = use200ma ? close>ema200 ? true : false : true\nshortfilter = use200ma ? close<ema200 ? true : false : true\nstoplosslevel_long = (1-(stoplosspercent/100)) * ta.valuewhen(buySig and filter,close\nstoplosslevel_short = (1+(stoplosspercent/100)) * ta.valuewhen(shortEntry and shortfilter\ninitiate_stoploss_long = stoploss ? ta.crossunder(close,stoplosslevel_long) : na\ninitiate_stoploss_short = stoploss ? ta.crossover(close,stoplosslevel_short) : na\nif buySig and filter\n    strategy.entry(\"Long\",strategy.long)\nif sellSig or initiate_stoploss_long\n    strategy.close(\"Long\")\nif shortEntry and shortfilter and tradeType == \"Long and Short\"\n    strategy.entry(\"Short\",strategy.short)\nif shortExit or initiate_stoploss_short\n    strategy.close(\"Short\")\nplotshape(buySig and filter,title=\"Buysig\",style=shape.triangleup,location=location.bottom\nplotshape(sellSig or initiate_stoploss_long,title=\"Sellsig\",style=shape.triangledown"}]}
{"messages": [{"role": "user", "content": "OVERVIEW: Kitchen is a strategy that aims to trade in the direction of the trend by using supertrend and stochRsi data by calculating at different time values. IMPLEMENTATION DETAILS \u2013 SETTINGS: First of all, let's understand the supertrend and stocrsi indicators. How do you read and use Super Trend for trading ? The price is often going upwards when it breaks the super trend line while keeping its position above the indication level.  When the market is in a bullish trend, the indicator becomes green. The indicator level will act as trendline support in such a scenario. The color of the indicator changes to red to indicate a negative trend once the price crosses the support line. The price uses the super trend level as a trendline resistance during a bearish move. \t\tIn our strategy, if our 1-hour and 4-hour supertrend lines show the up or down train in the same direction at the same time, we can assume that a train is forming here. Why do I use the time of 1 hour and 4 hours ? When I did a backtest from the past to the present, I discovered that the most accurate and consistent time zones are the 1 hour and 4 hour time zones. By the way we can change our short term timeframe(1H) and long term timeframe(4H) from settings panel. How do you read and use the Stoch-RSI Indicator? This indicator analyzes price dynamics automatically to detect overbought and oversold locations. The indicator includes:   - The primary line, which typically has values between 0 and 100;    - Two dynamic levels for overbought and oversold conditions. \t\tIF our stoch-rsi indicator value has fallen below our lower boundary line, the oversold event has been observed in the price, if our stoch-rsi value breaks up our bottom line after becoming oversold, we think that the price will start the recovery phase.(The case is also true for the opposite.)  However, this does not always apply and we need additional approvals, Therefore, our 1H and 4H supertrrend indicator provides us with additional confirmation. Buy Condition: \t\tOur 1H(short term) and 4H(long term) supertrrend indicator, has given the buy signal(green line and yellow line), and if our stochrsi indicator has broken our oversold line up on the past 15 bars, the buy signal is formed here. Sell Condition: \t\tOur 1H(short term)  and 4H(long term) supertrrend indicator, has given the sell signal(red line and orange line), and if our stochrsi indicator has broken our overbuy line down on the past 15 bars, the sell signal is formed here. Stop Loss or Take Profit Conditions: Exit Long Senerio: \t\tAll conditions are completed, the buy signal has arrived and we have entered a LONG trade, the 1-hour supertrend line follows the price rise(yellow line), if the price breaks below the 1-hour super trend line and a sell condition occurs for 1H timeframe for supertrend indcator, LONG trade will exit here. Exit Short Senerio: \t\tAll conditions are completed, the Sell signal has arrived and we have entered a SHORT trade, the 1-hour supertrend line follows the price down(orange line), if the price breaks up the 1-hour super trend line and a buy condition occurs for 1H timeframe for supertrend indcator, SHORT trade will exit here. What can you change in the settings panel? \t\t1-We can set Start and End date for backtest and future alarms  2-We can set ATR length and Factor for supertrend indicator  3-We can set our short term and long term timeframe value 4-We can set StochRsi Up and Low limit to confirm buy and sell conditions 5-We can set stochrsi retroactive approval length 6-We can set stochrsi values or the length 7-We can set Dollar cost for per position 8- We can choose the direction of our positions, we can set only LONG, only SHORT or both directions. 9-IF you want to place automatic buy and sell orders with this strategy, you can paste your codes into the Long open-close or Short open-close message sections. For example IF you write your alert window this code {{strategy.order.alert_message}}. When trigger Long signal you will get dynamically what you pasted here for Long Open Message ALSO: Please do not open trades without properly managing your risk and psychology!!! If you have any ideas what to add to my work to add more sources or make calculations cooler, suggest in DM ."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Baby_whale_to_moon\n//@version=5\nstrategy('Kitchen [ilovealgotrading]', overlay=true, format=format.price, initial_capital\n// BACKTEST DATE\nStart_Time = input.time(defval=timestamp('01 January 2017 13:30 +0000'), title='Start_Time'\nEnd_Time = input.time(defval=timestamp('30 April 2024 19:30 +0000'), title='End_Time'\n// supertrend \natrPeriod = input(10, 'ATR Length', group = \" #################  Supertrend  ################ \nfactor = input(3, 'Factor', group = \" #################  Supertrend  ################ \ntime1 = input.string(title='Short Time Period', defval='07 1h', options=['01 1m','02 3m'\ntime2 = input.string(title='Long Time Period', defval='10 4h', options=[ '01 1m','02 3m'\nres(Resolution) =>\n    if Resolution == '00 Current'\n        timeframe.period\n    else\n        if Resolution == '01 1m'\n            '1'\n        else\n            if Resolution == '02 3m'\n                '3'\n            else\n                if Resolution == '03 5m'\n                    '5'\n                else\n                    if Resolution == '04 15m'\n                        '15'\n                    else\n                        if Resolution == '05 30m'\n                            '30'\n                        else\n                            if Resolution == '06 45m'\n                                '45'\n                            else\n                                if Resolution == '07 1h'\n                                    '60'\n                                else\n                                    if Resolution == '08 2h'\n                                        '120'\n                                    else\n                                        if Resolution == '09 3h'\n                                            '180'\n                                        else\n                                            if Resolution == '10 4h'\n                                                '240'\n                                            else\n                                                if Resolution == '11 1D'\n                                                    '1D'\n                                                else\n                                                    if Resolution == '12 1W'\n                                                        '1W'\n                                                    else\n                                                        if Resolution == '13 1M'\n                                                            '1M'\n// supertrend Long time period \n[supertrend2, direction2] = request.security(syminfo.tickerid, res(time2), ta.supertrend\nbodyMiddle4 = plot((open + close) / 2, display=display.none)\nupTrend2 = plot(direction2 < 0 ? supertrend2 : na, 'Up Trend', color= color.new(color.green\ndownTrend2 = plot(direction2 < 0 ? na : supertrend2, 'Down Trend', color= color.new\n// supertrend short time period \n[supertrend1, direction1] = request.security(syminfo.tickerid, res(time1), ta.supertrend\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction1 < 0 ? supertrend1 : na, 'Up Trend', color= color.new(color.yellow\ndownTrend = plot(direction1 < 0 ? na : supertrend1, 'Down Trend', color= color.new\n// Stochastic RSI\nlow_limit_stoch_rsi = input.float(title = 'Stoch Rsi Low Limit', step=0.5, defval=\nup_limit_stoch_rsi = input.float(title = 'Stoch Rsi Up Limit', step=0.5, defval=85\nstocrsi_back_length = input.int(20, 'Stoch Rsi retroactive length', minval=1, group\nsmoothK = input.int(3, 'Stochastic RSI K', minval=1, group = \" #################  Stoch RSI   ################ \nlengthRSI = input.int(14, 'RSI Length', minval=1, group = \" #################  Stoch RSI   ################ \nlengthStoch = input.int(14, 'Stochastic Length', minval=1, group = \" #################  Stoch RSI   ################ \nsrc_rsi = input(close, title='RSI Source', group = \" #################  Stoch RSI   ################ \nrsi1 = request.security(syminfo.tickerid, '240', ta.rsi(src_rsi, lengthRSI))\nk = request.security(syminfo.tickerid, '240', ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch\n// Strategy settings \ndollar = input.float(title='Dollar Cost Per Position ', defval=1000, group = \" #################  Strategy Settings  ##########\ntrade_direction = input.string(title='Trade_direction', group = \" #################  Strategy Settings  ##########\nLong_message_open = input('Long Open', title = \"Long Open Message\", group = \" #################  Strategy Settings  ##########\nShort_message_open = input('Short Open', title = \"Short Open Message\", group = \" #################  Strategy Settings  ##########\nLong_message_close = input('Long Close', title = \"Long Close Message\", group = \" #################  Strategy Settings  ##########\nShort_message_close = input('Short Close', title = \"Short Close Message\", group = \nTime_interval = time > Start_Time and time < End_Time\nbgcolor(Time_interval ?  color.rgb(255, 235, 59, 95) : na)\nback_long = 0\nback_short = 0\nfor i = 1 to stocrsi_back_length by 1\n    if ta.crossover(k, low_limit_stoch_rsi)[i] == true \n        back_long += i\n        back_long\n    if ta.crossunder(k, up_limit_stoch_rsi)[i] == true \n        back_short += i\n        back_short\n// bgcolor(back_long>0?color.rgb(153, 246, 164, 54):na)\n// bgcolor(back_short>0?color.rgb(246, 153, 153, 54):na)\nbuy_signal = false\nsell_signal = false\nif direction2 < 0 and direction1 < 0 and back_long > 0\n    buy_signal := true\n    buy_signal\nif direction2 > 0 and direction1 > 0 and back_short > 0\n    sell_signal := true\n    sell_signal\n//bgcolor(buy_signal  ? color.new(color.lime,90) : na ,title=\"BUY bgcolor\")\nplotshape( buy_signal[1] == false and  strategy.opentrades == 0 and Time_interval \n//bgcolor(sell_signal  ? color.new(color.red,90) : na ,title=\"SELL bgcolor\")\nplotshape(sell_signal[1] == false and strategy.opentrades == 0 and Time_interval and\n// Strategy entries \nif strategy.opentrades == 0 and Time_interval and buy_signal and ( trade_direction\n    strategy.entry('Long_Open', strategy.long, qty=dollar / close, alert_message=Long_message_open\nif strategy.opentrades == 0 and Time_interval and sell_signal and ( trade_direction\n    strategy.entry('Short_Open', strategy.short, qty=dollar / close, alert_message\n// Strategy Close\nif close < supertrend1 and strategy.position_size > 0 \n    strategy.exit('Long_Close',from_entry = \"Long_Open\", stop=close, qty_percent=100\nif close > supertrend1 and strategy.position_size < 0 \n    strategy.exit('Short_Close',from_entry = \"Short_Open\", stop=close, qty_percent"}]}
{"messages": [{"role": "user", "content": "Title: Mean Reversion and Trendfollowing Introduction: This script presents a hybrid trading strategy that combines mean reversion and trend following techniques. The strategy aims to capitalize on short-term price corrections during a downtrend (mean reversion) as well as ride the momentum of a trending market (trend following). It uses a 200-period Simple Moving Average (SMA) and a 2-period Relative Strength Index (RSI) to generate buy and sell signals. Key Features: Combines mean reversion and trend following techniques Utilizes 200-period SMA and 2-period RSI Customizable starting date Allows for enabling/disabling mean reversion or trend following modes Adjustable position sizing for trend following and mean reversion Script Description: The script implements a trading strategy that combines mean reversion and trend following techniques. Users can enable or disable either of these techniques through the input options. The strategy uses a 200-period Simple Moving Average (SMA) and a 2-period Relative Strength Index (RSI) to generate buy and sell signals. The mean reversion mode is active when the price is below the SMA200, while the trend following mode is active when the price is above the SMA200. The script generates buy signals when the RSI is below 20 (oversold) in mean reversion mode or when the price is above the SMA200 in trend following mode. The script generates sell signals when the RSI is above 80 (overbought) in mean reversion mode or when the price falls below 95% of the SMA200 in trend following mode. Users can adjust the position sizing for both trend following and mean reversion modes using the input options. To use this script on TradingView, follow these steps: Open TradingView and load your preferred chart. Click on the 'Pine Editor' tab located at the bottom of the screen. Paste the provided script into the Pine Editor. Click 'Add to Chart' to apply the strategy to your chart. Please note that the past performance of any trading system or methodology is not necessarily indicative of future results. Always use proper risk management and consult a financial advisor before making any investment decisions. ------ The following is a summary of the underlying whitepaper (onlinelibrary.wiley....1111/0022-1082.00077) for this strategy: This paper proposes a theory of securities market under- and overreactions based on two psychological biases: investor overconfidence about the precision of private information and biased self-attribution, which causes asymmetric shifts in investors' confidence as a function of their investment outcomes. The authors show that overconfidence implies negative long-lag autocorrelations, excess volatility, and public-event-based return predictability. Biased self-attribution adds positive short-lag autocorrelations (momentum), short-run earnings \"drift,\" and negative correlation between future returns and long-term past stock market and accounting performance. The paper explains that there is empirical evidence challenging the traditional view that securities are rationally priced to reflect all publicly available information. Some of these anomalies include event-based return predictability, short-term momentum, long-term reversal, high volatility of asset prices relative to fundamentals, and short-run post-earnings announcement stock price \"drift.\" The authors argue that investor overconfidence can lead to stock prices overreacting to private information signals and underreacting to public signals. This overreaction-correction pattern is consistent with long-run negative autocorrelation in stock returns, excess volatility, and further implications for volatility conditional on the type of signal. The market's tendency to over- or underreact to different types of information allows the authors to address the pattern that average announcement date returns in virtually all event studies are of the same sign as the average post-event abnormal returns. Biased self-attribution implies short-run momentum and long-term reversals in security prices. The dynamic analysis based on biased self-attribution can also lead to a lag-dependent response to corporate events. Cash flow or earnings surprises at first tend to reinforce confidence, causing a same-direction average stock price trend. Later reversal of overreaction can lead to an opposing stock price trend. The paper concludes by summarizing the findings, relating the analysis to the literature on exogenous noise trading, and discussing issues related to the survival of overconfident traders in financial markets."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 I11L\n//@version=5\nstrategy(\"Mean Reversion and Trendfollowing\", overlay=true, pyramiding=1, default_qty_value\n// Input for the starting date\nstart_date = input.time(timestamp(\"1 Feb 2000 12:00\"), title=\"Starting Date\")\nenableMeanReversion = input.bool(true)\nenableTrendfollowing = input.bool(true)\ntrendPositionFactor = input.float(1)\nmeanReversionPositionFactor = input.float(0.5)\n// Convert the input string to a timestamp\nstart_ts = timestamp(year(start_date), month(start_date), dayofmonth(start_date), 0\n// Check if the current bar's time is greater than or equal to the start timestamp\nstart_condition = time >= start_ts\nvar tradeOrigin = \"\"\nsma200 = ta.sma(close,200)\nrsi2 = ta.rsi(close,2)\nisMeanReversionMode = close < sma200 or not(enableTrendfollowing)\nisTrendfollowingMode = close > sma200 or not(enableMeanReversion)\nisRsiBuy = rsi2 < 20 and enableMeanReversion\nisRsiClose = rsi2 > 80 and enableMeanReversion\nisSmaBuy = close > sma200 and enableTrendfollowing\nisSmaClose = close < sma200 * 0.95 and enableTrendfollowing\nisBuy = (isMeanReversionMode and isRsiBuy) or (isTrendfollowingMode and isSmaBuy)\npositionSizeFactor = isSmaBuy ? trendPositionFactor : meanReversionPositionFactor\n// Only execute the strategy after the starting date\nif (start_condition)\n    if (isBuy and strategy.opentrades == 0)\n        tradeOrigin := isSmaBuy ? \"SMA\" : \"RSI\"\n        strategy.entry(\"My Long Entry Id\", strategy.long, qty=(strategy.equity / close\n    isClose = tradeOrigin == \"SMA\" ? isSmaClose : isRsiClose\n    if (isClose)\n        strategy.exit(\"Exit\", limit = close)\nplot(sma200)\nplot(sma200 * 0.95, color= color.orange)"}]}
{"messages": [{"role": "user", "content": "The Flash-Strategy (Momentum-RSI, EMA-crossover, ATR) Are you tired of manually analyzing charts and trying to find profitable trading opportunities? Look no further! Our algorithmic trading strategy, \"Flash,\" is here to simplify your trading process and maximize your profits. Flash is an advanced trading algorithm that combines three powerful indicators to generate highly selective and accurate trading signals. The Momentum-RSI, Super-Trend Analysis and EMA-Strategy indicators are used to identify the strength and direction of the underlying trend. The Momentum-RSI signals the strength of the trend and only generates trading signals in confirmed upward or downward trends. The Super-Trend Analysis confirms the trend direction and generates signals when the price breaks through the super-trend line. The EMA-Strategy is used as a qualifier for the generation of trading signals, where buy signals are generated when the EMA crosses relevant trend lines. Flash is highly selective, as it only generates trading signals when all three indicators align. This ensures that only the highest probability trades are taken, resulting in maximum profits. Our trading strategy also comes with two profit management options. Option 1 uses the so-called supertrend-indicator which uses the dynamic ATR as a key input, while option 2 applies pre-defined, fixed SL and TP levels. The settings for each indicator can be customized, allowing you to adjust the length, limit value, factor, and source value to suit your preferences. You can also set the time period in which you want to run the backtest and how many dollar trades you want to open in each position for fully automated trading. Choose your preferred trade direction and stop-loss/take-profit settings, and let Flash do the rest. Say goodbye to manual chart analysis and hello to consistent profits with Flash. Try it now! General Comments This Flash Strategy has been developed in cooperation between Baby_whale_to_moon and JS-TechTrading. Cudos to Baby_whale_to_moon for doing a great job in transforming sophisticated trading ideas into pine scripts. Detailed Description The \u201cFlash\u201d script considers the following indicators for the generation of trading signals: 1.\tMomentum-RSI 2.\t\u2018Super-Trend\u2019-Analysis 3.\tEMA-Strategy 1.\tMomentum-RSI \u2022\tThis indicator signals the strength of the underlying upward- or downward-trend. \u2022\tThe signal range of this indicator is from 0 to 100. Values > 60 indicate a confirmed upward- or downward-trend. \u2022\tThe strategy will only generate trading signals in case the stock (or any other financial security) is in a confirmed upward- (long entry signals) or downward-trend (short entry signals). \u2022\tThis indicator provides information with regards to the strength of the underlying trend and it does not give any insight with regard to the direction of the trend. Therefore, this strategy also considers other indicators which provide technical confirmation with regards to the direction of the underlying trend. Graph 1 shows this concept: \u2022\tThe Momentum-RSI indicator gives lower readings during consolidation phases and no trading signals are generated during these periods. Example (graph 2): 2.\tSuper-Trend Analysis \u2022\tThe red line in the graph below represents the so-called super-trend-line. Trading signals are only generated in case the price action breaks through this super-trend-line indicating a new confirmed upward-trend (or downward-trend, respectively). \u2022\tIf that happens, the super trend-line changes its color from red to green, giving confirmation that the trend changed from bearish to bullish and long-entries can be considered.  \u2022\tThe vice-versa approach can be considered for short entries. Graph 3 explains this concept: 3.\tExponential Moving Average / EMA-Strategy The functionality of this EMA-element of the strategy has been programmed as follows: \u2022\tThe exponential moving average and two other trend lines are being used as qualifiers for the generation of trading-signals. \u2022\tBuy-signals for long-entries are only considered in case the EMA (yellow line in the graph below) crosses the red line. \u2022\tSell-signals for short-entries are only considered in case the EMA (yellow line in the graph below) crosses the green line. An example is shown in graph 4 below: We use this indicator to determine the new trend direction that may occur by using the data of the price's past movement. 4.\tBringing it all together This section describes in detail, how this strategy combines the Momentum-RSI, the super-trend analysis and the EMA-strategy. The strategy only generates trading-signals in case all of the following conditions and qualifiers are being met: 1.\tMomentum-RSI is higher than the set value of this strategy. The standard and recommended value is 60 (graph 5): 2.\tThe super-trend analysis needs to indicate a confirmed upward-trend (for long-entry signals) or a confirmed downward-trend (for short-entry signals), respectively. 3.\tThe EMA-strategy needs to indicate that the stock or financial security is in a confirmed upward-trend (long-entries) or downward-trend (short-entries), respectively. The strategy will only generate trading signals if all three qualifiers are being met. This makes this strategy highly selective and is the key secret for its success. Example for Long-Entry (graph 6): When these conditions are met, our Long position is opened. Example for Short-Entry (graph 7): Trade Management Options (graph 8) Option 1 In this dynamic version, the so-called supertrend-indicator is being used for the trade exit management. This supertrend-indicator is a sophisticated and optimized methodology which uses the dynamic ATR as one of its key input parameters. The following settings of the supertrend-indicator can be changed and optimized (graph 9): The dynamic SL/TP-lines of the supertrend-indicator are shown in the charts. The ATR-length and the  supertrend-factor result in a multiplier value which can be used to fine-tune and optimize this strategy based on the financial security, timeframe and overall market environment. Option 2 (graph 10): Option 2 applies pre-defined, fixed SL and TP levels which will appear as straight horizontal lines in the chart. Settings options (graph 11): The following settings can be changed for the three elements of this strategy: 1.\t(Length Mom-Rsi): Length of our Mom-RSI indicator. 2.\tMom-RSI Limit Val: the higher this number, the more momentum of the underlying trend is required before the strategy will start creating trading signals.  3.\tThe length and factor values of the super trend indicator can be adjusted:ATR Length SuperTrend and Factor Super Trend 4.\tYou can set the source value used by the ema trend indicator to determine the ema line: Source Ema Ind 5.\tYou can set the EMA length and the percentage value to follow the price: Length Ema Ind and Percent Ema Ind 6.\tThe backtesting period can be adjusted: Start and End time of BackTest 7.\tDollar cost per position: this is relevant for 100% fully automated trading. 8.\tTrade direction can be adjusted: LONG, SHORT or BOTH  9.\tAs we explained above, we can determine our stop-loss and take-profit levels dynamically or statically. (Version 1 or Version 2 ) Display options on the charts graph 12): 1.\tShow horizontal lines for the Stop-Loss and Take-profit levels on the charts.  2.\tDisplay relevant Trend Lines, including color setting options for the supertrend functionality. In the example below, green lines indicate a confirmed uptrend, red lines indicate a confirmed downtrend. Other comments \u2022\tThis indicator has been optimized to be applied for 1 hour-charts. However, the underlying principles of this strategy are supply and demand in the financial markets and the strategy can be applied to all timeframes. Daytraders can use the 1min- or 5min charts, swing-traders can use the daily charts. \u2022\tThis strategy has been designed to identify the most promising, highest probability entries and trades for each stock or other financial security. \u2022\tThe combination of the qualifiers results in a highly selective strategy which only considers the most promising swing-trading entries. As a result, you will normally only find a low number of trades for each stock or other financial security per year in case you apply this strategy for the daily charts. Shorter timeframes will result in a higher number of trades / year. \u2022\tConsequently, traders need to apply this strategy for a full watchlist rather than just one financial security."}, {"role": "assistant", "content": "//@version=5\nstrategy('The Flash-Strategy (Momentum-RSI, EMA-crossover, ATR)', shorttitle='The Flash-Strategy (Momentum-RSI, EMA-crossover, \n//// author -  Baby_whale_to_moon\n// MOM Rsi indicator \ngroup_mom_rsi = \"Rsi Of Momentum \"\nlen = input.int(10, minval=1, title=\"Length Mom-Rsi\", group =group_mom_rsi ,tooltip\nsrc2 = close\nmom = src2 - src2[len]\nrsi_mom = ta.rsi(mom, len)\nmom_rsi_val = input.int(60, minval=1, title=\"Mom-Rsi Limit Val\", group =group_mom_rsi\n// Super Trend Ind\ngroup_supertrend = \"SuperTrend indicator\"\natrPeriod = input(10, \"ATR Length SuperTrend\", group = group_supertrend)\nfactor = input.float(3.0, \"Factor SuperTrend\", step = 0.01, group = group_supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n// Ema Indicator\ngroup_most = \"Ema indicator\"\nsrc = input(close, 'Source Ema Ind',group = group_most)\nAP2 = input.int(defval=12, title='Length Ema Ind', minval=1,group = group_most)\nTrail1 = ta.ema(src, AP2) //Ema func\nAF2 = input.float(defval=1, title='Percent Ema Ind', minval=0.1,group = group_most\nSL2 = Trail1 * AF2  // Stoploss Ema\nTrail2 = 0.0\niff_1 = Trail1 > nz(Trail2[1], 0) ? Trail1 - SL2 : Trail1 + SL2\niff_2 = Trail1 < nz(Trail2[1], 0) and Trail1[1] < nz(Trail2[1], 0) ? math.min(nz(Trail2\nTrail2 := Trail1 > nz(Trail2[1], 0) and Trail1[1] > nz(Trail2[1], 0) ? math.max(nz\n//Bull = ta.barssince(Trail1 > Trail2 and close > Trail2 and low > Trail2) < ta.barssince(Trail2 > T\n//TS1 = plot(Trail1, 'ExMov', style=plot.style_line, color=Trail1 > Trail2 ? color.rgb(33, 149, 243,\n//TS2 = plot(Trail2, 'ema', style=plot.style_line, color=Trail1 > Trail2 ? color.rgb(76, 175, 79, 30\n//fill(TS1, TS2, Bull  ? color.green : color.red, transp=90)\n// Strategy Sett\ngroup_strategy = \"Settings of Strategy\"\nStart_Time = input.time(defval=timestamp('01 January 2000 13:30 +0000'), title='Start Time of BackTest'\nEnd_Time = input.time(defval=timestamp('30 April 2030 19:30 +0000'), title='End Time of BackTest'\ndollar = input.float(title='Dollar Cost Per Position* ', defval=1000, group =group_strategy\ntrade_direction = input.string(title='Trade_direction', group =group_strategy, options\nv1 = input(true, title=\"Version 1 - Uses SL/TP Dynamically \", group =group_strategy\nv2 = input(false, title=\"Version 2 -  Uses SL/TP Statically\", group =group_strategy\nv2stoploss_input = input.float(5, title='Static Stop.Loss % Val', minval=0.01, group\nv2takeprofit_input = input.float(10, title='Static Take.Prof % Val', minval=0.01, \nv2stoploss_level_long = strategy.position_avg_price * (1 - v2stoploss_input)\nv2takeprofit_level_long = strategy.position_avg_price * (1 + v2takeprofit_input)\nv2stoploss_level_short = strategy.position_avg_price * (1 + v2stoploss_input)\nv2takeprofit_level_short = strategy.position_avg_price * (1 - v2takeprofit_input)\ngroup_line = \"Line Settings\"\nshow_sl_tp = input.bool(title='  Show StopLoss - TakeProf Lines',inline = \"1\", defval\nshow_trend_line = input.bool(title='  Show Trend Line',inline = '3' ,defval=true, \nstoploss_colour = input.color(title='StopLoss Line Colour',inline = '2' ,defval= \nup_trend_line_colour = input.color(title='Up Trend line Colour',inline = '4' ,defval\ndown_trend_line_colour = input.color(title='Down Trend line Colour',inline = '4' ,\n//plot(supertrend ,color = strategy.position_size > 0 and show_sl_tp ? color.rgb(255, 0, 0) :show_sl\nplot(supertrend ,color = show_sl_tp and v1 ? stoploss_colour : na , style = plot.style_steplinebr\nplot(v2stoploss_level_long ,color = strategy.position_size > 0 and show_sl_tp and \nplot(v2stoploss_level_short ,color = strategy.position_size < 0 and show_sl_tp and\nplot(v2takeprofit_level_long  ,color = strategy.position_size > 0 and show_sl_tp and\nplot(v2takeprofit_level_short ,color = strategy.position_size < 0 and show_sl_tp and\nTS2 = plot(Trail2, 'Ema Strategy', style=plot.style_line, color=show_trend_line and\n// bgcolor(buy_signal ? color.rgb(0, 230, 119, 80) : na)\n// bgcolor(sell_signal ? color.rgb(255, 82, 82, 80) : na)\nTime_interval = time > Start_Time and time < End_Time\nbuy_signal = Trail1 > Trail2 and direction < 0 and rsi_mom > mom_rsi_val and Time_interval\nsell_signal =Trail1 < Trail2 and direction > 0 and rsi_mom > mom_rsi_val and Time_interval\n// Strategy entries \nif strategy.opentrades == 0 and buy_signal and ( trade_direction == 'LONG' or trade_direction\n    strategy.entry('Long_0', strategy.long, qty=dollar / close)\nif strategy.opentrades == 0 and sell_signal and ( trade_direction == 'SHORT' or trade_direction\n    strategy.entry('Short_0', strategy.short, qty=dollar / close)\nif close < supertrend and v1\n    strategy.exit('Long_Close',from_entry = \"Long_0\", stop=supertrend, qty_percent\nif  v2 and strategy.position_size > 0\n    strategy.exit('Long_Close',from_entry = \"Long_0\", stop=v2stoploss_level_long,limit\n    if close > supertrend and v1\n    strategy.exit('Short_Close',from_entry = \"Short_0\", stop=supertrend, qty_percent\nif  v2 and strategy.position_size < 0\n    strategy.exit('Short_Close',from_entry = \"Short_0\", stop=v2stoploss_level_short"}]}
{"messages": [{"role": "user", "content": "General Description and Unique Features of this Script Introducing the Advanced VWAP Momentum-Pullback Strategy (long-only) that offers several unique features: 1.\tOur script/strategy utilizes Mark Minervini's Trend-Template as a qualifier for identifying stocks and other financial securities in confirmed uptrends. Mark Minervini, a 2x US Investment Champion, developed the Trend-Template, which covers eight different and independent characteristics that can be adjusted and optimized in this trend-following strategy to ensure the best results. The strategy will only trigger buy-signals in case the optimized qualifiers are being met. 2.\tOur strategy is based on the supply/demand balance in the market, making it timeless and effective across all timeframes. Whether you are day trading using 1- or 5-min charts or swing-trading using daily charts, this strategy can be applied and works very well. 3.\tWe have also integrated technical indicators such as the RSI and the MA / VWAP crossover into this strategy to identify low-risk pullback entries in the context of confirmed uptrends. By doing so, the risk profile of this strategy and drawdowns are being reduced to an absolute minimum. Minervini\u2019s Trend-Template and the \u2018Stage-Analysis\u2019 of the Markets This strategy is a so-called 'long-only' strategy. This means that we only take long positions, short positions are not considered.  The best market environment for such strategies are periods of stable upward trends in the so-called stage 2 - uptrend.  In stable upward trends, we increase our market exposure and risk.  In sideways markets and downward trends or bear markets, we reduce our exposure very quickly or go 100% to cash and wait for the markets to recover and improve. This allows us to avoid major losses and drawdowns.  This simple rule gives us a significant advantage over most undisciplined traders and amateurs! \u2003 'The Trend is your Friend'. This is a very old but true quote. What's behind it??? \u2022 98% of stocks made their biggest gains in a Phase 2 upward trend. \u2022 If a stock is in a stable uptrend, this is evidence that larger institutions are buying the stock sustainably. \u2022 By focusing on stocks that are in a stable uptrend, the chances of profit are significantly increased. \u2022 In a stable uptrend, investors know exactly what to expect from further price developments. This makes it possible to locate low-risk entry points.  The goal is not to buy at the lowest price \u2013 the goal is to buy at the right price! Each stock goes through the same maturity cycle \u2013 it starts at stage 1 and ends at stage 4 \t\t\u2003 Stage 1 \u2013 Neglect Phase \u2013 Consolidation Stage 2 \u2013 Progressive Phase \u2013 Accumulation Stage 3 \u2013 Topping Phase \u2013 Distribution Stage 4 \u2013 Downtrend \u2013 Capitulation This strategy focuses on identifying stocks in confirmed stage 2 uptrends. This in itself gives us an advantage over long-term investors and less professional traders. By focusing on stocks in a stage 2 uptrend, we avoid losses in downtrends (stage 4) or less profitable consolidation phases (stages 1 and 3). We are fully invested and put our money to work for us, and we are fully invested when stocks are in their stage 2 uptrends. But how can we use technical chart analysis to find stocks that are in a stable stage 2 uptrend? Mark Minervini has developed the so-called 'trend template' for this purpose. This is an essential part of our JS-TechTrading pullback strategy. For our watchlists, only those individual values that meet the tough requirements of Minervini's trend template are eligible. The Trend Template \u2022\t200d MA increasing over a period of at least 1 month, better 4-5 months or longer \u2022\t150d MA above 200d MA \u2022\t50d MA above 150d MA and 200d MA \u2022\tCourse above 50d MA, 150d MA and 200d MA \u2022\tIdeally, the 50d MA is increasing over at least 1 month \u2022\tPrice at least 25% above the 52w low \u2022\tPrice within 25% of 52w high \u2022\tHigh relative strength according to IBD.  NOTE: In this basic version of the script, the Trend-Template has to be used as a separate indicator on TradingView (Public Trend-Template indicators are available in TradingView \u2013 community scripts). It is recommended to only execute buy signals in case the stock or financial security is in a stage 2 uptrend, which means that the criteria of the trend-template are fulfilled. This strategy can be applied to all timeframes from 5 min to daily. The VWAP Momentum-Pullback Strategy For the JS-TechTrading VWAP Momentum-Pullback Strategy, only stocks and other financial instruments that meet the selected criteria of Mark Minervini's trend template are recommended for algorithmic trading with this startegy. A further prerequisite for generating a buy signals is that the individual value is in a short-term oversold state (RSI).  When the selling pressure is over and the continuation of the uptrend can be confirmed by the MA / VWAP crossover after reaching a price low, a buy signal is issued by this strategy. Stop-loss limits and profit targets can be set variably. You also have the option to make use of the trailing stop exit strategy. Relative Strength Index (RSI) The Relative Strength Index (RSI) is a technical indicator developed by Welles Wilder in 1978. The RSI is used to perform a market value analysis and identify the strength of a trend as well as overbought and oversold conditions. The indicator is calculated on a scale from 0 to 100 and shows how much an asset has risen or fallen relative to its own price in recent periods. The RSI is calculated as the ratio of average profits to average losses over a certain period of time. A high value of the RSI indicates an overbought situation, while a low value indicates an oversold situation. Typically, a value > 70 is considered an overbought threshold and a value < 30 is considered an oversold threshold. A value above 70 signals that a single value may be overvalued and a decrease in price is likely , while a value below 30 signals that a single value may be undervalued and an increase in price is likely. For example, let's say you're watching a stock XYZ. After a prolonged falling movement, the RSI value of this stock has fallen to 26. This means that the stock is oversold and that it is time for a potential recovery. Therefore, a trader might decide to buy this stock in the hope that it will rise again soon. The MA / VWAP Crossover Trading Strategy This strategy combines two popular technical indicators: the Moving Average (MA) and the Volume Weighted Average Price (VWAP). The MA VWAP crossover strategy is used to identify potential trend reversals and entry/exit points in the market. The VWAP is calculated by taking the average price of an asset for a given period, weighted by the volume traded at each price level. The MA, on the other hand, is calculated by taking the average price of an asset over a specified number of periods. When the MA crosses above the VWAP, it suggests that buying pressure is increasing, and it may be a good time to enter a long position. When the MA crosses below the VWAP, it suggests that selling pressure is increasing, and it may be a good time to exit a long position or enter a short position. Traders typically use the MA VWAP crossover strategy in conjunction with other technical indicators and fundamental analysis to make more informed trading decisions. As with any trading strategy, it is important to carefully consider the risks and potential rewards before making any trades. This strategy is applicable to all timeframes and the relevant parameters for the underlying indicators (RSI and MA/VWAP) can be adjusted and optimized as needed.  Backtesting Backtesting gives outstanding results on all timeframes and drawdowns can be reduced to a minimum level. In this example, the hourly chart for MCFT has been used. Settings for backtesting are: -\tPeriod from Jan 2020 until March 2023 -\tStarting capital 100k USD -\tPosition size = 25% of equity -\t0.01% commission = USD 2.50.- per Trade -\tSlippage = 2 ticks Other comments - This strategy has been designed to identify the most promising, highest probability entries and trades for each stock or other financial security. - The combination of the Trend-Template and the RSI qualifiers results in a highly selective strategy which only considers the most promising swing-trading entries. As a result, you will normally only find a low number of trades for each stock or other financial security per year in case you apply this strategy for the daily charts. Shorter timeframes will result in a higher number of trades / year. - Consequently, traders need to apply this strategy for a full watchlist rather than just one financial security."}, {"role": "assistant", "content": "//@version=5\nstrategy(title='Advanced VWAP-Momentum_Pullback Strategy_Trend-Template Qualifier'\n// copyright JS-TechTrading 2023\ncb1 = input.bool(title=\"1. Stock price is above MA 150 and 200 ?\" , defval=false)\ncb2 = input.bool(title=\"2. MA 150 is above MA 200 ?\", defval=false)\ncb3 = input.bool(title=\"3. MA 200 is trending at least 1 month(22 days) ?\", defval\ncb4 = input.bool(title=\"4. MA 50 is above both MA 150 and MA 200 ?\", defval=false)\ncb5 = input.bool(title=\"5. The current stock price is trading above MA 50? \", defval\ncb6 = input.bool(title=\"6. Current stock price is 25% above 52 weeks low ?\", defval\ncb7 = input.bool(title=\"7. Current Price is within 25% of 52 week high ? \", defval\ncb8 = input.bool(title=\"8. Meet Minervini's Criteria?\", defval=false) \ncb9= input.bool(title=\"9. Enable IBD Qualifier?\",defval = false)\nibd_threshhold = input.float(title=\"IBD RS Threshhold 3Months\", defval=0.5,step = \n//IBD\nsrc = request.security(syminfo.ticker, 'D', close)\nmo_3 = 0.4 * (src / src[11]) + 0.2 * (src / src[21]) + 0.2 * (src / src[42]) + 0.2\nplot(100 * mo_3, style=plot.style_line, linewidth=1, color= color.new(#1E90FF, 0)\n//// Stoploss and Take Profit Parameters\n// Enable Long Strategy\n////////////\n// Date Range\nstart_date = input.int(title='Start Date', defval=1, minval=1, maxval=31, group='Date Range'\nend_date = input.int(title='End Date', defval=1, minval=1, maxval=31, group='Date Range'\nstart_month = input.int(title='Start Month', defval=1, minval=1, maxval=12, group=\nend_month = input.int(title='End Month', defval=1, minval=1, maxval=12, group='Date Range'\nstart_year = input.int(title='Start Year', defval=2000, minval=1800, maxval=3000, \nend_year = input.int(title='End Year', defval=2077, minval=1800, maxval=3000, group\nin_date_range = time >= timestamp(syminfo.timezone, start_year, start_month, start_date\n//// Indicator Inputs\n// RSI\nrsi_over_sold = input.int(defval=30, minval=1, title='Over Sold Level', group='RSI'\nrsi_over_bought = input.int(defval=70, minval=1, title='Over Bought Level', group=\nrsi_length = input.int(defval=14, minval=1, title='RSI Length', group='RSI')\nrsi = ta.rsi(close, rsi_length)\n// MACD\n// VWAP\nmaSource = input(title='SMA source', defval=close,group = \"VWAP\")\nmaInterval = input.int(title='SMA interval', minval=0, maxval=999, step=1, defval=\nma = ta.sma(maSource, maInterval)\n//// Strategy\n// Creating Long and Short Strategy\nwas_over_sold = ta.barssince(rsi <= rsi_over_sold) <= 10\nwas_over_bought = ta.barssince(rsi >= rsi_over_bought) <= 10\ncrossover_bull = ta.crossover(ma, ta.vwap)\ncrossover_bear = ta.crossunder(ma, ta.vwap)\n/////////////////\nsma50 = ta.sma(close, 50)\nsma150 = ta.sma(close, 150)\nsma200 = ta.sma(close, 200)\nsma200_22 = sma200[22]\n// 1. stock price is above ma 150 and 200\nis_price_above_sma_150_and_200 = close > sma150 and close > sma200 ? true:false\nc_1 = is_price_above_sma_150_and_200 ? true : false\n// 2. sma 150 is above sma 200\nis_sma_150_above_sma_200 = sma150 > sma200 ? true : false\nc_2 = is_sma_150_above_sma_200 ? true : false\n// 3. sma 200 is trending at least 1 month(22 days)\nis_trending_at_least_1_month = sma200 > sma200_22 ? true : false\nc_3 = is_trending_at_least_1_month ? true : false\n// 4. sma 50 is above both sma 150 and 200\nis_sma_50_above_sma_150_and_200 = sma50 > sma150 and sma50 > sma200 ? true : false\nc_4 = is_sma_50_above_sma_150_and_200 ? true : false\n// 5. current stock price is above sma 50 \nis_current_price_above_ma_50 = close > sma50 ? true:false\nc_5 = is_current_price_above_ma_50 ? true : false\n// 6. current stock price is 25% above 52 weeks low\n// Many of the best are up 100-300% before coming out of consolidation\nhigh_loopback = input(260, 'High Lookback Length')\nlow_loopback = input(260, 'Low Lookback Length')\nhighest_price = ta.highest(high, high_loopback)\nlowest_price = ta.lowest(low, low_loopback)\nis_price_25_percent_above_52_weeks_low = (close / lowest_price - 1) * 100 >= 25 ? \nc_6 = is_price_25_percent_above_52_weeks_low ? true : false\n// Show 52 High / Low Line \nshow_52_week_high_low = input(title='Show 52 week highest/lowest', defval=true)\nplot(show_52_week_high_low ? highest_price : na, title='52 Week High', trackprice=\nplot(show_52_week_high_low ? lowest_price : na, title='52 Week Low', trackprice=true\n// 7. Current Price is within 25% of 52 week high\nis_price_within_52_high = (1 - close / highest_price) * 100 <= 25 ? true : false\nc_7 = is_price_within_52_high ? true : false\n// relative strength IBD style\nthree_month_rs = 0.4 * (close / close[13])\nsix_month_rs = 0.2 * (close / (close[26] * 2))\nnine_month_rs = 0.2 * (close / (close[39] * 3))\ntwelve_month_rs = 0.2 * (close / (close[52] * 4))\nrs_rating = (three_month_rs + six_month_rs + nine_month_rs + twelve_month_rs) * 100\nrs_rating_str = str.tostring(rs_rating, '#.00')\nis_rs_rating_more_than_seventy = rs_rating > 70\n//c_8 = is_rs_rating_more_than_seventy ? 1 : 0\nis_meet_all_criteria = is_price_above_sma_150_and_200 and is_sma_150_above_sma_200\n//count = c_1 + c_2 + c_3 + c_4 + c_5 + c_6 + c_7 \n//\n//selection\nallConditionTrue = true\nif (cb1 == true) \n    if (allConditionTrue==true and is_price_above_sma_150_and_200==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb2 == true) \n    if (allConditionTrue==true and is_sma_150_above_sma_200==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb3 == true) \n    if (allConditionTrue==true and is_trending_at_least_1_month==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb4 == true) \n    if (allConditionTrue==true and is_sma_50_above_sma_150_and_200==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb5 == true) \n    if (allConditionTrue==true and is_current_price_above_ma_50==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb6 == true) \n    if (allConditionTrue==true and is_price_25_percent_above_52_weeks_low==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb7 == true) \n    if (allConditionTrue==true and is_price_within_52_high==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb8 == true) \n    if (allConditionTrue==true and is_meet_all_criteria==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\nif (cb9 == true) \n    if (allConditionTrue==true and mo_3>=ibd_threshhold==true)\n        allConditionTrue := true\n    else \n        allConditionTrue := false\n//\nlabel1=cb1==true?'1. Stock price is above MA 150 and 200 ? ' + (is_price_above_sma_150_and_200\nlabel2=cb2==true?'2. MA 150 is above MA 200 ? ' + (is_sma_150_above_sma_200 ? 'yes'\nlabel3=cb3==true?'3. MA 200 is trending at least 1 month(22 days) ? ' + (is_trending_at_least_1_month\nlabel4=cb4==true?'4. MA 50 is above both MA 150 and MA 200 ? ' + (is_sma_50_above_sma_150_and_200\nlabel5=cb5==true?'5. The current stock price is trading above MA 50? ' + (is_current_price_above_ma_50\nlabel6=cb6==true?'6. Current stock price is 25% above 52 weeks low ? ' + (is_price_25_percent_above_52_weeks_low\nlabel7=cb7==true?'7. Current Price is within 25% of 52 week high ? ' + (is_price_within_52_high\nlabel8=cb8==true?'8. Meet Minervini Criteria? ' + (is_meet_all_criteria ? 'yes' : \nlabel9=cb9==true?('9.IBD Qualifier? Enabled') + \" \"+ (mo_3>=ibd_threshhold?\"IBD Mathed\"\ntext_ = \"\"\ntext_ += 'Minervinis Strategy' + '\\n'\ntext_ += '\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed\u02ed' + '\\n'\ntext_ += 'Selected qualifiers are as below:' + '\\n'+ '\\n'\ntext_ += label1\ntext_ += label2\ntext_ += label3\ntext_ += label4\ntext_ += label5\ntext_ += label6\ntext_ += label7\ntext_ += label8\ntext_ += label9\n///////\nbars_right = input(5, 'x bars right')\nposition = input(close, 'Label position')\none_color = input(false, 'Label only in one color')\nlab_color = input( #ffd700, 'Label color')\nt = timenow + math.round(ta.change(time) * bars_right)\nvar label lab = na\nlabel.delete(lab)\nlab := label.new(t, position, text=text_, style=label.style_label_left, yloc=yloc.price\n//////////////////////////////////\nfastExit = input(false, title='Close Trade when opposite trading signal is triggered'\nclrBars = input(false, title='Mark candles according to order status')\norderType = input.string('Only Long', title='Long/Short Strategy', options=['Long & Short'\n//\nbuy_signal = orderType=='Flip'?was_over_bought and crossover_bear :was_over_sold and\nsell_signal = orderType=='Flip'?was_over_sold and crossover_bull :was_over_bought \n//\n//enable_long_strategy = input.bool(true, title='Enable Long Strategy', group='SL/TP f\u00fcr \n//enable_short_strategy = input.bool(false, title='Enable Short Strategy', group='SL/TP For Short St\n//lpp = input.float(title=\"Long Take Profit (%)\", minval=0.0, step=0.1, defval=5, group='SL/TP f\u00fcr \nAQUA =  #00FFFFFF\nBLUE =  #0000FFFF\nRED =  #FF0000FF\nLIME =  #00FF00FF\nGRAY =  #808080FF\nDARKRED =  #8B0000FF\nDARKGREEN =  #006400FF\nbclr = not clrBars ? na : strategy.position_size==0 ? GRAY : ta.change(strategy.position_size\nbarcolor(bclr, title='Trade State Bar Colouring')\n//lsl = input.float(title=\"Long Stop Loss (%)\", minval=0.0, step=0.1, defval=5, group='SL/TP f\u00fcr \nisS = input(false, 'Stop Loss Enable')\nslv = input.float(defval=5, title='Stop Loss (%)', minval=0, step=0.1)/100\n// Enable Short Strategy\nisTS = input(false, 'Trailing Stop Loss Enable')\ntrailPerc=input.float(title='Trailing Stop Loss (%)', minval=0.0, step=0.1, defval\nisTP = input(false, 'Take Profit Enable')\ntpv = input.float(defval=5, title='Take Profit %', minval=0, step=0.1)/100\n// Plot Stoploss & Take Profit Levels\nlong_stoploss_price = strategy.position_avg_price * (1 - slv )\nlong_takeprofit_price = strategy.position_avg_price * (1 +  tpv)\nshort_stoploss_price = strategy.position_avg_price * (1 + slv)\nshort_takeprofit_price = strategy.position_avg_price * (1 - tpv)\n// Long Strategy\nif strategy.equity > 0 and (fastExit==false?strategy.position_size ==0:true) and buy_signal\n    strategy.entry('Long', strategy.long, alert_message='Open Long Position')\nlongStopPrice = 0.0\nlongStopPrice := if strategy.position_size>0\n    stopValue = high * (1 - trailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nif strategy.position_size>0\n    strategy.exit(\"LEx\",\"Long\",limit = (isTP?long_takeprofit_price:na),stop = isTS\n// Short Strategy\nif strategy.equity > 0 and (fastExit==false?strategy.position_size ==0:true) and sell_signal\n    strategy.entry('Short', strategy.short, alert_message='Open Short Position')\nshortStopPrice = 0.0\nshortStopPrice := if strategy.position_size<0\n    stopValue = low * (1 + trailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    9999\nif strategy.position_size<0 \n    strategy.exit('SEx',\"Short\", limit =(isTP?short_takeprofit_price:na) ,stop = isTS\nplot(strategy.position_size > 0  and isTS==true?longStopPrice:na,\"Long Trailing SL\"\nplot(strategy.position_size < 0  and isTS==true?shortStopPrice:na,\"Short Trailing SL\"\nplot(strategy.position_size > 0  and isTS==false?long_stoploss_price:na,\"Long SL\",\nplot(strategy.position_size < 0  and isTS==false?short_stoploss_price:na,\"Short SL\"\nplot(strategy.position_size > 0  ?long_takeprofit_price:na,\"Long TP\",color= color.green\nplot(strategy.position_size < 0  ?short_takeprofit_price:na,\"Short TP\",color= color.green"}]}
{"messages": [{"role": "user", "content": "Title: Cycle Position Trading Strategy v1.0 Description: Cycle Position Trading Strategy is a simple yet effective trading strategy based on a 200-day Simple Moving Average (SMA). Users can select between two modes, \"Buy Uptrend\" and \"Buy Downtrend,\" to customize the strategy according to their trading preferences. The strategy allows users to set their own stop loss (SL) and take profit (TP) levels, providing more flexibility and control over their trades. Features: Choose between two trading modes: \"Buy Uptrend\" and \"Buy Downtrend.\" Customize your stop loss (SL) and take profit (TP) levels. Clear visual representation of the 200-day Simple Moving Average (SMA) on the chart. How to use: Add the strategy to your chart by searching for \"Cycle Position Trading Strategy\" in the TradingView \"Indicators & Strategies\" section. Configure the strategy settings according to your preferences: Select the trading mode from the dropdown menu. \"Buy Uptrend\" will open long positions when the closing price is above the 200-day SMA. \"Buy Downtrend\" will open long positions when the closing price is below the 200-day SMA. Set your desired stop loss (SL) and take profit (TP) levels. The default values are 0.9 (10% below the entry price) for the stop loss and 1.1 (10% above the entry price) for the take profit. Monitor the chart for trade signals based on the chosen mode and settings. The strategy will enter and exit trades automatically based on the selected mode and the configured stop loss and take profit levels. Analyze the performance of the strategy by checking the TradingView strategy performance summary or by viewing individual trades in the \"Trades\" list. Disclaimer: This strategy is intended for educational and illustrative purposes only. Use it at your own risk. Past performance is not indicative of future results. Trading stocks, cryptocurrencies, or any other financial instrument involves significant risk and may result in the loss of capital. Version: v1.0 Release date: 2023-03-25 Author: I11L License: Mozilla Public License 2.0 (mozilla.org/MPL/2.0/)"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 I11L\n//@version=5\nstrategy(\"Cycle Position Trading\", overlay=true, pyramiding=1, default_qty_value=100000\n// Input for selecting the mode\nmode = input.string(\"Buy Uptrend\", options = [\"Buy Uptrend\", \"Buy Downtrend\"])\n// Input for customizing stop loss and take profit levels\nstopLoss = input.float(0.9, title=\"Stop Loss (SL) level\", step=0.01)\ntakeProfit = input.float(1.1, title=\"Take Profit (TP) level\", step=0.01)\n// Calculate the 200-day Simple Moving Average (SMA)\nsma = ta.sma(close, 200)\n// Plot the SMA on the chart\nplot(sma)\n// Define the conditions for entering a long position based on the selected mode\nlongCondition = mode == \"Buy Uptrend\" ? close > sma and close[5] > sma : close < sma\n// Define the conditions for closing a position based on the selected mode\ncloseCondition = mode == \"Buy Uptrend\" ? (strategy.position_avg_price * stopLoss > \n// Execute a long position if the longCondition is met\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\n// Close the position if the closeCondition is met\nif (closeCondition)\n    strategy.exit(\"Exit\", limit = close)"}]}
{"messages": [{"role": "user", "content": "This strategy is based on the DIDI index with our own confirmations and calculated SL/TP . You can change every setting if you want it to use for another pair, but this is fine tuned for NATURALGAS The entries are taken when: Long: - Buy signal from the DIDI indicator  - Long EMA is underneath the Short EMA - Price must be Above the Long EMA - TP1 (default) - ATR based first TP is ATR * 1.2 Multiplier - TP2 (default) - ATR based first TP is ATR * 2 Multiplier - TP2 SL is the strategy entry price when we hit the first TP - SL (default) - Latest swing low with a look back of 17 candles Short: - Sell signal from the DIDI indicator  - Long EMA is Above the Short EMA - Price must be Below the Long EMA - TP1 (default) - ATR based first TP is ATR * 1.2 Multiplier - TP2 (default) - ATR based first TP is ATR * 2 Multiplier - TP2 SL is the strategy entry price when we hit the first TP - SL (default) - Latest swing low with a look back of 17 candles It's fairly simple, and i think you can use this base so extend your own strategy Good luck :) If you have any questions, feel free to comment"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 nedled\n//@version=5\nstrategy(\"Daily Investments Index Scalp\", overlay=true,format=format.price,precision\nvar entryPrice = 0\nStoplossType = input.string(title=\"Stoploss Type\", defval=\"SWING\", options=[\"ATR\",\ntakeProfitType = input.string(title=\"Take Profit Type\", defval=\"ATR\", options=[\"ATR\"\nSwingLenght = input.int(title=\"Swing Stoploss Lookback Candles\",defval = 15) \nshortLength =  input.int(title=\"Short Length\",defval = 3) \nmediumLength = input.int(title=\"Medium Length\",  defval=8)\nlongLength = input.int(title=\"Long Length\",  defval=20)\nsrc = input.source(title=\"source\", defval = close)\nmedium = ta.sma(src,mediumLength)\nshort = ta.sma(src,shortLength) / medium\nlong = ta.sma(src,longLength) / medium\nema = input.int(150,title = \"Ema Long Lenght\")\nemaShort = input.int(35,title = \"Ema Short Length\")\n//multi profit\nmultiplierTP1 = input.float(1.5,\"TP - ATR Multiplier\")\nmultiplierTP2 = input.float(3,\"TP - ATR Multiplier\")\nRRTP1 = input.float(1.2,\"TP - TP RR\")\nRRTP2 = input.float(2,\"TP - TP RR\")\nmultiplierSL = input.float(1.5,\"SL - ATR Multiplier\")\nemaValue = ta.ema(src,ema)\nemaShortValue = ta.ema(src,emaShort)\nplot(emaValue, color=  color.red)\nplot(emaShortValue, color =  color.blue)\nlengthAtr = input.int(title=\"ATR Length\", defval=14,minval = 1)\nsmoothingAtr = input.string(title=\"Smoothing ATR\", defval=\"RMA\", options=[\"RMA\", \"SMA\"\nsrc1 = input(high)\nsrc2 = input(low)\nma_function(source, length) =>\n    if smoothingAtr == \"RMA\"\n        ta.rma(source, length)\n    else\n        if smoothingAtr == \"SMA\"\n            ta.sma(source, length)\n        else\n            if smoothingAtr == \"EMA\"\n                ta.ema(source, length)\n            else\n                ta.wma(source, length)\nslShort = 0.0\nslLong = 0.0\nTP_Short_1 = 0.0\nTP_Short_2 = 0.0\nTP_Long_1 = 0.0\nTP_Long_2 = 0.0\nif(StoplossType == \"ATR\")\n    slShort := ma_function(ta.tr(true), lengthAtr) * multiplierSL + src1\n    slLong := src2 - ma_function(ta.tr(true), lengthAtr) * multiplierSL\nelse if(StoplossType == \"SWING\")\n    slShort :=   ta.highest(high,SwingLenght)\n    slLong  := ta.lowest(low, SwingLenght)\nif(takeProfitType == \"ATR\")\n    TP_Short_1 := src2 - ma_function(ta.tr(true), lengthAtr) * multiplierTP1\n    TP_Short_2 := src2 - ma_function(ta.tr(true), lengthAtr) * multiplierTP2\n    TP_Long_1 := ma_function(ta.tr(true), lengthAtr) * multiplierTP1 + src1\n    TP_Long_2 := ma_function(ta.tr(true), lengthAtr) * multiplierTP2 + src1\nelse if(takeProfitType == \"SWING\")\n    TP_Short_1 := close - ((ta.highest(high,SwingLenght) - close)* RRTP1)\n    TP_Short_2 := close - ((ta.highest(high,SwingLenght) - close)* RRTP2)\n    TP_Long_1 :=  close + ((close - ta.lowest(low, SwingLenght) ) * RRTP1)\n    TP_Long_2 := close + ((close - ta.lowest(low, SwingLenght)  ) * RRTP2)\nbool goLong = false\nif(ta.crossover(short,long) and close > emaValue and emaShortValue > emaValue and \n    goLong := true\n    strategy.close_all()\n    strategy.entry(\"Long\", strategy.long, stop = slLong, alert_message = \"Entered long position\"\n    strategy.exit(\"Exit Long TP1\", from_entry = \"Long\", limit = TP_Long_1, qty_percent\n    strategy.exit(\"Exit Long TP2\", from_entry = \"Long\", limit = TP_Long_2, stop = \nbool goShort = false\nif(ta.crossunder(short,long) and close < emaValue and  emaShortValue < emaValue and\n    goShort := true\n    strategy.close_all()\n    strategy.entry(\"Short\", strategy.short, stop = slShort, alert_message = \"Entered short position\"\n    strategy.exit(\"Exit Short TP1\", from_entry = \"Short\", limit= TP_Short_1, qty_percent\n    strategy.exit(\"Exit Short TP2\", from_entry = \"Short\", limit= TP_Short_2, stop \nlong_stop_level = float(na)\nlong_stop_level := goLong ? slLong : long_stop_level[1]\nlong_limit1_level = float(na)\nlong_limit1_level := goLong ? TP_Long_1 : long_limit1_level[1]\nlong_limit2_level = float(na)\nlong_limit2_level := goLong ? TP_Long_2 : long_limit2_level[1]\nshort_stop_level = float(na)\nshort_stop_level := goShort ?  slShort : short_stop_level[1]\nshort_limit1_level = float(na)\nshort_limit1_level := goShort ? TP_Short_1 : short_limit1_level[1]\nshort_limit2_level = float(na)\nshort_limit2_level := goShort ? TP_Short_2 : short_limit2_level[1]\ngetCurrentStageLong() =>\n    var stage = 0\n    if strategy.position_size == 0 \n        stage := 0\n    if stage == 0 and strategy.position_size > 0\n        stage := 1\n    else if stage == 1 and long_limit1_level[1] < high\n        stage := 2\n    stage\ngetCurrentStageShort() =>\n    var stage = 0\n    if strategy.position_size == 0 \n        stage := 0\n    if stage == 0 and strategy.position_size < 0\n        stage := 1\n    else if stage == 1 and short_limit1_level[1] > low\n        stage := 2\n        stage\ncurLongStage = getCurrentStageLong()\nif(curLongStage == 2)\n    strategy.exit(\"Exit Long TP2\", from_entry = \"Long\", limit = long_limit2_level,\ncurShortStage = getCurrentStageShort()\nif(curShortStage == 2)\n    strategy.exit(\"Exit Short TP2\", from_entry = \"Short\", limit = short_limit2_level\nprint(txt) =>\n    // Create label on the first bar.\n    var lbl = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na),\n    // On next bars, update the label's x and y position, and the text it displays.\n    label.set_xy(lbl, bar_index, ta.highest(10)[1])\n    label.set_text(lbl, txt)\nplot(strategy.position_size > 0 ?  long_stop_level : na,title= \"SL LONG\", color = \nplot(strategy.position_size > 0 ?  long_limit1_level : na,title= \"TP1 LONG\", color\nplot(strategy.position_size > 0 ?  long_limit2_level : na,title= \"TP2 LONG\", color\nplot(strategy.position_size < 0 ?  short_stop_level : na,title= \"SL SHORT\", color \nplot(strategy.position_size < 0 ?  short_limit1_level : na,title= \"TP1 SHORT\", color\nplot(strategy.position_size < 0 ?  short_limit2_level : na,title= \"TP2 SHORT\", color\n// Table Results\n//tableBgcolor=#686868\n//if barstate.islastconfirmedhistory\n  //  var tbl = table.new(position.bottom_right, 3, 3, bgcolor = tableBgcolor, frame_width = 2, frame_\n    //table.cell(tbl, 0, 1, \"Total Trades: \" + str.tostring(strategy.closedtrades),           bgcolor=co\n    //table.cell(tbl, 0, 2, \"Win Rate: \" +  str.tostring(math.round(strategy.wintrades / strategy.closed\n    //table.cell(tbl, 0, 0, \"Initial Capital: \" + str.tostring(strategy.initial_capital),     bgcolor=co\n    //table.cell(tbl, 1, 0, \"Net Profit: \"  + str.tostring(math.round(strategy.netprofit,2)) + \" (\"+  st\n    //table.cell(tbl, 1, 1, \"Current equity: \"+ str.tostring(math.round(strategy.equity,2))+ \"\",    bgco\n    //table.cell(tbl, 1, 2, \"Max DrawDown: \"+ str.tostring(math.round(strategy.max_drawdown))+ \" (\"+ str"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Update V1.3 - Trailing Stop By ATR                                                    Release Notes:                        Update To V.2 == ADD  SIMPLE STRATEGY ==  MA TYPE CROSS OVER AND CROSS UNDER = (EMA, SMA, WMA, HMA, VWMA)  MACD CROSS OVER AND CROSS UNDER   == CONFIRM MODE ==  CONFIRM BY MACD = (CONFIRM BY MACD > , < 0)  CONFIRM BY STOCHASTIC RSI = (STO FAST/SLOW > , < 0)  CONFIRM BY MA CROSS X = (CONFIRM BY FAST/SLOW > , < 0)  CONFIRM BY ICHIMOKU  = (CONFIRM BY TENKAN/KIJUN > , < 0)  == TAKE PROFIT & STOPLOSS & TRAILING STOP MODE ==  ATR TRAILING STOP FOR TP/SL  CALLBACK RATE  FROM LAST HIGH AND LOW ## ??? (SIMILAR BINANCE CALLBACK BUT CAN CUSTOMIZE % YOU WANT)  == OTHER ==  GROUP HEADER  ADD SYMBOL FOR HEADER  EDIT TEXT WHEN LONG AND SHORT POSITION  EDIT TEXT WHEN CONFIRM MODE  ALERT FOR BOT CAN ADJUST AND EDIT TEXT  ADD TIMES FOR BACKTEST                                                    Release Notes:                                                    Update 2.1 - Plot 15m High/Low (Enable/Disable)                                                    Release Notes:                                                    Update Version 2.2 - Add Plot BreakOut Line Length                                                     Release Notes:                        Update V2.3  Add Spot Mode -   Add TRENDLOCK Confirm Mode   MACD > 0  MA FAST > SLOW  SHORT POSITION  MACD < 0  MA FAST < SLOW  Fix Some Bug When Selected TP/SL%                            Release Notes:                        Update V2.4  Add Psudo Bollinger Band For Donchian Upper, Middle, Lower Band  Edit TP/SL% For Easy To Look    Fix Some Bug                            Release Notes:                                                    Update V.2.5 - Add Confirm By Aroon Hit 100% and -100% - Fix Bug For Normal Channel BreakOut Spot Mode                                                    Release Notes:                                                    Update Version 2.6 - Change Int to float for Callback %                                                    Release Notes:                                                    Update Version 2.7 - Replace RSI Confirm Instead Stochastic Confirm - - For Bot Trade and Hook Send Bot                                                    Release Notes:                                                    Update Version 2.8 - Set Default RSI Confirm 50/50 - Add TP/SL/TL to Command Send For X48-Saiyan3 (3in1) Bot                                                    Release Notes:                        Update  Volty Mode - Volume Trading For Forex and Gold (Best TF 1m & Commission 0)  Adaptive ATR MODE - (Adaptive ATR Calculate By Volty Strategy and Calculate Again With EMA By Adaptive ATR Value For Fast&Slow)  Fix TP&SL Text Show                             Release Notes:                        Update Version 2.10  Remove Locked Trend MODE (MA + MACD) = Because Too Slow By Wait Moving Average  Add Repeat Mode For MA Cross | (Fast > Slow) and (Fast < Slow) // Normally Crossover and Crossunder Only  Add Repeat Mode For MACD Cross 0 | (MACD > 0) and (MACD < 0) // Normally Crossover and Crossunder Only Repeat Mode Use By After TP/SL For Example EMA 12/26 Cross IF EMA Crossover (Uptrend) But SL = 5% >> After StopLoss Repeat Order Again If Fast > Slow Normally The Position Are Open First Time By Crossover and Crossunder                             Release Notes:                                                    Fix TP/SL 0% = Disable"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at \n// \u00a9 X4815162342\n//================== Read This First Before Use This Strategy ==============\n// *********** Please be aware that this strategy is not a guarantee of success and may lead to loss\n// *********** Trading involves risk and you should always do your own research before making any de\n// ================= Thanks Source Script and Explain This Strategy ===================\n// This Strategy Are Combine [5] Strategy and [8] Indicators [1] Alert Function For Systematric Trad\n// [3] Strategy List, Thanks For Original Source Script [1],[2] From Tradingview Build-in Script [3]\n// [3.1] Channel BreakOut Strategy : Calculate BreakOut Zone For Buy and Sell.\n// [3.2] Consecutive Bars UP/Down Strategy : The consecutive bars up/down strategy is a trading stra\n// [3.3] 15m Range Length SD : Range Of High and Low Candle Price and Lookback For Calculate Buy and\n// [3.4] MA Type CrossOver and CrossUnder\n// [3.5] MACD CrossOver and CrossUnder\n// [8] Indicators Are Simple Source Script (Almost I'm Chating With CHAT-GPT and Convert pinescript \n// [8.1] SwingHigh and SwingLow Plot For SL (StopLoss by Last Swing).\n// [8.2] Engulfing and 3 Candle Engulfing Plot.\n// [8.3] Stochastic RSI for Plot and Fill Background Paint and Plot TEXT For BULL and BEAR TREND.\n// [8.4] MA TYPE MODE are plot 2 line of MA Type (EMA, SMA, HMA, WMA, VWMA) for Crossover and Crossu\n// [8.5] Donchian Fans MODE are Plot Dot Line With Triangle Degree Bull Trend is Green Plot and Bear\n// [8.6] Ichimoku Cloud Are Plot Cloud A-B For Bull and Bear Trend.\n// [8.7] RSI OB and OS for TEXT PLOT 'OB' , 'OS' you will know after OB and OS, you can combo with o\n// [8.8] MACD for Plot Diamond when MACD > 0 and MACD < 0, you can combo with other indicators that'\n// [1] Alert Can Alert Sent When Buy and Sell or TP and SL, you can adjust text to alert sent by you\n// ========== Let'e Me Explain How To Use This Strategy =============\n// ========== Properties Setting ==========\n// Capital : Default : 500 USDT For Alot Of People Are Beginner Investor = It's Capital Your Cash Fo\n// Ordersize : Default Are Setting 5% / Order [It's Mean 5% From 1,000] We Call Compounded\n// ========== INPUT Setting ==========\n// First Part Use Must Choose Checkbox For Use [1] of [3] Strategy and Choose TP/SL by Swing or % (c\n// In Detail Of Setting Are Not Too Much, Please Read The Header Of Setting Before Change The Value\n// For The Indicator In List You Want To Add Just Check \u2705 From MODE Setting, It's Show On Your Chart\n// You Can Custom TP/SL % You Want\n// ========== ##### No trading strategy is guaranteed to be 100% successful. ###### =========\n// For Example In My Systematic Trading\n// Select 1/3 Strategy Setting TP/SL % Match With Timeframe TP Long Are Not Set It's Can 161.8 - 423\n// Choose Indicators For Make Sure Trend and Strategy are the same way like Strategy are Long Positi\n// Donchian Fans is Simple Support and Ressistant If You Don't Know How To Plot That's, This indicat\n// Make Sure With Engulfing and 3 Candle Engulfing If You Don't Know, What's The Engulfing, This Ind\n// For a Big Trend You can use Ichimoku Cloud For Check Trend, Candle Upper Than Cloud or Lower Than\n/////////notes////////////////////////////////////////\n// This is based on the ATR trailing stop indicator //\n// width addition of two levels of stops and        //\n// different interpretation.                        //\n// This is a fast-reacting system and is better     //\n// suited for higher volatility markets             //\n//////////////////////////////////////////////////////\n// ========== Confirm Setting ==========\n// 1. Confirm by MACD > 0 and < 0\n// 2. Confirm by Stochastic RSI Cross\n// 3. Confirm by MA Type Fast > Slow or <\n// 4. Confirm by Ichimoku Tenkan > Kijun or <\n// ========== TP/SL Setting ==========\n// 1. By Swing High / Low\n// 2. By ATR Trailing Stop\n// 3. By Callback [%] From Last H/L\n// 4. By FIX [%] TP/SL\n// For Forex Setting (For Free Swap And Commission 0 Only)\n// Capital = 50$\n// Order Size = 1 Contract\n// Commission = 0\n// Slippage = Average Your Spread Broker\n// TP = 0.0055% - 0.0057% (For Forex Use Lot For Easy TP by PNL 7-11 pip)\n// For Cryptocurrency Setting\n// Capital = 100$\n// Order Size = 16.333 USDT\n// Commission = 0.1 or 0.04\n//@version=5\nstrategy(\"X48 - Strategy | Channel BreakOut & Consecutive (17in1) + TL/TP/SL | V.2.10\"\n//================ SPOT MODE ==============\nGRSPT = \"=== \ud83c\udf40\ud83c\udf40\ud83c\udf40 SPOT MODE \ud83c\udf40\ud83c\udf40\ud83c\udf40 ===\"\nSpot_MODE = input.bool(defval = false, title = \"\ud83c\udf40 SPOT MODE\", group = GRSPT)\n//================ CHANNEL BREAKOUT SETTING ===============\nGRS = \"==1\ufe0f\u20e32\ufe0f\u20e33\ufe0f\u20e34\ufe0f\u20e35\ufe0f\u20e3 SELECT [X] STRATEGY + TAKE PROFIT & STOP LOSS ? + CONFIRM MODE ? \nGR1 = \"===== 1\ufe0f\u20e31\ufe0f\u20e31\ufe0f\u20e3 CHANNEL BREAKOUT STRATEGY 1\ufe0f\u20e31\ufe0f\u20e31\ufe0f\u20e3=====\"\nBreakOut_MODE = input.bool(defval = true, title = \"1\ufe0f\u20e3 CHANNEL BREAKOUT MODE\", group\nGRCON = \"=====\ud83c\udd70\ufe0f\ud83c\udd71\ufe0f CONFIRM MODE \ud83c\udd71\ufe0f\ud83c\udd70\ufe0f=====\"\nMACDConfirm_MODE = input.bool(defval = false, title = \"\ud83c\udd70\ufe0f MACD CONFIRM MODE\", group\n//StoConfirm_MODE = input.bool(defval = false, title = \"\ud83c\udd71\ufe0f STOCHASTIC CONFIRM MODE\", group = \nRSIConfirm_MODE = input.bool(defval = false, title = \"\ud83c\ude50 RSI CONFIRM MODE\", group \nMACross_MODE = input.bool(defval = false, title = \"\ud83d\udcaf MA CROSS X CONFIRM MODE\", group\nIchiConfirm_MODE = input.bool(defval = false, title = \"\ud83d\udcae ICHIMOKU TENKAN&KIJUN CROSS X CONFIRM MODE\"\nGRSUB = \"=====\ud83c\udd8e\ud83c\udd91\ud83c\udd7e\ufe0f\ud83c\udd98 TP & SL SELECT MODE \ud83c\udd98\ud83c\udd7e\ufe0f\ud83c\udd91\ud83c\udd8e=====\"\nSwing_STOP = input.bool(title=\"\ud83c\udd8e STOP LOSS BY SWING MODE\", defval=false, group = \nplotcolor = input.bool(defval = false, title = '\ud83c\udd91 ATR Trailing Stop', group = GRSUB\nBOTrail_MODE = input.bool(defval = false, title = \"\ud83c\udd7e\ufe0f CALLBACK Trailing Stop [Low Profit But More \nGRATR = \"\u2b50\u2b50 Volty Forex & Adaptive ATR Volume Setting \u2b50\u2b50\"\nForex_mode = input.bool(defval = false, title = \"\ud83d\udcb5\ud83d\udc95 Volty Forex Mode Only & Commission = 0 Only\"\nvolty_mode = input.bool(defval = false, title = \"\u2b50 Adaptive ATR Volty MODE For CryptoCurrency\"\nRepeat_mode = input.bool(defval = false, title = \"\ud83d\udccc Repeat Signal After TP/SL \u274c Can't Use With \nvolty_conse = input.bool(defval = false, title = \"\ud83c\udfaf Consecutive Bars Filter For Repeat Signal\"\nlength = input.int(defval = 5, title = \"Adaptive ATR Candle Length\", minval = 1, \nnumATRs = input.float(defval = 0.75, title = \"Adaptive ATR Multiply\", minval = 0.1\nFastEMATR = input.int(defval = 8, title = \"FAST Adaptive ATR LINE - After Calculate\"\nSlowEMATR = input.int(defval = 32, title = \"SLOW Adaptive ATR LINE - After Calculate\"\natrs = ta.sma(ta.tr, length)*numATRs\nbuycon = close+atrs\nsellcon = close-atrs\nnewcon = (buycon - sellcon) + close\nbuysig = ta.ema(buycon, 12)\nsellsig = ta.ema(sellcon, 12)\nnewsig = ta.ema(newcon, FastEMATR)\nnewsig2 = ta.ema(newcon, SlowEMATR)\nATRLCondition = ta.crossover(newsig, newsig2)\nATRSCondition = ta.crossunder(newsig, newsig2)\nL_Consecutive = close > close[1] and close[1] > close[2] and close[2] > close[3]\nS_Consecutive = close < close[1] and close[1] < close[2] and close[2] < close[3]\nLongRepeat = newsig > newsig2\nShortRepeat = newsig < newsig2\nplot(volty_mode ? newsig : na, \"newsig\", color =  color.white, linewidth = 1, style\nplot(volty_mode ? newsig2 : na, \"newsig2\", color =  color.blue, linewidth = 1, style\nplotshape(volty_mode ? ATRLCondition : na, title = \"LongSig\", style = shape.labelup\nplotshape(volty_mode ? ATRSCondition : na, title = \"ShortSig\", style = shape.labeldown\n////////////////////////////////////////////////////////////////////////////////////////////////////\nText_Alert_Future = '{{strategy.order.alert_message}}'\ncopy_Fu = input( defval= Text_Alert_Future ,    title=\"Alert Message for BOT\", inline\npassphrase = input.string(defval='1234', title ='Bot Pass',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nleveragex  = input.int(125,title='leverage',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nlongcommand = input.string(defval='AutoLong', title = 'Bot Long Command',group='\u2550 Bot Setting \u2550 \\n >> If You Dont Use Bot Just \nshortcommand = input.string(defval='AutoShort', title = 'Bot Short Command',group\nmarkettype = input.string(defval='bnfuture', title = 'Future/Spot Command',group=\n//////////////// Strategy Alert For X4815162342 BOT //////////////////////\n//////// For Use Bot Can Change This Command By Your Self /////////////////////\nstring Alert_OpenLong       = '{\"ex\":\"'+markettype+'\",\"side\": \"'+longcommand+'\", \"amount\": \"@{{strategy.order.contracts}}\", \"sy\nstring Alert_OpenShort      = '{\"ex\":\"'+markettype+'\",\"side\": \"'+shortcommand+'\", \"amount\": \"@{{strategy.order.contracts}}\", \"sy\n//string Alert_LongTP         = '{\"ex\":\"bnfuture\",\"side\": \"CloseLong\", \"amount\": \"@{{strategy.order.\n//string Alert_ShortTP        = '{\"ex\":\"bnfuture\",\"side\": \"CloseShort\", \"amount\": \"@{{strategy.order\n//var message_closelong       = '{\"ex\":\"bnfuture\",\"side\": \"CloseLong\", \"amount\": \"%100\", \"symbol\": \"\n//var message_closeshort      = '{\"ex\":\"bnfuture\",\"side\": \"CloseShort\", \"amount\": \"%100\", \"symbol\": \nstring Alert_StopLosslong   = '{\"ex\":\"'+markettype+'\",\"side\": \"CloseLong\", \"amount\": \"%100\", \"symbol\"\nstring Alert_StopLossshort  = '{\"ex\":\"'+markettype+'\",\"side\": \"CloseShort\", \"amount\": \"%100\", \"symbol\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\nPLOTBO_MODE = input.bool(title=\"[PLOT] BreakOut LINE [PLOT]\", defval = false, group\nlengthBO = input.int(title=\"1\ufe0f\u20e3 Length BreakOut\", minval=1, maxval=1000, defval=5,\ntriling_BO = input.float(title = \"\ud83c\udd7e\ufe0f BreakOut Trailing CALLBACK [%]\", defval = 25,\nupBound = ta.highest(high, lengthBO)\ndownBound = ta.lowest(low, lengthBO)\nSL_LongBO = (close < (upBound-((upBound*triling_BO)/100)))\nSL_ShortBO = (close > (downBound+((downBound*triling_BO)/100)))\npvthi_BO = upBound\npvtlo_BO = downBound\nShuntBO = 1  //Wait for close before printing pivot? 1 for true 0 for flase\nmaxLvlLenBO = 0  //Maximum Extension Length\npvthiBO = pvthi_BO[ShuntBO]\npvtloBO = pvtlo_BO[ShuntBO]\n// Count How many candles for current Pivot Level, If new reset.\ncounthiBO = ta.barssince(not na(pvthiBO))\ncountloBO = ta.barssince(not na(pvtloBO))\npvthisBO = fixnan(pvthiBO)\npvtlosBO = fixnan(pvtloBO)\nhipcBO = ta.change(pvthisBO) != 0 ? na :  color.lime\nlopcBO = ta.change(pvtlosBO) != 0 ? na :  color.red\n// Display Pivot lines\nplot(PLOTBO_MODE ? maxLvlLenBO == 0 or counthiBO < maxLvlLenBO ? pvthisBO : na : \nplot(PLOTBO_MODE ? maxLvlLenBO == 0 or countloBO < maxLvlLenBO ? pvtlosBO : na : \nif BOTrail_MODE == true\n    if Spot_MODE == false\n        if SL_LongBO and strategy.position_size > 0\n            strategy.close(\"Long\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\")\n        if SL_ShortBO and strategy.position_size < 0\n            strategy.close(\"Short\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\")\n    if Spot_MODE == true\n        if SL_LongBO and strategy.position_size > 0\n            strategy.close(\"Long\", qty_percent = 100, comment = \"\u2747\ufe0fCALLBACK\u2747\ufe0f\")\n//================ Consecutive UP/Down ===============\nGR2 = \"=====2\ufe0f\u20e32\ufe0f\u20e32\ufe0f\u20e3 Consecutive Up/Down Strategy 2\ufe0f\u20e32\ufe0f\u20e32\ufe0f\u20e3=====\"\nConsecutive_MODE = input.bool(defval = false, title = \"2\ufe0f\u20e3 CONSECUTIVE BarsUP/DOWN MODE\"\nconsecutiveBarsUp = input.int(defval = 3, title = '2\ufe0f\u20e3 Consecutive BarsUp', minval\nconsecutiveBarsDown = input.int(defval = 3, title = '2\ufe0f\u20e3 Consecutive BarsDown', minval\nprice = close\nups = 0.0\nups := price > price[1] ? nz(ups[1]) + 1 : 0\ndns = 0.0\ndns := price < price[1] ? nz(dns[1]) + 1 : 0\n// ============= 15m BREAK RANGE GOLD AND CRYPTO ===============\nGR3 = \"=====3\ufe0f\u20e33\ufe0f\u20e33\ufe0f\u20e3 15m BREAK RANGE STRATEGY 3\ufe0f\u20e33\ufe0f\u20e33\ufe0f\u20e3=====\"\nhlrang_mode = input.bool(defval = false, title = \"3\ufe0f\u20e3 15m High/Low Range Break MODE [BUY ONLY]\"\nhlrang_plot = input.bool(defval = false, title = \"[PLOT] 15m High/Low Range Break [PLOT]\"\nrrange = high-low\nlookback = input.int(2, minval=1, title=\"3\ufe0f\u20e3 15m - Lookback\", group = GR3)\nxr = input.int(10, minval=1, title=\"3\ufe0f\u20e3 15m - Range Length\", group = GR3)\nmult = input.float(2.0, minval=0.001, maxval=50, title=\"15m - SD\", group = GR3)\ncomputation = mult * ta.stdev(rrange, xr) + ta.sma(rrange, xr)\ncond1 = rrange > computation\nplot(hlrang_plot ? rrange : na, title=\"Range H-L\", style=plot.style_columns)\nplot(hlrang_plot ? computation : na, title=\"H-L SD\", style=plot.style_line, color\nplot(hlrang_plot ? close - close[lookback] : na, title=\"Close Direction\", color=close\nlongCondition15 =  hlrang_mode ? cond1 and close > close[lookback] : na\nshortCondition15 = hlrang_mode ? cond1 and close < close[lookback] : na\n//============== Swing High and Low Mode ===============\n// Swing Plot\n//Swing_MODE = input.bool(title=\"PLOT SWING MODE\", defval=true, group = '= SWING SETTING =', tooltip\npvtLenL = input.int(3, minval=1, title='\ud83c\udd8e Pivot Length Left Hand Side', group = '==\ud83c\udd8e\ud83c\udd8e\ud83c\udd8e TP/SL SWING SETTING \ud83c\udd8e\ud83c\udd8e\ud83c\udd8e=='\npvtLenR = input.int(3, minval=1, title='\ud83c\udd8e Pivot Length Right Hand Side', group = \n// Get High and Low Pivot Points\npvthi_ = ta.pivothigh(high, pvtLenL, pvtLenR)\npvtlo_ = ta.pivotlow(low, pvtLenL, pvtLenR)\n// Force Pivot completion before plotting.\nShunt = 1  //Wait for close before printing pivot? 1 for true 0 for flase\nmaxLvlLen = 0  //Maximum Extension Length\npvthi = pvthi_[Shunt]\npvtlo = pvtlo_[Shunt]\n// Count How many candles for current Pivot Level, If new reset.\ncounthi = ta.barssince(not na(pvthi))\ncountlo = ta.barssince(not na(pvtlo))\npvthis = fixnan(pvthi)\npvtlos = fixnan(pvtlo)\nhipc = ta.change(pvthis) != 0 ? na :  color.maroon\nlopc = ta.change(pvtlos) != 0 ? na :  color.green\n// Display Pivot lines\nplot(Swing_STOP ? maxLvlLen == 0 or counthi < maxLvlLen ? pvthis : na : na, color\nplot(Swing_STOP ? maxLvlLen == 0 or countlo < maxLvlLen ? pvtlos : na : na, color\nplot(Swing_STOP ? maxLvlLen == 0 or counthi < maxLvlLen ? pvthis : na : na, color\nplot(Swing_STOP ? maxLvlLen == 0 or countlo < maxLvlLen ? pvtlos : na : na, color\nstopswinglow = ta.crossunder(close,pvtlos)\nstopswinghigh = ta.crossover(close,pvthis)\nif Swing_STOP == true\n    if Spot_MODE == false\n        if (close < pvtlos)\n            strategy.close(\"Long\", qty_percent = 100, comment = \"StopLong\ud83c\udff3\ufe0fSwLow\",\n        if (close > pvthis)\n            strategy.close(\"Short\", qty_percent = 100, comment = \"StopShort\ud83c\udff3\ufe0fSwHi\"\n    if Spot_MODE == true\n        if (close < pvtlos)\n            strategy.close(\"Long\", qty_percent = 100, comment = \"StopLong\ud83c\udff3\ufe0fSwLow\",\nengulfing_mode = input.bool(title=\"Normal Engulfing Signal\", defval=false, group=\nthreeengulfing_mode = input.bool(title=\"3 Candle Engulfing Signal\", defval=false,\n// bullish engulfing (Bueng)\nBueng = open[3] > close[3] and open[2] > close[2] and open[1] > close[1] and close\nplotshape(threeengulfing_mode ? Bueng : na, style=shape.diamond, location=location.belowbar\n// bearish engulfing (Beeng)\nBeeng = open[3] < close[3] and open[2] < close[2] and close[1] > open[1] and open\nplotshape(threeengulfing_mode ? Beeng : na, style=shape.diamond, location=location.abovebar\n// bullish engulfing (Bueng)\nBueng2 = open[3] > close[3] ? open[2] > close[2] ? open[1] > close[1] ? close > open\nbarcolor(threeengulfing_mode ? Bueng2 : na)\n// bearish engulfing (Beeng)\nBeeng2 = open[3] < close[3] ? open[2] < close[2] ? close[1] > open[1] ? open > close\nbarcolor(threeengulfing_mode ? Beeng2 : na)\n///////////////////////////////////////////////////////////////////////////////////\n//GRSTO = \"==\ud83c\udd71\ufe0f\ud83c\udd71\ufe0f\ud83c\udd71\ufe0f STOCHASTIC RSI SETTING [BG/Confirm]\ud83c\udd71\ufe0f\ud83c\udd71\ufe0f\ud83c\udd71\ufe0f==\"\n//stobg_mode = input.bool(title=\"Stochastic RSI Background Paint\", defval=false, group=GRSTO)\n//stobg_plot = input.bool(title=\"STO-TEXT\", defval=false, group=GRSTO, inline = 'STOT1')\n//stobull_text = input.color(title = 'BULL', defval = color.white, group = GRSTO, inline = 'STOT1')\n//stobear_text = input.color(title = 'BEAR', defval = color.orange, group = GRSTO, inline = 'STOT1')\n//lengthMACD = input(title='\ud83c\udd71\ufe0f Length', defval=21, group = GRSTO, inline = '15')\n//offsetMACD = input(title='\ud83c\udd71\ufe0f Offset', defval=0, group = GRSTO, inline = '15')\n//srcMACD = input(close, title='\ud83c\udd71\ufe0f Source', group = GRSTO, inline = '16')\n//length2MACD = input(title='\ud83c\udd71\ufe0f Trigger Length', defval=6, group = GRSTO, inline = '16')\n//bullstobg = input.color(title = 'Bull BG Color', defval = color.green, group = GRSTO, inline = 'ST\n//bearstobg = input.color(title = 'Bear BG Color', defval = color.red, group = GRSTO, inline = 'STOB\n//transstobg = input.int(defval = 75, title = 'Trans', minval = 0, maxval = 100, group = GRSTO, inli\n//\n//lsma = ta.linreg(srcMACD, lengthMACD, offsetMACD)\n//lsma2 = ta.linreg(lsma, lengthMACD, offsetMACD)\n//b = lsma - lsma2\n//zlsma2 = lsma + b\n//trig2 = ta.sma(zlsma2, length2MACD)\n//\n//c1 = zlsma2 > trig2 ? bullstobg : bearstobg\n//stobull = ta.crossover(zlsma2,trig2)\n//stobear = ta.crossunder(zlsma2, trig2)\n//stobullplus = zlsma2 > trig2\n//stobearplus = zlsma2 < trig2\n//plotshape(stobg_plot ? stobull : na, title = 'STO-BULL', text = 'STO-BULL', location = location.be\n//plotshape(stobg_plot ? stobear : na, title = 'STO-BULL', text = 'STO-BEAR', location = location.ab\n//\n//p1 = plot(stobg_mode ? zlsma2 : na, color=c1, linewidth=0)\n//p2 = plot(stobg_mode ? trig2 : na, color=c1, linewidth=0)\n//fill(p1, p2, color=color.new(c1,transp = transstobg))\n// bullish engulfing\nbullishEngulfing = open[1] > close[1] ? close > open ? close >= open[1] ? close[1\nbarcolor(engulfing_mode ? bullishEngulfing : na)\n// bearish engulfing\nbearishEngulfing = close[1] > open[1] ? open > close ? open >= close[1] ? open[1]\nbarcolor(engulfing_mode ? bearishEngulfing : na)\nbullishEngulfing2 = (open[1] > close[1] and close > open and close >= open[1] and\nbearishEngulfing2 = (close[1] > open[1] and open > close and open >= close[1] and\nplotshape(engulfing_mode ? bullishEngulfing2 : na, style=shape.labelup, location=\nplotshape(engulfing_mode ? bearishEngulfing2 : na, style=shape.labeldown, location\n////////////////////////////////////////////////////////////////////////////////////\nGRMAC = '===\ud83d\udcaf\ud83d\udcaf\ud83d\udcaf4\ufe0f\u20e3 Multi MA SETTING 4\ufe0f\u20e3\ud83d\udcaf\ud83d\udcaf\ud83d\udcaf==='\nMAStrategy_MODE = input.bool(title='4\ufe0f\u20e3 MA CROSS X STRATEGY MODE', defval=false, group\nMARepeat_Mode = input.bool(title='4\ufe0f\u20e3 \ud83c\udfafMA CROSS X REPEAT MODE', defval=false, group\n/////////// Normal Setting ////////////////\nsrcstrategy = input(close, title='\ud83d\udcaf4\ufe0f\u20e3 Source Multi MA', group = GRMAC, tooltip = \n///////////// EMA/SMA SETTING /////////////\npricestrategy = request.security(syminfo.tickerid, timeframe.period, srcstrategy)\nfastSW = input.bool(title='Show Fast MA Line', defval=false, group = GRMAC, inline\nfastcolor = input.color( color.new(color.red,0), group = GRMAC, inline = '110', \nslowSW = input.bool(title='Show Slow MA Line', defval=false, group = GRMAC, inline\nslowcolor = input.color( color.new(color.yellow,0), group = GRMAC, inline = '110'\nma1strategy = input(12, title='\ud83d\udcaf4\ufe0f\u20e3 Fast MA Length', group = GRMAC, inline = '12')\ntype1strategy = input.string('EMA', 'Fast MA Type', options=['SMA', 'EMA', 'WMA',\nma3strategy = input(26, title='\ud83d\udcaf4\ufe0f\u20e3 Slow MA Length', group = GRMAC, inline = '13')\ntype3strategy = input.string('EMA', 'Slow MA Type', options=['SMA', 'EMA', 'WMA',\nprice1strategy = switch type1strategy\n    \"EMA\" => ta.ema(pricestrategy, ma1strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma1strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma1strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma1strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma1strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma1strategy)\n        price3strategy = switch type3strategy\n    \"EMA\" => ta.ema(pricestrategy, ma3strategy)\n    \"SMA\" => ta.sma(pricestrategy, ma3strategy)\n    \"WMA\" => ta.wma(pricestrategy, ma3strategy)\n    \"HMA\" => ta.hma(pricestrategy, ma3strategy)\n    \"RMA\" => ta.rma(pricestrategy, ma3strategy)\n    \"VWMA\" => ta.vwma(pricestrategy, ma3strategy)\nFastL = plot(fastSW ? price1strategy : na, 'Fast MA', color=fastcolor, style = plot.style_line\nSlowL = plot(slowSW ? price3strategy : na, 'Slow MA', color=slowcolor, style = plot.style_line\nBullMACross = ta.crossover(price1strategy, price3strategy)\nBearMACross = ta.crossunder(price1strategy, price3strategy)\nBullMAPlus = price1strategy > price3strategy\nBearMAPlus = price1strategy < price3strategy\n//********* Background Paint ***********************\nprefillFast = plot(fastSW ? price1strategy : na, 'Fast MA', color= color.new(color.red\nprefillSlow = plot(slowSW ? price3strategy : na, 'Fast MA', color= color.new(color.yellow\nfcolor = price1strategy > price3strategy ?  color.new(color.lime,70) :  color.new\nfill(prefillFast,prefillSlow, color=fcolor, title='BACKGROUND PAINT')\n// **********************************************\n// ==================== DONCHIAN FANS MODE =====================\nDonchian_MODE = input.bool(defval = false, title = \"DONCHIAN FANS MODE\", group = \nDonchian_Bollinger = input.bool(defval = false, title = \"DONCHIAN BOLLINGER LINE\"\n//  Initiate bars:\nvar int bd = -1\nbd += 1\n//----------------------------------------------------------------------------------\n//  Required functions:\nf_highest_bar(_source, _bars, _length) =>\n    float _h_value = _source\n    int _h_bar = _bars\n    for _i = 0 to math.max(_length - 1, 0) by 1\n        bool _isSourceOver = _source[_i] > _h_value\n        if _isSourceOver\n            _h_value := _source[_i]\n            _h_bar := _bars[_i]\n            _h_bar\n    [_h_value, _h_bar]\nf_lowest_bar(_source, _bars, _length) =>\n    float _l_value = _source\n    int _l_bar = _bars\n    for _i = 0 to math.max(_length - 1, 0) by 1\n        bool _isSourceUnder = _source[_i] < _l_value\n        if _isSourceUnder\n            _l_value := _source[_i]\n            _l_bar := _bars[_i]\n            _l_bar\n    [_l_value, _l_bar]\nf_line(_x1, _y1, _r, _color) =>\n    var line _li = na\n    line.delete(id=_li)\n    _li := line.new(x1=_x1 - 1, y1=_y1 - _r, x2=_x1, y2=_y1, xloc=xloc.bar_index,\n    _li\n//----------------------------------------------------------------------------------\nint FANSlength = input.int(defval=100, title='FANS length:', minval=1, group = \"== DONCHIAN FANS MODE ==\"\n[h_price, h_bar] = f_highest_bar(high, bd, FANSlength)\n[l_price, l_bar] = f_lowest_bar(low, bd, FANSlength)\nfloat mid = (h_price + l_price) / 2\nplot(Donchian_Bollinger ? h_price : na, title='H', color= color.new(color.white,\nplot(Donchian_Bollinger ? mid : na, title='M', color= color.new(color.white, 20)\nplot(Donchian_Bollinger ? l_price : na, title='L', color= color.new(color.white,\nvar float r = ta.atr(FANSlength)\nif ta.change(mid) != 0\n    r := ta.atr(FANSlength)\n    r\nvar line h_1_04 = na\nvar line h_1_08 = na\nvar line h_1_16 = na\nvar line h_1_32 = na\nvar line h_1_64 = na\nvar line l_1_04 = na\nvar line l_1_08 = na\nvar line l_1_16 = na\nvar line l_1_32 = na\nvar line l_1_64 = na\nbool is_new_h = h_price > h_price[1]\nbool is_new_l = l_price < l_price[1]\nvhb = ta.valuewhen(high >= h_price, h_bar, 0)\nvhp = ta.valuewhen(high >= h_price, h_price, 0)\nvlb = ta.valuewhen(low <= l_price, l_bar, 0)\nvlp = ta.valuewhen(low <= l_price, l_price, 0)\nif is_new_l and Donchian_MODE == true\n    h_1_04 := f_line(vhb, vhp, -r * (1. / 04.),  color.red)\n    h_1_08 := f_line(vhb, vhp, -r * (1. / 08.),  color.red)\n    h_1_16 := f_line(vhb, vhp, -r * (1. / 16.),  color.red)\n    h_1_32 := f_line(vhb, vhp, -r * (1. / 32.),  color.red)\n    h_1_64 := f_line(vhb, vhp, -r * (1. / 64.),  color.red)\n    h_1_64\nif is_new_h and Donchian_MODE == true\n    l_1_04 := f_line(vlb, vlp, r * (1. / 04.),  color.lime)\n    l_1_08 := f_line(vlb, vlp, r * (1. / 08.),  color.lime)\n    l_1_16 := f_line(vlb, vlp, r * (1. / 16.),  color.lime)\n    l_1_32 := f_line(vlb, vlp, r * (1. / 32.),  color.lime)\n    l_1_64 := f_line(vlb, vlp, r * (1. / 64.),  color.lime)\n    l_1_64\n// **********************************************\nGRIC = '===\ud83d\udcae\ud83d\udcae\ud83d\udcae ICHIMOKU SETTING \ud83d\udcae\ud83d\udcae\ud83d\udcae==='\nIchi_Mode = input.bool(title=\"ICHIMOKU PLOT MODE\", defval=false, group = GRIC)\ntenkan_len  = input(9,'\ud83d\udcae Tenkan\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004',inline='tenkan', group = GRIC, tooltip = 'TENKAN = FAST SIGNAL'\ntenkan_mult = input(2.,'',inline='tenkan', group = GRIC)\nkijun_len   = input(26,'\ud83d\udcae Kijun\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004\u2004',inline='kijun', group = GRIC, tooltip = 'KIJUN = SLOW SIGNAL'\nkijun_mult  = input(4.,'',inline='kijun', group = GRIC)\nspanB_len   = input(52,'Senkou Span A/B\u2004',inline='span', group = GRIC, tooltip = \nspanB_mult  = input(6.,'',inline='span', group = GRIC)\ncloudacolor = input.color(defval =  color.new(color.orange,20), title = 'CLOUD-A'\ncloudbcolor = input.color(defval =  color.new(color.purple,20), title = 'CLOUD-B'\nchi_color = input.color(defval =  color.new(#73ecff,0), title = \"Chikou-Color\", \noffset      = input(26,'Chikou', group = GRIC, tooltip = 'CHIKOU = CANDLE LOOK BACK DEFAULT = 26'\n//------------------------------------------------------------------------------\navg(src,length,mult)=>\n    atr = ta.atr(length)*mult\n    up = hl2 + atr\n    dn = hl2 - atr\n    upper = 0.,lower = 0.\n    upper := src[1] < upper[1] ? math.min(up,upper[1]) : up\n    lower := src[1] > lower[1] ? math.max(dn,lower[1]) : dn\n        os = 0,max = 0.,min = 0.\n    os := src > upper ? 1 : src < lower ? 0 : os[1]\n    spt = os == 1 ? lower : upper\n    max := ta.cross(src,spt) ? math.max(src,max[1]) : os == 1 ? math.max(src,max[\n    min := ta.cross(src,spt) ? math.min(src,min[1]) : os == 0 ? math.min(src,min[\n    math.avg(max,min)\n//------------------------------------------------------------------------------\ntenkan = avg(close,tenkan_len,tenkan_mult)\nkijun = avg(close,kijun_len,kijun_mult)\nsenkouA = math.avg(kijun,tenkan)\nsenkouB = avg(close,spanB_len,spanB_mult)\n//------------------------------------------------------------------------------\ntenkan_css =  color.white\nkijun_css =  #ff5d00\ncloud_a = cloudacolor\ncloud_b = cloudbcolor\nchikou_css =  color.new(#73ecff,20)\nplot(Ichi_Mode ? tenkan : na,'Tenkan-Sen',tenkan_css,style = plot.style_stepline,\nplot(Ichi_Mode ? kijun : na,'Kijun-Sen',kijun_css, style = plot.style_stepline, linewidth\nplot(Ichi_Mode ? ta.crossover(tenkan,kijun) ? kijun : na : na,'Crossover', #2157f3\nplot(Ichi_Mode ? ta.crossunder(tenkan,kijun) ? kijun : na : na,'Crossunder', #ff5d00\nA = plot(Ichi_Mode ? senkouA : na,'Senkou Span A',na,offset=offset-1)\nB = plot(Ichi_Mode ? senkouB : na,'Senkou Span B',na,offset=offset-1)\nfill(A,B,senkouA > senkouB ? cloud_a : cloud_b)\nichi_bull = ta.crossover(tenkan,kijun)\nichi_bear = ta.crossunder(tenkan,kijun)\nichi_bullplus = tenkan > kijun\nichi_bearplus = tenkan < kijun\nplot(Ichi_Mode ? close : na,'Chikou',chi_color,offset=-offset+1, linewidth = 2)\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\nGRCMA = '==\ud83c\udd70\ufe0f\ud83c\udd70\ufe0f5\ufe0f\u20e35\ufe0f\u20e3 MACD SETTING [PLOT/Confirm]5\ufe0f\u20e35\ufe0f\u20e3\ud83c\udd70\ufe0f\ud83c\udd70\ufe0f=='\nMACDStrategy_MODE = input.bool(title='5\ufe0f\u20e3 MACD CROSS [0] STRATEGY MODE', defval=false\nMACDStrategy_Repeat = input.bool(title='5\ufe0f\u20e3\ud83c\udfaf MACD CROSS [0] REPEAT MODE', defval=false\nMACD_MODE_SIG= input.bool(title=\"MACD MODE = MACD Cross Signal\", defval=false, group\n//if MACD_MODE_SIG == true\nMACDfastLength = input(12, title='\ud83c\udd70\ufe0f5\ufe0f\u20e3 MACD Fast', group = GRCMA, inline = 'MACDSIG1'\nMACDslowlength = input(26, title='\ud83c\udd70\ufe0f5\ufe0f\u20e3 MACD Slow', group = GRCMA, inline = 'MACDSIG1'\nMACDLength = input(18, title='\ud83c\udd70\ufe0f5\ufe0f\u20e3 MACD Length', group = GRCMA)\nmacdupcolor = input.color(defval =  color.new(color.green,0), title = 'CROSS-UP'\nmacddowncolor = input.color(defval =  color.new(color.red,0), title = 'CROSS-DOWN'\nMACD = ta.ema(close, MACDfastLength) - ta.ema(close, MACDslowlength)\naMACD = ta.ema(MACD, MACDLength)\ndelta = MACD - aMACD\nmacdTPl = (ta.crossover(delta, 0))\nmacdTPs = (ta.crossunder(delta, 0))\nMACDBull = delta > 0\nMACDBear = delta < 0\nplotshape(MACD_MODE_SIG ? macdTPl : na, title='macdTPl', text = '\ud83d\udc8e', color=macdupcolor\nplotshape(MACD_MODE_SIG ? macdTPs : na, title='macdTPs', text = '\ud83d\udc8e', color=macddowncolor\n//=============== TAKE PROFIT and STOP LOSS by % =================\ntpsl(percent) =>\n    strategy.position_avg_price * percent / 100 / syminfo.mintick\nGR4 = \"=====\ud83c\udd98\ud83c\udd98\ud83c\udd98 TAKE PROFIT & STOP LOSS BY [%] \ud83c\udd98\ud83c\udd98\ud83c\udd98=====\"\nmode= input.bool(title=\"\ud83c\udd98 Take Profit & Stop Loss By Percent (%)\", defval=false, \ntp_l = tpsl(input.float(99999, title='\ud83c\udd98 TP [LONG] %', group=GR4))\ntp_s = tpsl(input.float(33.3, title='\ud83c\udd98 TP [SHORT] %', group=GR4))\nsl = tpsl(input.float(0, title='\ud83c\udd98 Stop Loss %', group=GR4))\ncalcStopLossPrice(OffsetPts) =>\n    if strategy.position_size > 0\n        strategy.position_avg_price - OffsetPts * syminfo.mintick\n    else if strategy.position_size < 0\n        strategy.position_avg_price + OffsetPts * syminfo.mintick\n    else\n        na\ncalcStopLossL_AlertPrice(OffsetPts) =>\n    strategy.position_avg_price - OffsetPts * syminfo.mintick\ncalcStopLossS_AlertPrice(OffsetPts) =>\n    strategy.position_avg_price + OffsetPts * syminfo.mintick\ncalcTakeProfitPrice(OffsetPts) =>\n    if strategy.position_size > 0\n        strategy.position_avg_price + OffsetPts * syminfo.mintick\n    else if strategy.position_size < 0\n        strategy.position_avg_price - OffsetPts * syminfo.mintick\n    else\n        na\ncalcTakeProfitL_AlertPrice(OffsetPts) =>\n    strategy.position_avg_price + OffsetPts * syminfo.mintick\ncalcTakeProfitS_AlertPrice(OffsetPts) =>\n    strategy.position_avg_price - OffsetPts * syminfo.mintick\nvar stoploss = 0.\nvar stoploss_l = 0.\nvar stoploss_s = 0.\nvar takeprofit = 0.\nvar takeprofit_l = 0.\nvar takeprofit_s = 0.\nvar takeprofit_ll = 0.\nvar takeprofit_ss = 0.\nGRT = \"=====\ud83c\udd91\ud83c\udd91\ud83c\udd91 ATR TRAILING STOP \ud83c\udd91\ud83c\udd91\ud83c\udd91=====\"\n/////////notes////////////////////////////////////////\n// This is based on the ATR trailing stop indicator //\n// width addition of two levels of stops and        //\n// different interpretation.                        //\n// This is a fast-reacting system and is better     //\n// suited for higher volatility markets             //\n//////////////////////////////////////////////////////\n // Fast Trail //\nAP1 = input.int(5, '\ud83c\udd91 Fast ATR period', group = GRT)  // ATR Period\nAF1 = input.float(0.5, '\ud83c\udd91 Fast ATR multiplier', group = GRT)  // ATR Factor\nSL1 = AF1 * ta.atr(AP1)  // Stop Loss\nTrail1 = 0.0\niff_1 = close > nz(Trail1[1], 0) ? close - SL1 : close + SL1\niff_2 = close < nz(Trail1[1], 0) and close[1] < nz(Trail1[1], 0) ? math.min(nz(Trail1\nTrail1 := close > nz(Trail1[1], 0) and close[1] > nz(Trail1[1], 0) ? math.max(nz(\n// Slow Trail //\nAP2 = input.int(10, '\ud83c\udd91 Slow ATR period', group = GRT)  // ATR Period\nAF2 = input.float(2, '\ud83c\udd91 Slow ATR multiplier', group = GRT)  // ATR Factor\nSL2 = AF2 * ta.atr(AP2)  // Stop Loss\nTrail2 = 0.0\niff_3 = close > nz(Trail2[1], 0) ? close - SL2 : close + SL2\niff_4 = close < nz(Trail2[1], 0) and close[1] < nz(Trail2[1], 0) ? math.min(nz(Trail2\nTrail2 := close > nz(Trail2[1], 0) and close[1] > nz(Trail2[1], 0) ? math.max(nz(\nBuyLong = ta.crossover(Trail1, Trail2)\nSellShort = ta.crossunder(Trail1, Trail2)\nTS1 = plot(plotcolor ? Trail1 : na, 'Fast Trail', style=plot.style_line, color=Trail1\nTS2 = plot(plotcolor ? Trail2 : na, 'Slow Trail', style=plot.style_line, color=Trail1\nif plotcolor == true\n    if BuyLong and strategy.position_size < 0\n        strategy.close('Short', qty_percent = 100, alert_message = Alert_StopLossshort\n    if SellShort and strategy.position_size > 0\n        strategy.close('Long', qty_percent = 100, alert_message = Alert_StopLosslong\nGRARO = \"===\ud83c\udf69\ud83c\udf69\ud83c\udf69 AROON SETTING \ud83c\udf69\ud83c\udf69\ud83c\udf69===\"\n// ######### TRENDLOCK CONFIRM (MACD > 0 and MA FAST > SLOW) ########\nAroonConfirm_MODE = input.bool(defval = false, title = \"\ud83c\udf69AROON 100% & -100% CONFIRM\"\nlengthAroon = input.int(14, minval=1, title = \"AROON LENGTH\", group = GRARO)\nAroonUpper = 100 * (ta.highestbars(high, lengthAroon) + lengthAroon)/lengthAroon\nAroonLower = 100 * (ta.lowestbars(low, lengthAroon) + lengthAroon)/lengthAroon\nAroonCrossUp = ta.crossover(AroonUpper, AroonLower)\nAroonCrossDown = ta.crossunder(AroonUpper, AroonLower)\nAroonHitUp = AroonUpper > AroonLower\nAroonHitDown = AroonUpper < AroonLower\nGRRSI = \"\ud83c\ude50=== RSI MODE ===\"\nRSI_PLOT = input.bool(defval = false, title = \"\ud83c\ude50=== RSI LINE ===\", group = GRRSI)\nRSI_OB = input.int(defval = 50, title = \"\ud83c\ude50 RSI OverBought\", minval = 1, maxval = \nRSI_OS = input.int(defval = 50, title = \"\ud83c\ude50 RSI OverSold\", minval = 1, maxval = 100\nRSI_LENGTH = input.int(defval = 14, title = \"RSI LENGTH\", minval = 1, maxval = 999\nRSI_SMA = input.int(defval = 50, title = \"RSI SMA LENGTH\", minval = 1, maxval = 999\nRSI_COL = input.color(defval =  color.white, title = \"RSI LINE\", group = GRRSI, \nRSI_SIZE = input.int(defval = 2, title = \"SIZE\", minval = 0, maxval = 4, tooltip \nRSI_TRANS = input.int(defval = 0, title = \"TRNS\", minval = 0, maxval = 100, tooltip\nRSIMA_COL1 = input.color(defval =  color.blue, title = \"RSIMA LINE\", group = GRRSI\nRSIMA_COL2 = input.color(defval =  color.teal, title = \"\", group = GRRSI, inline\nRSIMA_SIZE = input.int(defval = 3, title = \"SIZE\", minval = 0, maxval = 4, tooltip\nRSIMA_TRANS = input.int(defval = 0, title = \"TRNS\", minval = 0, maxval = 100, tooltip\nup = ta.rma(math.max(ta.change(close), 0), RSI_LENGTH)\ndown = ta.rma(-math.min(ta.change(close), 0), RSI_LENGTH)\nrsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\nvrsi = ta.rsi(close, RSI_LENGTH)\nRSIUP = ta.crossover(vrsi, RSI_OB)\nRSIDOWN = ta.crossunder(vrsi, RSI_OS)\nrsiMA = ta.sma(rsi, RSI_SMA)\nRSIBULL = ta.crossover(rsi, rsiMA)\nRSIBEAR = ta.crossunder(rsi, rsiMA)\nBULLRSI = rsi <= RSI_OB\nBEARRSI = rsi >= RSI_OS\nRSIc1 = rsi > rsiMA ? color.new(RSIMA_COL1, RSIMA_TRANS) : color.new(RSIMA_COL2, \nplotshape(RSI_PLOT ? RSIUP : na, title='RSIUP', text = 'OB', color= color.new(color.yellow\nplotshape(RSI_PLOT ? RSIDOWN : na, title='RSIDOWN', text = 'OS', color= color.new\nplot(RSI_PLOT ? rsi : na, title = \"RSI\", color = color.new(RSI_COL,RSI_TRANS), linewidth\nplot(RSI_PLOT ? rsiMA : na, title = \"RSI-based MA\", color=RSIc1, linewidth = RSIMA_SIZE\nDisable_Confirm = MACDConfirm_MODE == false and RSIConfirm_MODE == false and MACross_MODE\n//////////// INPUT BACKTEST RANGE ////////////////////////////////////////////////////\nvar string BTR1         = '\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INPUT BACKTEST TIME RANGE \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550'\ni_startTime             = input.time(defval = timestamp(\"01 Jan 1945 00:00 +0000\"\ni_endTime               = input.time(defval = timestamp(\"01 Jan 2074 23:59 +0000\"\nif time >= i_startTime and time <= i_endTime\n    // ##### BreakOut Strategy ######\n    if Spot_MODE == false\n        if MACDConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and MACDBull\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if MACDBear\n                    strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and MACDBull\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19MACD\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and MACDBear\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7bMACD\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and MACDBull\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and MACDBear\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19MACD\", alert_message\n                if BearMACross and MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7bMACD\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19MACD\", alert_message\n                if BearMAPlus and MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7bMACD\", \n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if (MACDStrategy_MODE == true and MACDStrategy_Repeat == true)\n                if MACDBull or macdTPl\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if MACDBear or macdTPs\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if (MACDStrategy_MODE == false and MACDStrategy_Repeat == true)\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19MACD\", alert_message\n                if ATRSCondition and MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7bMACD\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MACD\", alert_message\n                if ShortRepeat and MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bMACD\", \n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and MACDBull and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MACD\", alert_message\n                if ShortRepeat and MACDBear and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bMACD\", \n            if Forex_mode == true\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if MACDBear\n                    strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n        if RSIConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if BEARRSI\n                    strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and BULLRSI\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19RSI\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and BEARRSI\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7bRSI\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and BULLRSI\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and BEARRSI\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMAPlus and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19RSI\", alert_message\n                if BearMAPlus and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7bRSI\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19RSI\", alert_message\n                if BearMAPlus and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if macdTPs and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (MACDBull and BULLRSI) or (macdTPl and BULLRSI)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if (MACDBear and BEARRSI) or (macdTPs and BEARRSI)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if MACDBull and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if MACDBear and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19RSI\", alert_message\n                if ATRSCondition and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19RSI\", alert_message\n                if ShortRepeat and BEARRSI\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and BULLRSI and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19RSI\", alert_message\n                if ShortRepeat and BEARRSI and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bRSI\", alert_message\n            if Forex_mode == true\n                if BULLRSI\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if BEARRSI\n                    strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n        if MACross_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and BullMAPlus\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19MA\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and BearMAPlus\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7bMA\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and BullMAPlus\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and BearMAPlus\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and BullMAPlus) or (MACDBull and BullMAPlus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if (macdTPs and BearMAPlus) or (MACDBear and BearMAPlus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if (macdTPl and BullMAPlus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if (macdTPs and BearMAPlus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and BullMAPlus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if (MACDBear and BearMAPlus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19\", alert_message\n                if BearMACross\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7b\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19\", alert_message\n                if BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7b\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19MA\", alert_message\n                if ATRSCondition and BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7bMA\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MA\", alert_message\n                if ShortRepeat and BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bMA\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and BullMAPlus and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MA\", alert_message\n                if ShortRepeat and BearMAPlus and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bMA\", alert_message\n            if Forex_mode == true\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n        if IchiConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and ichi_bullplus\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19ICHI\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and ichi_bearplus\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7bICHI\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and ichi_bullplus\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and ichi_bearplus\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19ICHI\", alert_message\n                if BearMACross and ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7bICHI\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19ICHI\", alert_message\n                if BearMAPlus and ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7bICHI\", \n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and ichi_bullplus) or (MACDBull and ichi_bullplus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if (macdTPs and ichi_bearplus) or (MACDBear and ichi_bearplus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bICHI\", \n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if (macdTPl and ichi_bullplus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if (macdTPs and ichi_bearplus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bICHI\", \n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and ichi_bullplus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if (MACDBear and ichi_bearplus)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bICHI\", \n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19ICHI\", alert_message\n                if ATRSCondition and ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7bICHI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19ICHI\", alert_message\n                if ShortRepeat and ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bICHI\", \n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and ichi_bullplus and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19ICHI\", alert_message\n                if ShortRepeat and ichi_bearplus and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bICHI\", \n            if Forex_mode == true\n                if ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if ichi_bearplus\n                    strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n        if AroonConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and AroonHitUp\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19AR\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and AroonHitDown\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7bAR\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and AroonHitUp\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and AroonHitDown\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19AR\", alert_message\n                if BearMACross and AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7bAR\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19AR\", alert_message\n                if BearMAPlus and AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if macdTPs and AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and AroonHitUp) or (MACDBull and AroonHitUp)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if (macdTPs and AroonHitDown) or (MACDBear and AroonHitDown)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and AroonHitUp)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if (MACDBear and AroonHitDown)\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19AR\", alert_message\n                if ATRSCondition and AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat and AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and AroonHitUp and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat and AroonHitDown and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if Forex_mode == true\n                if AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if AroonHitDown\n                    strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n        if MACDConfirm_MODE == false and RSIConfirm_MODE == false and MACross_MODE\n            if BreakOut_MODE == true\n                if not na(close[lengthBO])\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                strategy.entry(\"Short\", strategy.short, stop=downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na)\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na)\n                strategy.entry(\"Short\", strategy.short, comment=\"Down\ud83d\udc7b\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15)\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15)\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19\", alert_message\n                if BearMACross\n                    strategy.entry(\"Short\", strategy.short, comment=\"X\ud83d\udc7b\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19\", alert_message\n                if BearMAPlus\n                    strategy.entry(\"Short\", strategy.short, comment=\"X-Re\ud83d\udc7b\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if macdTPl or MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs or MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if MACDBear\n                    strategy.entry(\"Short\", strategy.short, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19\", alert_message\n                if ATRSCondition\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATR\ud83d\udc7b\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19\", alert_message\n                if ShortRepeat\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7b\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19\", alert_message\n                if ShortRepeat and S_Consecutive\n                    strategy.entry(\"Short\", strategy.short, comment=\"ATRR\ud83d\udc7b\", alert_message\n            if Forex_mode == true\n                strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment \n                strategy.entry(\"Short\", strategy.short, stop = close-atrs, comment\n    if Spot_MODE == true\n        if MACDConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and MACDBull\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if MACDBear\n                    strategy.close_all(immediately = true, comment=\"Break\ud83d\udc7bMACD\", \n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and MACDBull\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19MACD\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and MACDBear\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7bMACD\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and MACDBull\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and MACDBear\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19MACD\", alert_message\n                if BearMACross and MACDBear\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bMACD\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19MACD\", alert_message\n                if BearMAPlus and MACDBear\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bMACD\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if macdTPl or MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs or MACDBear\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if MACDBear\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19MACD\", alert_message\n                if ATRSCondition and MACDBear\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bMACD\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MACD\", alert_message\n                if ShortRepeat and MACDBear\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bMACD\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and MACDBull and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MACD\", alert_message\n                if ShortRepeat and MACDBear and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bMACD\", alert_message\n            if Forex_mode == true\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if MACDBear\n                    strategy.exit(\"Exit_LFX\", \"Long\", stop = close-atrs, comment \n        if RSIConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if BEARRSI\n                    strategy.close_all(immediately = true, comment=\"Break\ud83d\udc7bRSI\", alert_message\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and BULLRSI\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19RSI\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and BEARRSI\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7bRSI\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and BULLRSI\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and BEARRSI\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19RSI\", alert_message\n                if BearMACross and BEARRSI\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bRSI\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19RSI\", alert_message\n                if BearMAPlus and BEARRSI\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if macdTPs and BEARRSI\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and BULLRSI) or (MACDBull and BULLRSI)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if (macdTPs and BEARRSI) or (MACDBear and BEARRSI)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and BULLRSI)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19RSI\", alert_message\n                if (MACDBear and BEARRSI)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19RSI\", alert_message\n                if ATRSCondition and BEARRSI\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and BULLRSI\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19RSI\", alert_message\n                if ShortRepeat and BEARRSI\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bRSI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and BULLRSI and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19RSI\", alert_message\n                if ShortRepeat and BEARRSI and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bRSI\", alert_message\n            if Forex_mode == true\n                if BULLRSI\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if BEARRSI\n                    strategy.exit(\"Exit_LFX\", \"Long\", stop = close-atrs, comment \n        if MACross_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"Break\ud83d\udc7bMA\", alert_message\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and BullMAPlus\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19MA\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and BearMAPlus\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7bMA\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and BullMAPlus\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and BearMAPlus\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if macdTPs and BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and BullMAPlus) or (MACDBull and BullMAPlus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if (macdTPs and BearMAPlus) or (MACDBear and BearMAPlus)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and BullMAPlus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19MA\", alert_message\n                if (MACDBear and BearMAPlus)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bMA\", alert_message\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19MA\", alert_message\n                if BearMACross\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bMA\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19MA\", alert_message\n                if BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bMA\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19MA\", alert_message\n                if ATRSCondition and BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bMA\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MA\", alert_message\n                if ShortRepeat and BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bMA\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and BullMAPlus and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19MA\", alert_message\n                if ShortRepeat and BearMAPlus and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bMA\", alert_message\n            if Forex_mode == true\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if BearMAPlus\n                    strategy.exit(\"Exit_LFX\", \"Long\", stop = close-atrs, comment \n        if IchiConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"Break\ud83d\udc7bICHI\", \n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and ichi_bullplus\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19ICHI\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and ichi_bearplus\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7bICHI\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and ichi_bullplus\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and ichi_bearplus\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19ICHI\", alert_message\n                if BearMACross and ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bICHI\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19ICHI\", alert_message\n                if BearMAPlus and ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bICHI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if macdTPs and ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bICHI\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and ichi_bullplus) or (MACDBull and ichi_bullplus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if (macdTPs and ichi_bearplus) or (MACDBear and ichi_bearplus)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bICHI\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and ichi_bullplus)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19ICHI\", alert_message\n                if (MACDBear and ichi_bearplus)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bICHI\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19ICHI\", alert_message\n                if ATRSCondition and ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bICHI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19ICHI\", alert_message\n                if ShortRepeat and ichi_bearplus\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bICHI\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and ichi_bullplus and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19ICHI\", alert_message\n                if ShortRepeat and ichi_bearplus and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bICHI\", alert_message\n            if Forex_mode == true\n                if ichi_bullplus\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if ichi_bearplus\n                    strategy.exit(\"Exit_LFX\", \"Long\", stop = close-atrs, comment \n        if AroonConfirm_MODE == true\n            if BreakOut_MODE == true\n                if not na(close[lengthBO]) and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                if AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"Break\ud83d\udc7bAR\", alert_message\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na) and AroonHitUp\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19AR\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na) and AroonHitDown\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7bAR\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15) and AroonHitUp\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15) and AroonHitDown\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19AR\", alert_message\n                if BearMACross and AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bAR\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19AR\", alert_message\n                if BearMAPlus and AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if macdTPs and AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if (macdTPl and AroonHitUp) or (MACDBull and AroonHitUp)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if (macdTPs and AroonHitDown) or (MACDBear and AroonHitDown)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if (MACDBull and AroonHitUp)\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19AR\", alert_message\n                if (MACDBear and AroonHitDown)\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19AR\", alert_message\n                if ATRSCondition and AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat and AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat and AroonHitDown\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and AroonHitUp and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat and AroonHitDown and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if Forex_mode == true\n                if AroonHitUp\n                    strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment\n                if AroonHitDown\n                    strategy.exit(\"Exit_LFX\", \"Long\", stop = close-atrs, comment \n        if MACDConfirm_MODE == false and RSIConfirm_MODE == false and MACross_MODE\n            if BreakOut_MODE == true\n                if not na(close[lengthBO])\n                    strategy.entry(\"Long\", strategy.long, stop=upBound + syminfo.mintick\n                strategy.exit(\"Long\", qty_percent = 100,stop = downBound - syminfo.mintick\n            // ##### Consecutive Strategy #######\n            if (Consecutive_MODE ? ups >= consecutiveBarsUp : na)\n                strategy.entry(\"Long\", strategy.long, comment=\"Up\ud83c\udf19\", alert_message\n            if (Consecutive_MODE ? dns >= consecutiveBarsDown : na)\n                strategy.close_all(immediately = true, comment=\"Down\ud83d\udc7b\", alert_message\n            // ##### 15m Strategy ######\n            if (longCondition15)\n                strategy.entry(\"Long\", strategy.long, alert_message = Alert_OpenLong\n                alert(\"15m BREAK UP\", freq = alert.freq_once_per_bar_close)\n            if (shortCondition15)\n                strategy.close_all(\"15m BREAK DOWN\", immediately = true, alert_message\n                alert(\"15m BREAK DOWN\", freq = alert.freq_once_per_bar_close)\n            if MAStrategy_MODE == true and MARepeat_Mode == false\n                if BullMACross\n                    strategy.entry(\"Long\", strategy.long, comment=\"X\ud83c\udf19\", alert_message\n                if BearMACross\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7b\", alert_message\n            if (MAStrategy_MODE == true and MARepeat_Mode == true) or (MAStrategy_MODE\n                if BullMAPlus\n                    strategy.entry(\"Long\", strategy.long, comment=\"X-Re\ud83c\udf19\", alert_message\n                if BearMAPlus\n                    strategy.close_all(immediately = true, comment=\"X\ud83d\udc7b\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == false\n                if macdTPl\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == true and MACDStrategy_Repeat == true\n                if macdTPl or MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if macdTPs or MACDBear\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if MACDStrategy_MODE == false and MACDStrategy_Repeat == true\n                if MACDBull\n                    strategy.entry(\"Long\", strategy.long, comment=\"MACD\ud83c\udf19X\", alert_message\n                if MACDBear\n                    strategy.close_all(immediately = true, comment=\"MACD\ud83d\udc7bX\", alert_message\n            if volty_mode == true and Repeat_mode == false and volty_conse == false\n                if ATRLCondition\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATR\ud83c\udf19AR\", alert_message\n                if ATRSCondition\n                    strategy.close_all(immediately = true, comment=\"ATR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == false\n                if LongRepeat\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if volty_mode == true and Repeat_mode == true and volty_conse == true\n                if LongRepeat and L_Consecutive\n                    strategy.entry(\"Long\", strategy.long, comment=\"ATRR\ud83c\udf19AR\", alert_message\n                if ShortRepeat and S_Consecutive\n                    strategy.close_all(immediately = true, comment=\"ATRR\ud83d\udc7bAR\", alert_message\n            if Forex_mode == true\n                strategy.entry(\"Long\", strategy.long, stop = close+atrs, comment \n                strategy.exit(\"Spot_ExitFX\",\"Long\", stop = close-atrs, comment = \n////////////////////////////////////////////////////////////////////////////////////////////////////\nif mode == true\n    if Spot_MODE == false\n        if (strategy.position_size > 0)\n            if sl > 0\n                stoploss := calcStopLossPrice(sl)\n                stoploss_l := stoploss\n            else if sl <= 0\n                stoploss := na\n            if tp_l > 0\n                takeprofit := tp_l\n                takeprofit_ll := close + ((close/100)*tp_l)\n                //takeprofit_s := na\n            else if tp_l <= 0\n                takeprofit := na\n        if (strategy.position_size < 0)\n            if sl > 0\n                stoploss := calcStopLossPrice(sl)\n                stoploss_s := stoploss\n            else if sl <= 0\n                stoploss := na\n            if tp_s > 0\n                takeprofit := tp_s\n                takeprofit_ss := close - ((close/100)*tp_s)\n                //takeprofit_l := na\n            else if tp_s <= 0\n                takeprofit := na\n        else if strategy.position_size == 0\n            stoploss := na\n            takeprofit := na\n    if Spot_MODE == true\n        if (strategy.position_size > 0)\n            if sl > 0\n                stoploss := calcStopLossPrice(sl)\n                stoploss_l := stoploss\n            else if sl <= 0\n                stoploss := na\n            if tp_l > 0\n                takeprofit := tp_l\n                takeprofit_ll := close + ((close/100)*tp_l)\n                //takeprofit_s := na\n            else if tp_l <= 0\n                takeprofit := na\n        else if strategy.position_size == 0\n            stoploss := na\n            takeprofit := na\nif mode == true\n    if Spot_MODE == false\n        if strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100 , profit = takeprofit,\n        if strategy.position_size < 0\n            strategy.exit(\"Exit\",'Short', qty_percent = 100, profit = takeprofit,\n    if Spot_MODE == true\n        if strategy.position_size > 0\n            strategy.exit(\"Exit\",'Long', qty_percent = 100, profit = takeprofit, \n//===================== \u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49  library =========================\nimport X4815162342/X48_LibaryStrategyStatus/2 as fuLi \n//\u0e41\u0e2a\u0e14\u0e07\u0e1c\u0e25 Backtest\nshow_Net = input.bool(true,'Monitor Profit&Loss', inline = 'Lnet', group = '= PNL MONITOR SETTING ='\nposition_ = input.string('bottom_center','Position', options = ['top_right','middle_right'\nsize_i = input.string('auto','size', options = ['auto','tiny','small','normal'] ,\ncolor_Net = input.color( color.blue,\"\" , inline = 'Lnet')\nfuLi.NetProfit_Show(show_Net , position_ , size_i,  color_Net )"}]}
{"messages": [{"role": "user", "content": "This Pine Script code defines a TradingView strategy called \"I11L - Better Buy Low Volatility or High Volatility?\". The strategy aims to study the difference between buying when an asset's volatility is low and when it is high. It allows the user to select whether to buy during low or high volatility periods by changing the input variable mode. Here's a brief explanation of the System: The strategy is initialized with relevant settings such as overlay, pyramiding, default quantity type, initial capital, and others. The mode input allows the user to choose between \"Buy low Volatility\" and \"Buy high Volatility\" options. volatilityTargetRatio is the user-defined threshold to be used for making buy decisions. A value of 1 equals the average ATR (Average True Range) for the security. A lower value indicates lower volatility. atrLength is the number of periods to calculate the ATR. sellAfterNBarsLength sets the number of bars to hold the position before selling it. The script calculates the ATR using the ta.atr() function, and then divides it by the closing price to normalize the value. It also calculates the simple moving average (SMA) of the normalized ATR over a period of 5 times the ATR length, and then computes the ratio between the normalized ATR and its average. The script keeps track of the number of holding bars using the variable holdingBarsCounter. When there are open trades, the holding bars counter is incremented. The decision to buy is made based on the selected mode and whether the computed ratio is above or below the user-defined threshold. When the holding bars counter exceeds the user-defined limit, the position is closed. The script plots the computed ratio with different colors based on the buy and close conditions. The ratio is plotted in green when a buy signal is triggered, red when a close signal is triggered, and white in all other cases. The value of 1 (the reference for the average ATR) is also plotted on the chart in white color. This strategy helps traders study the difference between buying during low and high volatility periods and compare the performance of these conditions. It can be useful for analyzing the effectiveness of volatility-based trading strategies, such as entering positions when the market is calm or during periods of strong price movement."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 I11L\n//@version=5\nstrategy(\"I11L - Better Buy Low Volatility or High Volatility?\", overlay=false, pyramiding\nmode = input.string(\"Buy low Volatility\",options = [\"Buy low Volatility\",\"Buy high Volatility\"\nvolatilityTargetRatio = input.float(1,minval = 0, maxval = 100,step=0.1, tooltip=\"1 equals the average atr for the security, a lowe\natrLength = input.int(14)\natr = ta.atr(atrLength) / close\navg_atr = ta.sma(atr,atrLength*5)\nratio = atr / avg_atr\nsellAfterNBarsLength = input.int(5, step=5, minval=0)\nvar holdingBarsCounter = 0\nif(strategy.opentrades > 0)\n    holdingBarsCounter := holdingBarsCounter + 1\nisBuy = false\nif(mode == \"Buy low Volatility\")\n    isBuy := ratio < volatilityTargetRatio\nelse\n    isBuy := ratio > volatilityTargetRatio\nisClose = holdingBarsCounter > sellAfterNBarsLength\nif(isBuy)\n    strategy.entry(\"Buy\",strategy.long)\nif(isClose)\n    holdingBarsCounter := 0\n    strategy.exit(\"Close\",limit=close)\nplot(ratio, color=isBuy[1] ?  color.green : isClose[1] ?  color.red :  color.white\nplot(1, color= color.white)"}]}
{"messages": [{"role": "user", "content": "General Description and Unique Features of this Script Introducing the VWAP Momentum-Pullback Strategy (long-only) that offers several unique features: 1.\tOur script/strategy utilizes Mark Minervini's Trend-Template as a qualifier for identifying stocks and other financial securities in confirmed uptrends. NOTE: In this basic version of the script, the Trend-Template has to be used as a separate indicator on TradingView (Public Trend-Template indicators are available on TradingView \u2013 community scripts). It is recommended to only execute buy signals in case the stock or financial security is in a stage 2 uptrend, which means that the criteria of the trend-template are fulfilled. 2.\tOur strategy is based on the supply/demand balance in the market, making it timeless and effective across all timeframes. Whether you are day trading using 1- or 5-min charts or swing-trading using daily charts, this strategy can be applied and works very well. 3.\tWe have also integrated technical indicators such as the RSI and the MA / VWAP crossover into this strategy to identify low-risk pullback entries in the context of confirmed uptrends. By doing so, the risk profile of this strategy and drawdowns are being reduced to an absolute minimum. Minervini\u2019s Trend-Template and the \u2018Stage-Analysis\u2019 of the Markets This strategy is a so-called 'long-only' strategy. This means that we only take long positions, short positions are not considered.  The best market environment for such strategies are periods of stable upward trends in the so-called stage 2 - uptrend.  In stable upward trends, we increase our market exposure and risk.  In sideways markets and downward trends or bear markets, we reduce our exposure very quickly or go 100% to cash and wait for the markets to recover and improve. This allows us to avoid major losses and drawdowns.  This simple rule gives us a significant advantage over most undisciplined traders and amateurs! \u2003 'The Trend is your Friend'. This is a very old but true quote. What's behind it??? \u2022 98% of stocks made their biggest gains in a Phase 2 upward trend. \u2022 If a stock is in a stable uptrend, this is evidence that larger institutions are buying the stock sustainably. \u2022 By focusing on stocks that are in a stable uptrend, the chances of profit are significantly increased. \u2022 In a stable uptrend, investors know exactly what to expect from further price developments. This makes it possible to locate low-risk entry points.  The goal is not to buy at the lowest price \u2013 the goal is to buy at the right price! Each stock goes through the same maturity cycle \u2013 it starts at stage 1 and ends at stage 4 \u2003 Stage 1 \u2013 Neglect Phase \u2013 Consolidation Stage 2 \u2013 Progressive Phase \u2013 Accumulation Stage 3 \u2013 Topping Phase \u2013 Distribution Stage 4 \u2013 Downtrend \u2013 Capitulation This strategy focuses on identifying stocks in confirmed stage 2 uptrends. This in itself gives us an advantage over long-term investors and less professional traders. By focusing on stocks in a stage 2 uptrend, we avoid losses in downtrends (stage 4) or less profitable consolidation phases (stages 1 and 3). We are fully invested and put our money to work for us, and we are fully invested when stocks are in their stage 2 uptrends. But how can we use technical chart analysis to find stocks that are in a stable stage 2 uptrend? Mark Minervini has developed the so-called 'trend template' for this purpose. This is an essential part of our JS-TechTrading pullback strategy. For our watchlists, only those individual values that meet the tough requirements of Minervini's trend template are eligible. The Trend Template \u2022\t200d MA increasing over a period of at least 1 month, better 4-5 months or longer \u2022\t150d MA above 200d MA \u2022\t50d MA above 150d MA and 200d MA \u2022\tCourse above 50d MA, 150d MA and 200d MA \u2022\tIdeally, the 50d MA is increasing over at least 1 month \u2022\tPrice at least 25% above the 52w low \u2022\tPrice within 25% of 52w high \u2022\tHigh relative strength according to IBD.  NOTE: In this basic version of the script, the Trend-Template has to be used as a separate indicator on TradingView (Public Trend-Template indicators are available in TradingView \u2013 community scripts). It is recommended to only execute buy signals in case the stock or financial security is in a stage 2 uptrend, which means that the criteria of the trend-template are fulfilled. This strategy can be applied to all timeframes from 5 min to daily. The VWAP Momentum-Pullback Strategy For the JS-TechTrading VWAP Momentum-Pullback Strategy, only stocks and other financial instruments that meet the selected criteria of Mark Minervini's trend template are recommended for algorithmic trading with this startegy. A further prerequisite for generating a buy signals is that the individual value is in a short-term oversold state (RSI).  When the selling pressure is over and the continuation of the uptrend can be confirmed by the MA / VWAP crossover after reaching a price low, a buy signal is issued by this strategy. Stop-loss limits and profit targets can be set variably. Relative Strength Index (RSI) The Relative Strength Index (RSI) is a technical indicator developed by Welles Wilder in 1978. The RSI is used to perform a market value analysis and identify the strength of a trend as well as overbought and oversold conditions. The indicator is calculated on a scale from 0 to 100 and shows how much an asset has risen or fallen relative to its own price in recent periods. The RSI is calculated as the ratio of average profits to average losses over a certain period of time. A high value of the RSI indicates an overbought situation, while a low value indicates an oversold situation. Typically, a value > 70 is considered an overbought threshold and a value < 30 is considered an oversold threshold. A value above 70 signals that a single value may be overvalued and a decrease in price is likely , while a value below 30 signals that a single value may be undervalued and an increase in price is likely. For example, let's say you're watching a stock XYZ. After a prolonged falling movement, the RSI value of this stock has fallen to 26. This means that the stock is oversold and that it is time for a potential recovery. Therefore, a trader might decide to buy this stock in the hope that it will rise again soon. The MA / VWAP Crossover Trading Strategy This strategy combines two popular technical indicators: the Moving Average (MA) and the Volume Weighted Average Price (VWAP). The MA VWAP crossover strategy is used to identify potential trend reversals and entry/exit points in the market. The VWAP is calculated by taking the average price of an asset for a given period, weighted by the volume traded at each price level. The MA, on the other hand, is calculated by taking the average price of an asset over a specified number of periods. When the MA crosses above the VWAP, it suggests that buying pressure is increasing, and it may be a good time to enter a long position. When the MA crosses below the VWAP, it suggests that selling pressure is increasing, and it may be a good time to exit a long position or enter a short position. Traders typically use the MA VWAP crossover strategy in conjunction with other technical indicators and fundamental analysis to make more informed trading decisions. As with any trading strategy, it is important to carefully consider the risks and potential rewards before making any trades. This strategy is applicable to all timeframes and the relevant parameters for the underlying indicators (RSI and MA/VWAP) can be adjusted and optimized as needed.  Backtesting Backtesting gives outstanding results on all timeframes and drawdowns can be reduced to a minimum level. In this example, the hourly chart for MCFT has been used. Settings for backtesting are: -\tPeriod from April 2020 until April 2021 (1 yr) -\tStarting capital 100k USD -\tPosition size = 25% of equity -\t0.01% commission = USD 2.50.- per Trade -\tSlippage = 2 ticks Other comments \u2022\tThis strategy has been designed to identify the most promising, highest probability entries and trades for each stock or other financial security. \u2022\tThe RSI qualifier is highly selective and filters out the most promising swing-trading entries. As a result, you will normally only find a low number of trades for each stock or other financial security per year in case you apply this strategy for the daily charts. Shorter timeframes will result in a higher number of trades / year. \u2022\tAs a result, traders need to apply this strategy for a full watchlist rather than just one financial security."}, {"role": "assistant", "content": "//@version=5\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 JS-TechTrading 2023\nstrategy(title='JS-TechTrading: VWAP Momentum_Pullback Strategy', initial_capital=100000\n//// Stoploss and Take Profit Parameters\n// Enable Long Strategy\nenable_long_strategy = input.bool(true, title='Activate Long-Strategy', group='SL/TP for Long-Strategy'\nlong_stoploss_value = input.float(defval=3, title='Stop-Loss (SL) %', minval=0, group\nlong_stoploss_percentage = close * (long_stoploss_value / 100) / syminfo.mintick\nlong_takeprofit_value = input.float(defval=7, title='Take-Profit (TP) %', minval=0,\nlong_takeprofit_percentage = close * (long_takeprofit_value / 100) / syminfo.mintick\n// Enable Short Strategy\nenable_short_strategy = input.bool(false, title='Activate Short-Strategie', group='SL/TP for Short-Strategy'\nshort_stoploss_value = input.float(defval=50, title='Stop-Loss (SL) %', minval=0, group\nshort_stoploss_percentage = close * (short_stoploss_value / 100) / syminfo.mintick\nshort_takeprofit_value = input.float(defval=50, title='Take-Profit (TP) %', minval=\nshort_takeprofit_percentage = close * (short_takeprofit_value / 100) / syminfo.mintick\n// Plot Stoploss & Take Profit Levels\nlong_stoploss_price = strategy.position_avg_price * (1 - long_stoploss_value / 100)\nlong_takeprofit_price = strategy.position_avg_price * (1 + long_takeprofit_value / \nshort_stoploss_price = strategy.position_avg_price * (1 + short_stoploss_value / 100\nshort_takeprofit_price = strategy.position_avg_price * (1 - short_takeprofit_value \nplot(enable_long_strategy and not enable_short_strategy ? long_stoploss_price : na,\nplot(enable_long_strategy and not enable_short_strategy ? long_takeprofit_price : na\nplot(enable_short_strategy and not enable_long_strategy ? short_stoploss_price : na\nplot(enable_short_strategy and not enable_long_strategy ? short_takeprofit_price : \n// Date Range\nstart_date = input.int(title='Start Day', defval=1, minval=1, maxval=31, group='Time-Period for Back-Testing'\nend_date = input.int(title='until Day', defval=1, minval=1, maxval=31, group='Time-Period for Back-Testing'\nstart_month = input.int(title='Start Month', defval=10, minval=1, maxval=12, group=\nend_month = input.int(title='until Month', defval=1, minval=1, maxval=12, group='Time-Period for Back-Testing'\nstart_year = input.int(title='Start Year', defval=2022, minval=1800, maxval=3000, group\nend_year = input.int(title='until Year', defval=2077, minval=1800, maxval=3000, group\nin_date_range = time >= timestamp(syminfo.timezone, start_year, start_month, start_date\n//// Indicator Inputs\n// RSI\nrsi_over_sold = input.int(defval=40, minval=1, title='Oversold Level', group='RSI')\nrsi_over_bought = input.int(defval=70, minval=1, title='Overbought Level', group='RSI'\nrsi_length = input.int(defval=14, minval=1, title='RSI Length', group='RSI')\nrsi = ta.rsi(close, rsi_length)\n// VWAP\nmaSource = input(title='SMA source', defval=close,group = \"VWAP\")\nmaInterval = input.int(title='SMA interval', minval=0, maxval=999, step=1, defval=7\nma = ta.sma(maSource, maInterval)\n//// Strategy\n// Creating Long and Short Strategy\nwas_over_sold = ta.barssince(rsi <= rsi_over_sold) <= 10\nwas_over_bought = ta.barssince(rsi >= rsi_over_bought) <= 10\ncrossover_bull = ta.crossover(ma, ta.vwap)\ncrossover_bear = ta.crossunder(ma, ta.vwap)\nbuy_signal = was_over_sold and crossover_bull\nsell_signal = was_over_bought and crossover_bear\n// Long Strategy\nif buy_signal and in_date_range and enable_long_strategy == true\n    strategy.entry('Long', strategy.long, when=buy_signal, alert_message='Open Long Position'\n    strategy.exit('Long SL/TP', from_entry='Long', loss=long_stoploss_percentage, profit\n    strategy.close('Long', when=sell_signal, alert_message='Close Long Position')\n// Short Strategy\nif sell_signal and in_date_range and enable_short_strategy == true\n    strategy.entry('Short', strategy.short, when=sell_signal, alert_message='Open Short Position'\n    strategy.exit('Short SL/TP', from_entry='Short', loss=short_stoploss_percentage\n    strategy.close('Short', when=buy_signal, alert_message='Close Short Position')"}]}
{"messages": [{"role": "user", "content": "The Extended Price Volume Trend (EPVT) is a technical indicator that is used to identify potential trend changes and measure the strength of a trend. In this strategy, we combine the EPVT with other indicators to create a trading system that aims to capture trend reversals and momentum shifts. The EPVT indicator is calculated by taking the cumulative volume and multiplying it by the percentage change in price. We then find the highest and lowest values of this indicator over a certain period of time to determine the baseline. The difference between the EPVT and the baseline is then plotted on a chart to create the EPVT line. To use this indicator for trading, we look for crossovers of the EPVT line with zero. When the EPVT crosses above zero, it indicates that buying pressure is increasing, and we may consider taking a long position. Conversely, when the EPVT crosses below zero, it indicates that selling pressure is increasing, and we may consider taking a short position. To further refine our trading signals, we use three take-profit levels, which we set as a percentage of the current EPVT value. We also use a simple moving average to provide additional confirmation of trend changes. In summary, the EPVT trading strategy is a technical analysis-based approach to trading that aims to identify potential trend reversals and momentum shifts. By combining the EPVT indicator with other technical tools, we can create a comprehensive trading system that provides clear entry and exit signals for both long and short positions. Please note that this strategy is for educational purposes only and should not be taken as financial advice."}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"Extended Price Volume Trend\", overlay=true,default_qty_type = strategy.percent_of_equity\nvar cumVol = 0.\ncumVol += nz(volume)\nif barstate.islast and cumVol == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nsrc = close\nlenght = input(200,\"Trend Lenght\")   \nvt = ta.cum(ta.change(src)/src[1]*volume)\nupx = ta.highest(vt,lenght)\ndownx = ta.lowest(vt,lenght)\nbasex = (upx +downx)/2\nVTX = vt - basex\nVTY = ta.valuewhen(ta.cross(VTX,0),close,0)\nplot(VTY, color= color.black, title=\"Extended-PVT\")\n/////////////////////// STRATEGY ////////////////\n/////////////////////// TAKE PROFIT SECTION ////////////////\nlongConditionx = ta.crossover(close,VTY)\nShortConditionx = ta.crossunder(close,VTY)\ntp1 = input.int(10, minval=1,title = \"TP-1\")\ntp2 = input.int(20, minval=1,title = \"TP-2\")\ntp3 = input.int(30, minval=1,title = \"TP-3\")\nematp = ta.ema(close,2)\nTPTAKA1S = VTY*(1-tp1/100)\nplot(TPTAKA1S, \"SELL-TP1\", color= color.red,linewidth = 1)\nTPTAKA2S = VTY*(1-tp2/100)\nplot(TPTAKA2S, \"SELL-TP2\", color= color.red,linewidth = 1)\nTPTAKA3S = VTY*(1-tp3/100)\nplot(TPTAKA3S, \"SELL-TP3\", color= color.red,linewidth = 1)\nTPTAKA1B = VTY*(1+tp1/100)\nplot(TPTAKA1B, \"BUY-TP1\", color= color.red,linewidth = 1)\nTPTAKA2B = VTY*(1+tp2/100)\nplot(TPTAKA2B, \"BUY-TP2\", color= color.red,linewidth = 1)\nTPTAKA3B = VTY*(1+tp3/100)\nplot(TPTAKA3B, \"BUY-TP3\", color= color.red,linewidth = 1)\nBUYTP = ta.crossunder(close,VTY) or ta.crossunder(ematp,TPTAKA1B) or ta.crossunder(\nSELLTP = ta.crossover(close,VTY) or ta.crossover(ematp,TPTAKA1S) or ta.crossover(ematp\n/////////////////////// STRATEGY ////////////////\n// Check for Long Entry\nlongCondition = longConditionx==true\nif longCondition\n    strategy.entry('Long', strategy.long, comment = \"ENTER-LONG\")\nbuyclose = ShortConditionx==true or BUYTP==true \n// Exit condition \nstrategy.close('Long', when=buyclose or BUYTP==true, comment = \"EXIT-LONG\")\n// Check for Short Entry\nShortCondition = ShortConditionx==true\nif ShortCondition\n    strategy.entry('Short', strategy.short, comment = \"ENTER-SHORT\")\nsellclose = longConditionx==true or SELLTP ==true\n// Exit condition \nstrategy.close('Short', when=sellclose or SELLTP==true, comment = \"EXIT-SHORT\")\n///// END OF STRATEGY ///////////"}]}
{"messages": [{"role": "user", "content": "This is a strategy using SPX's Fair Value derived from Net Liquidity. The main difference between this one and calebsandfort's one is net liquidity values in this one are calculated in TradingView and doesn't need author's daily library updates to function.   Net Liquidity function is simply: Fed Balance Sheet - Treasury General Account - Reverse Repo Balance Formula for calculating the fair value of and Index using Net Liquidity looks like this: (WALCL - WTREGEN - RRPONTSYD)/1000000000/scalar - subtractor The Index Fair Value is then subtracted from the Index value which creates an oscillating diff value. When diff is greater than the overbought threshold, Index is considered overbought and we go short/sell. When diff is less than the oversold signal, Index is considered oversold and we cover/buy. Parameters: Index: SPX, NDX, RUT Strategy: Short Only, Long Only, Long/Short Inverse (bool): check if using an inverse ETF to go long instead of short. Scalar (float) Subtractor (int) Overbought Threshold (int) Oversold Threshold (int) Start After Date: When the strategy should start trading Close Date: Day to close open trades. I just like it to get complete results rather than the strategy ending with open trades. I've optimized the parameters for SPX."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9ekmll\n//@version=5\nstrategy(\"Fair Value Strategy ekmll\", overlay=false, initial_capital = 1000000, calc_on_every_tick\nfv_index_ticker = input.string(\"SPX\", \"Fair Value Index\", [\"SPX\", \"NDX\", \"RUT\"])\nmode = input.string(\"Long/Short\", \"Strategy\", [\"Short Only\", \"Long Only\", \"Long/Short\"\nscalar = input.float(1.1, \"Scalar\", 0.0, 5.0, .1)\nsubtractor = input.int(1425, \"Subtractor\", step = 25)\nob_threshold = input.int(0, \"OB Threshold\", step = 25)\nos_threshold = input.int(-175, \"OS Threshold\", step = 25)\ninverse = input.bool(false, \"Inverse\")\nstartDate = input.int(title=\"Start Day\", defval=20, minval=1, maxval=31)\nstartMonth = input.int(title=\"Start Month\", defval=12, minval=1, maxval=12)\nstartYear = input.int(title=\"Start Year\", defval=2021, minval=1800, maxval=2100)\n// See if this bar's time happened on/after start date\nafterStartDate = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\nuseCloseDate = input.bool(true, title=\"Use Close Date\")\ncloseDay = input.int(title=\"Close Day\", defval=20, minval=1, maxval=31)\ncloseMonth = input.int(title=\"Close Month\", defval=12, minval=1, maxval=12)\ncloseYear = input.int(title=\"Close Year\", defval=2024, minval=1800, maxval=2100)  \n// See if this bar's time happened on/after end date\nafterEndDate = year == closeYear and month == closeMonth and dayofmonth == closeDay\nnet_liquidity = request.security(\"(WALCL - WTREGEN - RRPONTSYD)\", \"D\", close)\nplotchar(net_liquidity, \"net_liquidity\", \"\", location.top)\nindex_fair_value = net_liquidity/1000000000/scalar - subtractor\nindex = request.security(fv_index_ticker, \"D\", close)\ndiff = index - index_fair_value\nplot(index_fair_value > 0 ? diff : na, title = \"Spread\", color =  color.blue, trackprice\nhline(0, title='Zero', color= color.gray, linestyle=hline.style_dotted, linewidth=\nhline(ob_threshold, title='Overbought', color= color.red, linestyle=hline.style_dotted\nhline(os_threshold, title='Oversold', color= color.green, linestyle=hline.style_dotted\noverbought_signal = net_liquidity > 0.0 and (diff[1] < ob_threshold and diff[0] > ob_threshold\noversold_signal = net_liquidity > 0.0 and (diff[1] > os_threshold and diff[0] < os_threshold\nbarcolor(overbought_signal ?  color.purple : oversold_signal ?  color.blue : na)\nqty = (strategy.initial_capital + strategy.netprofit + strategy.openprofit)/close\nqty_adj = strategy.opentrades > 0 ? math.abs(strategy.opentrades.size(0) * 1) : qty\nif (mode == \"Long/Short\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")        \n        else if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (afterStartDate and oversold_signal)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n        else if (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Short Only\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Long Only\")\n    if (inverse)\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n    else\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")"}]}
{"messages": [{"role": "user", "content": "This trading system, called \"I11L - Risk Adjusted Leveraging\", is designed to manage trades based on the current market volatility relative to its historical average. The system calculates the target number of open trades based on the ATR (Average True Range) indicator and adjusts the leverage accordingly. The system opens and closes trades using a pyramiding approach, allowing multiple positions to be opened at the same time. Here's a step-by-step explanation of the system: 1. Calculate the ATR with a 14-day period and normalize it by dividing it by the current closing price. 2. Calculate the 100-day simple moving average (SMA) of the normalized ATR. 3. Calculate the ratio of the normalized ATR to its 100-day SMA. 4. Determine the target leverage based on the inverse of the ratio (2 / ratio). 5. Calculate the target number of open trades by multiplying the target leverage by 5. 6. Plot the target number of open trades and the current number of open trades on the chart. 7. Check if there's an opportunity to buy (if the current number of open trades is less than the target) or close a trade (if the current number of open trades is more than the target plus 1). 8. If there's an opportunity to buy, open a long trade and add the trade's name to the openTrades array. 9. If there's an opportunity to close a trade and there are trades in the openTrades array, close the most recent trade by referencing the array and remove it from the array. This system aims to capture trends in the market by dynamically adjusting the number of open trades and leverage based on the market's volatility. It uses an array to keep track of open trades, allowing for better control over the opening and closing of individual trades."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"I11L - Risk Adjusted Leveraging\", overlay=false, pyramiding=25, default_qty_value\natr = ta.atr(14) / close\navg_atr = ta.sma(atr,100)\nratio = atr / avg_atr\ntargetLeverage = 2 / ratio\ntargetOpentrades = 5 * targetLeverage\nplot(targetOpentrades)\nplot(strategy.opentrades)\nisBuy = strategy.opentrades < targetOpentrades\nisClose = strategy.opentrades > targetOpentrades + 1\nvar string[] openTrades = array.new_string(0)\nif(isBuy)\n    strategy.entry(\"Buy\"+str.tostring(array.size(openTrades)),strategy.long)\n    array.push(openTrades, \"Buy\" + str.tostring(array.size(openTrades)))\nif(isClose)\n    if array.size(openTrades) > 0\n        strategy.close(array.get(openTrades, array.size(openTrades) - 1))\n        array.pop(openTrades)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added options for 1 entry per trigger for using fixed SL / PT                                                    Release Notes:                                                    Updated with options to change entry threshold for LaRSI"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 PtGambler\n//@version=5\nstrategy(\"3MA + Laguerre RSI + ADX [Pt]\", shorttitle = \"3MA+LaRSI+ADX[Pt]\", overlay\n// ********************************** Trade Period / Strategy Setting ******************************\nstartY = input(title='Start Year', defval=2011, group = \"Backtesting window\")\nstartM = input.int(title='Start Month', defval=1, minval=1, maxval=12, group = \"Backtesting window\"\nstartD = input.int(title='Start Day', defval=1, minval=1, maxval=31, group = \"Backtesting window\"\nfinishY = input(title='Finish Year', defval=2050, group = \"Backtesting window\")\nfinishM = input.int(title='Finish Month', defval=12, minval=1, maxval=12, group = \nfinishD = input.int(title='Finish Day', defval=31, minval=1, maxval=31, group = \"Backtesting window\"\ntimestart = timestamp(startY, startM, startD, 00, 00)\ntimefinish = timestamp(finishY, finishM, finishD, 23, 59)\nuse_entry_sess = input.bool(false, 'Use Entry Session Window', group = \"Trading Session\"\nt1_session = input.session(\"0930-1555:23456\", \"Entry Session\", group=\"Trading Session\"\nt1 = time(timeframe.period, t1_session)\nwindow = time >= timestart and time <= timefinish and t1 ? true : false \nmargin_req = input.float(1, title=\"Margin Requirement / Leverage\", step=0.1, group\nqty_per_trade = input.float(100, title = \"% of initial capital per trade\", group =\nreinvest = input.bool(defval=false,title=\"Reinvest profit\", group = \"Trading Options\"\nreinvest_percent = input.float(defval=100, title = \"Reinvest percentage\", group=\"Trading Options\"\nclose_eod = input.bool(false, \"All trades will close at the close of trading window\"\nclose_b4_open = input.bool(false, \"Position must hit either SL/PT before entering ne\nprofit = strategy.netprofit \nfloat trade_amount = math.floor(strategy.initial_capital*margin_req / close) \nif strategy.netprofit > 0 and reinvest\n    trade_amount := math.floor((strategy.initial_capital* (qty_per_trade/100)+(profit\nelse\n    trade_amount := math.floor(strategy.initial_capital* (qty_per_trade/100)*margin_req\n// ******************************************************************************************\ngroup_ma = \"Moving Average Ribbon\"\ngroup_larsi = \"Laguerre RSI\"\ngroup_adx = \"ADX\"\ngroup_SL = \"Stop Loss / Profit Target\"\n// ----------------------------------------- MA Ribbon -------------------------------------\nema1_len = input.int(16, \"Fast EMA Length\", group = group_ma)\nema2_len = input.int(48, \"Slow EMA Length \", group = group_ma)\nsma1_len = input.int(200, \"Slow SMA Length\", group = group_ma)\nema1 = ta.ema(close, ema1_len)\nema2 = ta.ema(close, ema2_len)\nsma1 = ta.sma(close, sma1_len)\nplot(ema1, \"EMA 1\",  color.white, linewidth = 2)\nplot(ema2, \"EMA 2\",  color.yellow, linewidth = 2)\nplot(sma1, \"SMA 1\",  color.purple, linewidth = 2)\nma_bull = ema1 > ema2 and ema2 > sma1   \nma_bear = ema1 < ema2 and ema2 < sma1\n// ------------------------------------------ Laguerre RSI ---------------------------------------\nalpha = input.float(0.2, title='Alpha', minval=0, maxval=1, step=0.1, group = group_larsi\nlong_thres = input.int(80, 'Long entry above this threshold', minval = 1, maxval =\nshort_thres = input.int(20, 'Short entry below this threshold', minval = 1, maxval\ngamma = 1 - alpha\nL0 = 0.0\nL0 := (1 - gamma) * close + gamma * nz(L0[1])\nL1 = 0.0\nL1 := -gamma * L0 + nz(L0[1]) + gamma * nz(L1[1])\nL2 = 0.0\nL2 := -gamma * L1 + nz(L1[1]) + gamma * nz(L2[1])\nL3 = 0.0\nL3 := -gamma * L2 + nz(L2[1]) + gamma * nz(L3[1])\ncu = (L0 > L1 ? L0 - L1 : 0) + (L1 > L2 ? L1 - L2 : 0) + (L2 > L3 ? L2 - L3 : 0)\ncd = (L0 < L1 ? L1 - L0 : 0) + (L1 < L2 ? L2 - L1 : 0) + (L2 < L3 ? L3 - L2 : 0)\ntemp = cu + cd == 0 ? -1 : cu + cd\nLaRSI = temp == -1 ? 0 : cu / temp\nLaRSI := LaRSI * 100\nbull_LaRSI = LaRSI > long_thres\nbear_LaRSI = LaRSI < short_thres\n// --------------------------------------- ADX  ------------------------\nadxlen = input(14, title=\"ADX Smoothing\", group = group_adx)\ndilen = input(14, title=\"DI Length\", group = group_adx)\ndirmov(len) =>\n    up = ta.change(high)\n    down = -ta.change(low)\n    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\n    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n    truerange = ta.rma(ta.tr, len)\n    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)\n    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)\n    [plus, minus]\nadx(dilen, adxlen) =>\n    [plus, minus] = dirmov(dilen)\n    sum = plus + minus\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)\nsig = adx(dilen, adxlen)\nactive_adx = sig > 20 //and sig > sig[1]\n// ******************************* Profit Target / Stop Loss ***************************************\nuse_SLPT = input.bool(false, 'Use Fixed SL / PT', group = group_SL)\nSL = input.float(50, 'Stop loss in ticks', step = 1, group = group_SL) * syminfo.mintick\nPT = input.float(100, \"Profit target in ticks\", step = 1, group = group_SL) * syminfo.mintick\nlimit_entry = input.bool(false, \"Limit same direction entry to 1 per trigger\", group\nvar L_PT = 0.0\nvar S_PT = 0.0\nvar L_SL = 0.0\nvar S_SL = 0.0\nif strategy.position_size > 0\n    L_SL := L_SL[1]\n    L_PT := L_PT[1]\nelse if strategy.position_size < 0\n    S_SL := S_SL[1]\n    S_PT := S_PT[1]\nelse\n    L_SL := close - SL\n    L_PT := close + PT\n    S_SL := close + SL\n    S_PT := close - PT\nentry_line = plot(use_SLPT and strategy.position_size != 0 ? strategy.opentrades.entry_price\nL_PT_line = plot(use_SLPT and strategy.position_size > 0 ? L_PT : na, \"L PT\",  color.green\nS_PT_line = plot(use_SLPT and strategy.position_size < 0 ? S_PT : na, \"S PT\",  color.green\nL_SL_line = plot(use_SLPT and strategy.position_size > 0 ? L_SL : na, \"L SL\",  color.red\nS_SL_line = plot(use_SLPT and strategy.position_size < 0 ? S_SL : na, \"S SL\",  color.red\nfill(L_PT_line, entry_line, color =  color.new(color.green,90))\nfill(S_PT_line, entry_line, color =  color.new(color.green,90))\nfill(L_SL_line, entry_line, color =  color.new(color.red,90))\nfill(S_SL_line, entry_line, color =  color.new(color.red,90))\n// ---------------------------------- Strategy setup -----------------------------------------------\nvar L_entry_trigger = true\nvar S_entry_trigger = true\nL_entry1 = ma_bull and bull_LaRSI and active_adx and (use_SLPT and limit_entry ? L_entry_trigger\nS_entry1 = ma_bear and bear_LaRSI and active_adx and (use_SLPT and limit_entry ? S_entry_trigger\nL_exit1 = ta.crossunder(ema1, ema2)\nS_exit1 = ta.crossover(ema1, ema2)\n// Trigger zones\nbgcolor(ma_bull ?  color.new(color.green ,90) : na)\nbgcolor(ma_bear ?  color.new(color.red,90) : na)\nif L_entry1 and (use_entry_sess ? window : true) and (close_b4_open ? strategy.position_size\n    strategy.entry(\"Long\", strategy.long, trade_amount)\n    L_entry_trigger := false\nif S_entry1 and (use_entry_sess ? window : true) and (close_b4_open ? strategy.position_size\n    strategy.entry(\"Short\", strategy.short, trade_amount)\n    S_entry_trigger := false\nif use_SLPT\n    strategy.exit(\"Exit Long\", \"Long\", limit = L_PT, stop = L_SL, comment_profit =\n    strategy.exit(\"Exit Short\", \"Short\", limit = S_PT, stop = S_SL, comment_profit\nelse\n    if L_exit1\n        strategy.close(\"Long\", comment = \"Exit Long\")\n    if S_exit1\n        strategy.close(\"Short\", comment = \"Exit Short\")\nif use_entry_sess and not window and close_eod\n    strategy.close_all(comment = \"EOD close\")\n//reset entry trigger\nif ta.crossunder(ema1, ema2)\n    L_entry_trigger := true\nif ta.crossover(ema1, ema2)\n    S_entry_trigger := true"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    BankNifty 5min Supertrend Based Strategy, Intraday. Work Best at 5mint chart on BankNifty . The strategy is designed to trade using the Supertrend indicator with session-based rules, and risk management. It allows for customization through input variables and aims to provide a clear visual representation of the Supertrend by changing the color. The strategy is designed to trade using the Supertrend indicator with session-based rules, risk management, and changing the color. The strategy starts by defining input variables such as the session time, start and end date for the backtesting, the length of the ATR, and the Supertrend factor. It also includes options for delay at session start and stop loss points and trail percentage. The code then checks if the current time is within the specified session and date range. If it is, the Supertrend and its direction are calculated using the defined input variables. The strategy then waits for N numbers of candles(Defined by the user) to form at the start of every session before entering a trade. The entry and exit conditions for long and short trades are defined based on the change in the Supertrend direction and the number of candles formed at the session start. Stop-loss and trailing stop-loss are also defined based on the input variables. The Supertrend plot is displayed with changing colors depending on the direction. Finally, the strategy closes all trades at the end of the session if there are any open trades. Overall, this strategy aims to trade with the Supertrend indicator using session-based rules and risk management.  However, as with any trading strategy, it is important to thoroughly test it before using it in live trading.                            Release Notes:                                                    You'll get a hint on how the strategy performed, at least in the past, although obviously there is no guarantee that it will make money in the future.                                                    Release Notes:                        Updates to this strategy Stop-loss is improved (fixed Points) Added Target Profit/Points Added option to take ReEntry in the supertrend direction after hitting Sl/TG/TSl.  This strategy Shows good results in the futures. Always Remember the strategy performed, at least in the past, although obviously there is no guarantee that it will make money in the future.                                                    Release Notes:                                                    Always Future Test (Paper Trade) the new strategy                                                    Release Notes:                                                    apply to chart"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"BankNifty 5min Supertrend Based Strategy, 09:15 Entry with Date Range and Risk Management\"\n// Session and date range input variables\nsession = input(\"0915-1510\", \"Session\", group=\"Indian Session Time\")\nstart_date = input.time(title=\"Start Date\", defval=timestamp(\"01 Jan 2022 00:00:00\"\nend_date = input.time(title=\"End Date\", defval=timestamp(\"01 Dec 2023 23:59:59\"))\natrPeriod = input(50, \"ATR Length\", group=\"SuperTrend Setting\")\nfactor = input.float(3.0, \"Factor\", step=0.1)\n//Delay N numbers of candles\nuseDelay = input(true, \"Use Delay?\", group=\"Delay at Session Start\")\nDelay = useDelay ? input(10, title=\"Delay N numbers of candle\", group=\"Delay at Session Start\"\n//reentry option\nTake_ReEntry = input(true, \"Take ReEntry After Delay/SL/Target?\", group=\"Delay at Session Start\"\nD1 = Take_ReEntry ? 100 : 0\n//stoploss and target\nuseDelay_stopLoss = input(true, \"Use Stoploss Fixed Points?\", group=\"Fixed Point SL/TG\"\nstopLoss = useDelay_stopLoss ? input(100, \"Stop Loss Fixed Points\", group=\"Fixed Point SL/TG\"\nuseTarget = input(true, \"Use Target Fixed Points?\", group=\"Fixed Point SL/TG\")\ntarget = useTarget? input(200, \"Use Target Fixed Points\", group=\"Fixed Point SL/TG\"\nstopLoss1 = 100\n// trailing stop loss\nuseDelay_stopLossPerc1 = input(true, \"Use Stoploss Trail?\", group=\"Trailing\")\nstopLossPerc1 =useDelay_stopLossPerc1 ? input.float(0.1, \"Stop Loss Trail%\", step=0.1\n// Check if current time is within the specified session and date range\ninSession = time(\"1\", session) and time >= start_date and time <= end_date\n//suprtrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n// Wait for n candles to form at the start of every session\nvar candlesFormed = 0\nif inSession and not inSession[1]\n    candlesFormed := 1\nelse if inSession and candlesFormed > 0\n    candlesFormed := candlesFormed + 1\nelse\n    candlesFormed := 0\n//get entry price\nentryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\n//stop and target based on entry price\nStopCE=entryPrice - stopLoss\nStopPE= entryPrice + stopLoss\ntargetCE= entryPrice + target\ntargetPE=entryPrice - target\n// long, short and close condition\nentryce = (ta.change(direction) < 0) or (candlesFormed >= Delay and candlesFormed <=\nexitce = ta.change(direction) > 0 or close < StopCE or close > targetCE\nentrype = (ta.change(direction) > 0) or (candlesFormed >= Delay and candlesFormed <=\nexitpe = ta.change(direction) < 0 or close > StopPE or close < targetPE\n// entry price variable for defining stoploss\nvar entryPrice1 = 0.0\n// Enter long trade\nif entryce and inSession\n    onePercent = strategy.position_avg_price *stopLossPerc1\n    entryPrice1 := close   \n    strategy.entry(\"My Long Entry Id\", strategy.long, comment=\"long\" )\n    strategy.exit(\"My Long Exit Id\", \"My Long Entry Id\", stop=(entryPrice1 - stopLoss1\n//close long trade\nif exitce and inSession\n    strategy.close(\"My Long Entry Id\", comment=\"close\" )\n// Enter short trade   \nif entrype and inSession\n    onePercent1 = strategy.position_avg_price *stopLossPerc1\n    entryPrice1 := close\n    strategy.entry(\"My Short Entry Id\", strategy.short, comment=\"short\")\n    strategy.exit(\"My Short Exit Id\", \"My Short Entry Id\", stop=(entryPrice1 + stopLoss1\n//close short trade\nif exitpe and inSession\n    strategy.close (\"My Short Entry Id\", comment=\"close\" )\n// Close all trades at end of session\nif not inSession and strategy.opentrades > 0\n    strategy.close_all()\n// Plot Supertrend with changing colors\nplot(supertrend, title=\"Supertrend\", color=direction == 1 ?  color.red :  color.green"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    When the bounce up or bounce down is detected it shows yellow tick marks above and below the orange triangle marker so users have an idea where potential run ends or to better understand when the analytic is wrong.                                                    Release Notes:                                                    Updated chart so it has clean chart vs other indicators.                                                    Release Notes:                                                    Corrected strategy tester so it used 10% of equity.                                                    Release Notes:                                                    Updated script to change wait time to 12 minutes between trades. Since pivot logic runs based on candle close of prior candle.  If prior candle had a large change of greater than expected move, then algo waits to initiate. This removes false signals that then closed immediately.                                                    Release Notes:                                                    Updated exit strategy of trade so if trending is detected via high ADX, Average Directional Index, the .30 take profit is ignored and trade will not close until either the ADX drops, which signals no trending, or if the 5 minute close for a given minute crosses the 5 minute 13 EMA. This avoids a series of closing positions and then waits when to re-enter when trending in a direction. Even though the win % drops slightly, as the winning position is held longer it profits a greater amount. Also, when exiting a position now ensure entering proper exit portion for Pivot Up vs Pivot down. Also, updated entering Pivot Up and Pivot Down logic to only enter if not in a position.                                                    Release Notes:                                                    If stop loss is breached it now closes trade instead of relying completely on higher degree trend closing trade.                                                    Release Notes:                                                    By mistake deleted script. Re-adding.                                                    Release Notes:                                                    Tweaked MACD signal to allow trades to be entered sooner for both Pivot Up and Pivot Down.                                                    Release Notes:                                                    Updated stop loss logic to percentage so now this will work on any trending stock!                                                    Release Notes:                                                    Main change further optimized Pivot Up and Pivot Down by including 3 new indicators: Stochastic signal, MACD difference and Root Mean Square of ATR. Also tweaked MACD signal and RSI. This slightly lessoned amounts of trades but improved their ability to enter sooner. Also by tweaking ADX from 25 to 18 was able to hold trades longer. These changes improved backtesting results by about 25% Also did some basic house cleaning on stale duplicate code and initial header explanation.                                                    Release Notes:                                                    Got rid of noisy trades by taking absolute difference between 5 & 13 ema on higher degree and ensuring it was > .11. This allowed the time between successful trades shrink to 7 minutes since not taking noisy trades. Now also only closing trades right before 10AM & 4PM (eliminated 1PM and 3PM). Backtest results indicated that trades shrunk by more than 50% but profits close to doubled and percent profitable jumped to over 70% due to noisy trades being removed.                                                    Release Notes:                                                    Now including 5 min 5 EMA (blue) and 13 EMA (orange). These are used on 1 min to exit trades which are trending and not take trades when the difference is less than 0.12. If less than 0.12 and only parameter not hitting, you will see a 5 below/above the L or S that is prepping you to get ready for pivot point.                                                    Release Notes:                                                    There are 10 parameters not 9 so needed to update for Pivot Signals and letters to show properly.                                                    Release Notes:                                                    Prior release was correct plus needed to remove unnecessary indicators.                                                    Release Notes:                                                    Discovered a couple inconsistencies with macdLine letter colors so updated.                                                    Release Notes:                                                    Removed candle spike logic as noisy trades have been removed.                                                    Release Notes:                                                    Updating description. Now that this works with any trending stock, stops and take profits are 0.00075% Tweaked bounce up and bounce down logic with a Updated description about wait period for trades as none is enabled due to removing noisy trades                                                    Release Notes:                                                    Only cleaned-up notes in code. Reload not necessary for this version.                                                    Release Notes:                                                    Only now entering long trades if close > open and short trades if close < open. This was added as a new condition for white and gold L's and S's as well. Also not entering trades during first five minutes. It can enter if still trending in 6th minute. Also, now only not taking trades in last two minutes of day instead of last two minutes of every hour.                                                    Release Notes:                                                    Released with extra unnecessary stuff. Re-releasing clean version.                                                    Release Notes:                                                    With fuchsia line now indicate high low price of day and will not Pivot Up when within 0.05% of high of day and will not Pivot Down when within 0.05% of low of day. Will now suggest protecting trades when longs achieve 2x take profit and shorts achieve 1.8x take profits. Stops are then set to break-even. These changes have boosted win percentage to over 80% as indicated by backtesting.                                                    Release Notes:                                                    Tweaked HOD / LOD logic so that won't take if within 0.1% instead of 0.05%                                                    Release Notes:                                                    Updated to give some leeway on entering trade only if Pivot Up and Pivot Down by comparing prior candle and 3 cent buffer.                                                    Release Notes:                                                    Changed Protect Longs to Exit Partial Longs and same with Shorts so it is more understandable Remove extra MACD indicator added by mistake in last release.                                                    Release Notes:                                                    Critical update as discovered issue with short stop loss that was causing it to sometimes close trade too early Prepping tool for VWAP inclusion                                                    Release Notes:                                                    Will now only take partial profit for Pivot Up once above 2x when a candle closes below the 5 minute 13 EMA and for Pivot Down once below 2x when a candle closes above the 5 minute 13 EMA Added 2x Take Profit Indicators as an orange tick mark                                                    Release Notes:                                                    Critical Update Please note that in order to use this script Extended Hours trading must be turned off Updated strategy and backtested/optimized 5 different trading periods throughout the day and color coordinated triangles based on best trading times of day for this script. Wasn't much of a surprise that first 90 minutes of day is best time to trade. Also lunchtime looks like good time as well for this script. First 90 minutes: 94% win rate (green triangles) Next hour: 80% win rate (orange triangles) Lunchtime: 90% (green triangles) After lunch until Power Hour: 80% (orange triangles) Power Hour: 70% (red triangles) Removed the following parameters from Pivot Up / Pivot Down signals: Stoichastic Signal, MACD Signal, MACD Difference between Line and Signal, RSI Signal Removed low ADX from closing trade                                                    Release Notes:                                                    Per other users feedback updated first line of code to stop repaint from occurring and improperly positively impacting backtest results. By add the following line backtest results were minimally impacted and first hour still rocks at 94% for last 38 days of trading. strategy(title=\"SPY 1 Minute Day Trader\", overlay=true, calc_on_every_tick=false, process_orders_on_close=true)                                                    Release Notes:                                                    Removed lookahead=barmerge.lookahead_on from request.security in script to avoid repaint at end of day. Tweaked values to get backtest clean.                                                    Release Notes:                                                    Had to remove volume or I get in trouble!                                                    Release Notes:                                                    Updated colors based on new backtesting and determined that for this strategy First 90 minutes and After lunch until power hour are good (green) After first 90 minutes until lunch is bad (red) 1PM until power hour is great! (lime)                                                    Release Notes:                                                    Added ADX to stay in trending trades that pop above 2x and tweaked 5 minute 5/13 ema difference.                                                    Release Notes:                                                    Stay out of more trades before lunch!                                                    Release Notes:                                                    Tweaked power hour to take less trades.                                                    Release Notes:                                                    Fixed when one parameter short, now shows which one missing with silver L or S and Gold L or S when everything is there and trade is ongoing. Also added barstate.isconfirmed so trades don't change at close of day. Didn't impact backtest.                                                    Release Notes:                                                    Added 3x pin bar reversals with the ability to toggle them in inputs (positive impact to backtest with limited additional trades). Also cleaned up other inputs.                                                    Release Notes:                                                    Updated to only take pin bar if not in that type of long/short position already and can take opposite position and close on trend reversal.                                                    Release Notes:                                                    Updated so that pin bar has meaningful size to remove small signals that aren't true reversals. Improved win rate and lessened trades.                                                    Release Notes:                                                    Optimized pin bar height for reversal signal Added VWAP to stop trying to short when above VWAP 2 standard deviations and long when below VWAP 2 standard deviations. Reversals are unlikely at that point! Show VWAP with basic 2 standard deviations Cleaned-up function bar to remove unnecessary string of zeros                                                    Release Notes:                                                    Disabled trading from 11 until 12 by default. Can enable in settings. Changed 5 min difference of 5 & 13 EMA to reference percentage instead of fixed values to work with more stocks. This is however optimized for SPY. Also optimized pin bar exit height strategy.                                                    Release Notes:                                                    Turned off pin bar exits as closing trades too early                                                    Release Notes:                                                    Fixed missing indicator to work on % instead of fixed value.                                                    Release Notes:                                                    Now can see Pin Bar pivot signals vs typical pivot signal                                                    Release Notes:                                                    Optimized Stochastic to minimize trades (Pivot Down > 0 and Pivot Up <90) Won't close trade in first 3 minutes if 5 min EMA < 13 EMA for Pivot Up or 5 min 5 EMA > 13 EMA for Pivot Down No trades in first 10 minutes of day and last 5 minutes of day Close all positions in last 3 minutes of day From 1PM until 3PM will now take HOD & LOD trades Now showing Exit Longs if stopped as Exit Longs Stopped and if Exist Shorts if stopped as Exit Shorts Stopped                                                    Release Notes:                                                    Now give flexibility to enable and disable trading times in Inputs. They are broken into 5 segments: 9:30 until 11 (default on) 11 until noon (default off) Lunchtime (default on) 1 until 3 (default on) Power Hour (default off) This way if you don't want alerts you won't get bothered during these times. Improved logic exiting trades to take profit sooner but if trending to allow it to run                                                    Release Notes:                                                    Had to remove Stoichastic... ugh.                                                    Release Notes:                                                    Cleaned-up bug in 1 to 3 5 min 5/13 diff                                                    Release Notes:                                                    Had to remove volume.                                                    Release Notes:                                                    Enabled all timeframes for trading by default. Can disable in Inputs. 11-12 and Power Hour are typically bad times to trade. Made one parameters missing descriptive and on by default. Can disable in Inputs if clutters screen with ability to toggle if interested.                                                    Release Notes:                                                    Critical Update: Discovered that exiting partial positions weren't occurring properly unless users had proper strategy of percent of equity selected vs the default. Updated strategy in order to approx. tune for a pair of 1 DTE ATM option contracts being bought/sold on SPY. Exit Partial refers to selling one contract and holding runner until Exit flashes for remaining. initial_capital=1800000, default_qty_type=strategy.percent_of_equity, default_qty_value=15, pyramiding=0, commission_type=strategy.commission.cash_per_order, commission_value=1.3                                                    Release Notes:                                                    Default state of missing 1 parameter from Pivot Up and Pivot Down signals, silver Ls and Ss, will now only show recent reasons with ability to hover over and have tool tip explain why position wasn't initiated. To see reasons for all time, simply check option box in Input (default is unchecked to show as stated above).                                                    Release Notes:                                                    Critical Update: Discovered a few repaints occurring so added barstate.isconfirmed to eliminate. Also check out new SPY 4 Hour Swing Trader! It works great with SPXL!!!                                                    Release Notes:                                                    Switched First 90 minutes of trading following one set of conditions to first 60 minutes. This in turn has next 30 minutes follow new conditions which now make 10: 30 until lunch profitable time period. Suggest not trading during power hour as this is still loses money. Also, forcing trades once over 2x to take profits vs adhere to limit order which improves profitability as well. Updated first hour of trading to lime and next 90 minutes to green.                                                    Release Notes:                                                    Fixed partial profit logic.                                                    Release Notes:                                                    After re-evaluating, removed partial logic as now able to re-enter if continuing trend after counter-trend.                                                    Release Notes:                                                    Critical Update: Was not detecting long properly and was shorting on false signals. Fixed parameters.                                                    Release Notes:                                                    Tweaked exiting trade to improve profit                                                    Release Notes:                                                    Updated trading pivot triangle colors for pivot signals based on how successful: 9:30 until 10:30 -> Green 10:30 until Noon -> Red (In backtesting didn't benefit) 1:00  until 3:00 -> Lime 3:00 until 4:00 -> Lime Removed unnecessary notes                                                    Release Notes:                                                    Updated to take more high and low of day trades first thing in morning (until noon) and during 1PM until 3PM as well. Will start trading after first 5 minutes after open.                                                    Release Notes:                                                    Added Stop Loss & Take Profit to Inputs Added Configurable date that is now tuned for 4 SPY 1 DTE option contracts that are to see profit or loss for day Found missing barstate.isconfirmed's that should correct any repaints                                                    Release Notes:                                                    Tweaked 5 minute differences between 5 and 13 EMAs. Eventually may rethink this part of strategy as it seems to change. Maybe this will be the last time for the tweak?                                                    Release Notes:                                                    Simplified getting into long trades by only including 5 ema > than 13 ema with 5 min 5 ema > 5 min 13 ema and RSI Signal < 49 and simplified getting into long trades by only including 5 ema < 13 ema with 5 min 5 ema < 5 min 13 ema and RSI Signal > 60 No longer need to show prep signals!                                                    Release Notes:                                                    Added alert messages to strategies so when alerts appear they can be more descriptive and show message indicating what action to take. Add the following code to your alert: {{ticker}} @ {{time}} {{strategy.order.action}} {{strategy.order.alert_message}}                                                    Release Notes:                                                    Forgot to remove indicators and lines.                                                    Release Notes:                                                    Trying to see if removing plotshape fixes alerts. Also removed excess commenting."}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"SPY 1 Minute Day Trader\", initial_capital=1800000, default_qty_type\n//This script has been created to take into account how the following variables impact trend for SPY\n//The SPY stop losses/take profit have been set to 0.00075% which equates to 10%ish on SPY 1 DTE ATM\n//5 ema vs 13 ema : A cross establishes start of trend\n//Stoicastic smoothed line: Establish over bought vs over sold\n//MACD (Line, Signal & Slope) : If you have momentum\n//ADX : if you are trending\n//RSI : If the trend has strength\n//MACD Difference between line and signal line to wait on buying\n//Root Mean Square of ATR to(Average True Range) Want to buy during lower values\n//When the bounce up or bounce down is detected it shows yellow tick marks above and below the orang\n//marker so users have an idea where potential run ends or to better understand when the analytic is\n//White L's indicate that 7 of 8 conditions are met due to impending uptrend w/ missing one in green\n//Yellow L's indicate that 8 of 8 conditions still are met\n//White S's indicate that 7 of 8 conditions are met due to impending downtrend w/ missing condition \n//Yellow S's indicate that 8 of 8 conditions still are met\n//Logic is available for trades to repeat before re-opening but has been disabled, since noisy trade\n//Won't close position until either it gets stopped based on 0.00075 * stock price or higher degree \n//changes (as long as trending) or loses trend as determined by ADX.\n//Won't open any trades on last two minutes of day and won't trade during first 5 minutes of day\n//Will close any open trades going into 10AM and 4PM\n//For 4 option contracts set account to $1,800,000 with 7% trade and option cost of $2.60 for each t\n//Forgot to remove lines and indicators\n// Initialize variables\nvar float long_entry_price = na\nvar float short_entry_price = na\nvar float stop_loss = na\nvar float take_profit = na\nvar float twoxtake_profit = na\nvar float threextake_profit = na\nvar float short_stop_loss = na\nvar float short_take_profit = na\nvar float twoxshort_take_profit = na\nvar float threexshort_take_profit = na\n//var float option_SL_P = 0.00075//approx 10% on SPY 1 DTE\n//var float option_TP_P = 0.00075//approx 10% on SPY 1 DTE\nvar long_entry_time = 0\nvar long_entry_minute = 0\nvar short_entry_time = 0\nvar short_entry_minute = 0\nvar allow_long_entry = true\nvar allow_short_entry = true\nvar allow_trades = true\nvar hourlyclose = 0\nvar notify = 0\nvar shortnotify = 0\nvar adxinput = 18\nvar entry = 0\nvar tooltipnote = \"Emtpy\"\nvar signal = \"Empty\"\nvar show = 0\nfloat upperBandValue = na\nfloat lowerBandValue = na\n// Trade pin bars reversals\nshortpinbars = input.bool(true, \"Trade 3x tail to body short pin bar reversals\")\nlongpinbars = input.bool(true, \"Trade 3x tail to body long pin bar reversals\")\n// Show 1 missing parameter by default\nD1 = input.bool(false, \"Show missing parameters for all time / Unchecked (default) will allow descriptive tooltip for last \n// Disable trading during tough times by default\nnotrade = input.bool(true, \"Trade from 10:30 until Noon EST\")\nnotradelunch = input.bool(true, \"Trade during lunchtime from noon until 1 EST\")\nnotrade1to3 = input.bool(true, \"Trade from 1 until 3 EST\") \nnotradePH = input.bool(true, \"Trade during Power Hour 3 until 4 EST\")\n// Calculate VWAP and upper and lower bands\nvwapmid = request.security(syminfo.tickerid, \"1\", ta.vwap(hlc3))\nvwap_array = array.new_float()\narray.push(vwap_array, vwapmid)\narray.push(vwap_array, vwapmid + 1)\narray.push(vwap_array, vwapmid - 1)\nstd_dev = array.stdev(vwap_array)\nupperBandValue := vwapmid + std_dev * 2\nlowerBandValue := vwapmid - std_dev * 2\nplot(vwapmid, title=\"VWAP\", color= color.aqua, linewidth = 2)\nplot(upperBandValue, title=\"Upper VWAP\", color= color.aqua, linewidth = 1)\nplot(lowerBandValue, title=\"Lower VWAP\", color= color.aqua, linewidth = 1)\n// Calculate the EMAs & SMAs\nema5 = ta.ema(close, 5)\nema13 = ta.ema(close, 13)\nsma20 = ta.sma(close, 20)\n// Input Stop Losses and Take Profits\noption_SL_P = input.float(0.00075, title = \"Stop Loss Percentage in Decimal Form\")\noption_TP_P = input.float(0.00075, title = \"Take Profit Percentage in Decimal Form\"\n//From Date\nTSTAMP = input.time(title=\"From this date. To see entire backtest range set to a year ago.\"\n// Input parameters\nfastLength = input.int(12, minval=1, title=\"MACD Fast Length\")\nslowLength = input.int(26, minval=1, title=\"MACD Slow Length\")\nsignalLength = input.int(9, minval=1, title=\"MACD Signal Smoothing\")\n// Inputs\nlength = input.int(14, \"Stochastic Length\")\nsmoothK = input.int(3, \"Stoicastic Smooth K\")\nsrc = input(close, \"Stoicastic Source\")\n//Stochastic Calculation\nhighestHigh = ta.highest(src, length)\nlowestLow = ta.lowest(src, length)\nk = 100 * ((src - lowestLow) / (highestHigh - lowestLow))\nd = ta.sma(k, smoothK)\n// Calculate the RSI\nrsiValue = ta.rsi(close, 5)\n// Calculate the signal line as the SMA of the RSI for 5 minute over 9 periods\nrsiSignal = ta.sma(rsiValue, 9)\n// Calculate MACD\n[macdLine, signalLine, _] = ta.macd(close, fastLength, slowLength, signalLength)\n// Calculate slope of MACD line\nmacdSlope = (macdLine - macdLine[3]) / (bar_index - bar_index[3])\n// Length of the ATR\natr_length = input.int(14, title=\"ATR Length\", minval=1)\n// Calculate the True Range\ntr = ta.tr(true)\n// Calculate the ATR\natr = ta.atr(atr_length)\n// Square the ATR values\natr_squared = math.pow(atr, 2)\n// Calculate the mean of the squared ATR values over a window of 20 bars\nmean_atr_squared = ta.sma(atr_squared, 20)\n// Take the square root of the mean to get the RMS\nrms_atr = math.sqrt(mean_atr_squared)\n// Length of the ADX\nlen = input.int(14, title=\"ADX Length\", minval=1)\n// Set minimum number of bars between trades\nmin_bars_between_trades = 12\n// Calculate the Directional Movement\nup = ta.change(high)\ndown = -ta.change(low)\nplusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\nminusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n// Calculate the Smoothed Directional Movement\nplusDI = 100 * ta.ema(plusDM, len) / ta.ema(tr, len)\nminusDI = 100 * ta.ema(minusDM, len) / ta.ema(tr, len)\n// Calculate the Directional Index (DX)\nDX = 100 * math.abs(plusDI - minusDI) / (plusDI + minusDI)\n// Calculate the ADX\nadx = ta.ema(DX, len)\n// Calculate 5-minute close price on a 1-minute chart\nsrc_5m = request.security(syminfo.tickerid, \"5\", close)//, lookahead=barmerge.lookahead_on)\nema_5m_20 = ta.ema(src_5m, 20)\nema_5m = ta.ema(src_5m, 13)\nema_5m_5 = ta.ema(src_5m, 5)\nplot(ema_5m, \"5 Min 13 EMA\", color= color.orange, linewidth = 2)\nplot(ema_5m_5, \"5 Min 5 EMA\", color= color.blue, linewidth = 2)\n// Get high, low, and close prices\nhighPrice = high\nlowPrice = low\nclosePrice = close\n// Get the Unix timestamp of the current bar\nunixTimestamp = time_close\n// Extract the minute value from the Unix timestamp\nminuteValue = minute(unixTimestamp)\n// Calculate the trading minute of the day\ntradingMinute = (minuteValue + (hour(unixTimestamp) - 9) * 60) - 30\n// Get the lowest low of the day\nlowOfDay = ta.lowest(low, tradingMinute)\nhighOfDay = ta.highest(high, tradingMinute)\n// Check if the current bar is after 10:30 AM\nisAfter1030 = request.security(syminfo.tickerid, \"60\", tradingMinute >= 0)\n// Get the highest high and lowest low of the last hour\nhighOfLastHour = ta.highest(high, 90)\nlowOfLastHour = ta.lowest(low, 90)\n// Plot the minute value and the low of the day on the chart \nplot(lowOfDay, \"Low of Day\",  color.fuchsia)\nplot(highOfDay, \"High of Day\",  color.fuchsia) \n // Determine buy and sell signals\nbuy_signal = (ema5 > ema13 and ema_5m > ema_5m_5 and rsiSignal < 49 and tradingMinute\n             (notrade == 1 and ema5 > ema13 and ema_5m > ema_5m_5 and rsiSignal < \n             (notradelunch == 1 and ema5 > ema13 and ema_5m > ema_5m_5 and rsiSignal\n             (notrade1to3 and ema5 > ema13 and ema_5m > ema_5m_5 and rsiSignal < 49\n             (notradePH == 1 and ema5 > ema13 and ema_5m > ema_5m_5 and rsiSignal \nshort_buy_signal = (ema5 < ema13 and ema_5m < ema_5m_5 and rsiSignal > 0 and tradingMinute\n                   (notrade == 1 and ema5 < ema13 and ema_5m < ema_5m_5 and rsiSignal\n                   (notradelunch == 1 and ema5 < ema13 and ema_5m < ema_5m_5 and rsiSignal\n                   (notrade1to3 and ema5 < ema13 and ema_5m < ema_5m_5 and rsiSignal\n                   (notradePH == 1 and ema5 < ema13 and ema_5m < ema_5m_5 and rsiSignal\n//short_buy_signal = false\n// Define long entry conditions\nC1 = ema5 > ema13 ? 1 : 0 //E below bar when only one missing\nC2 = d >= 0 ? 1 : 0 //d Smoothed Stoicastic below bar when when only one missing\n//C3 = macdLine < .5 ? 1 : 0 //M below bar when only one missing\nC4 = adx > 0 ? 1 : 0 //A below bar when only one missing\nC5 = macdSlope > 0 ? 1 : 0 //% below bar when only one missing\n//C6 = signalLine > -.2 ? 1 : 0 //S (MACD Signal) below bar when only one missing\n//C7 = rsiSignal > 30 ? 1 : 0 //R below bar when only one missing\n//C17 = math.abs(macdLine - signalLine) > 0.00 ? 1 : 0 //D MACD Difference below bar when only one m\nC18 = rms_atr < 0.75 ? 1 : 0 //T Root Mean Square of ATR below bar when only one missing\nC19 = ((ema_5m-ema_5m_5)/close >0.0005 and tradingMinute <= 60) or ((ema_5m-ema_5m_5\nC22 = close > open ? 1 : 0 //C difference below bar when only one missing\nC23 = (math.abs(close - highOfDay)/close > 0.0006 and tradingMinute <= 150) or (math.abs\nC25 = close >= lowerBandValue ? 1 : 0 //V close above lower band of VWAP below bar when \n// Define short entry conditions\nC8 = ema5 < ema13 ? 1 : 0 //E above bar when only one missing\nC9 = d >= 0 ? 1 : 0 //d Smoothed Stoicastic above bar when when only one missing\n//C10 = macdLine > -0.5 ? 1 : 0 //M above bar when only one missing\nC11 = adx > 20 ? 1 : 0 //A above bar when only one missing\nC12 = macdSlope < 0 ? 1 : 0 //% above bar when only one missing\n//C13 = signalLine < .2 ? 1 : 0 //S (MACD Signal) above bar when only one missing\n//C14 = rsiSignal < 70 ? 1 : 0 //R above bar when only one missing\n//C15 = math.abs(macdLine - signalLine) > 0.00 ? 1 : 0 //D MACD Difference above bar when only one m\nC16 = rms_atr < 0.75 ? 1 : 0 //T Root Mean Square of ATR above bar when only one missing\nC20 = ((ema_5m-ema_5m_5)/close >0.0005 and tradingMinute <= 60) or (math.abs(ema_5m\nC21 = open > close ? 1 : 0 //C difference above bar when only one missing\nC24 = (math.abs(close - lowOfDay)/close > 0.0006 and tradingMinute <= 150) or (math.abs\nC26 = close <= upperBandValue  ? 1 : 0 //V close above upper band of VWAP above bar when \n// labels for tooltips\nif (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C1) == 0 and barstate.isconfirmed\n    tooltipnote := \"1 min 13 EMA > 5 EMA (decreasing trend)\"\n    signal := \"\u2193\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C2) == 0 and barstate.isconfirmed\n    tooltipnote := \"Stoichastic > 90 (overbought may dump)\"\n    signal := \"d\"\n    show := 1\n//else if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C3) == 0 and barstate.isconfir\n//    tooltipnote := \"MACD > 0.5 (too much momentum already)\"\n//    signal := \"M\\nA\\nC\\nD\"\n//    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C4) == 0 and barstate.isconfirmed\n    tooltipnote := \"ADX < 20 (not trending)\"\n    signal := \"A\\nD\\nX\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C5) == 0 and barstate.isconfirmed\n    tooltipnote := \"MACD has downward slope (losing momentum)\"\n    signal := \"M\\n/\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C18) == 0 and \n    tooltipnote := \"ATR > 0.75 (increased volatility)\"\n    signal := \"A\\nT\\nR\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C19) == 0 and \n    tooltipnote := \"5 Min 5/13 EMA difference too close (noisy trade)\"\n    signal := \"5\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C22) == 0 and \n    tooltipnote := \"Candle closes below open (trend reversing?)\"\n    signal := \"C\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C23) == 0 and \n    tooltipnote := \"Too close to high of day (out of runway?)\"\n    signal := \"H\"\n    show := 1\nelse if (C1 + C2 + C4 + C5 + C18 + C19 + C22 + C23 + C25) == 8 and (C25) == 0 and \n    tooltipnote := \"Below VWAP 2 standard deviations (on a run!)\"\n    signal := \"V\"\n    show := 1\nif (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C8) == 0 and barstate.isconfirmed\n    tooltipnote := \"1 min 5 EMA > 13 EMA (increasing trend)\"\n    signal := \"\u2191\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C9) == 0 and\n    tooltipnote := \"Stoichastic > 0 (oversold may cause bounce)\"\n    signal := \"d\"\n    show := 2\n//else if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C10) == 0 and barstate.iscon\n//    tooltipnote := \"MACD < -0.5 (too little momentum already)\"\n//    signal := \"M\\nA\\nC\\nD\"\n//    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C11) == 0 and\n    tooltipnote := \"ADX < 20 (not trending)\"\n    signal := \"A\\nD\\nX\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C12) == 0 and\n    tooltipnote := \"MACD has upward slope (gaining momentum)\"\n    signal := \"M\\n/\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C16) == 0 and\n    tooltipnote := \"ATR > 0.75 (increased volatility)\"\n    signal := \"A\\nT\\nR\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C20) == 0 and\n    tooltipnote := \"5 Min 5/13 EMA difference too close (noisy trade)\"\n    signal := \"5\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C21) == 0 and\n    tooltipnote := \"Candle closes above open (trend reversing?)\"\n    signal := \"C\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C24) == 0 and\n    tooltipnote := \"Too close to low of day (out of runway?)\"\n    signal := \"L\"\n    show := 2\nelse if (C8 + C9 + C11 + C12 + C16 + C20 + C21 + C24 + C26) == 8 and (C26) == 0 and\n    tooltipnote := \"Above VWAP 2 standard deviations (on a run!)\"\n    signal := \"V\"\n    show := 2\nif show == 1 or show == 2\n    show := 0\nif ((buy_signal and strategy.position_size == 0 and allow_trades and allow_long_entry\n    long_entry_price := open\n    strategy.entry(\"Pivot Up\", strategy.long, alert_message = \"Pivoting Up\")\n    stop_loss := long_entry_price - (option_SL_P * open)\n    take_profit := long_entry_price + (option_TP_P * open)\n    twoxtake_profit := long_entry_price + (2 * option_TP_P * open)\n    threextake_profit := long_entry_price + (3 * option_TP_P * open)\n    long_entry_time := time\n    long_entry_minute := tradingMinute\n    allow_long_entry := false\n    allow_trades := false\n    notify := 1\n    entry := 0\nif ((high == open) and ((close - low >= 3*(open - close)) and open >= close and (high\n    long_entry_price := open\n    strategy.entry(\"Pivot Pin Bar Up\", strategy.long, alert_message = \"Pivoting Pin Bar Up\"\n    stop_loss := long_entry_price - (option_SL_P * open)\n    take_profit := long_entry_price + (option_TP_P * open)\n    twoxtake_profit := long_entry_price + (2 * option_TP_P * open)\n    threextake_profit := long_entry_price + (3 * option_TP_P * open)\n    long_entry_time := time\n    long_entry_minute := tradingMinute\n    allow_long_entry := false\n    allow_trades := false\n    notify := 1\n    entry := 0\nplot(notify == 1 ? open - (option_SL_P * open) : na, \"Stop Loss\",   color.yellow,\nplot(notify == 1 ? open + (option_TP_P * open) : na, \"Take Profit\",   color.yellow\nplot(notify == 1 ? open + 2 * (option_TP_P * open) : na, \"2x Take Profit\",   color.orange\nif notify == 1\n    notify := notify - 1\nif ((short_buy_signal and strategy.position_size == 0 and allow_trades and allow_short_entry\n    short_entry_price := open\n    strategy.entry(\"Pivot Down\", strategy.short, alert_message = \"Pivoting Down\")\n    short_stop_loss := short_entry_price + (option_SL_P * open)\n    short_take_profit := short_entry_price - (option_TP_P * open)\n    twoxshort_take_profit := short_entry_price - (2 * option_TP_P * open)\n    threexshort_take_profit := short_entry_price - (3 * option_TP_P * open)\n    short_entry_time := time\n    short_entry_minute := tradingMinute\n    allow_short_entry := false\n    allow_trades := false\n    shortnotify := 1\n    entry := 0\nif ((close == low) and (high - close >= 3*(close - open)) and open <= close and (high\n    short_entry_price := open\n    strategy.entry(\"Pivot Pin Bar Down\", strategy.short, alert_message = \"Pivoting Pin Bar Down\"\n    short_stop_loss := short_entry_price + (option_SL_P * open)\n    short_take_profit := short_entry_price - (option_TP_P * open)\n    twoxshort_take_profit := short_entry_price - (2 * option_TP_P * open)\n    threexshort_take_profit := short_entry_price - (3 * option_TP_P * open)\n    short_entry_time := time\n    short_entry_minute := tradingMinute\n    allow_short_entry := false\n    allow_trades := false\n    shortnotify := 1\n    entry := 0\nplot(shortnotify == 1 ? open + (option_SL_P * open) : na, \"Stop Loss\",   color.yellow\nplot(shortnotify == 1 ? open - (option_TP_P * open) : na, \"Take Profit\",   color.yellow\nplot(shortnotify == 1 ? open - 2 * (option_TP_P * open) : na, \"2x Take Profit\",   \nif shortnotify == 1 and barstate.isconfirmed\n    shortnotify := shortnotify - 1\nif strategy.position_size > 0 and barstate.isconfirmed\n    if close < stop_loss and barstate.isconfirmed\n        strategy.close(\"Pivot Up\", \"Exit Longs Stopped\", alert_message = \"Exit Longs Stopped\"\n        strategy.close(\"Pivot Pin Bar Up\", \"Exit Longs Stopped\", alert_message = \"Exit Longs Stopped\"\n    else if close >= twoxtake_profit and (adx <=25 or close < close[3]) and barstate.isconfirmed\n        if entry == 1 and barstate.isconfirmed\n            take_profit := threextake_profit\n        if entry == 0 and barstate.isconfirmed\n            entry := 1\n            stop_loss := take_profit\n            strategy.exit(\"Exit Longs\", \"Pivot Up\", stop=stop_loss, limit = take_profit\n            strategy.exit(\"Exit Longs\", \"Pivot Pin Bar Up\", stop=stop_loss, limit \n    else if src_5m < ema_5m and tradingMinute - long_entry_minute > 3 and (adx <=25\n        strategy.exit(\"Exit Longs 5 Min EMA Cross\", \"Pivot Up\", stop=stop_loss, limit\n        strategy.exit(\"Exit Longs 5 Min EMA Cross\", \"Pivot Pin Bar Up\", stop=stop_loss\nelse if strategy.position_size < 0 and barstate.isconfirmed\n    if close > short_stop_loss and barstate.isconfirmed\n        strategy.close(\"Pivot Down\", \"Exit Shorts Stopped\", alert_message = \"Exit Shorts Stopped\"\n        strategy.close(\"Pivot Pin Bar Down\", \"Exit Shorts Stopped\", alert_message \n    else if close <= twoxshort_take_profit and (adx <= 25 or close > close[3]) and\n        if entry == 1 and barstate.isconfirmed\n            take_profit := threexshort_take_profit\n        if entry == 0 and barstate.isconfirmed\n            entry := 1\n            stop_loss := short_take_profit\n            strategy.exit(\"Exit Shorts\", \"Pivot Down\", stop=short_stop_loss, limit\n            strategy.exit(\"Exit Shorts\", \"Pivot Pin Bar Down\", stop=short_stop_loss\n    else if src_5m > ema_5m and tradingMinute - short_entry_minute > 3 and (adx <=\n        strategy.exit(\"Exit Shorts 5 Min EMA Cross\", \"Pivot Down\", stop=short_stop_loss\n        strategy.exit(\"Exit Shorts 5 Min EMA Cross\", \"Pivot Pin Bar Down\", stop=short_stop_loss\n// Reset allow_trades after cool-down period of min_bars_between_trades bars set above\nif time > long_entry_time + (time - time[1]) * min_bars_between_trades and barstate.isconfirmed\n    allow_long_entry := true\n    allow_trades := true\nif time > short_entry_time + (time - time[1]) * min_bars_between_trades and barstate.isconfirmed\n    allow_short_entry := true\n    allow_trades := true\nif hour == 15 and minute >= 55 and barstate.isconfirmed// Last five minutes of trading day\n    allow_trades := false\nif hour == 9 and minute <= 35 and barstate.isconfirmed// First five minutes of trading day\n    allow_trades := false\n// Close all positions at the end of trading day\nif ((hour == 15 and minute == 57)) and strategy.position_size != 0  and barstate.isconfirmed\n    strategy.close(\"Pivot Up\", alert_message = \"Market Closing\")\n    strategy.close(\"Pivot Down\", alert_message = \"Market Closing\")\n    strategy.close(\"Pivot Pin Bar Up\", alert_message = \"Market Closing\")\n    strategy.close(\"Pivot Pin Bar Down\", alert_message = \"Market Closing\")\n    hourlyclose := 1\n//plotshape(hourlyclose == 1 ? 1 : na, \"Suggested Volatile Hour Close\", text=\"Close positions prior \nif hourlyclose == 1 and barstate.isconfirmed\n    hourlyclose := 0"}]}
{"messages": [{"role": "user", "content": "The Bollinger Bands are among the most famous and widely used indicators. A Bollinger Band is a technical analysis tool defined by a set of trendlines plotted two standard deviations (positively and negatively) away from a simple moving average ( SMA ) of a security's price, but which can be adjusted to user preferences. They can suggest when an asset is oversold or overbought in the short term, thus providing the best time for buying and selling it. The relative strength index ( RSI ) is a momentum indicator used in technical analysis. RSI measures the speed and magnitude of a security's recent price changes to evaluate overvalued or undervalued conditions in the price of that security. The RSI can do more than point to overbought and oversold securities. It can also indicate securities primed for a trend reversal or corrective pullback in price. It can signal when to buy and sell. Traditionally, an RSI reading of 70 or above indicates an overbought situation. A reading of 30 or below indicates an oversold condition. The short order is placed on assets that present strong momentum when it's more likely that it is about to reverse. The rule strategy places and closes the order when the following conditions are met: ENTRY The closing price is greater than the upper standard deviation of the Bollinger Bands  The RSI is less than 70. EXIT The trade is closed when the RSI is less than 70  The lower standard deviation of the Bollinger Band is less than the closing price. This strategy was backtested from the beginning of 2022 to capture how this strategy would perform in a bear market. The strategy assumes each order to trade 70% of the available capital to make the results more realistic. A trading fee of 0.1% is taken into account. The fee is aligned to the base fee applied on Binance, which is the largest cryptocurrency exchange by volume."}, {"role": "assistant", "content": "//@version=5\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Coinrule\nstrategy(\"Bollinger Band Below Price with RSI\",\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=70,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 1, 1, 0, 0)\nnotInTrade = strategy.position_size <= 0\n//Bollinger Bands Indicator\nlength = input.int(20, minval=1)\nsrc = input(close, title=\"Source\")\nmult = input.float(2.0, minval=0.001, maxval=50, title=\"StdDev\")\nbasis = ta.sma(src, length)\ndev = mult * ta.stdev(src, length)\nupper = basis + dev\nlower = basis - dev\noffset = input.int(0, \"Offset\", minval = -500, maxval = 500)\nplot(basis, \"Basis\", color= #FF6D00, offset = offset)\np1 = plot(upper, \"Upper\", color= #2962FF, offset = offset)\np2 = plot(lower, \"Lower\", color= #2962FF, offset = offset)\nfill(p1, p2, title = \"Background\", color= color.rgb(33, 150, 243, 95))\n// RSI inputs and calculations\nlengthRSI = 14\nRSI = ta.rsi(close, lengthRSI)\n// Configure trail stop level with input options\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\n// Determine trail stop loss prices\n//longStopPrice = 0.0\nshortStopPrice = 0.0\n//longStopPrice := if strategy.position_size > 0\n    //stopValue = close * (1 - longTrailPerc)\n    //math.max(stopValue, longStopPrice[1])\n//else\n    //0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\n//Entry and Exit\nstrategy.entry(id=\"short\", direction=strategy.short, when=ta.crossover(close, upper\nif (ta.crossover(upper, close) and RSI > 70 and timePeriod)\n    strategy.exit(id='close', limit = shortStopPrice)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    It was a bit of a headache, but I think I found a more elegant way to calculate the exponential DCA layers. The base number is calculated based on the max amount of DCA layers and the range between the entry price and 0. With this method the DCA layers never will be negative. The more layers you set the more the exponential layers get squeezed between the range limit of the entry price and 0.  I also added the option to switch to a linear calculation of the DCA layers. Enjoy!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at \n// \u00a9 A3Sh\n//@version=5\n// Study of a Simple RSI based, PA (priceaveraging) and DCA strategy that opens a new position every\n// The first entry is opened when the specified rsi and moving average conditions are met. \n// The following DCA levels are calculated exponentially and set, starting with a specified % of pri\n// The disctance between the dca levels can be changed with the exponential scale.\n// Each position closes individually when it reaches a specified take profit.\n// The position can re-open again when it hits the price level again.\n// Each time a position is closed and reopened, the average price drops a little.\n// The position stays open until the first entry closes or when the price reaches the Stop level.\n// When the price reaches the Stop level, all positions will close at once.\n// The RSI and MA code for opening the entry is adapted from the Optimized RSI Buy the Dips strategy\n// This code is used for study purposes, but any other low/ dip finding indicator can be used.\n// https://www.tradingview.com/script/Pm1WAtyI-Optimized-RSI-Strategy-Buy-The-Dips-by-Coinrule/\n// Dynamic DCA layers are inspired by the Backtesting 3commas DCA Bot v2, by rouxam\n// This logic gives more flexibility because you can dyanically change the amount of dca entries.\n// https://www.tradingview.com/script/8d6Auyst-Backtesting-3commas-DCA-Bot-v2/\n// The use of for loops to (re)open and close different entries separately is based on the Simple_Py\n// https://www.tradingview.com/script/t6cNLqDN-Simple-Pyramiding/\nstrategy('Simple_RSI+PA+DCA', overlay=true, pyramiding=99, initial_capital=500, calc_on_order_fills\n// Backtest Window //\nstart_time   = input.time(defval=timestamp(\"01 April 2021 20:00\"), group = \"Backtest Window\"\nend_time     = input.time(defval=timestamp(\"01 Aug 2030 20:00\"),   group = \"Backtest Window\"\nwindow() => time >= start_time and time <= end_time\n// Inputs //\ntakeProfit      = input.float  (3,           group = 'Risk',           title = 'Take Profit %'\ntakeProfitAll   = input.float  (6,           group = \"Risk\",           title = 'Close All %'\nlinear_mode     = input.bool   (false,       group = 'DCA Settings',   title = 'Switch to linear DCA Layers'\nposCount        = input.int    (8,           group = 'DCA Settings',   title = 'Max Amount of DCA Layers'\nincrement       = input.float  (2,           group = 'DCA Settings',   title = 'Base % to calculate DCA layers'\nbar_lookback    = input.int    (4999,        group = 'DCA Settings',   title = 'Lines Bar Lookback'\nplotMA          = input.bool   (false,       group = 'Moving Average', title = 'Plot Moving Average'\nmoving_average  = input.int    (100,         group = 'Moving Average', title = 'MA Length'\nrsiLengthInput  = input.int    (14,          group = 'RSI Settings',   title = \"RSI Length\"\nrsiSourceInput  = input.source (close,       group = 'RSI Settings',   title = 'Source'\noverSold        = input.int    (29,          group = 'RSI Settings',   title = 'Oversold, Trigger to Enter First Position'\n// variables //\nvar open_position    = true   // true when there are open positions\nvar entry_price      = 0.0    // the entry price of the first entry\nvar dca_price        = 0.0    // the price of the different dca layers\nvar int count        = 0      // bar counter since first open position\nvar int max_bar      = 0      // max bar buffer variable for DCA lines, stop lines, average price\nvar line dca_line    = na     // lines variable for creating dca lines\n// arrays //\nlinesArray = array.new_float(posCount,na)  // array to store different dca price levels for c\n// Create max bar buffer for DCA lines, Stop and average price lines ///\nmax_bar := count >= bar_lookback ? bar_lookback : count\n// Order size based on first entry and amount of DCA layers\nq = (strategy.equity  / posCount + 1) / open\n// Calculate Moving Averages\nmovingaverage_signal = ta.sma(close ,moving_average)\nplot (plotMA ? movingaverage_signal : na, color =  color.new(#f5ff35, 0))\n// RSI calculations //\nup   = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)\ndown = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)\nrsi  = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\n// Buy Signal (co)\nco = ta.crossover(rsi, overSold) and close < movingaverage_signal\n// Create a white line for average price, since the last opened position //\naverage_price = line.new(x1 = bar_index - max_bar, y1 = strategy.position_avg_price\n    // Stop //\n// Create a red Stop level line based on a specified % above the average price //\nstop_level = strategy.position_avg_price + (strategy.position_avg_price / 100 * takeProfitAll\nstop_line  = line.new(x1 = bar_index - max_bar, y1 = stop_level, x2 = bar_index, y2\n    // Take profit definition per open position //\ntake_profit_price = close * takeProfit / 100 / syminfo.mintick\n// Make sure the Stop level and average price level don't excied the bar buffer to avoid errors //\nif count <= bar_lookback\n    line.set_x1(stop_line,     strategy.opentrades.entry_bar_index(strategy.opentrades\n    line.set_x1(average_price, strategy.opentrades.entry_bar_index(strategy.opentrades\n// Exponential DCA Layer Calculation fucntion --> New caclulation, the base number is calculated bas\ndca_exponent_level(index) =>\n    base_number = math.pow(entry_price, (1 / posCount))\n    dca_level_calc = (entry_price - (math.pow(base_number,index))) * (1 - ((math.pow\n// Linear DCA Layer Calculation // Added option to switch\ndca_linear_level(index) =>   \n   entry_price - ((entry_price / posCount) * index)\n// Set  Entries //\n// Open the first entry and set the entry price //\nif co and strategy.position_size == 0 and window() \n    open_position := true\n    entry_price   := close\n    strategy.entry(id = 'FE1', direction = strategy.long, qty = q)  \n    first_entry_line = line.new(x1 = bar_index - max_bar, y1 = entry_price, x2 = bar_index\n// Start bar counting since the position is open //\nif open_position == true\n    count := count + 1\n// Set the DCA entries //\n// Prices below 1 are not set to avoid negative prices //\nif strategy.position_size > 0 and window()\n    for i = 0 to strategy.opentrades\n        dca_level_mode = linear_mode ? dca_linear_level(i) : dca_exponent_level(i)\n        if strategy.opentrades == i and i < posCount\n            dca_price := dca_level_mode\n            entry_id = 'DCA' + str.tostring(i + 1) \n            strategy.entry(id = entry_id, direction = strategy.long, limit = dca_price\n// Store the values of the different dca price levels in an array and create the dca lines // \n// Prices below 1 are not stored//\nif open_position==true and window() \n    for i = 1 to posCount -1\n        dca_level_mode = linear_mode ? dca_linear_level(i) : dca_exponent_level(i)\n        array.push(linesArray, dca_level_mode) \n        for i = 1 to array.size(linesArray) - 1\n        dca_line := line.new(x1 = bar_index - max_bar, y1 = array.get(linesArray, \n// Create thick line to show the last Entry price //\nlast_entry_price = line.new(x1 = bar_index[5], y1 = strategy.opentrades.entry_price\n// Exit the first entry when the take profit triggered //   \nif strategy.opentrades > 0 and window() \n    strategy.exit(id = 'Exit FE', from_entry = 'FE1', profit = take_profit_price)\n// Exit DCA entries when take profit is triggered //\nif strategy.opentrades > 0 and window() \n    for i = 1 to strategy.opentrades \n        exit_from = 'DCA' + str.tostring(i + 1)\n        exit_id = 'Exit_' + str.tostring(i + 1)\n        strategy.exit(id = exit_id, from_entry = exit_from, profit = take_profit_price\n// Close all positions at once when Stop is crossed //\nif strategy.opentrades > 0 and ta.crossover(close,stop_level) and window() \n    strategy.close_all()\n// Make sure nothing is open after alle positions are closed and set the condiftion back to be open \nif strategy.position_size[1] > 0 and strategy.position_size == 0\n    strategy.cancel_all()\n    strategy.close_all()\n    line.delete(average_price)\n    line.delete(stop_line)\n    line.delete(dca_line)\n    open_position := false   // All position are closed, so back to false\n    count := 0               // Reset bar counter"}]}
{"messages": [{"role": "user", "content": "Inspired by Linda Bradford Raschke. Entry criteria: This strategy is used to capture momentum effects on the daily periodicities. Once prices have had a run of 8 or more consecutive closes above or below the 5-period simple moving average the strategy is primed to trade.  It will then enter a short on the first close above the 5sma after a run of 8 or more closes below the 5sma (it will enter a long when the price closes below the 5sma after a run of  8 or more closes above the 5sma).  Exit criteria: All trades are exited on the first close back above/ below the 5sma."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Marcuscor\n//@version=5\n// Inpsired by Linda Bradford Raschke: a strategy for trading momentum in futures markets\nstrategy(\"8D Run\", initial_capital = 50000, commission_value = 0.0004) \nSMA = ta.sma(close,5)\nTrendUp = close >= SMA\nTrendDown = close <= SMA\n//logic to long\nTriggerBuy = ta.barssince(close < SMA) >= 8\nBuy = TriggerBuy[1] and TrendDown \nstrategy.entry(\"EL\", strategy.long, when = Buy)\nstrategy.close(id = \"EL\", when = close > SMA)\n// 1) color background when \"run\" begins and 2) change color when buy signal occurs\nbgcolor(TriggerBuy?  color.green : na, transp = 90)\nbgcolor(Buy ?  color.green : na, transp = 70)\n// logic to short \nTriggerSell = ta.barssince(close > SMA) >= 8\nSell = TriggerSell[1] and TrendUp\nstrategy.entry(\"ES\", strategy.short, when = Sell)\nstrategy.close(id = \"ES\", when = close < SMA)\n// 1) color background when \"run\" begins and 2) change color when sell signal occurs\nbgcolor(TriggerSell ?  color.red : na, transp = 90)\nbgcolor(Sell ?  color.red : na, transp = 70)"}]}
{"messages": [{"role": "user", "content": "I will start with the context, and some things to think about when using a strategy tool to back-test ideas. CONTEXT FIRST: This is derived from other people's work, but I honestly hadn't found a mixed indicator MA strategy tool that does what this now does.  If it is out there, apologies!! This tool can help back-test various MA trends (SMA, EMA, HMA, VWMA); as well as factoring in RSI levels (or not); and can factor in a fixed HTF MA (or not). You can apply a 'retest entry' or a 'breakout entry', and you can also apply various risk mgt for SL/TP orders: 1) No SL/TP; or 2) a fixed %, or 3) dynamic ATR multipliers. Find below, some details explaining what this tool is attempting to do.  Thank you, tack, salute! THINGS TO REVIEW (it is not just about 'profitability'!!) Whilst discretion is always highly encouraged as a trader, and a 100% indicator-driven strategy is VERY unlikely to yield sustainable results going forward, at the very least back-testing your strategies can help provide some guidance, not just on win rate Vs profit factor, but other things including:  a) Trade frequency: if a strategy has an 75% win rate and profit factor of 4, with all your parameters and confluence checks, but only triggers 3 trades every 5 years, is that realistically implementable to your trading situation if you have a $10,000 account?   b) Trade entry type: is it consistently better to wait for a retest of an 'MA zone', or is it better to market buy/sell on breakout of the 'MA zone'? c) Risk management (SL/TP): is it consistently better to have a fixed static % for SL/TP (\"I always place my stops 2% away, whether it is EURUSD or BTCUSDT\"), or would you be better placed to try using an ATR multiplier of the respective assets? d) Moving average type: is your old faithful 100 EMA really serving you well, or is the classic SMA more reliable, or how about the HMA, or the VWMA? Is the 100/200 cross holding up, or do you need something more sensitive? Is there any significant difference between a 10 EMA/20 EMA trend zone compared to a 13 EMA /25 EMA zone? e) Confluence: Do added confluence checks (RSI, higher timeframe MA) actually improve profitability? But even if they do, is at the cost of cutting too many trades?  INPUTS AND PARAMETERS Choice 1) Entry Strategy: Retest or Breakout - You can select both! []: a) RETEST entry strat: price crosses UNDER FastMA INTO the 'MA trend zone'.  b) BREAKOUT entry strat: price crosses OVER FastMA OUT the 'MA trend zone'.  Choice 2) Risk Management (SL and TP) - You can select more than 1 strategy! a) No SL/TP: Long trades are closed when the LOW crosses back UNDER the fastMA again, and shorts are closed when the HIGH crosses back OVER the fastMA again.                                       b) Static % SL/TP: Your SL/TP will be a fixed % away from avg. position price... WARNING: You should change this for various asset classes; FX vol is not the same as crypto altcoin vol!  c) Dynamic ATR SL/TP:  Your SL/TP is a multiple of your selected ATR range (default is 50, see 'info' when you select ATR range). ATR accounts for the change in vol of different asset classes somewhat, HOWEVER... you should probably still not have the same multiplier trading S&P500 as you would trading crypto altcoins! Then select your preferred parameters: EMA, SMA, HMA, VWMA, etc. You can mix and match, and most options have a info/tooltip guide. RSI note: If you don't care for RSI levels, then set buy signal at 1... i.e always buys! Similarly set sell signal at 99. ATR note: standard ATR length is usually 14, however... your SL/TP will move POST entry, and can tighten or widen your initial SL/TP... for better AND usually for worse! Go find a trade (strat 3) on the chart, look at the SL/TP lines, now change the number to 5, you'll see. Fixed HTF MA note: If you don't care for HTF MA confluence, just change the timeframe/options to match the 'Slow MA' options you've chosen."}, {"role": "assistant", "content": "//@version=5\n// *** USE AT YOUR OWN RISK ***\n// FIRST: This is MASSIVELY derived from other people's work... \n// I honestly hadn't found a mixed indicator MA strategy tool that does what this now does.  If it i\n// This tool can help backtest various MA trends; can factor in RSI levels (or not); and can factor \n// You can apply a 'retest entry' or a 'breakout entry', and you can apply various risk mgt for SL/T\n// 1) No SL/TP or 2) a fixed %, or 3) dynamic ATR multipliers.\n// For those of us who love indicators & analysis, and make no money... and LOVE every day of it :)\n// Thank you, tack, salute!\nstrategy('Negroni MA & RSI Strategy', shorttitle='Negroni MA & RSI Strategy', overlay\n// === Inputs ===\n//\n// Retest or Breakout Strategy\ns1 = input(true, title='Retest Entry strategy', group=\"Trade entry strategy\", tooltip\ns2 = input(false, title='Breakout Entry strategy', group=\"Trade entry strategy\", tooltip\n// Stop-loss and Take-profit Inputs\nv1 = input(false, title='Strat 1) No SL/TP', group=\"Risk Mgt strategy\", tooltip = \nv2 = input(false, title='Strat 2) Static % SL/TP', group=\"Risk Mgt strategy\", tooltip\nv3 = input(true, title='Strat 3) Dynamic ATR SL/TP', group=\"Risk Mgt strategy\", tooltip\nv2stoploss_input = input.float(2.5, title='2) Fixed Stop Loss %', minval=0.01, tooltip\nv2takeprofit_input = input.float(3.0, title='2) Fixed Take Profit %', minval=0.01,\natrLength=input.int(defval=50, title= '3) ATR Length', minval=1, tooltip = \"Standard ATR length is usually 14, however... you\nv3stoploss_input = input.float(defval=2.0, title= '3) ATR SL Multiplier', minval=1\nv3takeprofit_input = input.float(defval=2.5, title= '3) ATR TP Multiplier', minval\nlongv2stoploss_level = strategy.position_avg_price * (1 - v2stoploss_input)\nlongv2takeprofit_level = strategy.position_avg_price * (1 + v2takeprofit_input)\nshortv2stoploss_level = strategy.position_avg_price * (1 + v2stoploss_input)\nshortv2takeprofit_level = strategy.position_avg_price * (1 - v2takeprofit_input)\nlongv3stoploss_level = strategy.position_avg_price - (v3stoploss_input*(ta.atr(atrLength\nlongv3takeprofit_level = strategy.position_avg_price + (v3takeprofit_input*(ta.atr\nshortv3stoploss_level = strategy.position_avg_price + (v3stoploss_input*(ta.atr(atrLength\nshortv3takeprofit_level = strategy.position_avg_price - (v3takeprofit_input*(ta.atr\n// Plots both long and short SL and TP lines (I wasn't good enough to make this only plot the SL/TP \nplot(v2 and v2stoploss_input and longv2stoploss_level ? longv2stoploss_level : na,\nplot(v2 and v2takeprofit_input ? longv2takeprofit_level : na, title = 'Strat 2) long TP'\nplot(v2 and v2stoploss_input and shortv2stoploss_level ? shortv2stoploss_level : na\nplot(v2 and v2takeprofit_input ? shortv2takeprofit_level : na, title = 'Strat 2) short TP'\nplot(v3 and v3stoploss_input and longv3stoploss_level ? longv3stoploss_level : na,\nplot(v3 and v3takeprofit_input ? longv3takeprofit_level : na, title = 'Strat 3) long TP'\nplot(v3 and v3stoploss_input and shortv3stoploss_level ? shortv3stoploss_level : na\nplot(v3 and v3takeprofit_input ? shortv3takeprofit_level : na, title = 'Strat 3) short TP'\n// RSI\nrsiLength = input.int(defval=14, title = 'RSI length', minval = 1, group=\"RSI options\"\nrsiBuyLevel = input.int(defval=55, title = 'RSI Buy signal', minval = 1, group=\"RSI options\"\nrsiSellLevel = input.int(defval=45, title = 'RSI Sell signal', minval = 1, group=\"RSI options\"\nsrc = close\nup = ta.rma(math.max(ta.change(src), 0), rsiLength)\ndown = ta.rma(-math.min(ta.change(src), 0), rsiLength)\nrsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)\n///// Moving average types and variables ////////\n// Fast MA\nfastMAtype = input.string(title='Fast MA Type', defval='EMA', options=['EMA', 'SMA'\nmaFastSource = input(defval=close, title='Fast MA Source', group=\"Fast MA options\"\nmaFastLength = input.int(defval=13, title='Fast MA Period', minval=1, group=\"Fast MA options\"\nfastMA = fastMAtype == 'EMA' ? ta.ema(maFastSource, maFastLength) : fastMAtype == \n// Trend MA\ntrendMAtype = input.string(title='Trend MA Type', defval='EMA', options=['EMA', 'SMA'\nmaTrendSource = input(defval=close, title='Trend MA Source', group=\"Trend MA options\"\nmaTrendLength = input.int(defval=32, title='Trend MA Period', minval=1, group=\"Trend MA options\"\ntrendMA = trendMAtype == 'EMA' ? ta.ema(maTrendSource, maTrendLength) : trendMAtype\n// Slow MA\nslowMAtype = input.string(title='Slow MA Type', defval='EMA', options=['EMA', 'SMA'\nmaSlowSource = input(defval=close, title='Slow MA Source', group=\"Slow MA options\"\nmaSlowLength = input.int(defval=64, title='Slow MA Period', minval=1, group=\"Slow MA options\"\nslowMA = slowMAtype == 'EMA' ? ta.ema(maSlowSource, maSlowLength) : slowMAtype == \n// Plot MAs and colour-fills inbetween the fastMA & trendMA to make pretty clouds... \n// (if you aren't making art whilst trading, then why even bother!)\nfastMAline = plot(fastMA, title='Fast MA', color= color.new(#b9cbef, 60))\ntrendMAline = plot(trendMA, title='Trend MA', color= color.new(#4b21f3, 50), style\nslowMAline = plot(slowMA, title='Slow MA', color= color.new(#3b3eff, 30))\nfill(fastMAline, trendMAline, color=fastMA > trendMA ?  color.rgb(232, 234, 163, \n// Fixed 100 MA (e.g. if you are on the 4H, then this will show the 1D 100MA)\nfixedMA1type = input.string(title='Fixed MA Type', defval='EMA', options=['EMA', 'SMA'\nema1FixSource = input(defval=close, title='Fixed EMA Source', group=\"Fixed HTF MA 1 options\"\nema1FixLength = input.int(defval=100, title='Fixed EMA Period', minval=1, group=\"Fixed HTF MA 1 options\"\nema1Res   = input.timeframe(title=\"Fixed EMA Timeframe\", defval=\"D\", group=\"Fixed HTF MA 1 options\"\nema1col     = input.bool(title=\"Fixed HTF EMA bull/bear colouring\", defval=true, group\nema1smooth  = input.bool(title=\"Smoothed?\", defval=false, group=\"Fixed HTF MA 1 options\"\nfixedMA1 = fixedMA1type == 'EMA' ? ta.ema(ema1FixSource, ema1FixLength) : fixedMA1type\nema1Step = request.security(syminfo.tickerid, ema1Res, fixedMA1[barstate.isrealtime\nema1Smooth = request.security(syminfo.tickerid, ema1Res, fixedMA1[barstate.isrealtime\nplot(ema1smooth ? ema1Smooth : ema1Step, color=ema1col ? (close > ema1Step ?  color.rgb\n// Fixed 200 MA (e.g. if you are on the 4H, then this will show the 1D 200MA)\nfixedMA2type = input.string(title='Fixed MA Type', defval='EMA', options=['EMA', 'SMA'\nema2FixSource = input(defval=close, title='Fixed EMA Source', group=\"Fixed HTF MA 2 options\"\nema2FixLength = input.int(defval=200, title='Fixed EMA Period', minval=1, group=\"Fixed HTF MA 2 options\"\nema2Res   = input.timeframe(title=\"Fixed EMA Timeframe\", defval=\"D\", group=\"Fixed HTF MA 2 options\"\nema2col     = input.bool(title=\"Fixed HTF EMA bull/bear colouring\", defval=true, group\nema2smooth  = input.bool(title=\"Smoothed?\", defval=false, group=\"Fixed HTF MA 2 options\"\nfixedMA2 = fixedMA2type == 'EMA' ? ta.ema(ema2FixSource, ema2FixLength) : fixedMA2type\nema2Step = request.security(syminfo.tickerid, ema2Res, fixedMA2[barstate.isrealtime\nema2Smooth = request.security(syminfo.tickerid, ema2Res, fixedMA2[barstate.isrealtime\nplot(ema2smooth ? ema2Smooth : ema2Step, color=ema2col ? (close > ema2Step ?  color.rgb\n////////////////////////////////////////////////\n// ========== TRADE ENTRY PARAMETERS ============\n// v1 Retest Strategy Parameters \nBBLongTrigger1 = ta.crossunder(close, fastMA)\nBBShortTrigger1 = ta.crossover(close, fastMA)\nBBcloseLongTrigger1 = ta.crossunder(low, fastMA)\nBBcloseShortTrigger1 = ta.crossover(high, fastMA)\nMABuyGuard1 = fastMA > trendMA and trendMA > slowMA\nMASellGuard1 = fastMA < trendMA and trendMA < slowMA\nlongFixedMAGuard1 = close > ema1Step\nshortFixedMAGuard1 = close < ema1Step\nrsiBuyGuard1 = rsi > rsiBuyLevel\nrsiSellGuard1 = rsi < rsiSellLevel\n// v1 Breakout Strategy Parameters\nbrBBLongTrigger1 = ta.crossover(close, fastMA)\nbrBBShortTrigger1 = ta.crossunder(close, fastMA)\n// v2 Retest Strategy Parameters\nBBLongTrigger2 = ta.crossunder(close, fastMA)\nBBShortTrigger2 = ta.crossover(close, fastMA)\nBBcloseLongTrigger2 = ta.crossunder(low, fastMA)\nBBcloseShortTrigger2 = ta.crossover(high, fastMA)\nMABuyGuard2 = trendMA > slowMA and trendMA > slowMA\nMASellGuard2 = trendMA < slowMA and trendMA < slowMA\nlongFixedMAGuard2 = close > ema1Step\nshortFixedMAGuard2 = close < ema1Step\nrsiBuyGuard2 = rsi > rsiBuyLevel\nrsiSellGuard2 = rsi < rsiSellLevel\n// v2 Breakout Strategy Parameters\nbrBBLongTrigger2 = ta.crossover(close, fastMA)\nbrBBShortTrigger2 = ta.crossunder(close, fastMA)\n// v3 Retest Strategy Parameters\nBBLongTrigger3 = ta.crossunder(close, fastMA)\nBBShortTrigger3 = ta.crossover(close, fastMA)\nBBcloseLongTrigger3 = ta.crossunder(low, fastMA)\nBBcloseShortTrigger3 = ta.crossover(high, fastMA)\nMABuyGuard3 = trendMA > slowMA and trendMA > slowMA\nMASellGuard3 = trendMA < slowMA and trendMA < slowMA\nlongFixedMAGuard3 = close > ema1Step\nshortFixedMAGuard3 = close < ema1Step\nrsiBuyGuard3 = rsi > rsiBuyLevel\nrsiSellGuard3 = rsi < rsiSellLevel\n// v3 Breakout Strategy Parameters\nbrBBLongTrigger3 = ta.crossover(close, fastMA)\nbrBBShortTrigger3 = ta.crossunder(close, fastMA)\n////////////////////////////////////////////////\n// ====== TRADE ENTRY TRIGGERS ======\n// v1 Retest Signals\nLong_1 = BBLongTrigger1 and MABuyGuard1 and rsiBuyGuard1 and longFixedMAGuard1\ncloseLong_1 = BBcloseLongTrigger1\nShort_1 = BBShortTrigger1 and MASellGuard1 and rsiSellGuard1 and shortFixedMAGuard1\ncloseShort_1 = BBcloseShortTrigger1 \nif s1 == true and v1 == true\n    strategy.entry(\"Strat 1 'Retest' Long\", strategy.long, when = Long_1, alert_message\n    strategy.close(\"Strat 1 'Retest' Long\", when = closeLong_1, alert_message = \"Strat 1 'Retest' - Close Signal!\"\n    strategy.entry(\"Strat 1 'Retest' Short\", strategy.short, when = Short_1, alert_message\n    strategy.close(\"Strat 1 'Retest' Short\", when = closeShort_1, alert_message = \n// v1 Breakout Signals\nbrLong_1 = brBBLongTrigger1 and MABuyGuard1 and rsiBuyGuard1 and longFixedMAGuard1\nbrcloseLong_1 = BBcloseLongTrigger1\nbrShort_1 = brBBShortTrigger1 and MASellGuard1 and rsiSellGuard1 and shortFixedMAGuard1\nbrcloseShort_1 = BBcloseShortTrigger1 \nif s2 == true and v1 == true\n    strategy.entry(\"Strat 1 'Breakout' Long\", strategy.long, when = brLong_1, alert_message\n    strategy.close(\"Strat 1 'Breakout' Long\", when = closeLong_1, alert_message = \n    strategy.entry(\"Strat 1 'Breakout' Short\", strategy.short, when = brShort_1, alert_message\n    strategy.close(\"Strat 1 'Breakout' Short\", when = closeShort_1, alert_message \n// v2 Retest Signals\nLong_2 = BBLongTrigger2 and MABuyGuard2 and rsiBuyGuard2 and longFixedMAGuard2\nShort_2 = BBShortTrigger2 and MASellGuard2 and rsiSellGuard2 and shortFixedMAGuard2\nif s1 == true and v2 == true\n    strategy.entry(\"Strat 2 Retest Long\", strategy.long, when = Long_2, alert_message\n    strategy.exit(\"SL/TP Strat 2 Retest long\", \"Strat 2 Retest Long\", stop = longv2stoploss_level\n    strategy.entry(\"Strat 2 Retest Short\", strategy.short, when = Short_2, alert_message\n    strategy.exit(\"SL/TP Strat 2 Retest short\", \"Strat 2 Retest Short\", stop = shortv2stoploss_level\n// v2 Breakout Signals\nbrLong_2 = brBBLongTrigger2 and MABuyGuard2 and rsiBuyGuard2 and longFixedMAGuard2\nbrShort_2 = brBBShortTrigger2 and MASellGuard2 and rsiSellGuard2 and shortFixedMAGuard2\nif s2 == true and v2 == true\n    strategy.entry(\"Strat 2 Breakout Long\", strategy.long, when = brLong_2, alert_message\n    strategy.exit(\"SL/TP Strat 2 Breakout long\", \"Strat 2 Breakout Long\", stop = longv2stoploss_level\n    strategy.entry(\"Strat 2 Breakout Short\", strategy.short, when = brShort_2, alert_message\n    strategy.exit(\"SL/TP Strat 2 Breakout short\", \"Strat 2 Breakout Short\", stop =\n// v3 Retest Signals\nLong_3 = BBLongTrigger3 and MABuyGuard3 and rsiBuyGuard3 and longFixedMAGuard3\nShort_3 = BBShortTrigger3 and MASellGuard3 and rsiSellGuard3 and shortFixedMAGuard3\nif s1 == true and v3 == true\n    strategy.entry(\"Strat 3 Retest Long\", strategy.long, when = Long_3, alert_message\n    strategy.exit(\"SL/TP Strat 3 Retest long\", \"Strat 3 Retest Long\", stop = longv3stoploss_level\n    strategy.entry(\"Strat 3 Retest Short\", strategy.short, when = Short_3, alert_message\n    strategy.exit(\"SL/TP Strat 3 Retest short\", \"Strat 3 Retest Short\", stop = shortv3stoploss_level\n// v3 Breakout Signals\nbrLong_3 = brBBLongTrigger3 and MABuyGuard3 and rsiBuyGuard3 and longFixedMAGuard3\nbrShort_3 = brBBShortTrigger3 and MASellGuard3 and rsiSellGuard3 and shortFixedMAGuard3\nif s2 == true and v3 == true\n    strategy.entry(\"Strat 3 Breakout Long\", strategy.long, when = brLong_3, alert_message\n    strategy.exit(\"SL/TP Strat 3 Breakout long\", \"Strat 3 Breakout Long\", stop = longv3stoploss_level\n    strategy.entry(\"Strat 3 Breakout Short\", strategy.short, when = brShort_3, alert_message\n    strategy.exit(\"SL/TP Strat 3 Breakout short\", \"Strat 3 Breakout Short\", stop =\n////////////////////////////////////////////////"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    There are some coding upgrades on the script. Feel free to use it, thank you in advance guys.                                                    Release Notes:                                                    In oder to increase the profit % the ema filter was added in strategy, if you have any applicable sugestions to decrease the drawdown feel free to write us guys, thank you in advance.                                                    Release Notes:                                                    Some minor adjustments was made.                                                    Release Notes:                                                    Price based trailing stop loss was ( similar to donchian base line ) added on the strategy in order to increase profitability and decrease the dragdown. Hope you are enjoying the results guys :D There are lots of thing needs to be improved we are aware of it and we appreciate if you write us your comments, thank you in advance.                                                    Release Notes:                                                    Some codes was updated and macd was added as a trend filter too , look for results ...                                                    Release Notes:                                                    Hello guys, The strategy is refined for visual understanding we also added a three limited take profit sections. Hop you enjoy it and dont forget to like & share , we are also appreciate if you buy us a coffe or beer either way we dont say no to donations :D"}, {"role": "assistant", "content": "//@version=5\nstrategy(title=\"DON-SS-TREND-V1.2\", overlay=true,default_qty_type = strategy.percent_of_equity\nlength = input.int(42, minval=1, title = \"Donchian Lenght\")\nlower = ta.lowest(length)\nupper = ta.highest(length)\nbasis = math.avg(upper, lower)\nupdiff = upper - close\ndowndiff = lower - close\ndontrend = -(updiff + downdiff)   \n//plot(dontrend, \"DON-SS\", color=color.green,linewidth = 3)\n//zerox =ta.valuewhen(ta.cross(dontrend,0),close,0)\n//plot(zerox, \"ZEROTH\", color=color.black,linewidth = 3)\nxupx = ta.highest(dontrend,length) \nxdownx = ta.lowest(dontrend,length) \ninversedragup = xupx[1]  \ninversedragdown = xdownx[1]  \ninversedragon = (inversedragup+inversedragdown)/2\n//plot(close+inversedragon, \"Inverse-Drag\", color=color.blue,style = plot.style_line,linewidth = 3)\nemalengthslow = input.int(5, minval=1,title = \"Slow EMA\")\nemax = ta.ema(dontrend,emalengthslow)\n//plot(emax, \"EMA-SLOW\", color=color.black)\nemalengthfast = input.int(45, minval=1,title = \"Fast EMA\")\nemin = ta.ema(dontrend,emalengthfast)\n//plot(emin, \"EMA-FAST\", color=color.black)\nEMAlengthTRF = input.int(200, minval=1,title = \"EMA Filter\")\nematrf = ta.ema(close,EMAlengthTRF)\n/////////////////////// MACD FILTER ////////////////\nfast_length = input(title=\"Fast Length-MACD\", defval=5)\nslow_length = input(title=\"Slow Length-MACD\", defval=45)\nsrc = input(title=\"Source\", defval=close)\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nsma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\"SMA\"\nsma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\n// Calculating\nfast_ma = sma_source == \"SMA\" ? ta.sma(src, fast_length) : ta.ema(src, fast_length)\nslow_ma = sma_source == \"SMA\" ? ta.sma(src, slow_length) : ta.ema(src, slow_length)\nmacd = fast_ma - slow_ma\nsignal = sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\nhist = macd - signal\n/////////////////////// STRATEGY ////////////////\nShortConditionx = (ta.crossunder(emax,emin) and close<ematrf) or ta.crossunder(close\nlongConditionx = (ta.crossover(emax,emin) and close>ematrf) or ta.crossover(close,ematrf\ntp1 = input.int(5, minval=1,title = \"TP-1\")\ntp2 = input.int(10, minval=1,title = \"TP-2\")\ntp3 = input.int(15, minval=1,title = \"TP-3\")\nematp = ta.ema(close,5)\nsellzerox =ta.valuewhen(ShortConditionx,close,0)\nplot(sellzerox, \"SELL-ZEROTH\", color= color.black,linewidth = 3)\nTPTAKA1S = sellzerox*(1-tp1/100)\nplot(TPTAKA1S, \"SELL-TP1\", color= color.red,linewidth = 1)\nTPTAKA2S = sellzerox*(1-tp2/100)\nplot(TPTAKA2S, \"SELL-TP2\", color= color.red,linewidth = 1)\nTPTAKA3S = sellzerox*(1-tp3/100)\nplot(TPTAKA3S, \"SELL-TP3\", color= color.red,linewidth = 1)\nbuyzerox =ta.valuewhen(longConditionx,close,0)\nplot(buyzerox, \"BUY-ZEROTH\", color= color.blue,linewidth = 3)\nTPTAKA1B = buyzerox*(1+tp1/100)\nplot(TPTAKA1B, \"BUY-TP1\", color= color.red,linewidth = 1)\nTPTAKA2B = buyzerox*(1+tp2/100)\nplot(TPTAKA2B, \"BUY-TP2\", color= color.red,linewidth = 1)\nTPTAKA3B = buyzerox*(1+tp3/100)\nplot(TPTAKA3B, \"BUY-TP3\", color= color.red,linewidth = 1)\n/////////////////////// TAKE PROFIT SECTION ////////////////\nBUYTP = ta.crossunder(dontrend,inversedragon) or ta.crossunder(ematp,TPTAKA1B) or ta.crossunder\nSELLTP = ta.crossover(dontrend,inversedragon) or ta.crossover(ematp,TPTAKA1S) or ta.crossover\n// Check for Long Entry\nlongCondition = (ta.crossover(emax,emin) and close>ematrf) or ta.crossover(close,ematrf\nif longCondition\n    strategy.entry('Long', strategy.long, comment = \"ENTER-LONG\")\nbuyclose = ta.crossunder(emax,emin) or ta.crossunder(close,ematrf) or ShortConditionx\n// Exit condition \nstrategy.close('Long', when=buyclose or BUYTP==true, comment = \"EXIT-LONG\")\n// Check for Short Entry\nShortCondition = (ta.crossunder(emax,emin) and close<ematrf) or ta.crossunder(close\nif ShortCondition\n    strategy.entry('Short', strategy.short, comment = \"ENTER-SHORT\")\nsellclose = ta.crossover(emax,emin) or ta.crossover(close,ematrf) or longConditionx\n// Exit condition \nstrategy.close('Short', when=sellclose or SELLTP==true, comment = \"EXIT-SHORT\")\n///// END OF STRATEGY ///////////"}]}
{"messages": [{"role": "user", "content": "This script marks the high and low of 9.45 to 10.15 price. When the price breaks high, then gives Buy signal. When the price breaks low, then it gives Sell Signal. These buy and sell signals are given with labels \"ARCHENS BUY\" or \"ARCHENS SELL\". With my observation in stock market, I have made this strategy. This strategy works in normal candle pattern but i observed that it works well in heikenashi candle. For this strategy to work well, we have to select 5 mins heikenashi candles.  If this strategy gives \"ARCHENS buy\", then buy it. Target should be as per individuals mind. But Stop loss should be hitted when there are two continue opposite {red} heikenashi candle. If this strategy gives \"ARCHENS sell\", then sell it. Target should be as per individuals mind. But Stop loss should be hitted when there are two continue opposite {green} heikenashi candle."}, {"role": "assistant", "content": "// Copyright (c) 2019-present\n//@version=5\nstrategy(\"ARCHENS SHARES\", overlay=true)\ntimeframe = input.timeframe(defval = \"30\", title = \"timeframe\")\nsession = input.session(defval=\"0945-1015\", title = \"session\")\ntradein = time(timeframe, session)\nhalf_high = request.security(syminfo.tickerid, \"30\", high)\nhalf_low = request.security(syminfo.tickerid, \"30\", low)\nHH = ta.valuewhen(tradein, half_high, 0 )\nHL = ta.valuewhen(tradein, half_low, 0 )\nbuy = ta.crossover(close,HH)\nsell = ta.crossunder(close,HL)\n// Reset strategy at the start of each day\nif dayofweek != dayofweek[1]\n    buy := false\n    sell := false\nplot(HH, style=plot.style_circles, color =  color.orange, linewidth = 2)\nplot(HL, style=plot.style_circles, color =  color.orange, linewidth = 2)\nstrategy.entry(\"long\", direction = strategy.long, when = buy, comment = \"ARCHENS BUY\"\nstrategy.entry(\"short\", direction = strategy.short, when = sell, comment = \"ARCHENS SELL\""}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Fixed bug with the function 'Use Opposite Signal SL' (close current order on Opposite signal) Please Note:  If you are using function 'Use Opposite Signal SL' And you want to use one of the available filters for signals (RSI, MFI, CCI, Mom etc). Then you must activate and LONG and SHORT options for these filters  (ex. 'Use RSI LONG Range' and 'Use RSI SHORT Range'). (Even if you have configured the strategy to trade only One direction.)                                                    Release Notes:                                                    - Added option to open Opposite order after SL"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at \n// Strategy based on \"Divergence for Many Indicators v4 ST\" by CannyTolany01\n// which is based on \"Divergence for Many Indicator\" indicator by LonesomeTheBlue\n//@version=5\nstrategy('Divergence for Many [Dimkud - v5]', overlay=true, calc_on_order_fills=true\n// DIMAK  Static SL/TP - Begin\nGRUPO_statSLTP = 'Static SL/TP'\nUSEdisplTPSL =  input(defval=false, title='Display Visualisation for TP/SL ?', group\nenable_long_strategy = input.bool(false, title='Use Long ?', group=GRUPO_statSLTP\nenable_short_strategy = input.bool(true, title='Use Short ?', group=GRUPO_statSLTP\nSLsameTP = input.bool(false, 'SL = TP ?', group=GRUPO_statSLTP)\nUSE_SignSL = input.bool(false, 'Use Opposite Signal SL ?', group=GRUPO_statSLTP)\nUSEorderOnSL =  input(defval=false, title='New Opposite-Order after SL ?', group \nlongProfitPerc = input.float(defval=0.9, title='Take Profit (%)', group=GRUPO_statSLTP\nlongSLPerc = input.float(defval=0.9, title='Stop Loss (%)', group=GRUPO_statSLTP,\nlongSLPerc := SLsameTP ? longProfitPerc : longSLPerc\nshortProfitPerc = longProfitPerc\nshortSLPerc = longSLPerc\nlongExitPrice = strategy.position_avg_price * (1 + longProfitPerc)\nshortExitPrice = strategy.position_avg_price * (1 - shortProfitPerc)\nlongSLExitPrice = strategy.position_avg_price * (1 - longSLPerc)\nshortSLExitPrice = strategy.position_avg_price * (1 + shortSLPerc)\n// use such: limit=shortExitPrice, stop=shortSLExitPrice\n// DIMAK  Static SL/TP - END\n// =================================================================================================\n// DIMAK - TimeFrame request.security - Repaint-Non Repaint\nf_security(_sym, _res, _src, _rep) =>\n    request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[\n// DIMAK - TimeFrame request.security - Repaint-Non Repaint\n// Time filter =================================\ngrTIMEset = \"Testing Period\"\ntestPeriod() =>\n    // Testing Start dates\n    testStartYear = input.int(2022, 'Start Year', inline='date1', group=grTIMEset\n    testStartMonth = input.int(5, '', inline='date1', group=grTIMEset)\n    testStartDay = input.int(1, '', inline='date1', group=grTIMEset)\n    testPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0\n    //Stop date if you want to use a specific range of dates\n    testStopYear = input.int(2030, 'Stop Year', inline='date2', group=grTIMEset)\n    testStopMonth = input.int(12, '', inline='date2', group=grTIMEset)\n    testStopDay = input.int(30, '', inline='date2', group=grTIMEset)\n    testPeriodStop = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)\n    time >= testPeriodStart and time < testPeriodStop ? true : false\n    // pass some date\n    //testPeriodStop2 =  timestamp(2022,6,14,0,0)\n    //testPeriodStop3 =  timestamp(2022,6,16,0,0)\n    //(time >= testPeriodStart) and (time < testPeriodStop) and ((time < testPeriodStop2) or (time > tes\n// Time filter =================================\ngrMAINset = \"Main Divergence Settings\"\nprd = input.int(defval=9, title='Pivot Period(9)', minval=1, maxval=50, group = grMAINset\nsource = input.string(defval='Close', title='Source for Pivot Points', options=['Close'\n//searchdiv = input.string(defval='Regular', title='Divergence Type', options=['Regular', 'Hidden', \n// works only Regular\nsearchdiv = 'Regular'\nshowindis = input.string(defval='Don\\'t Show', title='Show Indicator Names', options\n//showlimit = input.int(1, title='Minimum Number of Divergence', minval=1, maxval=11)\n// not good results and not work now\nshowlimit = 1\nmaxpp = input.int(defval=10, title='Maximum Pivot Points to Check', minval=10, maxval\nmaxbars = input.int(defval=100, title='Maximum Bars to Check', minval=100, maxval\nshownum = input(defval=true, title='Show Divergence Number', group = grMAINset)\nshowlast = input(defval=false, title='Show Only Last Divergence', group = grMAINset\ndontconfirm = input(defval=false, title='Don\\'t Wait for Confirmation', group = grMAINset\nshowlines = input(defval=false, title='Show Divergence Lines', group = grMAINset)\nshowpivot = input(defval=false, title='Show Pivot Points', group = grMAINset)\n// declaration\nmacd = 0.0\ndeltamacd = 0.0\nrsi = 0.0\nstk = 0.0\ncci = 0.0\nmoment = 0.0\nObv = 0.0\nvwmacd = 0.0\ncmf = 0.0\nMfi = 0.0\naStDev = 0.0\nwvf = 0.0\nStochRSIk = 0.0\noscSMIO = 0.0\ndmVWMACD_LB = 0.0\nBBPower = 0.0\nSmootherBOP = 0.0\nrviMA = 0.0\n// declaration\ncalcmacd = input(defval=true, title='MACD')\ndimmacdFast = input.int(defval=12, title='Fast(12):', minval=1, maxval=70, inline\ndimmacdSlow = input.int(defval=26, title='Slow(26):', minval=1, maxval=70, inline\ndimmacdSignal = input.int(defval=9, title='Sign(9):', minval=1, maxval=70, inline\ncalcmacda = input(defval=true, title='MACD Histogram')\nif calcmacd or calcmacda\n    //[macd, signal, deltamacd] = macd(close, 12, 26, 9) // MACD\n    [macd2, signal, deltamacd2] = ta.macd(close, dimmacdFast, dimmacdSlow, dimmacdSignal\n    macd := macd2\n    deltamacd := deltamacd2\n    deltamacd\ncalcrsi = input(defval=true, title='RSI')\ndimRSI = input.int(defval=14, title='RSI period (14):', minval=1, maxval=70)\nif calcrsi\n    //rsi = rsi(close, 14) // RSI\n    rsi := ta.rsi(close, dimRSI)  // RSI\n    rsi\ncalcstoc = input(defval=true, title='Stochastic')\ndimSTOCHlength = input.int(defval=14, title='STOCH Length(14):', minval=1, maxval\nif calcstoc\n    //stk = sma(stoch(close, high, low, 14), 3) // Stoch\n    stk := ta.sma(ta.stoch(close, high, low, dimSTOCHlength), 3)  // Stoch\n    stk\ncalccci = input(defval=true, title='CCI')\ndimCCIL = input.int(defval=10, title='CCI Length(10)', minval=1, maxval=70, inline\nif calccci\n    //cci = cci(close, 10) // CCI\n    cci := ta.cci(close, dimCCIL)  // CCI\n    cci\ncalcmom = input(defval=true, title='Momentum')\ndimmomentL = input.int(defval=10, title='Momentum Length(10)', minval=1, maxval=70\nif calcmom\n    //moment = mom(close, 10) // Momentum\n    moment := ta.mom(close, dimmomentL)  // Momentum\n    moment\ncalcobv = input(defval=true, title='OBV')\nif calcobv\n    Obv := ta.obv  // OBV\n    Obv\ncalcvwmacd = input(true, title='VWmacd')\ndimmaFast = input.int(defval=12, title='Volume Weighted Macd. Fast(12)', minval=1\ndimmaSlow = input.int(defval=26, title='Slow(26)', minval=1, maxval=70, inline='112'\nif calcvwmacd\n    //maFast = vwma(close, 12), maSlow = vwma(close, 26), vwmacd = maFast - maSlow // volume weighted ma\n    maFast = ta.vwma(close, dimmaFast)\n    maSlow = ta.vwma(close, dimmaSlow)\n    vwmacd := maFast - maSlow  // volume weighted macd\n    vwmacd\ncalccmf = input(true, title='Chaikin Money Flow')\ndimCMFperiod = input.int(defval=21, title='CMF period(21)', minval=1, maxval=70, \nif calccmf\n    //Cmfm = ((close-low) - (high-close)) / (high - low), Cmfv = Cmfm * volume, cmf = sma(Cmfv, 21) / sm\n    Cmfm = (close - low - (high - close)) / (high - low)\n    Cmfv = Cmfm * volume\n    cmf := ta.sma(Cmfv, dimCMFperiod) / ta.sma(volume, dimCMFperiod)  // Chaikin money flow\n    cmf\ncalcmfi = input(true, title='Money Flow Index')\ndimMfilength = input.int(defval=14, title='Mfi length(14)', minval=1, maxval=70, \nif calcmfi\n    //Mfi = mfi(close, 14) // Moneyt Flow Index\n    Mfi := ta.mfi(close, dimMfilength)  // Moneyt Flow Index\n    Mfi\n//==================================================================================\ncalcWVIX = input(true, title='Williams_Vix_Fix')\npd = input(21, title='Williams_Vix_Fix Period(21)')\nif calcWVIX\n    wvf := (ta.highest(close, pd) - low) / ta.highest(close, pd) * -100\n    wvf\n//==================================================================================\ncalcStochRSI = input.bool(true, title='Use Stochastic RSI ?', group='Stochastic RSI'\nsmoothK = input.int(3, 'Stochastic K(3)', minval=1, group='Stochastic RSI')\nlengthSTRSI = input.int(14, 'RSI Length(14)', minval=1, group='Stochastic RSI')\nlengthStoch = input.int(14, 'Stochastic Length(14)', minval=1, group='Stochastic RSI'\nif calcStochRSI\n    rsi1 = ta.rsi(close, lengthSTRSI)\n    StochRSIk := ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)\n    StochRSIk\n//==================================================================================\ncalcSMIO = input.bool(true, title='Use SMIO ?', group='SMI Ergodic Oscillator')\nlonglenSMIO = input.int(20, minval=1, title='Long Length(20)', group='SMI Ergodic Oscillator'\nshortlenSMIO = input.int(5, minval=1, title='Short Length(5)', group='SMI Ergodic Oscillator'\nsiglenSMIO = input.int(5, minval=1, title='Signal Line Length(5)', group='SMI Ergodic Oscillator'\nif calcSMIO\n    ergSMIO = ta.tsi(close, shortlenSMIO, longlenSMIO)\n    sigSMIO = ta.ema(ergSMIO, siglenSMIO)\n    oscSMIO := ergSMIO - sigSMIO\n    oscSMIO\n//==================================================================================\ncalcVWMACD_LB = input.bool(true, title='Use VWMACD_LB ?', group='Volume Weighted MACD [LazyBear]'\nslowVWMACD_LB = input.int(12, 'Short period(12)', minval=1)\nfastVWMACD_LB = input.int(26, 'Long period(26)', minval=1)\nsignalVWMACD_LB = input.int(9, 'Smoothing period(9)', minval=1)\nif calcVWMACD_LB\n    maFastVWMACD_LB = ta.ema(volume * close, fastVWMACD_LB) / ta.ema(volume, fastVWMACD_LB\n    maSlowVWMACD_LB = ta.ema(volume * close, slowVWMACD_LB) / ta.ema(volume, slowVWMACD_LB\n    dVWMACD_LB = maSlowVWMACD_LB - maFastVWMACD_LB\n    maSignalVWMACD_LB = ta.ema(dVWMACD_LB, signalVWMACD_LB)\n    dmVWMACD_LB := dVWMACD_LB - maSignalVWMACD_LB\n    dmVWMACD_LB\n//==================================================================================\ncalcBBP = input.bool(true, title='Use BBP', group='Bull Bear Power')\nlengthInputBBP = input.int(13, title='BBP Length(13)', minval=1, group='Bull Bear Power'\nif calcBBP\n    bullPowerBBP = high - ta.ema(close, lengthInputBBP)\n    bearPowerBBP = low - ta.ema(close, lengthInputBBP)\n    BBPower := bullPowerBBP + bearPowerBBP\n    BBPower\n//==================================================================================\ncalcBOP = input.bool(true, title='Use BOP', group='Balance of Power')\nEMA = input.int(20, 'BOP Smooth Length(20)', minval=1, group='Balance of Power')\nTEMA = input.int(20, 'TRIPLE Smooth Length(20)', minval=1, group='Balance of Power'\nif calcBOP\n    THL = high != low ? high - low : 0.01\n    BullOpen = (high - open) / THL\n    BearOpen = (open - low) / THL\n    BullClose = (close - low) / THL\n    BearClose = (high - close) / THL\n    BullOC = close > open ? (close - open) / THL : 0\n    BearOC = open > close ? (open - close) / THL : 0\n    BullReward = (BullOpen + BullClose + BullOC) / 3\n    BearReward = (BearOpen + BearClose + BearOC) / 3\n    BOP = BullReward - BearReward\n    SmoothBOP = ta.ema(BOP, EMA)\n    xEMA1 = ta.ema(SmoothBOP, TEMA)\n    xEMA2 = ta.ema(xEMA1, TEMA)\n    xEMA3 = ta.ema(xEMA2, TEMA)\n    nRes = 3 * xEMA1 - 3 * xEMA2 + xEMA3\n    SmootherBOP := nRes\n    SmootherBOP\n//==================================================================================\ncalcRVI = input.bool(true, title='Use RVI', group='Relative Volatility Index')\nlengthRVI = input.int(10, title='RVI length(10)', minval=1, group='Relative Volatility Index'\nmaTypeInput = input.string('WMA', title='MA Type', options=['SMA', 'EMA', 'SMMA (RMA)'\nmaLengthInput = input.int(14, title='MA Length(14)', group='Relative Volatility Index'\nif calcRVI\n    stddevRVI = ta.stdev(close, lengthRVI)\n    upperRVI = ta.ema(ta.change(close) <= 0 ? 0 : stddevRVI, 14)\n    lowerRVI = ta.ema(ta.change(close) > 0 ? 0 : stddevRVI, 14)\n    rviRVI = upperRVI / (upperRVI + lowerRVI) * 100\n    rviMA := maTypeInput == 'SMA' ? ta.sma(rviRVI, maLengthInput) : maTypeInput ==\n    rviMA\n//==================================================================================\n// Logistic Dominance\ncalcLD = input.bool(true, title='Logistic Dominance', group='Logistic Settings')\nsource2 = close\nlength = input.int(13, 'Map Length(13)', minval=1, inline='LOG', group='Logistic Settings'\nlenLD = input.int(5, 'Dominance(5)', minval=1, inline='LOG', group='Logistic Settings'\nf_logmap(_s, _r, _l) =>\n    _r * _s / ta.highest(_l) * (1 - _s / ta.highest(_l))\nf_map(_s, _r, _v) =>\n    mapeq = f_logmap(_s, _r, length)\n    lmap = mapeq\n    for i = 0 to 29 by 1\n        array.push(_v, lmap)\n        lmap := _r * math.abs(mapeq[i]) * (1 - mapeq[i])\n        lmap\n    lmap\nif calcLD\n    r = -f_logmap(-source2, ta.change(source2, lenLD) / source2[lenLD], lenLD) - \n    var v = array.new_float(0)\n    val = f_map(source2, r, v)\n    array.remove(v, 0)\n    aStDev := math.sign(array.avg(v)) * array.stdev(v)\n    array.clear(v)\n// Logistic Dominance\n//==================================================================================\ncalcext = input(false, title='Check External Indicator')\nexternalindi = input(defval=close, title='External Indicator')\npos_reg_div_col = input(defval= color.yellow, title='Positive Regular Divergence'\nneg_reg_div_col = input(defval= color.navy, title='Negative Regular Divergence')\npos_hid_div_col = input(defval= color.lime, title='Positive Hidden Divergence')\nneg_hid_div_col = input(defval= color.red, title='Negative Hidden Divergence')\npos_div_text_col = input(defval= color.black, title='Positive Divergence Text Color'\nneg_div_text_col = input(defval= color.white, title='Negative Divergence Text Color'\nreg_div_l_style_ = input.string(defval='Solid', title='Regular Divergence Line Style'\nhid_div_l_style_ = input.string(defval='Dashed', title='Hdden Divergence Line Style'\nreg_div_l_width = input.int(defval=2, title='Regular Divergence Line Width', minval\nhid_div_l_width = input.int(defval=1, title='Hidden Divergence Line Width', minval\nshowmas = input.bool(defval=false, title='Show MAs 50 & 200', inline='ma12')\ncma1col = input.color(defval= color.lime, title='', inline='ma12')\ncma2col = input.color(defval= color.red, title='', inline='ma12')\nplot(showmas ? ta.sma(close, 50) : na, color=showmas ? cma1col : na)\nplot(showmas ? ta.sma(close, 200) : na, color=showmas ? cma2col : na)\n// set line styles\nvar reg_div_l_style = reg_div_l_style_ == 'Solid' ? line.style_solid : reg_div_l_style_\nvar hid_div_l_style = hid_div_l_style_ == 'Solid' ? line.style_solid : hid_div_l_style_\n// keep indicators names and colors in arrays\n// !!!!!!!! DIMAK - add num of Indicators +1\nvar indicators_name = array.new_string(19)\nvar div_colors = array.new_color(4)\nif barstate.isfirst\n    // names\n    array.set(indicators_name, 0, showindis == 'Full' ? 'MACD' : 'M')\n    array.set(indicators_name, 1, showindis == 'Full' ? 'Hist' : 'H')\n    array.set(indicators_name, 2, showindis == 'Full' ? 'RSI' : 'E')\n    array.set(indicators_name, 3, showindis == 'Full' ? 'Stoch' : 'S')\n    array.set(indicators_name, 4, showindis == 'Full' ? 'CCI' : 'C')\n    array.set(indicators_name, 5, showindis == 'Full' ? 'MOM' : 'M')\n    array.set(indicators_name, 6, showindis == 'Full' ? 'OBV' : 'O')\n    array.set(indicators_name, 7, showindis == 'Full' ? 'VWMACD' : 'V')\n    array.set(indicators_name, 8, showindis == 'Full' ? 'CMF' : 'C')\n    array.set(indicators_name, 9, showindis == 'Full' ? 'MFI' : 'M')\n    array.set(indicators_name, 10, showindis == 'Full' ? 'Extrn' : 'X')\n    array.set(indicators_name, 11, showindis == 'Full' ? 'Logist' : 'L')\n    array.set(indicators_name, 12, showindis == 'Full' ? 'WVIX' : 'VIX')\n    array.set(indicators_name, 13, showindis == 'Full' ? 'StochRSI' : 'SR')\n    array.set(indicators_name, 14, showindis == 'Full' ? 'calcSMIO' : 'SM')\n    array.set(indicators_name, 15, showindis == 'Full' ? 'VWMACD_LB' : 'VWM')\n    array.set(indicators_name, 16, showindis == 'Full' ? 'BBP' : 'BBP')\n    array.set(indicators_name, 17, showindis == 'Full' ? 'BOP' : 'BOP')\n    array.set(indicators_name, 18, showindis == 'Full' ? 'RVI' : 'RVI')\n// !!!!!!!!!!! DIMAK - num of Ind +1    \n    //colors\n    array.set(div_colors, 0, pos_reg_div_col)\n    array.set(div_colors, 1, neg_reg_div_col)\n    array.set(div_colors, 2, pos_hid_div_col)\n    array.set(div_colors, 3, neg_hid_div_col)\n// Check if we get new Pivot High Or Pivot Low\nfloat ph = ta.pivothigh(source == 'Close' ? close : high, prd, prd)\nfloat pl = ta.pivotlow(source == 'Close' ? close : low, prd, prd)\nplotshape(ph and showpivot, text='H', style=shape.labeldown, color= color.new(color.white\nplotshape(pl and showpivot, text='L', style=shape.labelup, color= color.new(color.white\n// keep values and positions of Pivot Highs/Lows in the arrays\nvar int maxarraysize = 20\nvar ph_positions = array.new_int(maxarraysize, 0)\nvar pl_positions = array.new_int(maxarraysize, 0)\nvar ph_vals = array.new_float(maxarraysize, 0.)\nvar pl_vals = array.new_float(maxarraysize, 0.)\n// add PHs to the array\nif ph\n    array.unshift(ph_positions, bar_index)\n    array.unshift(ph_vals, ph)\n    if array.size(ph_positions) > maxarraysize\n        array.pop(ph_positions)\n        array.pop(ph_vals)\n// add PLs to the array\nif pl\n    array.unshift(pl_positions, bar_index)\n    array.unshift(pl_vals, pl)\n    if array.size(pl_positions) > maxarraysize\n        array.pop(pl_positions)\n        array.pop(pl_vals)\n// functions to check Regular Divergences and Hidden Divergences\n// function to check positive regular or negative hidden divergence\n// cond == 1 => positive_regular, cond == 2=> negative_hidden\npositive_regular_positive_hidden_divergence(src, cond) =>\n    divlen = 0\n    prsc = source == 'Close' ? close : low\n    // if indicators higher than last value and close price is higher than las close \n    if dontconfirm or src > src[1] or close > close[1]\n        startpoint = dontconfirm ? 0 : 1  // don't check last candle\n        // we search last 15 PPs\n        for x = 0 to maxpp - 1 by 1\n            len = bar_index - array.get(pl_positions, x) + prd\n            // if we reach non valued array element or arrived 101. or previous bars then we don't search more\n            if array.get(pl_positions, x) == 0 or len > maxbars\n                break\n            if len > 5 and (cond == 1 and src[startpoint] > src[len] and prsc[startpoint\n                slope1 = (src[startpoint] - src[len]) / (len - startpoint)\n                virtual_line1 = src[startpoint] - slope1\n                slope2 = (close[startpoint] - close[len]) / (len - startpoint)\n                virtual_line2 = close[startpoint] - slope2\n                arrived = true\n                for y = 1 + startpoint to len - 1 by 1\n                    if src[y] < virtual_line1 or nz(close[y]) < virtual_line2\n                        arrived := false\n                        break\n                    virtual_line1 -= slope1\n                    virtual_line2 -= slope2\n                    virtual_line2\n                if arrived\n                    divlen := len\n                    break\n    divlen\n// function to check negative regular or positive hidden divergence\n// cond == 1 => negative_regular, cond == 2=> positive_hidden\nnegative_regular_negative_hidden_divergence(src, cond) =>\n    divlen = 0\n    prsc = source == 'Close' ? close : high\n    // if indicators higher than last value and close price is higher than las close \n    if dontconfirm or src < src[1] or close < close[1]\n        startpoint = dontconfirm ? 0 : 1  // don't check last candle\n        // we search last 15 PPs\n        for x = 0 to maxpp - 1 by 1\n            len = bar_index - array.get(ph_positions, x) + prd\n            // if we reach non valued array element or arrived 101. or previous bars then we don't search more\n            if array.get(ph_positions, x) == 0 or len > maxbars\n                break\n            if len > 5 and (cond == 1 and src[startpoint] < src[len] and prsc[startpoint\n                slope1 = (src[startpoint] - src[len]) / (len - startpoint)\n                virtual_line1 = src[startpoint] - slope1\n                slope2 = (close[startpoint] - nz(close[len])) / (len - startpoint\n                virtual_line2 = close[startpoint] - slope2\n                arrived = true\n                for y = 1 + startpoint to len - 1 by 1\n                    if src[y] > virtual_line1 or nz(close[y]) > virtual_line2\n                        arrived := false\n                        break\n                    virtual_line1 -= slope1\n                    virtual_line2 -= slope2\n                    virtual_line2\n                if arrived\n                    divlen := len\n                    break\n    divlen\n// calculate 4 types of divergence if enabled in the options and return divergences in an array\ncalculate_divs(cond, indicator_1) =>\n    divs = array.new_int(4, 0)\n    array.set(divs, 0, cond and (searchdiv == 'Regular' or searchdiv == 'Regular/Hidden'\n    array.set(divs, 1, cond and (searchdiv == 'Regular' or searchdiv == 'Regular/Hidden'\n    array.set(divs, 2, cond and (searchdiv == 'Hidden' or searchdiv == 'Regular/Hidden'\n    array.set(divs, 3, cond and (searchdiv == 'Hidden' or searchdiv == 'Regular/Hidden'\n    divs\n// array to keep all divergences\n// !!!!!!!!!! DIMAK - add num of Indicators *4\nvar all_divergences = array.new_int(76)  // 11 indicators * 4 divergence = 44 elements\n// set related array elements\narray_set_divs(div_pointer, index) =>\n    for x = 0 to 3 by 1\n        array.set(all_divergences, index * 4 + x, array.get(div_pointer, x))\n// set divergences array \nif calcmacd\n    array_set_divs(calculate_divs(calcmacd, macd), 0)\nif calcmacda\n    array_set_divs(calculate_divs(calcmacda, deltamacd), 1)\nif calcrsi\n    array_set_divs(calculate_divs(calcrsi, rsi), 2)\nif calcstoc\n    array_set_divs(calculate_divs(calcstoc, stk), 3)\nif calccci\n    array_set_divs(calculate_divs(calccci, cci), 4)\nif calcmom\n    array_set_divs(calculate_divs(calcmom, moment), 5)\nif calcobv\n    array_set_divs(calculate_divs(calcobv, Obv), 6)\nif calcvwmacd\n    array_set_divs(calculate_divs(calcvwmacd, vwmacd), 7)\nif calccmf\n    array_set_divs(calculate_divs(calccmf, cmf), 8)\nif calcmfi\n    array_set_divs(calculate_divs(calcmfi, Mfi), 9)\nif calcext\n    array_set_divs(calculate_divs(calcext, externalindi), 10)\nif calcLD\n    array_set_divs(calculate_divs(calcLD, aStDev), 11)\nif calcWVIX\n    array_set_divs(calculate_divs(calcWVIX, wvf), 12)\nif calcStochRSI\n    array_set_divs(calculate_divs(calcStochRSI, StochRSIk), 13)\nif calcSMIO\n    array_set_divs(calculate_divs(calcSMIO, oscSMIO), 14)\nif calcVWMACD_LB\n    array_set_divs(calculate_divs(calcVWMACD_LB, dmVWMACD_LB), 15)\nif calcBBP\n    array_set_divs(calculate_divs(calcBBP, BBPower), 16)\nif calcBOP\n    array_set_divs(calculate_divs(calcBOP, SmootherBOP), 17)\nif calcRVI\n    array_set_divs(calculate_divs(calcRVI, rviMA), 18)\n// !!!!!!! DIMAK - add num of Indicators \n// check minimum number of divergence, if less than showlimit then delete all divergence\ntotal_div = 0\nfor x = 0 to array.size(all_divergences) - 1 by 1\n    total_div += math.round(math.sign(array.get(all_divergences, x)))\nif total_div < showlimit\n    array.fill(all_divergences, 0)\n// keep line in an array\nvar pos_div_lines = array.new_line(0)\nvar neg_div_lines = array.new_line(0)\nvar pos_div_labels = array.new_label(0)\nvar neg_div_labels = array.new_label(0)\n// remove old lines and labels if showlast option is enabled\ndelete_old_pos_div_lines() =>\n    if array.size(pos_div_lines) > 0\n        for j = 0 to array.size(pos_div_lines) - 1 by 1\n            line.delete(array.get(pos_div_lines, j))\n            1\n        array.clear(pos_div_lines)\ndelete_old_neg_div_lines() =>\n    if array.size(neg_div_lines) > 0\n        for j = 0 to array.size(neg_div_lines) - 1 by 1\n            line.delete(array.get(neg_div_lines, j))\n            1\n        array.clear(neg_div_lines)\ndelete_old_pos_div_labels() =>\n    if array.size(pos_div_labels) > 0\n        for j = 0 to array.size(pos_div_labels) - 1 by 1\n            label.delete(array.get(pos_div_labels, j))\n        array.clear(pos_div_labels)\ndelete_old_neg_div_labels() =>\n    if array.size(neg_div_labels) > 0\n        for j = 0 to array.size(neg_div_labels) - 1 by 1\n            label.delete(array.get(neg_div_labels, j))\n        array.clear(neg_div_labels)\n// delete last creted lines and labels until we met new PH/PV \ndelete_last_pos_div_lines_label(n) =>\n    if n > 0 and array.size(pos_div_lines) >= n\n        asz = array.size(pos_div_lines)\n        for j = 1 to n by 1\n            line.delete(array.get(pos_div_lines, asz - j))\n            array.pop(pos_div_lines)\n        if array.size(pos_div_labels) > 0\n            label.delete(array.get(pos_div_labels, array.size(pos_div_labels) - 1\n            array.pop(pos_div_labels)\ndelete_last_neg_div_lines_label(n) =>\n    if n > 0 and array.size(neg_div_lines) >= n\n        asz = array.size(neg_div_lines)\n        for j = 1 to n by 1\n            line.delete(array.get(neg_div_lines, asz - j))\n            array.pop(neg_div_lines)\n        if array.size(neg_div_labels) > 0\n            label.delete(array.get(neg_div_labels, array.size(neg_div_labels) - 1\n            array.pop(neg_div_labels)\n// variables for Alerts\npos_reg_div_detected = false\nneg_reg_div_detected = false\npos_hid_div_detected = false\nneg_hid_div_detected = false\n// to remove lines/labels until we met new // PH/PL\nvar last_pos_div_lines = 0\nvar last_neg_div_lines = 0\nvar remove_last_pos_divs = false\nvar remove_last_neg_divs = false\nif pl\n    remove_last_pos_divs := false\n    last_pos_div_lines := 0\n    last_pos_div_lines\nif ph\n    remove_last_neg_divs := false\n    last_neg_div_lines := 0\n    last_neg_div_lines\n// draw divergences lines and labels\ndivergence_text_top = ''\ndivergence_text_bottom = ''\ndistances = array.new_int(0)\ndnumdiv_top = 0\ndnumdiv_bottom = 0\ntop_label_col =  color.white\nbottom_label_col =  color.white\nold_pos_divs_can_be_removed = true\nold_neg_divs_can_be_removed = true\nstartpoint = dontconfirm ? 0 : 1  // used for don't confirm option\n// !!!!!!!!!!!! DIMAK - add num of Indicators \nfor x = 0 to 18 by 1\n    div_type = -1\n    for y = 0 to 3 by 1\n        if array.get(all_divergences, x * 4 + y) > 0  // any divergence?\n            div_type := y\n            if y % 2 == 1\n                dnumdiv_top += 1\n                top_label_col := array.get(div_colors, y)\n                top_label_col\n            if y % 2 == 0\n                dnumdiv_bottom += 1\n                bottom_label_col := array.get(div_colors, y)\n                bottom_label_col\n            if not array.includes(distances, array.get(all_divergences, x * 4 + y\n                array.push(distances, array.get(all_divergences, x * 4 + y))\n                new_line = showlines ? line.new(x1=bar_index - array.get(all_divergences\n                if y % 2 == 0\n                    if old_pos_divs_can_be_removed\n                        old_pos_divs_can_be_removed := false\n                        if not showlast and remove_last_pos_divs\n                            delete_last_pos_div_lines_label(last_pos_div_lines)\n                            last_pos_div_lines := 0\n                            last_pos_div_lines\n                        if showlast\n                            delete_old_pos_div_lines()\n                    array.push(pos_div_lines, new_line)\n                    last_pos_div_lines += 1\n                    remove_last_pos_divs := true\n                    remove_last_pos_divs\n                if y % 2 == 1\n                    if old_neg_divs_can_be_removed\n                        old_neg_divs_can_be_removed := false\n                        if not showlast and remove_last_neg_divs\n                            delete_last_neg_div_lines_label(last_neg_div_lines)\n                            last_neg_div_lines := 0\n                            last_neg_div_lines\n                        if showlast\n                            delete_old_neg_div_lines()\n                    array.push(neg_div_lines, new_line)\n                    last_neg_div_lines += 1\n                    remove_last_neg_divs := true\n                    remove_last_neg_divs\n            // set variables for alerts\n            if y == 0\n                pos_reg_div_detected := true\n                pos_reg_div_detected\n            if y == 1\n                neg_reg_div_detected := true\n                neg_reg_div_detected\n            if y == 2\n                pos_hid_div_detected := true\n                pos_hid_div_detected\n            if y == 3\n                neg_hid_div_detected := true\n                neg_hid_div_detected\n    // get text for labels\n    if div_type >= 0\n        divergence_text_top += (div_type % 2 == 1 ? showindis != 'Don\\'t Show' ? \n        divergence_text_bottom += (div_type % 2 == 0 ? showindis != 'Don\\'t Show'\n        divergence_text_bottom\n// draw labels\nif showindis != 'Don\\'t Show' or shownum\n    if shownum and dnumdiv_top > 0\n        divergence_text_top += str.tostring(dnumdiv_top)\n        divergence_text_top\n    if shownum and dnumdiv_bottom > 0\n        divergence_text_bottom += str.tostring(dnumdiv_bottom)\n        divergence_text_bottom\n    if divergence_text_top != ''\n        if showlast\n            delete_old_neg_div_labels()\n        array.push(neg_div_labels, label.new(x=bar_index, y=math.max(high, high[1\n    if divergence_text_bottom != ''\n        if showlast\n            delete_old_pos_div_labels()\n        array.push(pos_div_labels, label.new(x=bar_index, y=math.min(low, low[1])\n//alertcondition(pos_reg_div_detected, title='Positive Regular Divergence Detected', message='Positi\n//alertcondition(neg_reg_div_detected, title='Negative Regular Divergence Detected', message='Negati\n//alertcondition(pos_hid_div_detected, title='Positive Hidden Divergence Detected', message='Positiv\n//alertcondition(neg_hid_div_detected, title='Negative Hidden Divergence Detected', message='Negativ\n//alertcondition(pos_reg_div_detected or pos_hid_div_detected, title='Positive Divergence Detected',\n//alertcondition(neg_reg_div_detected or neg_hid_div_detected, title='Negative Divergence Detected',\n// =================================================================================================\nGRUPO_KC = 'Keltner Channel'\nuse_KC = input.bool(false, 'Use Channel ?', group=GRUPO_KC)\nP_indicador = input.string('Keltner Channel', 'Channel to Use:', options=['Keltner Channel'\nP_cond_entrada = input.string('Wick out of band', 'Enter Conditions', options=['Wick out of band'\nKC_length = input.int(title='Keltner Long.', group=GRUPO_KC, defval=14, minval=1,\nKC_mult = input.float(title='Keltner Mult.', group=GRUPO_KC, defval=1.5, minval=0.01\n[KC_mid, KC_upper, KC_lower] = ta.kc(close, KC_length, KC_mult)\nGRUPO_BB = 'Bollinger Bands Filter'\nBB_length = input.int(title='BB Long. ', group=GRUPO_KC, defval=20, minval=1, inline\nBB_dev = input.float(title='BB Deviation (Desv.)', group=GRUPO_KC, defval=2.0, minval\n[BB_mid, BB_upper, BB_lower] = ta.bb(close, BB_length, BB_dev)\nKanal_upper = KC_upper\nKanal_mid = KC_mid\nKanal_lower = KC_lower\nif P_indicador == 'Bollinger Bands'\n    Kanal_upper := BB_upper\n    Kanal_mid := BB_mid\n    Kanal_lower := BB_lower\n    //Kanal_lower\n//displ= display.none\ndispl = use_KC ? display.all : display.none\nplot(Kanal_upper, 'UP',  color.new(color.aqua, 0), display = displ)\nplot(Kanal_mid, 'Mid',  color.new(color.orange, 0), display = displ)\nplot(Kanal_lower, 'DOWN',  color.new(color.aqua, 0), display = displ)\nlongCondition2 = true\nshortCondition2 = true\nif use_KC\n    longCondition2 := false\n    shortCondition2 := false\n    if P_cond_entrada == 'Wick out of band'\n        longCondition2 := low < Kanal_lower\n        shortCondition2 := high > Kanal_upper\n        shortCondition2\n    else if P_cond_entrada == 'Wick out of the band then close in'\n        longCondition2 := low[1] < Kanal_lower and close > Kanal_lower\n        shortCondition2 := high[1] > Kanal_upper and close < Kanal_upper\n        shortCondition2\n    else if P_cond_entrada == 'Out-of-band closure'\n        longCondition2 := close < Kanal_lower\n        shortCondition2 := close > Kanal_upper\n        shortCondition2\n    else\n        // Close out of the band then close in\n        longCondition2 := close[1] < Kanal_lower and close > Kanal_lower\n        shortCondition2 := close[1] > Kanal_upper and close < Kanal_upper\n        shortCondition2\nelse\n    longCondition2 := true\n    shortCondition2 := true\n    shortCondition2\n// =================================================================================================\n// ======================= dimak RSI timeframe   Begin 1111111 ====================\nGRUPO_RSI_TF  = \"========== RSI FILTER ============\"\nlengthRSI = input.int(title=\"RSI TF Long(14):\", group=GRUPO_RSI_TF, defval=14, minval\ntf_rsi_indicator = input.timeframe(\"\",title=\"RSI TimeFrame:\", group=GRUPO_RSI_TF)\nuseRSITFoverSold = input.bool(false, 'Use RSI LONG Range', group=GRUPO_RSI_TF)\noverSoldRSITF = input.int(title='(LONG) RSI is More', group=GRUPO_RSI_TF, defval=\noverSold2RSITF = input.int(title='& RSI Less', group=GRUPO_RSI_TF, defval=70, minval\nuseRSITFFoverBought = input.bool(false, 'Use RSI SHORT Range', group=GRUPO_RSI_TF\noverBoughtRSITF = input.int(title='(SHORT) RSI is Less', group=GRUPO_RSI_TF, defval\noverBought2RSITF = input.int(title='& RSI More', group=GRUPO_RSI_TF, defval=30, minval\n//rsi_tf1 = request.security(syminfo.tickerid, tf_rsi_indicator, ta.rsi(close, lengthRSI), barmerge.\nrsi_tf1 = f_security(syminfo.tickerid, tf_rsi_indicator, ta.rsi(close, lengthRSI)\n//=====================================================    \nlongCondition8  = true\nshortCondition8 = true\nif useRSITFoverSold or useRSITFFoverBought\n    longCondition8  := false\n    shortCondition8 := false\n    if useRSITFoverSold and (rsi_tf1 >= overSoldRSITF) and (rsi_tf1 <= overSold2RSITF\n        longCondition8  := true\n        if useRSITFFoverBought and (rsi_tf1 <= overBoughtRSITF)  and (rsi_tf1 >= overBought2RSITF\n        shortCondition8 := true\nelse \n    longCondition8  := true\n    shortCondition8 := true\n//dimak RSI timeframe  END\n//=====================================================\n// ======================= dimak RSI timeframe   Begin 22222222 ====================\nGRUPO_RSI_TF2  = \"======= RSI FILTER - Multi TimeFrame [2] =======\"\nlengthRSI2 = input.int(title=\"RSI TF Long(14):[2]\", group=GRUPO_RSI_TF2, defval=14\ntf_rsi_indicator2 = input.timeframe(\"\",title=\"RSI TimeFrame:[2]\", group=GRUPO_RSI_TF2\nuseRSITFoverSold2 = input.bool(false, 'Use RSI LONG Range[2]', group=GRUPO_RSI_TF2\noverSoldRSITF2 = input.int(title='(LONG) RSI is More[2]', group=GRUPO_RSI_TF2, defval\noverSold2RSITF2 = input.int(title='& RSI Less[2]', group=GRUPO_RSI_TF2, defval=70\nuseRSITFFoverBought2 = input.bool(false, 'Use RSI SHORT Range[2]', group=GRUPO_RSI_TF2\noverBoughtRSITF2 = input.int(title='(SHORT) RSI is Less[2]', group=GRUPO_RSI_TF2,\noverBought2RSITF2 = input.int(title='& RSI More[2]', group=GRUPO_RSI_TF2, defval=\n//rsi_tf2 = request.security(syminfo.tickerid, tf_rsi_indicator2, ta.rsi(close, lengthRSI2), barmerg\nrsi_tf2 = f_security(syminfo.tickerid, tf_rsi_indicator2, ta.rsi(close, lengthRSI2\n//=====================================================    \nlongCondition10  = true\nshortCondition10 = true\nif useRSITFoverSold2 or useRSITFFoverBought2 and not na(rsi_tf2)\n    longCondition10  := false\n    shortCondition10 := false\n    if useRSITFoverSold2 and (rsi_tf2 >= overSoldRSITF2) and (rsi_tf2 <= overSold2RSITF2\n        longCondition10  := true\n        if useRSITFFoverBought2 and (rsi_tf2 <= overBoughtRSITF2)  and (rsi_tf2 >= overBought2RSITF2\n        shortCondition10 := true\nelse \n    longCondition10  := true\n    shortCondition10 := true\n//dimak RSI timeframe  END\n//=====================================================\n// ============ dimak \"Money Flow Index\" Filter Timeframe  [111]  =============\nGRUPO_MFI_TF = '=========== MFI FILTER  ==========='\nlengthMFI = input.int(title='MFI TF Long:', group=GRUPO_MFI_TF, defval=14, minval\ntf_mfi_indicator = input.timeframe('', title='MFI TimeFrame:', group=GRUPO_MFI_TF\nuseMFITFoverSold = input.bool(false, 'Use MFI LONG Range', group=GRUPO_MFI_TF)\noverSold = input.int(title='(LONG) MFI is More', group=GRUPO_MFI_TF, defval=10, step\noverSold2 = input.int(title='& MFI Less', group=GRUPO_MFI_TF, defval=60, maxval =\nuseMFITFoverBought = input.bool(false, 'Use MFI SHORT Range', group=GRUPO_MFI_TF)\noverBought = input.int(title='(SHORT) MFI is Less', group=GRUPO_MFI_TF, defval=95\noverBought2 = input.int(title='& MFI More', group=GRUPO_MFI_TF, defval=50, maxval\nmfi_tf1 = f_security(syminfo.tickerid, tf_mfi_indicator, ta.mfi(hlc3, lengthMFI),\n//mfi_tf1 = request.security(syminfo.tickerid, tf_mfi_indicator, ta.mfi(hlc3, lengthMFI), barmerge.g\n// =====================================================    \nlongCondition4 = true\nshortCondition4 = true\n    if useMFITFoverSold or useMFITFoverBought\n    longCondition4 := false\n    shortCondition4 := false\n    if useMFITFoverSold and (mfi_tf1 > overSold) and (mfi_tf1 < overSold2)\n        longCondition4 := true\n          if useMFITFoverBought and (mfi_tf1 < overBought) and (mfi_tf1 > overBought2) \n        shortCondition4 := true\n                 else\n    longCondition4 := true\n    shortCondition4 := true\n   // dimak MFI timeframe [111] END\n// =====================================================    \nuse_mfi_tf1_rising = input.bool(false, 'Use MFI TF Rising ?', group=GRUPO_MFI_TF)\nmfi_tf1_rising_len = input.int(3, title='MFI TF Rising Lengh:', group=GRUPO_MFI_TF\nuse_mfi_tf1_falling = input.bool(false, 'Use MFI TF Falling ?', group=GRUPO_MFI_TF\nmfi_tf1_falling_len = input.int(3, title='MFI TF Falling Lengh:', group=GRUPO_MFI_TF\nmfi_tf1_falling = ta.falling(mfi_tf1, mfi_tf1_falling_len)\nmfi_tf1_rising = ta.rising(mfi_tf1, mfi_tf1_rising_len)\n//mfi_tf1_falling_tf = request.security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_falling, barmerg\n//mfi_tf1_rising_tf = request.security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_rising, barmerge.\nmfi_tf1_falling_tf = f_security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_falling\nmfi_tf1_rising_tf = f_security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_rising\n    longCondition12 = true\nshortCondition12 = true\n    if use_mfi_tf1_falling or use_mfi_tf1_rising\n        longCondition12 := false\n    shortCondition12 := false\n          if (use_mfi_tf1_falling and mfi_tf1_falling_tf) or (use_mfi_tf1_rising and mfi_tf1_rising_tf\n        shortCondition12 := true\n        longCondition12 := true\n        else\n    longCondition12 := true\n    shortCondition12 := true\n   // dimak MFI timeframe  END\n// =====================================================\n// =====================================================\n// Two ATR (Volatility Check)\ngrDATR=\"=======Two ATR (Volatility Check) Base Settings=========\"\n//useDATR = input(defval=false, title='Use Two ATR (Volatility Check) ?', group = grDATR)\nlengthDATR = input.int(title='ATR length1 (20)(5)', defval=20, minval=1, group = \nlength2DATR = input.int(title='ATR length2 (100)(20)', defval=100, minval=1, group\nsmoothingDATR = input.string(title='ATR Smoothing', defval='WMA', options=['RMA',\nDATR_ma_function(sourceDATR, lengthDATR1) =>\n    if smoothingDATR == 'RMA'\n        ta.rma(sourceDATR, lengthDATR1)\n    else\n        if smoothingDATR == 'SMA'\n            ta.sma(sourceDATR, lengthDATR1)\n        else\n            if smoothingDATR == 'EMA'\n                ta.ema(sourceDATR, lengthDATR1)\n            else // WMA\n                ta.wma(sourceDATR, lengthDATR1)\ndatr1 = DATR_ma_function(ta.tr(true), lengthDATR)\ndatr2 = DATR_ma_function(ta.tr(true), length2DATR)\n// ATR Histograme\ndatr_hist = datr1-datr2\n//plot(datr1+0.4, title='ATR', color=color.new(#77C5E1, 0))\n//plot(datr2+0.4, title='ATR', color=color.new(#FF5252, 0))\n//plot(datr_hist, color=color.red, style=plot.style_histogram)\n// block for filters \"ATR1 < ATR2\" BEGIN\n// \"ATR1 < ATR2 - Volatility is Small in last bars, ATR1 > ATR2 - Volatility is High in last bars\"\n//grATR1ATR2 = \"=============== Two ATR (ATR1 <> ATR2)==============\"\nuse_atr1toart2_more_less = input(defval=false, title='Use ATR1 <> ATR2 ? ', group\natr1toart2_more_less = input.string(title='ATR1 to ATR2', defval='ATR1 < ATR2', options\ndatr1todatr3 = use_atr1toart2_more_less and (atr1toart2_more_less == \"ATR1 < ATR2\"\nlongCondition1 = true\nshortCondition1 = true\nif use_atr1toart2_more_less\n    longCondition1 := false\n    shortCondition1 := false\n       longCondition1 := datr1todatr3\n    shortCondition1 := longCondition1 \nelse\n    longCondition1 := true\n    shortCondition1 := true\n// shortCondition1 and longCondition1 is if Fast ATR Must be higher (or Lower) than Slow ATR !!!\n// block for filters \"ATR1 < ATR2\" END\n// ==========================================================================\n// NOTE \"ATR1 < ATR2\" and ( Barssince_Highest/Lowest + falling/rising ) are working separately. But \n// ==========================================================================\n// ========== Two Average True Range ===============================\n// ==================== Volume Filter =================== Begin\ngrVOL=\"=======Volume Filter=========\"\nuse_VOL_more_less = input(defval=false, title='Use VOL1 <> VOL2 ? ', group = grVOL\nVOL_more_less = input.string(title='VOL1 to VOL2', defval='VOL1 < VOL2', options=\nlengthVOL = input.int(title='VOL length1 (20)(5)', defval=20, minval=1, group = grVOL\nlength2VOL = input.int(title='VOL length2 (100)(20)', defval=100, minval=1, step \nsmoothingVOL = input.string(title='VOL Smoothing', defval='WMA', options=['RMA', \nVOL_ma_function(sourceVOL, XlengthVOL) =>\n    if smoothingVOL == 'RMA'\n        ta.rma(sourceVOL, XlengthVOL)\n    else\n        if smoothingVOL == 'SMA'\n            ta.sma(sourceVOL, XlengthVOL)\n        else\n            if smoothingVOL == 'EMA'\n                ta.ema(sourceVOL, XlengthVOL)\n            else // WMA\n                ta.wma(sourceVOL, XlengthVOL)\nvol1 = VOL_ma_function(volume, lengthVOL)\nvol2 = VOL_ma_function(volume, length2VOL)\nlongCondition11 = true\nshortCondition11 = true\nif use_VOL_more_less\n    longCondition11 := false\n    shortCondition11 := false\n       longCondition11 := use_VOL_more_less and (VOL_more_less == \"VOL1 < VOL2\") and\n    shortCondition11 := longCondition11 \nelse\n    longCondition11 := true\n    shortCondition11 := true\n// ==================== Volume Filter =================== END\n// ======================= dimak CCI timeframe   Begin 1111111 ====================\nGRUPO_CCI_TF  = \"========== CCI FILTER ============\"\nlengthCCI = input.int(title=\"CCI TF Long(14):\", group=GRUPO_CCI_TF, defval=14, minval\ntf_CCI_indicator = input.timeframe(\"\",title=\"CCI TimeFrame:\", group=GRUPO_CCI_TF)\nuseCCITFoverSold = input.bool(false, 'Use CCI LONG Range', group=GRUPO_CCI_TF)\noverSoldCCITF = input.int(title='(LONG) CCI is More', group=GRUPO_CCI_TF, defval=\noverSold2CCITF = input.int(title='& CCI Less', group=GRUPO_CCI_TF, defval=400, minval\nuseCCITFFoverBought = input.bool(false, 'Use CCI SHORT Range', group=GRUPO_CCI_TF\noverBoughtCCITF = input.int(title='(SHORT) CCI is Less', group=GRUPO_CCI_TF, defval\noverBought2CCITF = input.int(title='& CCI More', group=GRUPO_CCI_TF, defval=10, minval\n//CCI_tf1 = request.security(syminfo.tickerid, tf_CCI_indicator, ta.cci(close, lengthCCI), barmerge.\nCCI_tf1 = f_security(syminfo.tickerid, tf_CCI_indicator, ta.cci(close, lengthCCI)\n//=====================================================    \nlongCondition9  = true\nshortCondition9 = true\nif useCCITFoverSold or useCCITFFoverBought\n    longCondition9  := false\n    shortCondition9 := false\n    if useCCITFoverSold and (CCI_tf1 >= overSoldCCITF) and (CCI_tf1 <= overSold2CCITF\n        longCondition9  := true\n        if useCCITFFoverBought and (CCI_tf1 <= overBoughtCCITF)  and (CCI_tf1 >= overBought2CCITF\n        shortCondition9 := true\nelse \n    longCondition9  := true\n    shortCondition9 := true\n//dimak CCI timeframe  END\n//=====================================================\n// ======================= dimak Momentum timeframe   Begin 1111111 ====================\nGRUPO_MOM_TF  = \"==========Momentum FILTER ============\"\nlengthMOM = input.int(title=\"Momentum TF Long(14):\", group=GRUPO_MOM_TF, defval=14\ntf_MOM_indicator = input.timeframe(\"\",title=\"Momentum TimeFrame:\", group=GRUPO_MOM_TF\nuseMOMTFoverSold = input.bool(false, 'Use Momentum LONG Range (-100:100)', group=\noverSoldMOMTF = input.int(title='(LONG) Momentum is More', group=GRUPO_MOM_TF, defval\noverSold2MOMTF = input.int(title='& Mom Less', group=GRUPO_MOM_TF, defval=10, minval\nuseMOMTFFoverBought = input.bool(false, 'Use Momentum SHORT Range (100:-100)', group\noverBoughtMOMTF = input.int(title='(SHORT) Momentum is Less', group=GRUPO_MOM_TF,\noverBought2MOMTF = input.int(title='& Mom More', group=GRUPO_MOM_TF, defval=-30, \nsrcMOM = input(close, \"Momentum Source\", group=GRUPO_MOM_TF)\nmomm = ta.change(srcMOM)\nf1(m) => m >= 0.0 ? m : 0.0\nf2(m) => m >= 0.0 ? 0.0 : -m\nm1 = f1(momm)\nm2 = f2(momm)\nsm1 = math.sum(m1, lengthMOM)\nsm2 = math.sum(m2, lengthMOM)\npercent(nom, div) => 100 * nom / div\nchandeMO = percent(sm1-sm2, sm1+sm2)\n//MOM_tf2 = request.security(syminfo.tickerid, tf_MOM_indicator, chandeMO, barmerge.gaps_off)\nMOM_tf2 = f_security(syminfo.tickerid, tf_MOM_indicator, chandeMO, false) // Repaint = false\n//=====================================================    \nlongCondition3  = true\nshortCondition3 = true\nif useMOMTFoverSold or useMOMTFFoverBought\n    longCondition3  := false\n    shortCondition3 := false\n    if useMOMTFoverSold and (MOM_tf2 >= overSoldMOMTF) and (MOM_tf2 <= overSold2MOMTF\n        longCondition3  := true\n        if useMOMTFFoverBought and (MOM_tf2 <= overBoughtMOMTF)  and (MOM_tf2 >= overBought2MOMTF\n        shortCondition3 := true\nelse \n    longCondition3  := true\n    shortCondition3 := true\n//dimak MOM timeframe  END\n//=====================================================\n// ========== Super Trend =============================== Begin \ngrSUPTREND = \"=============SUPER TREND FILTER=============\"\nuseSUPTREND = input(defval=false, title='Use SuperTrend ?', group = grSUPTREND)\nopposite_SUPTREND = input(defval=false, title='Opposite SP Signal? (Sell on UPtrend..)'\nPeriodsST = input.int(title='SuperTrend ATR Period', defval=10, minval=1, group=grSUPTREND\nMultiplierST = input.float(title='SuperTrend ATR Multiplier', step=0.1, defval=3.0\n//srcST = input(hl2, title='SuperTrend Source', group=grSUPTREND)\nsrcST = hl2\n//changeATR = input(title='Set ATR Smoothing to SMA ?', defval=true, group=grSUPTREND)\nchangeATR = true\nhighlightingST = input(title='Show SuperTrend ?', defval=false, group=grSUPTREND)\natr2ST = ta.sma(ta.tr, PeriodsST)\natrST = changeATR ? ta.atr(PeriodsST) : atr2ST\nupST = srcST - MultiplierST * atrST\nup1ST = nz(upST[1], upST)\nupST := close[1] > up1ST ? math.max(upST, up1ST) : upST\ndnST = srcST + MultiplierST * atrST\ndn1ST = nz(dnST[1], dnST)\ndnST := close[1] < dn1ST ? math.min(dnST, dn1ST) : dnST\ntrendST = 1\ntrendST := nz(trendST[1], trendST)\ntrendST := trendST == -1 and close > dn1ST ? 1 : trendST == 1 and close < up1ST ?\n// check if Trend Changed. Not used now. Commented below.\nbuySignalST = trendST == 1 and trendST[1] == -1\nsellSignalST = trendST == -1 and trendST[1] == 1\n// check if Trend Changed. Not used now. Commented below.\n// visual\ndisplST = highlightingST ? display.all : display.none\nupPlot = plot(trendST == 1 ? upST : na, title='Up Trend', style=plot.style_linebr\ndnPlot = plot(trendST == 1 ? na : dnST, title='Down Trend', style=plot.style_linebr\nmPlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0)\nfill(mPlot, upPlot, title='UpTrend Highligter', color= color.rgb(76, 144, 175, 90\nfill(mPlot, dnPlot, title='DownTrend Highligter', color= color.rgb(255, 82, 255,\n// visual\nlongCondition5 = true\nshortCondition5 = true\nif useSUPTREND\n    longCondition5 := false\n    shortCondition5 := false\n       longCondition5 := trendST == 1 and not opposite_SUPTREND ? true : trendST == \n    shortCondition5 := trendST == -1 and not opposite_SUPTREND ? true : trendST ==\n    // signals by change trend\n    //longCondition5 := not opposite_SUPTREND ? buySignalST : sellSignalST\n    //shortCondition5 := not opposite_SUPTREND ? sellSignalST : buySignalST\nelse\n    longCondition5 := true\n    shortCondition5 := true\n// ========== Super Trend =============================== End \n// =================================================================================================\nif USE_SignSL\n    //if pos_reg_div_detected and not enable_long_strategy\n    if pos_reg_div_detected and longCondition1  and longCondition2 and longCondition3\n        strategy.close('sell', comment='Close Short L-Sign', alert_message='stoploss'\n            //if neg_reg_div_detected and not enable_short_strategy\n    if neg_reg_div_detected  and shortCondition1 and shortCondition2 and shortCondition3\n        strategy.close('buy', comment='Close Long S-Sign', alert_message='stoploss'\n// =================================================================================================\n// ==  TEST CODE by  ===============================================================================\n//reverseCond = strategy.closedtrades.exit_comment(strategy.closedtrades - 1)\n//exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\n//if strategy.position_size == 0 and reverseCond == 'LSL'\n//    strategy.entry('sell', strategy.short, alert_message='enter_cycle')\n//if strategy.position_size == 0 and reverseCond == 'SSL'\n//    strategy.entry('buy', strategy.long, alert_message='enter_cycle')\n// =====  TEST CODE by   ===========================================================================\nNotMultiOrders = ((strategy.closedtrades == 0) or ((bar_index != strategy.closedtrades.entry_bar_index\n//NotMultiOrders = true\n// ============ New order after SL =================================================================\nvar wasLong = false\nvar wasShort = false\nif USEorderOnSL and strategy.closedtrades.exit_bar_index(strategy.closedtrades-1)\n    if wasLong\n        wasLong := false\n        strategy.entry('sell222', strategy.short, alert_message='enter_cycle')\n            if wasShort\n        wasShort := false\n        strategy.entry('buy222', strategy.long, alert_message='enter_cycle')\n // ============= New order after SL ================================================================\n // =================================================================================================\nif pos_reg_div_detected and enable_long_strategy and testPeriod()  and NotMultiOrders\n    strategy.entry('buy', strategy.long, alert_message='enter_cycle')\n    //strategy.order('sell333',strategy.short,stop = longSLExitPrice, limit = longSLExitPrice, alert_mes\n    wasLong := true\n    wasShort := false\nif neg_reg_div_detected and enable_short_strategy and testPeriod()  and NotMultiOrders\n    strategy.entry('sell', strategy.short, alert_message='enter_cycle')\n    //strategy.order('buy333',strategy.long,stop = shortSLExitPrice, limit = shortSLExitPrice, alert_mes\n    wasShort := true\n    wasLong := false\n// =================================================================================================\n// =================================================================================================\nif strategy.position_size > 0\n    strategy.exit(id='Close Long %', from_entry='buy', stop=longSLExitPrice, limit\nif strategy.position_size < 0\n    strategy.exit(id='Close Short %', from_entry='sell', stop=shortSLExitPrice, limit\n// =================================================================================================\ndisplTPSL = not USEdisplTPSL ? display.none : display.all\n// visual TP SL\navg_position_price_plot = plot(series=strategy.position_size != 0 ? strategy.position_avg_price\nLONG_tp_plot            = plot(strategy.position_size > 0 and longExitPrice > 0.0\nLONG_sl_plot            = plot(strategy.position_size > 0 and longSLExitPrice > 0.0\nfill(avg_position_price_plot, LONG_tp_plot, color= color.new(color.olive, 90), display\nfill(avg_position_price_plot, LONG_sl_plot, color= color.new(color.maroon, 90), \nSHORT_tp_plot            = plot(strategy.position_size < 0 and shortExitPrice > 0.0\nSHORT_sl_plot            = plot(strategy.position_size < 0 and shortSLExitPrice >\nfill(avg_position_price_plot, SHORT_tp_plot, color= color.new(color.olive, 90), \nfill(avg_position_price_plot, SHORT_sl_plot, color= color.new(color.maroon, 90),"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    I hope this strategy is just an idea and a starting point, I use the correlation of the Sp500 with the Btc , this does not mean that this correlation will exist forever!. I love Trading view and I'm learning to program, I find correlations very interesting and here is a simple strategy. This is a trading strategy script written in Pine Script language for use in TradingView. Here is a brief overview of the strategy: The script uses the RSI ( Relative Strength Index ) technical indicator with a period of 14 on two securities: the S&P 500 (SPX) and the symbol corresponding to the current chart (presumably Bitcoin , based on the variable name \"Btc_1h_fixed\"). The RSI is plotted on the chart for both securities. The script then sets up two trading conditions using the RSI values: A long entry condition: when the RSI for the current symbol crosses above the RSI for the S&P 500 , a long trade is opened using the \"strategy.entry\" function. A short entry condition: when the RSI for the current symbol crosses below the RSI for the S&P 500 , a short trade is opened using the \"strategy.entry\" function. The script also includes a take profit input parameter that allows the user to set a percentage profit target for closing the trade. The take profit is set using the \"strategy.exit\" function. Overall, the strategy aims to take advantage of divergences in RSI values between the current symbol and the S&P 500 by opening long or short trades accordingly. The take profit parameter allows the user to set a specific profit target for each trade. However, the script does not include any stop loss or risk management features, which should be considered when implementing the strategy in a real trading scenario."}, {"role": "assistant", "content": "//This strategy is just a starting point that serves to see the correlation between rsi SPX and rsi \n//@version=5\nstrategy(\"rsi fix\", overlay= false) // margin_long=100, margin_short=100)\n// Impostazione dell'input per il take profit\ntp_input = input.float(3, title=\"Take Profit %\")\nSpx_1h = request.security(\"SPX\", \"60\", ta.rsi(close, 14))\nBtc_1h_fixed = request.security(syminfo.tickerid, \"60\", ta.rsi(close, 14))\n// disegni trazdizionali\n// plot(Spx_1h, color=color.rgb(220, 228, 109), linewidth = 3)\n// plot(Btc_1h_fixed, color=color.rgb(162, 8, 189), linewidth = 3)\nlongCondition = ta.crossover(Btc_1h_fixed, Spx_1h)\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nshortCondition = ta.crossunder (Btc_1h_fixed, Spx_1h)\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)  \n// Impostazione del take profit\nstrategy.exit(\"My Long Entry Id\", \"My Long TP\", profit = strategy.position_avg_price\nstrategy.exit(\"My Short Entry Id\", \"My Short TP\", profit = strategy.position_avg_price\n// colorare gli spazi\ncolor1 = Spx_1h > Btc_1h_fixed ?  color.new(color.fuchsia,30) :  color.new(color.yellow\ncolor2 = Spx_1h > Btc_1h_fixed ?  color.red :  color.green\nplot1 = plot(Spx_1h, \"rsi 1h\", color=color2, linewidth = 2)\nplot2 = plot(Btc_1h_fixed, \"Btc_rsi\", color=color2, linewidth = 2)\nfill(plot1,plot2, color1)"}]}
{"messages": [{"role": "user", "content": "IMPORTANT: This script needs as much historic data as possible. Please run it on \t\t\tBTCUSD\t\t, \t\t\tBLX\t\t or another chart of sufficient length. MVRV The MVRV (Market Value to Realised Value Ratio) simply divides bitcoins market cap by bitcoins realized market cap. This was previously impossible on Tradingview but has now been made possible thanks to Coinmetrics providing us with the realized market cap data. In the free float version, the free float market cap is used instead of the regular market cap. Z-Score The MVRV Z-score divides the difference between Market cap and realized market cap by the historic standard deviation of the market cap. Historically, this has been insanely accurate at detecting bitcoin tops and bottoms: A Z-Score above 7 means bitcoin is vastly overpriced and at a local top. A Z-Score below 0.1 means bitcoin is underpriced and at a local bottom. In the free float version, the free float market cap is used instead of the regular market cap. The Z-Score, also known as the standard score is hugely popular in a wide range of mathematical and statistical fields and is usually used to measure the number of standard deviations by which the value of a raw score is above or below the mean value of what is being observed or measured. Credits MVRV Z Score initially created by aweandwonder MVRV initially created by Murad Mahmudov and David Puell"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Powerscooter\n//@version=5\nstrategy(\"MVRV Z Score and MVRV Free Float Z-Score\",shorttitle = \"MVRV Z Score\",precision\n//Inputs\nStrategymode = input.bool(false,\"Strategy Mode\",\"Switches between indicator and strategy mode.\"\nCalculation = input.string(\"Standard\", \"Calculation Method\",options = [\"Standard\",\"Free Float\"\nSource = input.string(\"Glassnode\", \"Market Cap Source\",options = [\"Glassnode\",\"Coinmetrics\"\nUpper = input.float(7.0,\"Upper Line\",tooltip=\"Z-Score value above which a sell signal is given,\nLower = input.float(0.1,\"Lower Line\",tooltip=\"Z-Score value below which a buy signal is given, \n//Query\nMC1 = request.security(\"GLASSNODE:BTC_MARKETCAP\",\"D\",close)\nMC2 = request.security(\"CRYPTOCAP:BTC\",\"D\",close)\nMCF = request.security(\"COINMETRICS:BTC_MARKETCAPFF\",\"D\",close)\nMCR = request.security(\"COINMETRICS:BTC_MARKETCAPREAL\",\"D\",close)\n//Initialize var\nvar float MC = 0\nvar MCA = array.new<float>()\nvar float MVRV = 0\nvar float Zscore = 0\n//Calculations\nif Source==\"Glassnode\"\n    MC := MC1\nelse\n    MC := MC2\narray.push(MCA,MC)\nStdDevA = array.stdev(MCA)\nif Calculation==\"Standard\"\n    MVRV := MC/MCR\nif Calculation==\"Free Float\"\n    MVRV := MCF/MCR\nif Calculation==\"Standard\"  \n    Zscore := (MC-MCR)/StdDevA\nif Calculation==\"Free Float\"  \n    Zscore := (MCF-MCR)/StdDevA\n//Plotting\nMVRVplot = plot(MVRV, \"MVRV\", color= color.blue,transp=40)\nZplot = plot(Zscore, \"Z-score\",color= color.yellow,linewidth = 2)\nUpperLine = Zscore>=Upper?Upper:na\nLowerLine = Zscore<=Lower?Lower:na\n//Lower and UpperLine are undefined when Zscore isn't close to them so they don't affect panel scali\nUpperPlot = plot(UpperLine, transp=100, trackprice = true, color= color.red, display\nLowerPlot = plot(LowerLine, transp=100, trackprice = true, color= color.green, display\nfill(plot1=Zplot,plot2=UpperPlot,color= color.red, transp=30)\nfill(plot1=Zplot,plot2=LowerPlot,color= color.green, transp=30)\n//Order Conditions\nLong = ta.crossunder(Zscore,Lower)\nTakeProfit = ta.crossover(Zscore,Upper)\n//Execution\nif Long and Strategymode\n    strategy.entry(\"Long\",strategy.long)\nif TakeProfit and Strategymode\n    strategy.close(\"Long\")"}]}
{"messages": [{"role": "user", "content": "(FibMAI) Fibonacci Moving Averages Input is a strategy based on moving averages cross-over or cross-under signals. The bullish golden cross appears on a chart when a stock's short-term moving average crosses above its long-term moving average. The bearish death cross appears on a chart when a stock\u2019s short-term moving average, crosses below its long-term moving average. The general market consensus values used are the 50-day moving average and the 200-day moving average. With the (FibMAI) Fibonacci Moving Averages Input strategy you can use any value you choose for your bullish or bearish cross. For visual display purposes I have a lot of the Fib Moving Averages 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987 shown while hiding the chart candlesticks. But to use this indicator I click on only a couple of MA's to see if there's a notable cross-over or cross-under pattern signal. Then, most importantly, I back test those values into the FibMAI strategy Long or Short settings input. For example, this NQ1! day chart has it's Long or Short settings input as follows: Bullish = FibEMA34 cross-over FibEMA144 Bearish = FibEMA55 cross-under FibSMA144 As you can see you can mix or match 4 different MA's values either Exponential or Simple. Default color settings: Rising value = green color Falling value = red color Default Visual FibMA settings: FibEMA's 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181 Default Visual MA settings: SMA's 50, 100, 150, 200 Default Long or Short settings: Bullish = FibEMA34 cross-over FibEMA144 Bearish = FibEMA55 cross-under FibSMA144"}, {"role": "assistant", "content": "//@version=5\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Options360 : Fibonacci MAI (Moving Averages Input) beta 10/15/22\n// \u00a9 Options360 original public release = 2/25/23\n// * This script uses altered pieces of code from my @Options360 \"Fibonacci MA7\" indicator*\n// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711,\n////\nstrategy(title=\"Fibonacci Moving Averages Input\", shorttitle = \"FibMAI\", overlay=true\nsrc = input(ohlc4, 'source')\n//\nstring  GRP = \"Long or Short Settings\"\nexponential1 = input(true, title=\"long EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\nlong = input.int(34, minval=1, title=\"long\", tooltip=\"Signal Moving average long input\"\nlong1 = exponential1 ? ta.ema(src, long) : ta.sma(src, long)\nexponential2 = input(true, title=\"crossover EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\nlonger = input.int(144, minval=1, title=\"crossover\", tooltip=\"Crossed over Moving average long input\"\nlong2 = exponential2 ? ta.ema(src, longer) : ta.sma(src, longer)\nexponential3 = input(true, title=\"short EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\nshort = input.int(55, minval=1, title=\"short\", tooltip=\"Signal Moving average short input\"\nshort1 = exponential3 ? ta.ema(src, short) : ta.sma(src, short)\nexponential4 = input(false, title=\"crossunder EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\nshorter = input.int(144, minval=1, title=\"crossunder\", tooltip=\"Crossed under Moving average short input\"\nshort2 = exponential4 ? ta.ema(src, shorter) : ta.sma(src, shorter)\n//\nstring  GRP2 = \"Visual FibMA Settings\"\nexponential = input(true, title=\"Fib EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\n//\nsmaplot11 = input (true, title=\"MA1\")\nlen11 = input.int(1, minval=1, title=\"ma Length\")\nout11 = exponential ? ta.ema(src, len11) : ta.sma(src, len11)\nup11 = out11 > out11[1]\ndown11 = out11 < out11[1]\nmycolor11 = up11 ?  #3cfe12 : down11 ?  #ff0202 :  #008eff\nplot(out11 and smaplot11 ? out11 :na, title=\"1\", color=mycolor11, linewidth=1)\nsmaplot18 = input (true, title=\"MA2\")\nlen18 = input.int(2, minval=1, title=\"ma Length\")\nout18 = exponential ? ta.ema(src, len18) : ta.sma(src, len18)\nup18 = out18 > out18[1]\ndown18 = out18 < out18[1]\nmycolor18 = up18 ?  #3cfe12 : down18 ?  #ff0202 :  #008eff\nplot(out18 and smaplot18 ? out18 :na , title=\"2\", color=mycolor18, linewidth=1)\nsmaplot13 = input (true, title=\"MA3\")\nlen13 = input.int(3, minval=1, title=\"ma Length\")\nout13 = exponential ? ta.ema(src, len13) : ta.sma(src, len13)\nup13 = out13 > out13[1]\ndown13 = out13 < out13[1]\nmycolor13 = up13 ?  #3cfe12 : down13 ?  #ff0202 :  #008eff\nplot(out13 and smaplot13 ? out13 :na , title=\"3\", color=mycolor11, linewidth=1)\nsmaplot9 = input (true, title=\"MA5\")\nlen9 = input.int(5, minval=1, title=\"ma Length\")\nout9 = exponential ? ta.ema(src, len9) : ta.sma(src, len9)\nup9 = out9 > out9[1]\ndown9 = out9 < out9[1]\nmycolor9 = up9 ?  #3cfe12 : down9 ?  #ff0202 :  #008eff\nplot(out9 and smaplot9 ? out9 :na , title=\"5\", color=mycolor9, linewidth=1)\nsmaplot8 = input (true, title=\"MA8\")\nlen8 = input.int(8, minval=1, title=\"ma Length\")\nout8 = exponential ? ta.ema(src, len8) : ta.sma(src, len8)\nup8 = out8 > out8[1]\ndown8 = out8 < out8[1]\nmycolor8 = up8 ?  #3cfe12 : down8 ?  #ff0202 :  #008eff\nplot(out8 and smaplot8 ? out8 :na , title=\"8\", color=mycolor8, linewidth=1)\nsmaplot7 = input (true, title=\"MA13\")\nlen7 = input.int(13, minval=1, title=\"ma Length\")\nout7 = exponential ? ta.ema(src, len7) : ta.sma(src, len7)\nup7 = out7 > out7[1]\ndown7 = out7 < out7[1]\nmycolor7 = up7 ?  #3cfe12 : down7 ?  #ff0202 :  #008eff\nplot(out7 and smaplot7 ? out7 :na , title=\"13\", color=mycolor7, linewidth=1)\nsmaplot = input (true, title=\"MA21\")\nlen = input.int(21, minval=1, title=\"ma Length\")\nout = exponential ? ta.ema(src, len) : ta.sma(src, len)\nup = out > out[1]\ndown = out < out[1]\nmycolor = up ?  #3cfe12 : down ?  #ff0202 :  #008eff\nplot(out and smaplot ? out :na, title=\"21\", color=mycolor, linewidth=1)\nsmaplot2 = input (true, title=\"MA34\")\nlen2 = input.int(34, minval=1, title=\"ma Length\")\nout2 = exponential ? ta.ema(src, len2) : ta.sma(src, len2)\nup2 = out2 > out2[1]\ndown2 = out2 < out2[1]\nmycolor2 = up2 ?  #3cfe12 : down2 ?  #ff0202 :  #008eff\nplot(out2 and smaplot2 ? out2 :na , title=\"34\", color=mycolor2, linewidth=1)\nsmaplot3 = input (true, title=\"MA55\")\nlen3 = input.int(55, minval=1, title=\"ma Length\")\nout3 = exponential ? ta.ema(src, len3) : ta.sma(src, len3)\nup3 = out3 > out3[1]\ndown3 = out3 < out3[1]\nmycolor3 = up3 ?  #3cfe12 : down3 ?  #ff0202 :  #008eff\nplot(out3 and smaplot3 ? out3 :na, title=\"55\", color=mycolor3, linewidth=1)\nsmaplot4 = input (true, title=\"MA89\")\nlen4 = input.int(89, minval=1, title=\"ma Length\")\nout4 = exponential ? ta.ema(src, len4) : ta.sma(src, len4)\nup4 = out4 > out4[1]\ndown4 = out4 < out4[1]\nmycolor4 = up4 ?  #3cfe12 : down4 ?  #ff0202 :  #008eff\nplot(out4 and smaplot4 ? out4 :na , title=\"89\", color=mycolor4, linewidth=1)\nsmaplot5 = input (true, title=\"MA144\")\nlen5 = input.int(144, minval=1, title=\"ma Length\")\nout5 = exponential ? ta.ema(src, len5) : ta.sma(src, len5)\nup5 = out5 > out5[1]\ndown5 = out5 < out5[1]\nmycolor5 = up5 ?  #3cfe12 : down5 ?  #ff0202 :  #008eff\nplot(out5 and smaplot5 ? out5 :na, title=\"144\", color=mycolor5, linewidth=1)\nsmaplot6 = input (true, title=\"MA233\")\nlen6 = input.int(233, minval=1, title=\"ma Length\")\nout6 = exponential ? ta.ema(src, len6) : ta.sma(src, len6)\nup6 = out6 > out6[1]\ndown6 = out6 < out6[1]\nmycolor6 = up6 ?  #3cfe12 : down6 ?  #ff0202 :  #008eff\nplot(out6 and smaplot6 ? out6 :na , title=\"233\", color=mycolor6, linewidth=1)\nsmaplot10 = input (true, title=\"MA377\")\nlen10 = input.int(377, minval=1, title=\"ma Length\")\nout10 = exponential ? ta.ema(src, len10) : ta.sma(src, len10)\nup10 = out10 > out10[1]\ndown10 = out10 < out10[1]\nmycolor10 = up10 ?  #3cfe12 : down10 ?  #ff0202 :  #008eff\nplot(out10 and smaplot10 ? out10 :na , title=\"377\", color=mycolor10, linewidth=1)\nsmaplot14 = input (true, title=\"MA610\")\nlen14 = input.int(610, minval=1, title=\"ma Length\")\nout14 = exponential ? ta.ema(src, len14) : ta.sma(src, len14)\nup14 = out14 > out14[1]\ndown14 = out14 < out14[1]\nmycolor14 = up14 ?  #3cfe12 : down14 ?  #ff0202 :  #008eff\nplot(out14 and smaplot14 ? out14 :na , title=\"610\", color=mycolor14, linewidth=1)\nsmaplot15 = input (true, title=\"MA987\")\nlen15 = input.int(987, minval=1, title=\"ma Length\")\nout15 = exponential ? ta.ema(src, len15) : ta.sma(src, len15)\nup15 = out15 > out15[1]\ndown15 = out15 < out15[1]\nmycolor15 = up15 ?  #3cfe12 : down15 ?  #ff0202 :  #008eff\nplot(out15 and smaplot15 ? out15 :na , title=\"987\", color=mycolor15, linewidth=1)\nsmaplot16 = input (true, title=\"MA1597\")\nlen16 = input.int(1597, minval=1, title=\"ma Length\")\nout16 = exponential ? ta.ema(src, len16) : ta.sma(src, len16)\nup16 = out16 > out16[1]\ndown16 = out16 < out16[1]\nmycolor16 = up16 ?  #3cfe12 : down16 ?  #ff0202 :  #008eff\nplot(out16 and smaplot16 ? out16 :na , title=\"1597\", color=mycolor16, linewidth=1)\nsmaplot17 = input (true, title=\"MA2584\")\nlen17 = input.int(2584, minval=1, title=\"ma Length\")\nout17 = exponential ? ta.ema(src, len17) : ta.sma(src, len17)\nup17 = out17 > out17[1]\ndown17 = out17 < out17[1]\nmycolor17 = up17 ?  #3cfe12 : down17 ?  #ff0202 :  #008eff\nplot(out17 and smaplot17 ? out17 :na , title=\"2584\", color=mycolor17, linewidth=1)\nsmaplot19 = input (true, title=\"MA4181\")\nlen19 = input.int(4181, minval=1, title=\"ma Length\")\nout19 = exponential ? ta.ema(src, len19) : ta.sma(src, len19)\nup19 = out19 > out19[1]\ndown19 = out19 < out19[1]\nmycolor19 = up19 ?  #3cfe12 : down19 ?  #ff0202 :  #008eff\nplot(out19 and smaplot19 ? out19 :na , title=\"4181\", color=mycolor19, linewidth=1)\n//\nstring  GRP3 = \"Visual MA Settings\"\nexponential5 = input(false, title=\"EMA or SMA\", tooltip=\"EMA checked or SMA unchecked\"\nsmaplot50 = input (true, title=\"MA50\")\nlen50 = input.int(50, minval=1, title=\"ma Length\")\nma50 = exponential5 ? ta.ema(src, len50) : ta.sma(src, len50)\nup50 = ma50 > ma50[1]\ndown50 = ma50 < ma50[1]\nmycolor50 = up50 ?  #3cfe12 : down50 ?  #ff0202 :  #008eff\nplot(ma50 and smaplot50 ? ma50 :na , title=\"50\", color=mycolor50, linewidth=1)\nsmaplot100 = input (true, title=\"MA100\")\nlen100 = input.int(100, minval=1, title=\"ma Length\")\nma100 = exponential5 ? ta.ema(src, len100) : ta.sma(src, len100)\nup100 = ma100 > ma100[1]\ndown100 = ma100 < ma100[1]\nmycolor100 = up100 ?  #3cfe12 : down100 ?  #ff0202 :  #008eff\nplot(ma100 and smaplot100 ? ma100 :na , title=\"100\", color=mycolor100, linewidth=1\nsmaplot150 = input (true, title=\"MA150\")\nlen150 = input.int(150, minval=1, title=\"ma Length\")\nma150 = exponential5 ? ta.ema(src, len150) : ta.sma(src, len150)\nup150 = ma150 > ma150[1]\ndown150 = ma150 < ma150[1]\nmycolor150 = up150 ?  #3cfe12 : down150 ?  #ff0202 :  #008eff\nplot(ma150 and smaplot150 ? ma150 :na , title=\"150\", color=mycolor150, linewidth=1\nsmaplot200 = input (true, title=\"MA200\")\nlen200 = input.int(200, minval=1, title=\"ma Length\")\nma200 = exponential5 ? ta.ema(src, len200) : ta.sma(src, len200)\nup200 = ma200 > ma200[1]\ndown200 = ma200 < ma200[1]\nmycolor200 = up200 ?  #3cfe12 : down200 ?  #ff0202 :  #008eff\nplot(ma200 and smaplot200 ? ma200 :na , title=\"200\", color=mycolor200, linewidth=1\n//\nif (ta.crossover(long1, long2))\n    strategy.entry(\"maL\", strategy.long, comment=\"maLong\")\nif (ta.crossunder(short1, short2))\n    strategy.entry(\"maS\", strategy.short, comment=\"maShort\")\n////"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Just a small change. Now you can use a stop loss based in last swing high/low :)                                                    Release Notes:                        You can now choose if you want to use take profits or not. This is useful in some assets like Banknifty with stoplosses based in last swing high/low"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n//@version=5\n//Developed by StrategiesForEveryone\nstrategy(\"UT Bot alerts strategy\", overlay=true, process_orders_on_close = true, initial_capital\n// ------ Inputs for calculating position --------\ninitial_actual_capital = input.float(defval=10000, title = \"Enter initial/current capital\"\nrisk_c = input.float(2.5, '% account risk per trade', step=1, group = \"============ Calculate amount position ==========\n// ------ Date filter (obtained from ZenAndTheArtOfTrading) ---------\ninitial_date = input.time(title=\"Initial date\", defval=timestamp(\"10 Feb 2014 13:30 +0000\"\nfinal_date   = input.time(title=\"Final date\", defval=timestamp(\"01 Jan 2030 19:30 +0000\"\ndateFilter(int st, int et) => time >= st and time <= et\ncolorDate = input.bool(defval=false, title=\"Date background\", tooltip = \"Add color to the period of time of the strategy t\nbgcolor(colorDate and dateFilter(initial_date, final_date) ? color.new( color.blue\n// ------ Session limits (obtained from ZenAndTheArtOfTrading) -------\ntimeSession = input.session(title=\"Time session\", defval=\"0000-2400\", group=\"============ Time filter ============ \"\ncolorBG     = input.bool(title=\"Session background\", defval=false, tooltip = \"Add color to session time background\"\ninSession(sess) => na(time(timeframe.period, sess + ':1234567')) == false\nbgcolor(inSession(timeSession) and colorBG ?  color.rgb(0, 38, 255, 84) : na)\n// ----------- Ema ----------------------\nema = input.int(200, title='Ema length', minval=1, maxval=500, group = \"============ Trend ============\"\nema200 = ta.ema(close, ema)\nbullish = close > ema200\nbearish = close < ema200\nshow_ema = input.bool(defval=false, title=\"Show ema ?\", group = \"============ Appearance ============\"\nplot(show_ema ? ema200 : na, title = \"Ema\", color= color.white, linewidth=2, display\n// -------------- UT BOT ALERTS INDICATOR by @QuantNomad -------------------------\n// Inputs\na = input(3, title='Key Vaule', group = \"============ UT BOT ALERTS ============\",\nc = input(1, title='ATR Period', group = \"============ UT BOT ALERTS ============\"\nh = input(false, title='Signals from Heikin Ashi Candles', group = \"============ UT BOT ALERTS ============\"\nxATR = ta.atr(c)\nnLoss = a * xATR\nsrc = h ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, \nxATRTrailingStop = 0.0\niff_1 = src > nz(xATRTrailingStop[1], 0) ? src - nLoss : src + nLoss\niff_2 = src < nz(xATRTrailingStop[1], 0) and src[1] < nz(xATRTrailingStop[1], 0) ?\nxATRTrailingStop := src > nz(xATRTrailingStop[1], 0) and src[1] > nz(xATRTrailingStop\nshow_atr_ut = input.bool(defval=false, title=\"Show atr from ut bot alerts ?\", group\nplot(show_atr_ut ? xATRTrailingStop : na, color =  color.orange, linewidth = 2, display\npos = 0\niff_3 = src[1] > nz(xATRTrailingStop[1], 0) and src < nz(xATRTrailingStop[1], 0) ?\npos := src[1] < nz(xATRTrailingStop[1], 0) and src > nz(xATRTrailingStop[1], 0) ? \nxcolor = pos == -1 ?  color.red : pos == 1 ?  color.green :  color.blue\nema_ut = ta.ema(src, 1)\nshow_ema_ut = input.bool(defval=false, title=\"Show ema from ut bot alerts ?\", group\nplot(show_ema_ut ? ema_ut : na, color =  color.white, linewidth = 2, display = display.all\nabove = ta.crossover(ema_ut, xATRTrailingStop)\nbelow = ta.crossover(xATRTrailingStop, ema_ut)\nbuy = src > xATRTrailingStop and above\nsell = src < xATRTrailingStop and below\nclose_buy = src < xATRTrailingStop and below\nclose_sell = src > xATRTrailingStop and above\nbarbuy = src > xATRTrailingStop\nbarsell = src < xATRTrailingStop\nshow_signals = input.bool(true, title = \"Show signals ?\", group = \"============ Appearance ============\"\npaint_candles = input.bool(false, title = \"Paint candles ?\", group = \"============ Appearance ============\"\nplotshape(bullish and show_signals ? buy : na, title='Buy', text='Buy', style=shape.labelup\nplotshape(bearish and show_signals ? sell : na, title='Sell', text='Sell', style=shape.labeldown\nplotshape(bullish and show_signals ? close_buy : na, title='Close Buy', text='Cl Buy'\nplotshape(bearish and show_signals ? close_sell : na, title='Close Sell', text='Cl Sell'\nbarcolor(barbuy and paint_candles ?  color.green : na)\nbarcolor(barsell and paint_candles ?  color.red : na)\n// -------------- Atr stop loss by garethyeo (modified) -----------------\nlong_condition_atr = src > xATRTrailingStop and above \nshort_condition_atr = src < xATRTrailingStop and below \nsource_atr = input(close, title='Source', group = \"============ Atr stop loss ============\"\nlength_atr = input.int(14, minval=1, title='Period', group = \"============ Atr stop loss ============\"\nmultiplier = input.float(1.5, minval=0.1, step=0.1, title='Atr multiplier', group \nshow_stoploss = input.bool(defval = true, title = \"Show stop loss ?\", group = \"============ Appearance ============\"\nvar float shortStopLoss = na\nvar float longStopLoss = na \nvar float atr_past_candle_long = na\nvar float atr_past_candle_short = na\n//shortStopLoss = source_atr + ta.atr(length_atr) * multiplier\n//longStopLoss = source_atr - ta.atr(length_atr) * multiplier\n//atr_past_candle_short = close[1] + ta.atr(length_atr)[1] * multiplier[1]\n//atr_past_candle_long = close[1] - ta.atr(length_atr)[1] * multiplier[1]\ncandle_of_stoploss = input.string(defval = \"Current candle\", title = \"Stop loss source for atr stoploss\"\nif candle_of_stoploss == \"Current candle\"\n    shortStopLoss := source_atr + ta.atr(length_atr) * multiplier\n    longStopLoss := source_atr - ta.atr(length_atr) * multiplier\nif candle_of_stoploss == \"Past candle\"\n    shortStopLoss := close[1] + ta.atr(length_atr)[1] * multiplier[1]\n    longStopLoss := close[1] - ta.atr(length_atr)[1] * multiplier[1]\n// --------- Stop loss based in last swing high/low --------\nhigh_bars = input.int(defval = 10, title = \"Highest price bars: \", group = \"============ Swing highs/lows stop losses =======\nlow_bars = input.int(defval = 10, title = \"Lowest price bars: \", group = \"============ Swing highs/lows stop losses =======\nstop_high = ta.highest(high, high_bars)\nstop_low = ta.lowest(low, low_bars)\n// --------- Stop loss source selection ---------------\nstoploss_type = input.string(defval = \"Atr stop loss\", title = \"General stop loss source\"\nif stoploss_type == \"Atr stop loss\"\n    shortStopLoss := source_atr + ta.atr(length_atr) * multiplier\n    longStopLoss := source_atr - ta.atr(length_atr) * multiplier\nif candle_of_stoploss == \"Past candle\" and stoploss_type == \"Atr stop loss\"\n    shortStopLoss := close[1] + ta.atr(length_atr)[1] * multiplier[1]\n    longStopLoss := close[1] - ta.atr(length_atr)[1] * multiplier[1]\nif stoploss_type == \"Swing high/low\"\n    shortStopLoss := stop_high\n    longStopLoss := stop_low\n// Ploting stop losses\nplot(show_stoploss and long_condition_atr and bullish ? longStopLoss : na, color =\nplot(show_stoploss and short_condition_atr and bearish ? shortStopLoss : na, color\n// ------------- Money management --------------\nstrategy_contracts = strategy.equity / close\ndistance_sl_atr_long = -1 * (longStopLoss - close) / close\ndistance_sl_atr_short = (shortStopLoss - close) / close\nrisk = input.float(2.5, '% Account risk per trade for backtesting', step=1, group \nlong_amount = strategy_contracts * (risk / 100) / distance_sl_atr_long\nshort_amount = strategy_contracts * (risk / 100) / distance_sl_atr_short\n// ---- Fixed amounts ----\n//fixed_amounts = input.bool(defval = false, title = \"Fixed amounts ?\", group = \"============ Risk m\n//fixed_amount_input = input.float(defval = 1000, title = \"Fixed amount in usd\", group = \"==========\n//if fixed_amounts \n//    long_amount := fixed_amount_input / close\n//if fixed_amounts\n//    short_amount := fixed_amount_input / close\n//\nleverage=input.bool(defval=true, title=\"Use leverage for backtesting ?\", group = \"============ Risk management for trades =========\nif not leverage and long_amount>strategy_contracts\n    long_amount:=strategy.equity/close\nif not leverage and short_amount>strategy_contracts\n    short_amount:=strategy.equity/close\n// ---------- Risk management ---------------\nrisk_reward_breakeven_long= input.float(title=\"Risk/reward for breakeven long\", defval\nrisk_reward_take_profit_long= input.float(title=\"Risk/reward for take profit long\"\nrisk_reward_breakeven_short= input.float(title=\"Risk/reward for break even short\",\nrisk_reward_take_profit_short= input.float(title=\"Risk/reward for take profit short\"\ntp_percent=input.float(title=\"% of trade for first take profit\", defval=50, step=5\n// ------------ Trade conditions ---------------\nbullish := close > ema200\nbearish := close < ema200\nbought = strategy.position_size > 0\nsold = strategy.position_size < 0\nbuy  := src > xATRTrailingStop and above \nsell := src < xATRTrailingStop and below \nvar float sl_long = na\nvar float sl_short = na \nvar float be_long = na\nvar float be_short = na\nvar float tp_long = na\nvar float tp_short = na\nif not bought\n    be_long:=na\n    sl_long:=na\n    tp_long:=na\nif not sold\n    be_short:=na\n    sl_short:=na\n    tp_short:=na\nlong_positions = input.bool(defval = true, title = \"Long positions ?\", group = \"============ Positions management ============\"\nshort_positions = input.bool(defval = true, title = \"Short positions ?\", group = \"============ Positions management ============\"\nuse_takeprofit = input.bool(defval = true, title = \"Use take profit ?\", group = \"============ Risk management for trades =========\n// ======================= Strategy ================================================================\n// Long position with take profit\nif not bought and buy and dateFilter(initial_date, final_date) and long_positions \n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    tp_long:=close+(long_stoploss_distance*risk_reward_take_profit_long)\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long\n    sl_long := strategy.position_avg_price\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0\n    strategy.close(\"L\", comment=\"CL\")\n// Long position without take profit\nif not bought and buy and dateFilter(initial_date, final_date) and long_positions \n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long\n    sl_long := strategy.position_avg_price\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and sell and strategy.openprofit>0\n    strategy.close(\"L\", comment=\"CL\")\n// Short position with take profit\nif not sold and sell and dateFilter(initial_date, final_date) and short_positions \n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    tp_short:=((short_stoploss_distance*risk_reward_take_profit_short)-close)*-1\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short \n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)    \nif sold and buy and strategy.openprofit>0\n    strategy.close(\"S\", comment=\"CS\") \n// Short position without take profit\nif not sold and sell and dateFilter(initial_date, final_date) and short_positions \n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, qty_percent=tp_percent)\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short \n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, qty_percent=tp_percent)\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)    \nif sold and buy and strategy.openprofit>0\n    strategy.close(\"S\", comment=\"CS\") \n// =================================================================================================\n// ---------- Draw positions and signals on chart (strategy as an indicator) -------------\nif high>tp_long\n    tp_long:=na\nif low<tp_short\n    tp_short:=na\nif high>be_long\n    be_long:=na\nif low<be_short\n    be_short:=na\nshow_position_on_chart = input.bool(defval=true, title=\"Draw position on chart ?\",\nposition_price = plot(show_position_on_chart? strategy.position_avg_price : na, style\nsl_long_price = plot(show_position_on_chart and bought ? sl_long : na, style = plot.style_linebr\nsl_short_price = plot(show_position_on_chart and sold ? sl_short : na, style = plot.style_linebr\ntp_long_price = plot(strategy.position_size>0 and show_position_on_chart and use_takeprofit\ntp_short_price = plot(strategy.position_size<0 and show_position_on_chart and use_takeprofit\nbreakeven_long = plot(strategy.position_size>0 and high<be_long and show_position_on_chart\nbreakeven_short = plot(strategy.position_size<0 and low>be_short and show_position_on_chart\nshow_break_even_on_chart = input.bool(defval=true, title=\"Draw first take profit/breakeven price on chart ?\nlong_stoploss_distance = close - longStopLoss\nshort_stoploss_distance=shortStopLoss - close\nbe_long_plot = close + long_stoploss_distance * risk_reward_breakeven_long\nbe_short_plot =((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\nplot(show_break_even_on_chart and buy and bullish? be_long_plot : na, color= color.new\nplot(show_break_even_on_chart and sell and bearish? be_short_plot : na, color= color.new\nposition_profit_long = plot(bought and show_position_on_chart and strategy.openprofit\nposition_profit_short = plot(sold and show_position_on_chart and strategy.openprofit\nfill(plot1 = position_price, plot2 = position_profit_long, color =  color.new(#4cd350\nfill(plot1 = position_price, plot2 = position_profit_short, color =  color.new(#4cd350\nfill(plot1 = position_price, plot2 = sl_long_price, color =  color.new(color.red,\nfill(plot1 = position_price, plot2 = sl_short_price, color =  color.new(color.red\nfill(plot1 = position_price, plot2 = tp_long_price, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = tp_short_price, color =  color.new(color.green\n// --------------- Positions amount calculator  -------------\ncontracts_amount_c = initial_actual_capital / close\ndistance_sl_long_c = -1 * (longStopLoss - close) / close \ndistance_sl_short_c = (shortStopLoss - close) / close\nlong_amount_c = close * (contracts_amount_c * (risk_c / 100) / distance_sl_long_c)\nshort_amount_c = close * (contracts_amount_c * (risk_c / 100) / distance_sl_short_c\nlong_amount_lev = close * (contracts_amount_c * (risk_c / 100) / distance_sl_long_c\nshort_amount_lev = close * (contracts_amount_c * (risk_c / 100) / distance_sl_short_c\nleverage_for_calculator=input.bool(defval=true, title=\"Use leverage ?\", group = \"============ Calculate amount position ==========\nif not leverage_for_calculator and long_amount_lev>initial_actual_capital\n    long_amount_lev:=initial_actual_capital\nif not leverage_for_calculator and short_amount_lev>initial_actual_capital\n    short_amount_lev:=initial_actual_capital\nplot(buy and leverage_for_calculator ? long_amount_c : na, color =  color.rgb(136\nplot(sell and leverage_for_calculator ? short_amount_c : na, color =  color.rgb(136\nplot(buy and not leverage_for_calculator ? long_amount_lev : na, color =  color.rgb\nplot(sell and not leverage_for_calculator ? short_amount_lev : na, color =  color.rgb"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Updated the strategy. removed Ema filter . added stop loss and target (defined by the user ) based on the entry price().  the strategy performed, at least in the past, although obviously there is no guarantee that it will make money in the future. Always Future Test (Paper Trade) the new strategy.                                                    Release Notes:                        Quick Summary This is a trading strategy script written in Pine Script language for trading the NIFTY 50 index in the 5-minutes time frame. The strategy is based on breakout trading where the high and low of the first candle of the session are used as breakout levels. The script has inputs to define the start and end dates of the backtesting period, the trading session, the stop loss and target levels, the maximum number of trades, and the trade direction. The script also tracks the number of trades taken and submits buy/sell orders based on signals and maximum trades. The script has some functions such as is_newbar() which checks if a new bar has formed, strategy.entry() to enter a long or short position, and strategy.close() to close a position. The script also uses variables such as counter_call and counter_put to track the number of trades taken and First_high and First_low to store the high and low of the first candle of the session. Overall, the script is a simple breakout trading strategy that can be easily customized based on the user's preferences. However, it is important to note that trading strategies should be backtested thoroughly and validated before being used in live trading."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"NIFTY 50 5mint Strategy\", overlay = true)\n//Backtest Date \nstart_date = input.time(title=\"Start Date\", defval=timestamp(\"01 Jan 2022 00:00:00\"\nend_date = input.time(title=\"End Date\", defval=timestamp(\"01 Dec 2023 23:59:59\"))\n//session input\nsess = input.session(\"0915-1515\", title=\"Session Time/Intraday Time\", group = \"Indian Session\"\nsess1 = input.session(\"0915-0916\",  title=\"Breakout Candle Time\", group = \"Indian Session\"\n//stoploss and target for Long\nusestopLossCE = input(true, \"Use Stoploss Fixed Points for BUY/CE?\", group=\"StopLoss and Target For Long\"\nstopLoss = usestopLossCE ? input(20, \"Stop Loss\", group=\"StopLoss and Target For Long\"\nuseTargetCE = input(true, \"Use Target Fixed Points for BUY/CE?\", group=\"StopLoss and Target For Long\"\ntarget = useTargetCE? input(150, \"Target\", group=\"StopLoss and Target For Long\"): \n//stoploss and target for Short\nusestopLossPE = input(true, \"Use Stoploss Fixed Points For SELL/PE?\", group=\"StopLoss and Target For Short\"\nstopLoss1 = usestopLossPE ? input(20, \"Stop Loss\", group=\"StopLoss and Target For Short\"\nuseTargetPE = input(true, \"Use Target Fixed Points for SELL/PE?\", group=\"StopLoss and Target For Short\"\ntarget1 = useTargetPE? input(150, \"Target\", group=\"StopLoss and Target For Short\")\n//Option to take either Long and Short\ntradeDirection = input.string(title=\"Trade Direction \", options=[\"Long\", \"Short\", \n//number of trades\nmax_trades_call = input.int(1, minval=1, title=\"Max Trades buy/CE\", group = \"Maximum Numbers of Trades\"\nmax_trades_put = input.int(1, minval=1, title=\"Max Trades sell/PE\", group = \"Maximum Numbers of Trades\"\n//session\nt=time(timeframe.period, sess1 + \":1234567\")\ntt = time(timeframe.period, sess + \":1234567\")\nis_newbar(res) => ta.change(time(res)) != 0\nsession = not na(t)\nat_opening  = session and not session[1]\ntimerange=not na(tt)\ninDateRange = ((time >= start_date)  and timerange ) and ((time  <= end_date)and timerange\nlimit_session = time(\"D\")\n// Define the trade counter\nvar counter_call = 0\nvar counter_put = 0\n// Execute trades based on signals\nif (limit_session != limit_session[1])\n    counter_call := 0\n    counter_put  := 0\n//First candle high and Low calculation\nFirst_high = float(na)\nFirst_low = float(na)\nif at_opening \n    First_high := high\n    First_low := low\nelse\n    First_high := First_high[1]\n    First_low := First_low[1]\nif high > First_high and session\n    First_high := high\nif low < First_low and session\n    First_low := low\nCEX=First_high\nPEX=First_low\n// stoploss \nentryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\n//stop and target based on entry price\nStopCE=entryPrice - stopLoss\nStopPE= entryPrice + stopLoss1\ntargetCE= entryPrice + target\ntargetPE=entryPrice - target1\nuse5mint_stopLoss = input(true, \"Use High Breakout of 1st candle as Sl?\", group=\"StopLoss and Target For Long\"\nstopLoss5min = use5mint_stopLoss ? CEX: na\nuse5mint_stopLoss1 = input(true, \"Use Low Breakout of 1st candle as Sl?\", group=\"StopLoss and Target For Short\"\nstopLoss5min1 = use5mint_stopLoss1 ? PEX: na\n//Long trade condition\nbuy_signal = close > First_high and close[1]< First_high[1] and is_newbar(\"1\") \nstopC=(close<stopLoss5min and is_newbar(\"1\"))  or close < StopCE or close > targetCE\n//Short trade condition\nsell_signal = close < First_low and close[1] > First_low[1] and is_newbar(\"1\") \nstopP=(close > stopLoss5min1 and is_newbar(\"1\")) or close > StopPE or close < targetPE\nlongOK  = (tradeDirection == \"Long\") or (tradeDirection == \"Both\")\nshortOK = (tradeDirection == \"Short\") or (tradeDirection == \"Both\")\n// Track the number of trades taken\n// Submit buy/sell orders based on signals and maximum trades\nif buy_signal and inDateRange and counter_call < max_trades_call and longOK\n    strategy.entry('Buy', strategy.long,  comment= \"buy/CE\")\n    counter_call := counter_call + 1\nif  (inDateRange  and stopC ) \n    strategy.close('Buy',comment= \"close\")\n   if sell_signal and inDateRange and counter_put < max_trades_put and shortOK \n    strategy.entry('Sell', strategy.short, comment= \"sell/PE\")\n    counter_put := counter_put + 1\nif  ( inDateRange and stopP )\n    strategy.close('Sell',comment= \"close\")\n    //Plot High and Low\nplot(First_high, style=plot.style_line, color=First_high[1] != First_high ? na :  \nplot(First_low, style=plot.style_line, color=First_low[1] != First_low ? na :  color.red\nif (not inDateRange )\n    strategy.close_all()"}]}
{"messages": [{"role": "user", "content": "This strategy buys when price crosses above an upper Bollinger Band and sells when the lower band is breached.  What makes this strategy different than others:  Long only with filtering for only showing strong tickers  Filter out trades below a moving average on both the current timeframe and a longer period timeframe to keep you out of bear markets  Optional ability to set a tighter initial stop level to increase exposure and decrease downside risk on freshly opened trades while you wait for the lower Bollinger Band trailing stop to catch up  Take entries/exits on wicks/stops or wait for candle closes before entry  Select which dates to backtest  Customize Bollinger Band parameters including the ability to have different values for the upper and lower band standard deviation"}, {"role": "assistant", "content": "//@version=5\n// Revision:        1\n// Author:          @millerrh\n// Strategy:  \n//      Entry: Buy when price breaks out of upper Bollinger Band\n//      Exit: Trail a stop with the lower Bollinger Band \n// Conditions/Variables:\n//    1. Can add a filter to only take setups that are above a user-defined moving average on curren\n//    2. Manually configure which dates to back test\n//    3. User-Configurable Bollinger Band Settings\n//    4. Optionally use a tighter initial stop level.  Once Bollinger Band catches up, trail with lo\n// strategy('Donchian Breakout', overlay=true, initial_capital=100000, currency='USD', default_qty_t\n//   default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1)\nstrategy('Bollinger Breakout', overlay=true, initial_capital=100000, currency='USD'\n  default_qty_value=100, commission_type=strategy.commission.percent, commission_value\n// === BACKTEST RANGE ===\nStart = input.time(defval = timestamp(\"01 Jan 2019 06:00 +0000\"), title = \"Backtest Start Date\"\nFinish = input.time(defval = timestamp(\"01 Jan 2100 00:00 +0000\"), title = \"Backtest End Date\"\n// == INPUTS ==\n// Bollinger Band Inputs\nbbLength = input.int(20, minval=1, group = \"Bollinger Band Settings\", title=\"Bollinger Band Length\"\n  tooltip = \"Bollinger Band moving average length.\")\nbbMultTop = input.float(2.0, minval=0.001, maxval=50, title=\"Standard Deviation (Top)\"\nbbMultBot = input.float(2.0, minval=0.001, maxval=50, title=\"Standard Deviation (Bottom)\"\nuseTightStop = input.bool(title='Use Fixed Percentage for Initial Stop?', defval=false\n  tooltip = \"'Keep your losers small and let winners run' is the saying.  This will allow you to use a tight ini\n  until the lower Bollinger Band catches up.\")\npercStop = input.int(title=\"Stop\", defval=8, group = \"order entry\", inline = \"perc\"\ntrigInput = input.string(title='Execute Trades On...', defval='Wick', options=['Wick'\n  tooltip = \"Useful for comparing standing stop orders at the Bollinger Band boundary (executing on the wick) vs\n// Moving Average Filtering Inputs\nuseMaFilter = input.bool(title='Use Moving Average for Filtering (Current Timeframe)?'\n  tooltip = \"Signals will be ignored when price is under this moving average.  The intent is to keep you out of \n             price is showing strength.\")\nmaType = input.string(defval='SMA', options=['EMA', 'SMA'], title='MA Type For Filtering'\nmaLength = input.int(defval=50, title=\"Moving Average: \u2007\u2007\u2007Length\", minval=1, group\nma1Color = input.color( color.new(color.green, 50), title = \"\u2007Color\", group = \"moving average filtering\"\nuseMaFilter2 = input.bool(title='Use Moving Average for Filtering (High Timeframe)\ntfSet = input.timeframe(defval=\"D\", title=\"Timeframe of Moving Average\", group = \"moving average filtering\"\n  tooltip = \"Allows you to set a different time frame for a moving average filter.  Trades will be ignored when \n  The idea is to keep your eye on the larger moves in the market and stay on the right\n  the stocks you trade.\")\nma2Type = input.string(defval='SMA', options=['EMA', 'SMA'], title='MA Type For Filtering'\nma2Length = input.int(defval=50, title=\"Moving Average: \u2007\u2007\u2007Length\", minval=1, group\nma2Color = input.color( color.new(color.white, 50), title = \"\u2007Color\", group = \"moving average filtering\"\n// === THE BOLLINGER BAND ===\n// Logic\nbbBasis = ta.sma(close, bbLength)\nbbUpper = bbBasis + bbMultTop * ta.stdev(close, bbLength)\nbbLower = bbBasis - bbMultBot * ta.stdev(close, bbLength)\n// Plotting\nplot(bbBasis, \"Basis\", color= color.new(color.white, 50))\np1 = plot(bbUpper, color= color.new(color.blue, 50), linewidth=1, title='Upper Bollinger Band'\np2 = plot(bbLower, color= color.new(color.blue, 50), linewidth=1, title='Lower Bollinger Band'\nfill(p1, p2, title = \"Background\", color= color.rgb(33, 150, 243, 95))\n// == FILTERING LOGIC ==\n// Declare function to be able to swap out EMA/SMA\nma(maType, src, length) =>\n    maType == 'EMA' ? ta.ema(src, length) : ta.sma(src, length)  //Ternary Operator (if maType equals EMA, then do \nmaFilter = ma(maType, close, maLength)\nmaFilter2 = request.security(syminfo.tickerid, tfSet, ma(ma2Type, close, ma2Length\n// Plotting\nplot(useMaFilter ? maFilter : na, title='Trend Filter MA - CTF', color=ma1Color, linewidth\nplot(useMaFilter2 ? maFilter2 : na, title='Trend Filter MA - HTF', color=ma2Color,\n// == ENTRY AND EXIT CRITERIA ==\n// Trigger stop based on candle close or High/Low (i.e. Wick)\ntrigResistance = trigInput == 'Close' ? close : trigInput == 'Wick' ? high : na\ntrigSupport = trigInput == 'Close' ? close : trigInput == 'Wick' ? low : na\nbuySignal = trigResistance >= bbUpper \nbuyConditions = (useMaFilter ? bbUpper > maFilter : true) and\n  (useMaFilter2 ? bbUpper > maFilter2 : true) and\n  time > Start and time < Finish\n  // == STOP AND PRICE LEVELS ==\n// Configure initial stop level\ninPosition = strategy.position_size > 0\nstopLevel = strategy.position_avg_price - (strategy.position_avg_price * percStop/\nposStop = stopLevel > bbLower ? stopLevel : bbLower\n// Check if using stop vs. not\nstop = useTightStop ? posStop : bbLower\nplot(inPosition ? stop : na, style=plot.style_linebr, color= color.new(color.red,\nsellSignal = trigSupport <= stop\n// == STRATEGY ENTRIES & EXITS ==\n// This string of code enters and exits at the candle close\nif trigInput == 'Close'\n    strategy.entry('Long', strategy.long, when=buyConditions and buySignal)\n    strategy.close('Long', when=sellSignal)\n// This string of code enters and exits at the wick (i.e. with pre-set stops)\nif trigInput == 'Wick'\n    strategy.entry('Long', strategy.long, stop=bbUpper, when=buyConditions)\n    strategy.exit('Exit Long', from_entry='Long', stop=stop)\nstrategy.cancel('Long',when= not(buyConditions)) // Resets stop level once buyConditions aren't tru"}]}
{"messages": [{"role": "user", "content": "For trading ES on 30min Chart  Trading Rules Post Baseline Cross Qualifier (PBCQ): If price crosses the baseline but the trade is invalid due to additional qualifiers, then the strategy doesn't enter a trade on that candle. This setting allows you override this disqualification in the following manner: If price crosses XX bars ago and is now qualified by other qualifiers, then the strategy enters a trade. Volatility: If price crosses the baseline, we check to see how far it has moved in terms of multiples of volatility denoted in price (ATR x multiple). If price has moved by at least \"Qualifier multiplier\" and less than \"Range Multiplier\", then the strategy enters a trade. This range is shown on the chart with yellow area that tracks price above/blow the baseline. Also, see the dots at the top of the chart. If the dots are green, then price passes the volatility test for a long. If the dots are red, then price passes the volatility test for a short. Take Profit/Stoploss Quantity Removed 1 Take Profit: 100% of the trade is closed when the profit target or stoploss is reached. 2 Take Profits: Quantity is split 50/50 between Take Profit 1 and Take Profit 2 3 Take Profits: Quantify is split 50/25/25. Stratgey Inputs Baseline Length 37 Post Baseline Cross Qualifier Enabled On Post Baseline Cross Qualifier Bars Ago 9 ATR Length 9 Volatility Multiplier 0 Volatility Range Multiplier 10 Volatility Qualifier Multiplier 2 Take Profit Type 1 Take Profit HMA Length 11"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 sevencampbell\n//@version=5\nstrategy(title=\"Baseline Cross Qualifier Volatility Strategy with HMA Trend Bias\", \n// --- User Inputs ---\n// Baseline Inputs\nbaselineLength = input.int(title=\"Baseline Length\", defval=20)\nbaseline = ta.sma(close, baselineLength)\n// PBCQ Inputs\npbcqEnabled = input.bool(title=\"Post Baseline Cross Qualifier Enabled\", defval=true\npbcqBarsAgo = input.int(title=\"Post Baseline Cross Qualifier Bars Ago\", defval=3)\n// Volatility Inputs\natrLength = input.int(title=\"ATR Length\", defval=14)\nmultiplier = input.float(title=\"Volatility Multiplier\", defval=2.0)\nrangeMultiplier = input.float(title=\"Volatility Range Multiplier\", defval=1.0)\nqualifierMultiplier = input.float(title=\"Volatility Qualifier Multiplier\", defval=0.5\n// Take Profit Inputs\ntakeProfitType = input.string(title=\"Take Profit Type\", options=[\"1 Take Profit\", \"2 Take Profits\"\n// HMA Inputs\nhmaLength = input.int(title=\"HMA Length\", defval=50)\n// --- Calculations ---\n// ATR\natr = ta.atr(atrLength)\n// Range Calculation\nrangeHigh = baseline + rangeMultiplier * atr\nrangeLow = baseline - rangeMultiplier * atr\nrangeColor = rangeLow <= close and close <= rangeHigh ?  color.yellow : na\nbgcolor(rangeColor, transp=90)\n// Qualifier Calculation\nqualifier = qualifierMultiplier * atr\n// Dot Calculation\nisLong = close > baseline and (close - baseline) >= qualifier and close > ta.hma(close\nisShort = close < baseline and (baseline - close) >= qualifier and close < ta.hma(close\ncolorDot = isLong ?  color.green : isShort ?  color.red : na\nplot(isLong or isShort ? baseline : na, color=colorDot, style=plot.style_circles, linewidth\n// --- Strategy Logic ---\n// PBCQ\npbcqValid = not pbcqEnabled or low[pbcqBarsAgo] > baseline\n// Entry Logic\nlongCondition = isLong and pbcqValid\nshortCondition = isShort and pbcqValid\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n// Exit Logic\nif (takeProfitType == \"1 Take Profit\")\n    strategy.exit(\"TP/SL\", \"Long\", limit=rangeHigh, stop=rangeLow)\n    strategy.exit(\"TP/SL\", \"Short\", limit=rangeLow, stop=rangeHigh)\nelse if (takeProfitType == \"2 Take Profits\")\n    strategy.exit(\"TP1\", \"Long\", qty=strategy.position_size * 0.5, limit=rangeHigh \n    strategy.exit(\"TP2\", \"Long\", qty=strategy.position_size * 0.5, limit=rangeHigh)\n    strategy.exit(\"TP1\", \"Short\", qty=strategy.position_size * 0.5, limit=rangeLow \n    strategy.exit(\"TP2\", \"Short\", qty=strategy.position_size * 0.5, limit=rangeLow)\nelse if (takeProfitType == \"3 Take Profits\")\n    strategy.exit(\"TP1\", \"Long\", qty=strategy.position_size * 0.5, limit=rangeHigh \n    strategy.exit(\"TP2\", \"Long\", qty=strategy.position_size * 0.25, limit=rangeHigh\n    strategy.exit(\"TP3\", \"Long\", qty=strategy.position_size * 0.25, limit=rangeHigh"}]}
{"messages": [{"role": "user", "content": "Trading Bot V1, This code implements a combined trading strategy that uses several indicators and strategies to make buy and sell decisions in the market. The code is written in Pine Script\u2122, which is a programming language used in the TradingView platform. By BraelonWhitfield.Eth The strategy uses the Average Directional Movement Index (ADX) and the Pine SuperTrend indicator to identify trends and price movements in the market. The SuperTrend indicator is a popular technical analysis tool that helps to identify the direction of the current trend and provides entry and exit points for trades. The strategy also uses the Relative Strength Index (RSI) to identify overbought and oversold conditions in the market. The RSI is a momentum indicator that measures the speed and change of price movements in the market. The first part of the code defines the inputs for the ADX and DI Length, which are used to calculate the ADX and DI values. The dirmov() function is used to calculate the positive and negative directional indicators (plusDM and minusDM) based on the high and low prices. The truerange variable is then calculated using the True Range (TR) formula. Finally, the plus and minus variables are calculated using the smoothed moving average of the plusDM and minusDM values. The adx() function is then used to calculate the ADX values based on the plus and minus variables. The Pine SuperTrend indicator is defined using the pine_supertrend() function. This function uses the high-low average (hl2) and the Average True Range (ATR) to calculate the upper and lower bands for the indicator. The direction of the current trend is then determined based on whether the current price is above or below the upper or lower bands. The RSI values are then calculated using the ta.rsi() function, with the inputs for the close price and the RSI period. The overbought and oversold conditions are defined using the OB and OS inputs, which specify the threshold values for the RSI. The upTrend and downTrend variables are defined based on the direction of the Pine SuperTrend indicator. The next part of the code defines the 20-period Simple Moving Average (SMA) using the ta.sma() function. The os and ob variables are then calculated based on the RSI values and the OB and OS inputs. The strategy.entry() function is used to define the buy and sell orders based on the upTrend and downTrend variables, as well as the Pine SuperTrend indicator, the 20-period SMA, and the os variable. The final part of the code defines the Channel Breakout Strategy using the ta.highest() and ta.lowest() functions to calculate the upper and lower bounds of the channel. The strategy.entry() function is then used to define the buy and sell orders based on whether the current price is above or below the upper or lower bounds. In summary, this code implements a combined trading strategy that uses several indicators and strategies to make buy and sell decisions in the market. The strategy is designed to identify trends and price movements in the market, as well as overbought and oversold conditions, to provide entry and exit points for trades. The strategy uses the Pine SuperTrend indicator, the ADX and DI indicators, the RSI, and the 20-period SMA, as well as the Channel Breakout Strategy to make informed trading decisions."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Combined Strategy\", overlay=true, default_qty_value=100, initial_capital=\nadxlen = input(7, title=\"ADX Smoothing\")\ndilen = input(7, title=\"DI Length\")\ndirmov(len) =>\n    up = ta.change(high)\n    down = -ta.change(low)\n    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\n    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\n    truerange = ta.rma(ta.tr, len)\n    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)\n    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)\n    [plus, minus]\nadx(dilen, adxlen) =>\n    [plus, minus] = dirmov(dilen)\n    sum = plus + minus\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)\nsig = adx(dilen, adxlen)\n// The same on Pine Script\u2122\npine_supertrend(factor, atrPeriod) =>\n    src = hl2\n    atr = ta.atr(atrPeriod)\n    upperBand = src + factor * atr\n    lowerBand = src - factor * atr\n    prevLowerBand = nz(lowerBand[1])\n    prevUpperBand = nz(upperBand[1])\n    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand \n    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand \n    int direction = na\n    float superTrend = na\n    prevSuperTrend = superTrend[1]\n    if na(atr[1]) and ta.rsi(close, 21) < 66 and ta.rsi(close,3) > 80 and ta.rsi(close\n        direction := 1\n    else if prevSuperTrend == prevUpperBand\n        direction := close > upperBand ? -1 : 1\n    else\n        direction := close < lowerBand ? 1 : -1\n    superTrend := direction == -1 ? lowerBand : upperBand\n    [superTrend, direction]\n[pineSupertrend, pineDirection] = pine_supertrend(3, 10)\nupTrend = pineDirection < 0\ndownTrend = pineDirection > 0\n// Define the 20-period SMA\nsma20 = ta.sma(close, 20)\na = ta.rsi(close,14)\nOB = input(70)\nOS = input(30)\nos = a > OB\nob = a < OS\nif upTrend and close > pineSupertrend and close > sma20 and os\n    strategy.entry(\"Buy\", strategy.long)\nif ta.crossunder(close, sma20) or ob\n    strategy.close_all()\n//define when to breakout of channel \n//(\"ChannelBreakOutStrategy\", overlay=true)\nlength = input.int(title=\"Length\", minval=1, maxval=1000, defval=5)\nupBound = ta.highest(high, length)\ndownBound = ta.lowest(low, length)\nif (not na(close[length]))\n    strategy.entry(\"ChBrkLE\", strategy.long, stop=upBound + syminfo.mintick, comment\nstrategy.entry(\"ChBrkSE\", strategy.short, stop=downBound - syminfo.mintick, comment"}]}
{"messages": [{"role": "user", "content": "This is another simple strategy  based on ema  Entry Buy -  1) when close crossover ema then buy and only open one trade till it not close                    2) if previous buy trade is profitable open another trade and check again trade is profitable or not                    3)if trade is not profitable reset and wait for sell condition... Entry Sell  -1) when close crossunder ema then sell and only open one trade till it not close                    2) if previous sell trade is profitable open another trade and check again trade is profitable or not                    3) if trade is not profitable reset and wait for buy condition..... stop loss and take profit is percentage based ..."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Shauryam_or\n//@version=5\nstrategy('Ema Scalp', overlay=true)\n// Moving Averages to get some example trades generated\neg1 = ta.ema(close, 100)\nplot(eg1,color= color.aqua)\nlong = close>eg1\nshort = close<eg1\nvar countbuy=0\nif long\n    countbuy:=countbuy+1\nif strategy.position_size<0 \n    countbuy:=0\nvar countsell=0\nif short\n    countsell:=countsell+1\nif strategy.position_size>0 \n    countsell:=0\n////////////////////////////////\n// stratgey started\nif long and strategy.opentrades==0 and countbuy==1  // open first long when close>ema \n    strategy.entry(\"enter long\", strategy.long)\nif short and strategy.opentrades==0 and countsell==1 // open first short when close<ema\n    strategy.entry(\"enter short\", strategy.short)\n// checking last trade is long or short\nis_pos_closed = (strategy.position_size[1] != 0 and strategy.position_size == 0) or\nis_long = strategy.position_size > 0\nis_short = strategy.position_size < 0\nptrade_islong=is_pos_closed and is_long[1]\nptrade_isshort=is_pos_closed and is_short[1]\n// checking is last trade is profit\nvar lastTradeWasprofit = false\nif (strategy.wintrades[0] > strategy.wintrades[1])   \n    // last trade was a profit\n    lastTradeWasprofit := true\nif  (strategy.losstrades[0] > strategy.losstrades[1])  \n    // unsuccessful trade, reset\n    lastTradeWasprofit := false\n// if last trade is a long trade and loss and close>ema open 2nd trade long side\nnew_counnb=0\nnew_couns=0\nif   lastTradeWasprofit and ptrade_islong\n    new_counnb:=new_counnb+1\n    if   lastTradeWasprofit and ptrade_isshort\n    new_couns:=new_couns+1\nif   lastTradeWasprofit and ptrade_islong  \n    strategy.entry(\"El2\",strategy.long,comment =\"long\")\nif   lastTradeWasprofit and ptrade_isshort\n    strategy.entry(\"Es2\",strategy.short,comment =\"short\")\n//exit in percentage \n// User Options to Change Inputs (%)\nstopPer = input.float(0.8,step=0.1, title='Stop Loss %') / 100\ntakePer = input.float(1.0,step=0.1, title='Take Profit %') / 100\n// Determine where you've entered and in what direction\nlongStop  =strategy.position_avg_price * (1 - stopPer)\nshortStop =strategy.position_avg_price * (1 + stopPer)\nshortTake =strategy.position_avg_price * (1 - takePer)\nlongTake  =strategy.position_avg_price * (1 + takePer)\nif strategy.position_size > 0\n    strategy.exit(id='Close Long',from_entry = \"enter long\", stop=longStop, limit=\nif strategy.position_size < 0\n    strategy.exit(id='Close Short',from_entry = \"enter short\", stop=shortStop, limit\nif strategy.position_size > 0\n    strategy.exit(id='Close Long2',from_entry = \"El2\", stop=longStop, limit=longTake\nif strategy.position_size < 0\n    strategy.exit(id='Close Short2',from_entry = \"Es2\", stop=shortStop, limit=shortTake\n//PLOT FIXED SLTP LINE\nplot(strategy.position_size > 0 ? longStop : na, style=plot.style_linebr, color= \nplot(strategy.position_size < 0 ? shortStop : na, style=plot.style_linebr, color= \nplot(strategy.position_size > 0 ? longTake : na, style=plot.style_linebr, color= \nplot(strategy.position_size < 0 ? shortTake : na, style=plot.style_linebr, color="}]}
{"messages": [{"role": "user", "content": "Stop worrying about catching the lowest price, it's almost impossible!: with this trend-following strategy and protection from bearish phases, you will know how to enter the market properly to obtain benefits in the long term. Backtesting context: 1899-11-01 to 2023-02-16 of SPX by Tvc. Commissions: 0.05% for each entry, 0.05% for each exit. Risk per trade: 2.5% of the total account For this strategy, 5 indicators are used: One Ema of 200 periods  Atr Stop loss indicator from Gatherio Squeeze momentum indicator from LazyBear Moving average convergence/divergence or Macd  Relative strength index or Rsi  Trade conditions: There are three type of entries, one of them depends if we want to trade against a bearish trend or not.  ---If we keep Against trend option deactivated, the rules for two type of entries are:---  First type of entry:  With the next rules, we will be able to entry in a pull back situation: Squeeze momentum is under 0 line (red)  Close is above 200 Ema and close is higher than the past close  Histogram from macd is under 0 line and is higher than the past one  Once these rules are met, we enter into a buy position. Stop loss will be determined by atr stop loss (white point) and break even(blue point) by a risk/reward ratio of 1:1.  For closing this position: Squeeze momentum crosses over 0 and, until squeeze momentum crosses under 0, we close the position. Otherwise, we would have closed the position due to break even or stop loss. Second type of entry:  With the next rules, we will not lose a possible bullish movement: Close is above 200 Ema  Squeeze momentum crosses under 0 line  Once these rules are met, we enter into a buy position. Stop loss will be determined by atr stop loss (white point) and break even(blue point) by a risk/reward ratio of 1:1. Like in the past type of entry, for closing this position: Squeeze momentum crosses over 0 and, until squeeze momentum crosses under 0, we close the position. Otherwise, we would have closed the position due to break even or stop loss. ---If we keep Against trend option activated, the rules are the same as the ones above, but with one more type of entry. This is more useful in weekly timeframes, but could also be used in daily time frame:--- Third type of entry:  Close is under 200 Ema  Squeeze momentum crosses under 0 line  Once these rules are met, we enter into a buy position. Stop loss will be determined by atr stop loss (white point) and break even(blue point) by a risk/reward ratio of 1:1. Like in the past type of entries, for closing this position: Squeeze momentum crosses over 0 and, until squeeze momentum crosses under 0, we close the position. Otherwise, we would have closed the position due to break even or stop loss. Risk management For calculating the amount of the position you will use just a small percent of your initial capital for the strategy and you will use the atr stop loss for this. Example: You have 1000 usd and you just want to risk 2,5% of your account, there is a buy signal at price of 4,000 usd. The stop loss price from atr stop loss is 3,900. You calculate the distance in percent between 4,000 and 3,900. In this case, that distance would be of 2.50%. Then, you calculate your position by this way: (initial or current capital * risk per trade of your account) / (stop loss distance). Using these values on the formula: (1000*2,5%)/(2,5%) = 1000usd. It means, you have to use 1000 usd for risking 2.5% of your account. We will use this risk management for applying compound interest.  In settings, with position amount calculator, you can enter the amount in usd of your account and the amount in percentage for risking per trade of the account. You will see this value in green color in the upper left corner that shows the amount in usd to use for risking the specific percentage of your account. Script functions Inside of settings, you will find some utilities for display atr stop loss, break evens, positions, signals, indicators, etc. You will find the settings for risk management at the end of the script if you want to change something. But rebember, do not change values from indicators, the idea is to not over optimize the strategy. If you want to change the initial capital for backtest the strategy, go to properties, and also enter the commisions of your exchange and slippage for more realistic results. If you activate break even using rsi, when rsi crosses under overbought zone break even will be activated. This can work in some assets.  ---Important: In risk managment you can find an option called \"Use leverage ?\", activate this if you want to backtest using leverage, which means that in case of not having enough money for risking the % determined by you of your account using your initial capital, you will use leverage for using the enough amount for risking that % of your acount in a buy position. Otherwise, the amount will be limited by your initial/current capital--- Some things to consider USE UNDER YOUR OWN RISK. PAST RESULTS DO NOT REPRESENT THE FUTURE. DEPENDING OF % ACCOUNT RISK PER TRADE, YOU COULD REQUIRE LEVERAGE FOR OPEN SOME POSITIONS, SO PLEASE, BE CAREFULL AND USE CORRECTLY THE RISK MANAGEMENT Do not forget to change commissions and other parameters related with back testing results! Some assets and timeframes where the strategy has also worked:  BTCUSD : 4H, 1D, W  SPX (US500) : 4H, 1D, W   GOLD : 1D, W  SILVER : 1D, W   ETHUSD : 4H, 1D  DXY : 1D  AAPL : 4H, 1D, W   AMZN : 4H, 1D, W   META : 4H, 1D, W  (and others stocks)  BANKNIFTY : 4H, 1D, W   DAX : 1D, W  RUT : 1D, W   HSI : 1D, W   NI225 : 1D, W  USDCOP : 1D, W"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Developed by \u00a9 StrategiesForEveryone\n//@version=5\nstrategy('Investments/swing trading strategy for different assets', overlay=true, \nhow_to_use = input.bool(defval=true, title=\"How to use the strategy ----->\", group\n// ------ Position amount calculator ------\ninitial_actual_capital_c = input.float(defval=1000000.0, title = \"Initial/Actual Capital\"\nrisk_c = input.float(defval = 2.5, title = '% account risk per trade', step=1, group\n// ------ Date filter ---------\ninitial_date = input.time(title=\"Initial date\", defval=timestamp(\"01 Jan 1800 13:30 +0000\"\nfinal_date   = input.time(title=\"Final date\", defval=timestamp(\"1 Jan 2030 19:30 +0000\"\ndateFilter(int st, int et) => time >= st and time <= et\ncolorDate = input.bool(defval=false, title=\"Date background\", tooltip = \"Add color to the period of time of the strategy t\nbgcolor(colorDate and dateFilter(initial_date, final_date) ? color.new( color.blue\n// ------ Session limits -------\ntimeSession = input.session(title=\"Time session\", defval=\"0000-2400\", group=\"Time filter\"\ncolorBG     = input.bool(title=\"Session background\", defval=false, tooltip = \"Add color to session time background\"\ninSession(sess) => na(time(timeframe.period, sess + ':1234567')) == false\nbgcolor(inSession(timeSession) and colorBG ?  color.rgb(0, 38, 255, 84) : na)\n// ------------------ Squeeze momentum Lazy Bear -----------------------\nlength = input(20, title='BB Length', group = \"Squeeze Momentum\", inline = \"c\")\nmult = input(2.0, title='BB MultFactor', group = \"Squeeze Momentum\", inline = \"c\")\nsource = close\nlengthKC = input(20, title='KC Length', group = \"Squeeze Momentum\", inline = \"c\")\nmultKC = input(1.5, title='KC MultFactor', group = \"Squeeze Momentum\", inline = \"c\"\nuseTrueRange = input(true, title='Use TrueRange (KC)', group = \"Squeeze Momentum\",\nma = ta.sma(source, length)\nbasis = ma\ndev = mult * ta.stdev(source, length)\nupperBB = basis + dev\nlowerBB = basis - dev\nrange_1 = useTrueRange ? ta.tr : high - low\nrangema = ta.sma(range_1, lengthKC)\nupperKC = ma + rangema * multKC\nlowerKC = ma - rangema * multKC\nsqzOn = lowerBB > lowerKC and upperBB < upperKC\nsqzOff = lowerBB < lowerKC and upperBB > upperKC\nnoSqz = sqzOn == false and sqzOff == false\nval = ta.linreg(source - math.avg(math.avg(ta.highest(high, lengthKC), ta.lowest(low\niff_1 = val > nz(val[1]) ?  #00ff00 :  #008000\niff_2 = val < nz(val[1]) ?  #FF0000 :  #800000\nbcolor = val > 0 ? iff_1 : iff_2\ngreen_sqz = val > 0\nred_sqz = val < 0\nshow_sqz = input.bool(defval=false, title = \"Show squeeze momentum ?\", group = \"Appearance\"\nplot(show_sqz ? val : na, color=bcolor, style=plot.style_columns, linewidth=4, display\n// ----------- Ema ----------------------\nema = input.int(200, title='Ema length', minval=1, maxval=500, group = \"Trend\")\nema200 = ta.ema(close, ema)\nbullish = close > ema200\nbearish = close < ema200\nshow_ema = input.bool(defval=true, title=\"Show Ema ?\", group = \"Appearance\")\nplot(show_ema ? ema200 : na, color= color.white, linewidth=2, display = display.all\n// --------------- Custom Rsi ------------------\noverbought = input.int(70, title='Over bought line rsi', minval=50, maxval=100, group\noversold = input.int(30, title='Over sold line rsi', minval=0, maxval=50, group = \nperiods = input.int(5, title='Rsi Length', minval=1, maxval=200, group = \"Rsi\", inline\nrsi_filter = ta.rsi(close, periods)\nshow_rsi = input.bool(defval=false, title=\"Show Rsi ?\", group = \"Appearance\")\nplot(show_rsi ? rsi_filter : na, color= color.white, linewidth=2, display = display.all\nhline(show_rsi ? overbought : na, color= color.green, linewidth = 1, display = display.all\n// --------- Macd -----------\n// Getting inputs\nfast_length = input(title=\"Fast Length\", defval=16, group = \"Macd\")\nslow_length = input(title=\"Slow Length\", defval=26, group = \"Macd\")\nsrc = input(title=\"Source\", defval=close)\nsignal_length = input.int(title=\"Signal Smoothing\",  minval = 1, maxval = 50, defval\nsma_source = input.string(title=\"Oscillator MA Type\",  defval=\"EMA\", options=[\"SMA\"\nsma_signal = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\n// Plot colors\ncol_macd = input( #2962FF, \"MACD Line\u2003\u2004\", group=\"Color Settings\", inline=\"MACD\")\ncol_signal = input( #FF6D00, \"Signal Line\u2003\u2006\", group=\"Color Settings\", inline=\"Signal\"\ncol_grow_above = input( #26A69A, \"Above\u2004\u2004\u2005Grow\", group=\"Histogram\", inline=\"Above\"\ncol_fall_above = input( #B2DFDB, \"Fall\", group=\"Histogram\", inline=\"Above\")\ncol_grow_below = input( #FFCDD2, \"Below\u2003Grow\", group=\"Histogram\", inline=\"Below\"\ncol_fall_below = input( #FF5252, \"Fall\", group=\"Histogram\", inline=\"Below\")\n// Calculating\nfast_ma = sma_source == \"SMA\" ? ta.sma(src, fast_length) : ta.ema(src, fast_length\nslow_ma = sma_source == \"SMA\" ? ta.sma(src, slow_length) : ta.ema(src, slow_length\nmacd = fast_ma - slow_ma\nsignal = sma_signal == \"SMA\" ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length\nhist = macd - signal\n//hline(0, \"Zero Line\", color=color.new(#787B86, 50))\nshow_macd = input.bool(defval=false, title = \"Show Macd ?\", group = \"Appearance\")\nplot(show_macd ? hist : na, title=\"Histogram\", style=plot.style_columns, color=(hist\n//plot(macd, title=\"MACD\", color=col_macd)\n//plot(signal, title=\"Signal\", color=col_signal)\n// -------------- Atr stop loss by Gatherio -----------------\nsource_atr = input(close, title='Source', group = \"Atr stop loss\", inline = \"A\")\nlength_atr = input.int(14, minval=1, title='Period', group = \"Atr stop loss\" , inline\nmultiplier = input.float(1.6, minval=0.1, step=0.1, title='Atr multiplier', group \nshortStopLoss = source_atr + ta.atr(length_atr) * multiplier\nlongStopLoss = source_atr - ta.atr(length_atr) * multiplier\natr_past_candle_buy = close[1] - ta.atr(length_atr)[1] * multiplier[1]\n// ------- Money management ---------\nstrategy_contracts = strategy.equity / close\ndistance_sl_buy = -1 * (longStopLoss - close) / close\ndistance_sl_buy_past_candle = -1 * (atr_past_candle_buy - close) / close  // distancia stop loss en porcentaje\nrisk = input.float(2.5, '% Account risk per trade for backtesting', step=1, group \namount_1 = strategy_contracts * (risk / 100) / distance_sl_buy\namount_2 = strategy_contracts * (risk / 100) / distance_sl_buy_past_candle\n// ------- Risk management ---------\nrisk_reward_breakeven = input.float(title='Risk reward for break even', defval=1.0\nvar float sl = na\nvar float be_buy = na\nvar float tp_buy = na\nvar float stop_loss_distance = na\nvar float buy_amount = na  \nvar float asset_amount = na \nvar float be_buy_calculator = na\nvar float stoploss_distance = na\nleverage=input.bool(defval=false, title=\"Use leverage ?\", group = \"Risk management\"\nif not leverage and amount_1>strategy_contracts\n    amount_1:=strategy.equity/close\nif not leverage and amount_2>strategy_contracts\n    amount_2:=strategy.equity/close\n// --------- Risk calculator --------------------------\nnumber_of_contracts = initial_actual_capital_c / close\nbuy_amount_atr_actual_candle = close * (number_of_contracts * (risk_c / 100) / distance_sl_buy\nbuy_amount_atr_past_candle = close * (number_of_contracts * (risk_c / 100) / distance_sl_buy_past_candle\n// Plot purchase currency units amount\nif close>ema200\n    buy_amount:=close * (number_of_contracts * (risk / 100) / distance_sl_buy)\nif close>ema200 and hist[0] > hist[1] and close[0] > close[1] and hist<0 and red_sqz\n    buy_amount:= close * (number_of_contracts * (risk / 100) / distance_sl_buy_past_candle\nif close<ema200\n    buy_amount:=close * (number_of_contracts * (risk / 100) / distance_sl_buy)\nif not leverage and buy_amount>initial_actual_capital_c\n    buy_amount:=initial_actual_capital_c\nplot(buy_amount, display = display.all - display.pane, color= color.rgb(0, 255, 55\n// Plot stop loss price\ndraw_sl_be = input.bool(defval=true, title=\"Show stop loss and break even ?\", group\nif close>ema200 \n    sl:=longStopLoss\nif close>ema200 and hist[0] > hist[1] and close[0] > close[1] and hist<0 and red_sqz\n    sl:=atr_past_candle_buy\nif close<ema200 \n    sl:=longStopLoss\n// Plot stop loss % distance\nif close>ema200\n    stop_loss_distance:=(-1 * (longStopLoss - close) / close)*100  \nif close>ema200 and hist[0] > hist[1] and close[0] > close[1] and hist<0 and red_sqz\n    stop_loss_distance:=(-1 * (atr_past_candle_buy - close) / close)*100   \nif close<ema200    \n    stop_loss_distance:=(-1 * (longStopLoss - close) / close)*100  \nplot(stop_loss_distance, title=\"Stop loss % distance\", color= color.rgb(255, 136,\n// Plot break even \ndistance_stop_buy_break_even = close - longStopLoss\ndistance_stop_buy_break_even_past_candle = close - atr_past_candle_buy\nbe_buy_calculator:= close + distance_stop_buy_break_even * risk_reward_breakeven\nif close>ema200\n    be_buy_calculator:= close + distance_stop_buy_break_even * risk_reward_breakeven\nif close>ema200 and hist[0] > hist[1] and close[0] > close[1] and hist<0 and red_sqz\n    be_buy_calculator:=close + distance_stop_buy_break_even_past_candle * risk_reward_breakeven\nif close<ema200\n    be_buy_calculator:= close + distance_stop_buy_break_even * risk_reward_breakeven\n// ------- Conditions for buying -----------\nbought = strategy.position_size > 0\nsold = strategy.position_size < 0\nbuy_rsi_signal = ta.crossover(rsi_filter, oversold) and red_sqz and bearish \nbuy_macd_signal = hist[0] > hist[1] and close[0] > close[1] and hist<0 and red_sqz\nsell_rsi_signal = ta.crossunder(rsi_filter, overbought) and green_sqz and bought \ntrend_sell_signal_sqz = ta.crossunder(val, 0)\ntrend_buy_signal_sqz = ta.crossover(val, 0) or (val>0 and (val[0] > val[1] and val\npositive_close=strategy.openprofit>0\ninformation = input.bool(defval=true, title=\"Read ------>\", group = \"Final information\"\nagaints_trend = input.bool(defval=false, title=\"Againts trend ?\", group =\"Risk management\"\nbreak_even_with_rsi = input.bool(defval=false, title=\"Break even using rsi ?\", group\nvar float sl_1 = na\nvar float sl_2 = na\nvar float sl_3 = na\nif not bought\n    sl_1:=na\n    sl_2:=na\n    sl_3:=na\n// --------- Use of strategy conditions  ----------\n// ------------------------ Sqz momentum signal ------------------------\n// ---------------------- Againts Trend ----------------------\nif trend_buy_signal_sqz and dateFilter(initial_date, final_date) and inSession(timeSession\n    sl_1:=longStopLoss         \n    stoploss_distance:= close - longStopLoss\n    be_buy := close + stoploss_distance * risk_reward_breakeven\n    strategy.entry(\"Buy\", strategy.long,  qty=amount_1)\n    strategy.exit(\"Cl Buy\", \"Buy\", stop=sl_1)\nif high > be_buy or sell_rsi_signal and positive_close and break_even_with_rsi\n    sl_1:=strategy.position_avg_price\n    strategy.exit(\"Cl Buy\", \"Buy\", stop=sl_1) \nif (bought and trend_sell_signal_sqz)        \n    strategy.close(\"Buy\", comment=\"Cl Buy\")\n//---------------In favor of the trend\"---------------------\nif trend_buy_signal_sqz and dateFilter(initial_date, final_date) and inSession(timeSession\n    sl_2:=longStopLoss           \n    stoploss_distance:= close - longStopLoss\n    be_buy := close + stoploss_distance * risk_reward_breakeven\n    strategy.entry('Buy', strategy.long,  qty=amount_1)\n    strategy.exit('Cl Buy', 'Buy', stop=sl_2)\nif high > be_buy or sell_rsi_signal and positive_close and break_even_with_rsi\n    sl_2:=strategy.position_avg_price\n    strategy.exit(\"Cl Buy\", \"Buy\", stop=sl_2) \nif (trend_sell_signal_sqz)         \n    strategy.close(\"Buy\", comment=\"Cl Buy\")\n// ---------------------- Macd signal ----------------------------------------\nif buy_macd_signal and dateFilter(initial_date, final_date) and inSession(timeSession\n    sl_3:=atr_past_candle_buy\n    stoploss_distance:= close - atr_past_candle_buy\n    be_buy := close + stoploss_distance * risk_reward_breakeven\n    strategy.entry('Buy.', strategy.long, qty=amount_2)\n    strategy.exit('Cl Buy.', 'Buy.', stop=sl_3)\nif high > be_buy or sell_rsi_signal and positive_close and break_even_with_rsi\n    sl_3:=strategy.position_avg_price\n    strategy.exit(\"Cl Buy.\", \"Buy.\", stop=sl_3) \nif (trend_sell_signal_sqz)        \n    strategy.close(\"Buy.\", comment=\"Cl Buy.\")\n// ---------- Draw position on chart -------------\nif high > be_buy\n    be_buy:=na\nshow_position_on_chart = input.bool(defval=true, title=\"Draw position on chart ?\",\nposition_price = plot(show_position_on_chart? strategy.position_avg_price : na, style\nbreak_even_price = plot(strategy.position_size>0 and high<be_buy and show_position_on_chart\nsl1_price = plot(show_position_on_chart and bought and againts_trend ? sl_1 : na, \nsl2_price = plot(show_position_on_chart and bought ? sl_2 : na, style = plot.style_linebr\nsl3_price = plot(show_position_on_chart and bought ? sl_3 : na, style = plot.style_linebr\nposition_profit_price = plot(strategy.position_size>0 and show_position_on_chart and\nfill(plot1 = position_price, plot2 = position_profit_price, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = sl1_price, color =  color.new(color.red,90))\nfill(plot1 = position_price, plot2 = sl2_price, color =  color.new(color.red,90))\nfill(plot1 = position_price, plot2 = sl3_price, color =  color.new(color.red,90))\n// --------- Strategy as indicator -----------\nshow_signals = input.bool(defval=true, title=\"Draw signals on chart ?\", group = \"Appearance\"\nplot(draw_sl_be and trend_buy_signal_sqz and not bought or draw_sl_be and buy_macd_signal\nplot(draw_sl_be and trend_buy_signal_sqz and not bought or draw_sl_be and buy_macd_signal\nplotshape(show_signals and break_even_with_rsi and bought? sell_rsi_signal : na, style"}]}
{"messages": [{"role": "user", "content": "This strategy is based on the Korea Premium, also known as the \u201cKimchi Premium,\u201d which indicates how expensive or cheap the price of Bitcoin in Korean Won on a Bitcoin exchange in South Korea is relative to the price of Bitcoin being traded in USD or Tether. Inverse Kimchi Premium RSI was newly defined to create a strategy with Kimchi Premium. Assuming that the larger the kimchi premium, the greater the individual's purchasing power. In this case, if the Inverse Kimchi Premium RSI falls and closes the candle below the bear level, a short is triggered. Long is the opposite. This strategy defaults to a combination of the traditional RSI and the Inverse Kimchi Premium RSI. If the user wishes to unlock the Inverse Kimchi Premium RSI combination and only use it as a traditional RSI strategy, the following settings can be used. Use Combination of Inverse Kimchi Premium RSI: Uncheck Resolution: Chart (4hr Candle) Source: Close Length of RSI: 14 Bull Level: 74 Bear Level: 25 __________________________________________________________________________________ \uae40\uce58\ud504\ub9ac\ubbf8\uc5c4(\uae40\ud504) \uc804\ub7b5\uc740 \u1103\u1161\u11af\u1105\u1165 \u1112\u1169\u11a8\u110b\u1173\u11ab \u1110\u1166\u1103\u1165\u1105\u1169 \u1100\u1165\u1105\u1162\u1103\u116c\u1100\u1169 \u110b\u1175\u11bb\u1102\u1173\u11ab \u1107\u1175\u1110\u1173\u110f\u1169\u110b\u1175\u11ab \u1100\u1161\u1100\u1167\u11a8 \u1103\u1162\u1107\u1175 \u1112\u1161\u11ab\u1100\u116e\u11a8\u110b\u1166 \u110b\u1175\u11bb\u1102\u1173\u11ab \u1107\u1175\u1110\u1173\u110f\u1169\u110b\u1175\u11ab \u1100\u1165\u1105\u1162\u1109\u1169\u110b\u1174 \u1107\u1175\u1110\u1173\u110f\u1169\u110b\u1175\u11ab \u110b\u116f\u11ab\u1112\u116a \u1100\u1161\u1100\u1167\u11a8\u110b\u1175 \u110b\u1165\u11af\u1106\u1161\u1102\u1161 \u1107\u1175\u110a\u1161\u1100\u1169 \u110a\u1161\u11ab \u110c\u1175\u1105\u1173\u11af \u1102\u1161\u1110\u1161\u1102\u1162\u1102\u1173\u11ab \u110f\u1169\u1105\u1175\u110b\u1161 \u1111\u1173\u1105\u1175\u1106\u1175\u110b\u1165\u11b7, \u110b\u1175\u11af\u1106\u1167\u11bc \"\u1100\u1175\u11b7\u110e\u1175 \u1111\u1173\u1105\u1175\u1106\u1175\u110b\u1165\u11b7\" \u110c\u1175\u1111\u116d\ub97c \uae30\ubc18\uc73c\ub85c \ub9cc\ub4e4\uc5b4\uc84c\uc2b5\ub2c8\ub2e4. \uae40\uce58 \ud504\ub9ac\ubbf8\uc5c4\uc744 \uac00\uc9c0\uace0 \uc804\ub7b5\uc744 \ub9cc\ub4e4\uae30\uc704\ud574 Inverse Kimchi Premium RSI\ub97c \uc0c8\ub86d\uac8c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \uae40\uce58 \ud504\ub9ac\ubbf8\uc5c4\uc774 \ucee4\uc9c8\uc218\ub85d \uac1c\uc778\uc758 \ub9e4\uc218\uc138\uac00 \ucee4\uc9c4\ub2e4\uace0 \uac00\uc815\ud558\uace0, \uc774 \uacbd\uc6b0 Inverse Kimchi Premium RSI\uc774 \ud558\ub77d\ud558\uc5ec Bear Level \uc544\ub798\uc5d0\uc11c \uce94\ub4e4 \ub9c8\uac10\uc744 \ud558\uba74 Short\uc744 \ud2b8\ub9ac\uac70 \ud569\ub2c8\ub2e4. Long\uc740 \uadf8 \ubc18\ub300\uc785\ub2c8\ub2e4. \uc774 \uc804\ub7b5\uc740 \uc804\ud1b5\uc801\uc778 RSI\uc640 Inverse Kimchi Premium RSI\uc744 \uc870\ud569\ud558\uc5ec \uae30\ubcf8\uac12\uc744 \uc124\uc815\ud558\uc600\uc2b5\ub2c8\ub2e4. \uc720\uc800\uac00 \uc6d0\ud55c\ub2e4\uba74 Inverse Kimchi Premium RSI\uc758 \uc870\ud569\uc744 \ud574\uc81c\ud558\uace0 \uc804\ud1b5\uc801\uc778 RSI \uc804\ub7b5\uc73c\ub85c\ub9cc \uc0ac\uc6a9\ud558\ub824\uba74 \uc544\ub798 \ub2e4\uc74c\uc758 \uc124\uc815\uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. Use Combination of Inverse Kimchi Premium RSI: \uccb4\ud06c \ud574\uc81c Resolution: Chart (4hr Candle) Source: Close Length of RSI: 14 Bull Level: 74 Bear Level: 25"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 chanu_lev10k\n//@version=5\nstrategy(\"Kimchi Premium Strategy\", overlay=false)\n// Inputs\nsym_krw = input.symbol(title='Select BTCKRW Market', defval='BITHUMB:BTCKRW')\nsym_usd = input.symbol(title='Select BTCUSD Market', defval='BITSTAMP:BTCUSD')\nres = input.timeframe(title='Resolution', defval='')\nsrc = input.source(title='Source', defval=close)\nlen1 = input.int(defval=4, title='Length of RSI')\nlen2 = input.int(defval=12, title='Length of Inverse Kimchi Premium RSI')\nisikp = input.bool(title='Use Combination of Inverse Kimchi Premium RSI ?', defval=\nbullLevel = input.float(title='Bull Level', defval=63, step=1.0, maxval=100, minval\nbearLevel = input.float(title='Bear Level', defval=28, step=1.0, maxval=100, minval\nhighlightBreakouts = input(title='Highlight Bull/Bear Breakouts ?', defval=true)\n// Inverse Kimichi Premium RSI Definition\nup = ta.rma(math.max(ta.change(src), 0), len1)\ndown = ta.rma(-math.min(ta.change(src), 0), len1)\nrsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\nusdkrw = request.security('FX_IDC:USDKRW', res, src)\nbtckrw = request.security(sym_krw, res, src)\nbtcusd = request.security(sym_usd, res, src)\nbtcusd_to_krw = btcusd * usdkrw\nikp = (btcusd_to_krw / btckrw - 1) * 100\nikp_f(res, len1, len2) =>\n    n = rsi\n    t = (rsi + ta.rsi(ikp, len2))/2\n    isikp ? t : n\ntot_rsi = ikp_f(res, len1, len2)\n// Plot\nrcColor = tot_rsi > bullLevel ?  #0ebb23 : tot_rsi < bearLevel ?  #ff0000 :  #f4b77d\nmaxBand = hline(100, title='Max Level', linestyle=hline.style_dotted, color= color.white\nhline(0, title='Zero Level', linestyle=hline.style_dotted)\nminBand = hline(0, title='Min Level', linestyle=hline.style_dotted, color= color.white\nbullBand = hline(bullLevel, title='Bull Level', linestyle=hline.style_dotted)\nbearBand = hline(bearLevel, title='Bear Level', linestyle=hline.style_dotted)\nfill(bullBand, bearBand, color= color.new(color.purple, 95))\nbullFillColor = tot_rsi > bullLevel and highlightBreakouts ?  color.green : na\nbearFillColor = tot_rsi < bearLevel and highlightBreakouts ?  color.red : na\nfill(maxBand, bullBand, color=color.new(bullFillColor, 80))\nfill(minBand, bearBand, color=color.new(bearFillColor, 80))\nplot(tot_rsi, title='Total RSI', linewidth=2, color=rcColor)\nplot(rsi, title='RSI', linewidth=1, color= color.new(color.purple, 0))\nplot(ta.rsi(ikp, len2), title='Inverse Kimchi Premium RSI', linewidth=1, color= color.new\n// Long Short conditions\nlongCondition = ta.crossover(tot_rsi, bullLevel)\nif longCondition\n    strategy.entry('Long', strategy.long)\nshortCondition = ta.crossunder(tot_rsi, bearLevel)\nif shortCondition\n    strategy.entry('Short', strategy.short)"}]}
{"messages": [{"role": "user", "content": "This is a very profitable strategy focusing on 15 minute intervals on  the Micro Nasdaq Futures contracts.  \t\t\tMNQH2023As this contract only keeps positions for on average about an hour risk is managed. At a profit factor of 3.382 with a max drawdown of $123 from January 1st to February 15.   Looking back to Dec 2019 still maintains a profit factor of 1.3.  See backtesting:  www.screencast.com/t/Sm2lKDiLSa6n 2019 backtesting:  www.screencast.com/t/wnj9z9FlF Based on the classic Lazy Bear Oscillator Squeeze with a number of modifications from ADX, MAs and adding fibonacci levels. We like keeping strategies simple yet powerful, no completely where you can't understand your own trades.  Our team is always modifying and improving the strategy. Always open to collaborating on improving as there is no perfect strategy.https://www.screencast.com/t/Sm2lKDiLSa6n"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 vitruvius\n//@version=5\nstrategy(\"Athena Momentum Squeeze - Autoview\", overlay=true)\n// Inputs {\n// -- Automate \nbroker = input.string(\"tradovate\",\"Broker\",group=\"AutoView\",tooltip = \"tradovate/tradovatesim\"\npair0 = input.string(\"MSFT\",\"Pair:\",group=\"AutoView\",tooltip = \"ZNH2/MSFT/ESH2\")\nqty = input.string(\"1\",\"Qty:\",group=\"AutoView\",tooltip = \"q=10% (% of accountsize) \\n q=50(Qty)\"\nlo_mess =  \"e=\"+str.tostring(broker)       +\" s=\"+str.tostring(pair0)  +\" b=long\"     \nsh_mess =  \"e=\"+str.tostring(broker)       +\" s=\"+str.tostring(pair0)  +\" b=short\"\nexl_mess =  \"e=\"+str.tostring(broker)       +\" s=\"+str.tostring(pair0)  +\"b=long c=position t=market\"\nexs_mess =  \"e=\"+str.tostring(broker)       +\" s=\"+str.tostring(pair0)  +\"b=short c=position t=market\"\n// Entry {\nentry_gr_name = \"Entry\"\nentry_tt_sqz_filter = \"Checks number of dark blue dots before entering a position\"\nentry_long_light_green = \"Light green\", entry_long_dark_green = \"Dark green\", entry_long_none\nentry_short_light_red = \"Light red\", entry_short_dark_red = \"Dark red\", entry_short_none\nin_entry_sqz_bar_type_long = input.string(entry_long_light_green, \"Long entry\", [entry_long_light_green\nin_entry_sqz_bar_type_short = input.string(entry_short_light_red, \"Short entry\", [\nin_entry_sqz_filter_en = input.bool(true, \"Enable squeeze filter?\", tooltip=entry_tt_sqz_filter\nin_entry_sqz_filter_cnt = input.int(6, \"Squeeze dot count\", group=entry_gr_name)\n//}\n// Exit {\nexit_gr_name = \"Exit\"\nexit_long_light_green = \"Light green\", exit_long_dark_green = \"Dark green\", exit_long_light_red\nexit_short_light_green = \"Light green\", exit_short_dark_green = \"Dark green\", exit_short_light_red\nexit_type_per_tp = \"Percentage\", exit_type_atr_tp = \"ATR\", exit_type_rr_tp = \"Risk/Reward\"\nexit_type_per_sl = \"Percentage\", exit_type_atr_sl = \"ATR\", exit_type_none_sl = \"None\"\nexit_tt_val_tp = \"Percantage: Percentage value\\nATR: ATR multiplier\\nRisk/Reward: R:R ratio\"\nexit_tt_val_sl = \"Percantage: Percentage value\\nATR: ATR multiplier\"\nin_exit_sqz_bar_type_long = input.string(exit_long_dark_green, \"Long close\", [exit_long_light_green\nin_exit_sqz_bar_type_short = input.string(exit_short_dark_red, \"Short close\", [exit_short_light_green\nin_exit_sqz_bar_close_in_profit = input.bool(false, \"Close only in profit\", group=\nin_exit_type_tp = input.string(exit_type_none_tp, \"Take profit type\", [exit_type_per_tp\nin_exit_val_tp = input.float(2.0, \"Take profit value\", step=0.1, tooltip=exit_tt_val_tp\nin_exit_type_sl = input.string(exit_type_atr_sl, \"Stop loss type\", [exit_type_per_sl\nin_exit_val_sl = input.float(2.0, \"Stop loss value\", step=0.1, tooltip=exit_tt_val_sl\nin_exit_atr_len = input.int(14, \"ATR length\", group=exit_gr_name)\n//}\n// Squeeze Momentum {\nsqz_gr_name = \"Squeeze Momentum\"\nin_sqz_length = input(20, title='BB Length', group=sqz_gr_name)\nin_sqz_mult = input(2.0, title='BB MultFactor', group=sqz_gr_name)\nin_sqz_lengthKC = input(20, title='KC Length', group=sqz_gr_name)\nin_sqz_multKC = input(1.5, title='KC MultFactor', group=sqz_gr_name)\nin_sqz_useTrueRange = input(true, title='Use TrueRange (KC)', group=sqz_gr_name)\n//}\n// Moving Average {\nma_gr_name = \"Moving Average\"\nma_type_rma = \"RMA\", ma_type_sma = \"SMA\", ma_type_ema = \"EMA\", ma_type_wma = \"WMA\"\nin_ma_en = input.bool(true, \"Enable moving average filter?\", group=ma_gr_name)\nin_ma_type = input.string(ma_type_sma, \"Type\", [ma_type_rma, ma_type_sma, ma_type_ema\nin_ma_src = input.source(close, \"Source\", group=ma_gr_name)\nin_ma_len = input.int(200, \"Length\", group=ma_gr_name)\nin_ma_show = input.bool(true, \"Plot?\", inline=\"ma_plot\", group=ma_gr_name)\nin_ma_col = input.color( color.yellow, \"\", inline=\"ma_plot\", group=ma_gr_name)\nin_ma_w = input.int(2, \"\", inline=\"ma_plot\", group=ma_gr_name)\n//}\n// Display {\ndisp_gr_name = \"Display\"\nin_disp_ep_col = input.color( color.gray, \"Entry Price\", group=disp_gr_name)\nin_disp_tp_col = input.color( color.green, \"Take Profit\", group=disp_gr_name)\nin_disp_sl_col = input.color( color.red, \"Stop Loss\", group=disp_gr_name)\n//}\n//}\n// Variables {\n// Entry {\nentry_long_sel_light_green = (in_entry_sqz_bar_type_long == entry_long_light_green\nentry_long_sel_dark_green = (in_entry_sqz_bar_type_long == entry_long_dark_green)\nentry_short_sel_light_red = (in_entry_sqz_bar_type_short == entry_short_light_red)\nentry_short_sel_dark_red = (in_entry_sqz_bar_type_short == entry_short_dark_red)\n//}\n// Exit {\nexit_long_sel_light_green = (in_exit_sqz_bar_type_long == exit_long_light_green)\nexit_long_sel_dark_green = (in_exit_sqz_bar_type_long == exit_long_dark_green)\nexit_long_sel_light_red = (in_exit_sqz_bar_type_long == exit_long_light_red)\nexit_long_sel_dark_red = (in_exit_sqz_bar_type_long == exit_long_dark_red)\nexit_short_sel_light_green = (in_exit_sqz_bar_type_short == exit_short_light_green\nexit_short_sel_dark_green = (in_exit_sqz_bar_type_short == exit_short_dark_green)\nexit_short_sel_light_red = (in_exit_sqz_bar_type_short == exit_short_light_red)\nexit_short_sel_dark_red = (in_exit_sqz_bar_type_short == exit_short_dark_red)\n//}\n// Strategy {\nstrat_is_long = strategy.position_size > 0\nstrat_is_short = strategy.position_size < 0\nstrat_is_new_pos = (strategy.position_size[1] == 0 and strategy.position_size != 0\n//}\n//}\n// Functions {\n// Moving Average {\nf_ma(type, src, len) =>\n    switch type\n        ma_type_rma => ta.rma(src, len)\n        ma_type_sma => ta.sma(src, len)\n        ma_type_ema => ta.ema(src, len)\n        ma_type_dema => \n            e1 = ta.ema(src, len)\n            e2 = ta.ema(e1, len)\n            dema = 2 * e1 - e2\n        ma_type_tema =>\n            ema1 = ta.ema(src, len)\n            ema2 = ta.ema(ema1, len)\n            ema3 = ta.ema(ema2, len)\n            out = 3 * (ema1 - ema2) + ema3\n        ma_type_wma => ta.wma(src, len)\n        ma_type_hma => ta.hma(src, len)\n        ma_type_vwma => ta.vwma(src, len)\n        => ta.ema(src, len)\n//}\n//}\n// Indicator {\n// Squeeze Momentum {\nvar sqz_dark_blue_dot_cnt = 0\n// Calculate BB\nsqz_source = close\nsqz_basis = ta.sma(sqz_source, in_sqz_length)\nsqz_dev = in_sqz_multKC * ta.stdev(sqz_source, in_sqz_length)\nsqz_upperBB = sqz_basis + sqz_dev\nsqz_lowerBB = sqz_basis - sqz_dev\n// Calculate KC\nsqz_ma = ta.sma(sqz_source, in_sqz_lengthKC)\nsqz_range_1 = in_sqz_useTrueRange ? ta.tr : high - low\nsqz_rangema = ta.sma(sqz_range_1, in_sqz_lengthKC)\nsqz_upperKC = sqz_ma + sqz_rangema * in_sqz_multKC\nsqz_lowerKC = sqz_ma - sqz_rangema * in_sqz_multKC\nsqz_sqzOn = sqz_lowerBB > sqz_lowerKC and sqz_upperBB < sqz_upperKC\nsqz_sqzOff = sqz_lowerBB < sqz_lowerKC and sqz_upperBB > sqz_upperKC\nsqz_noSqz = sqz_sqzOn == false and sqz_sqzOff == false\nsqz_val = ta.linreg(sqz_source - math.avg(math.avg(ta.highest(high, in_sqz_lengthKC\nsqz_bar_light_green = (sqz_val > 0) and (sqz_val > nz(sqz_val[1]))\nsqz_bar_dark_green = (sqz_val > 0) and not (sqz_val > nz(sqz_val[1]))\nsqz_bar_light_red = not (sqz_val > 0) and (sqz_val < nz(sqz_val[1]))\nsqz_bar_dark_red = not (sqz_val > 0) and not (sqz_val < nz(sqz_val[1]))\nsqz_circle_dark_blue = sqz_noSqz or (not sqz_noSqz and sqz_sqzOn)\nsqz_circle_light_blue = (not sqz_noSqz and not sqz_sqzOn)\nsqz_bar_cond_long = entry_long_sel_light_green ? sqz_bar_light_green : entry_long_sel_dark_green\nsqz_bar_cond_short = entry_short_sel_light_red ? sqz_bar_light_red : entry_short_sel_dark_red\nsqz_bar_cond_long := sqz_bar_cond_long and sqz_circle_light_blue\nsqz_bar_cond_short := sqz_bar_cond_short and sqz_circle_light_blue\nsqz_close_cond_long = exit_long_sel_light_green ? sqz_bar_light_green : exit_long_sel_dark_green\nsqz_close_cond_short = exit_short_sel_light_green ? sqz_bar_light_green : exit_short_sel_dark_green\nsqz_dark_blue_dot_cnt := sqz_circle_dark_blue ? sqz_dark_blue_dot_cnt + 1 : 0\nsqz_filter_cnt_cond = in_entry_sqz_filter_en ? (sqz_dark_blue_dot_cnt[1] >= in_entry_sqz_filter_cnt\nplotchar(sqz_dark_blue_dot_cnt, \"Dark blue dot count\", \"\", color= color.blue)\n//}\n// Moving Average {\nma_val = f_ma(in_ma_type, in_ma_src, in_ma_len)\nma_cond_long = in_ma_en ? (close > ma_val) : true\nma_cond_short = in_ma_en ? (close < ma_val) : true\nplot(in_ma_en and in_ma_show ? ma_val : na, \"Moving Average\", in_ma_col, in_ma_w)\n//}\n// ATR {\nvar float atr_at_entry = na\natr_val = ta.atr(in_exit_atr_len)\natr_at_entry := strat_is_new_pos ? atr_val[1] : atr_at_entry\n//}\n// Strategy {\nstrat_long_cond = sqz_bar_cond_long and sqz_filter_cnt_cond and ma_cond_long\nstrat_short_cond = sqz_bar_cond_short and sqz_filter_cnt_cond and ma_cond_short\nif (strat_long_cond)\n    strategy.entry(\"Long\", strategy.long,alert_message = lo_mess)\nif (strat_short_cond)\n    strategy.entry(\"Short\", strategy.short,alert_message = sh_mess)\nstrat_profit_cond_close = in_exit_sqz_bar_close_in_profit ? (strategy.openprofit >\nif (strat_is_long and sqz_close_cond_long and strat_profit_cond_close)\n    strategy.close(\"Long\",alert_message = exl_mess)\nif (strat_is_short and sqz_close_cond_short and strat_profit_cond_close)\n    strategy.close(\"Short\",alert_message = exs_mess)\nstrat_entry_price = strategy.opentrades.entry_price(strategy.opentrades - 1)\n// Stop Loss {\nvar float strat_sl_price_long = na\nvar float strat_sl_price_short = na\nstrat_sl_price_long := if (strat_is_new_pos)\n    switch in_exit_type_sl\n        exit_type_per_sl => strategy.position_avg_price * (1 - (in_exit_val_sl * 0.01\n        exit_type_atr_sl => strat_entry_price - (in_exit_val_sl * atr_val)\n        => na\nelse\n    strat_sl_price_long\nstrat_sl_price_short := if (strat_is_new_pos)\n    switch in_exit_type_sl\n        exit_type_per_sl => strategy.position_avg_price * (1 + (in_exit_val_sl * 0.01\n        exit_type_atr_sl => strat_entry_price + (in_exit_val_sl * atr_val)\n        => na\nelse\n    strat_sl_price_short\nfloat strat_sl_price = strat_is_long ? strat_sl_price_long : strat_is_short ? strat_sl_price_short\nstrat_sl_diff = math.abs(strat_entry_price - strat_sl_price)\n//}\n// Take Profit {\nvar float strat_tp_price_long = na\nvar float strat_tp_price_short = na\nstrat_tp_price_long := if (strat_is_new_pos)\n    switch in_exit_type_tp\n        exit_type_per_tp => strategy.position_avg_price * (1 + (in_exit_val_tp * 0.01\n        exit_type_atr_tp => strat_entry_price + (in_exit_val_tp * atr_val)\n        exit_type_rr_tp => strat_entry_price + (in_exit_val_tp * strat_sl_diff)\n        => na\nelse\n    strat_tp_price_long\nstrat_tp_price_short := if (strat_is_new_pos)\n    switch in_exit_type_tp\n        exit_type_per_tp => strategy.position_avg_price * (1 - (in_exit_val_tp * 0.01\n        exit_type_atr_tp => strat_entry_price - (in_exit_val_tp * atr_val)\n        exit_type_rr_tp => strat_entry_price - (in_exit_val_tp * strat_sl_diff)\n        => na\nelse\n    strat_tp_price_short\nfloat strat_tp_price = strat_is_long ? strat_tp_price_long : strat_is_short ? strat_tp_price_short\n//}\nif (strat_is_long)\n    strategy.exit(\"LE\", \"Long\", stop=strat_sl_price, limit=strat_tp_price, comment_loss\nif (strat_is_short)\n    strategy.exit(\"SE\", \"Short\", stop=strat_sl_price, limit=strat_tp_price, comment_loss\n//}\n// Display {\np_ep = plot(strat_entry_price, \"Entry Price\", in_disp_ep_col, 1, plot.style_circles\np_tp = plot(strat_tp_price, \"Take Profit\", in_disp_tp_col, 1, plot.style_circles)\np_sl = plot(strat_sl_price, \"Stop Loss\", in_disp_sl_col, 1, plot.style_circles)\nfill(p_ep, p_tp, color.new(in_disp_tp_col, 85), title=\"Take Profit Fill\")\nfill(p_ep, p_sl, color.new(in_disp_sl_col, 85), title=\"Stop Loss Fill\")\n//}\n//}"}]}
{"messages": [{"role": "user", "content": "what is Exponential Stochastic? it is a modified version of the stochastic indicator. This strategy does not include pyramiding, repaint, trailing stop or take profit. what it does? It contains an extra input in addition to the stochastic indicator. Thanks to this input, different exponential weights can be given to the outputs and the indicator can be made more sensitive or insensitive. The strategy buys when the indicator leaves the overbought zone, sells when it leaves the oversold zone and always stays in the trade. how it does it? it uses this formula:https://i.hizliresim.com/aiepcpp.png Thanks to this formula, even if the weights given to the outputs change, the indicator always continues to take a value between 0 and 100. how to use it ? With the input named \"exp\", you can change the sensitivity of the indicator and develop different strategies. other inputs are the same as the stochastic indicator. Increasing the exp value causes the indicator to signal less, decreasing it makes it much more sensitive."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 faytterro\n//@version=5\nstrategy(\"Exponential Stochastic Strategy\", overlay=false, default_qty_type=strategy.percent_of_equity\nlen=input.int(14, \"length\") \nex=input.int(2, title=\"exp\", minval=1, maxval=10)\nexp= ex<10? (ex)/(10-ex) : 99\ns=100 * (close - ta.lowest(low, len)) / (ta.highest(high, len) - ta.lowest(low, len\nks=s>50? math.pow(math.abs(s-50),exp)/math.pow(50,exp-1)+50 :\n -math.pow(math.abs(s-50),exp)/math.pow(50,exp-1)+50\nplot(ks, color=  color.white)\nbot=input.int(20)\ntop=input.int(80)\nlongCondition = ta.crossover(ks, bot) and bar_index>0\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nshortCondition = ta.crossunder(ks, top) and bar_index>0\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)\n//    strategy.close(\"My Long Entry Id\")\nalertcondition(longCondition, title = \"buy\")\nalertcondition(shortCondition, title = \"sell\")\nh1=hline(top)\nh2=hline(bot)\nh3=hline(100)\nh4=hline(0)\nfill(h1,h3, color=  color.rgb(255,0,0,200-top*2))\nfill(h2,h4, color=  color.rgb(0,255,0,bot*2))"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Updated the Source of the Backtest Adapter to be set to \"Lorentzian Classification: Backtest Stream\""}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 jdehorty\n//@version=5\nstrategy(\"Backtest Adapter\", overlay=true)\nuseDateFilter = input.bool(true, title=\"Begin Backtest at Start Date\", group=\"Backtest Time Period\"\nbacktestStartDate = input.time(timestamp(\"11 May 2022\"), title=\"Start Date\", group=\ninTradeWindow = not useDateFilter or time >= backtestStartDate\nsrc = input.source(title=\"Source\", defval=close, tooltip=\"Source of the input data\"\n// Set up your entry and exit conditions for positions based on the indicator stream. \n// The values here must correspond to the values in the Source indicator.\nstartLongTrade = src == 1\nendLongTrade = src == 2\nstartShortTrade = src == -1\nendShortTrade = src == -2\ntransactionQty = 1\nif startLongTrade and inTradeWindow\n    strategy.order(\"Enter Long\", strategy.long, qty=transactionQty) \n    if endLongTrade and strategy.position_size > 0 and inTradeWindow\n    strategy.order(\"Exit Long\", strategy.short, qty=transactionQty)\nif startShortTrade and inTradeWindow\n    strategy.order(\"Enter Short\", strategy.short, qty=transactionQty)\nif endShortTrade and strategy.position_size < 0 and inTradeWindow\n    strategy.order(\"Exit Short\", strategy.long, qty=transactionQty)"}]}
{"messages": [{"role": "user", "content": "#13 on the Myth-Busting bench, we are automating the \"I Found The Highest Win Rate 15 Minute Scalping Trading Strategy Ever\" strategy from \"TradeIQ\" who claims to have backtested this manually and achieved 410% profit over 100 trades within 6 months on Natural Gas with 79 Wins / 21 Losses with an astounding 3.96% Max Drawdown. It was quite challenging emulating the same subjective EMA pullback logic along with the dependent sequencing of events necessary to enter a trade and we might improve on this to make it better in the future. Super kudos to @spdoinkal who helped with this strategy. If you have ideas on how this could be improved on, would love to hear about them. As is, we were unable to substantiate similar results to what was manually backtested by TradeIQ, we do however see potential here. Given some optimizations and improvements to the the entry logic accommodating for a wider more variable margin after pullbacks reestablish above/below the fast EMA we think the performance of this strategy could certainly be improved upon. So not sure if we have totally myth busted this completely at this point in time. This strategy uses a combination of 2 open-source public indicators: 3 EMA's (Trading View Internal) B-Xtrender by Puppytherapy Three separate (21), (89) and (200) EMA's are used as a means to confirm and keep entry out of ranged markets.  When the 3 EMA's are all clumped up together with no distance it's indicative of a flat or ranged market.  This is then used in conjunction with B-XTrender as a means to detect the trend direction.   B-XTrender which is a trend following indicator originally published in the IFTA Journal by Bharat Jhunjhunwala. It uses both a short and long term lengths along with a compound EMA used as a means to smooth and sample trend direction.    Trading Rules 15 min candles but other lower time-frames Stop Loss on previous swing high/low No Take Profit, Exit on new red/green circles from BX-Trender Long EMA Green (21) on top, White (89)in middle and red (200) on bottom and there is distance between EMA's need to be spaced, otherwise in a ranged market Price action must pull back into 89 EMA (White line) either close or touching it. Once pullback occurs wait for BX Trender to issue a new green circle and BX Trend line must be green and above 0 Price action must also pull up back above the (Green Line) EMA 21 Short EMA Red (200) on top, White (89) in middle and Green (21) on bottom and there is distance between EMA's need to be spaced, otherwise in a ranged market Price action must pull back into 89 EMA (White line) either close or touching it. Once pullback occurs wait for BX Trender to issue a new red circle and BX Trend line must be red and below 0 Price action must also pull up back below the (green Line) EMA 21 If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 spdoinkal / myncrypto\n//@version=5\nstrategy('Strategy Myth-Busting #13 - MultiEMA+BXTrender - [SP/MYN]', max_bars_back\n// Secret EMA Cloud by teddycleps\n// B-X Trender \n// Keep all default\n// Distance between EMA's need to be spaced, otherwise in a ranged market\n// 15 min candles\n// Stop Loss on previous swing high/low\n// No take profit. Exit on new red/green circle\n//Long\n//EMA Green (21) on top, White (89)in middle and red (200) on bottom and there is distance between E\n// Price action must pull back into 89 EMA (White line) either close or touching it.\n// Once pullback occurs wait for BX Trender to issue a new green circle and BX Trend line must be gr\n// Price action must also pull up back above the (Green Line) EMA 21\n//Short\n//EMA Red (200) on top, White (89) in middle and Green (21) on bottom and there is distance between \n// Price action must pull back into 89 EMA (White line) either close or touching it.\n// Once pullback occurs wait for BX Trender to issue a new red circle and BX Trend line must be red \n// Price action must also pull up back below the (green Line) EMA 21\n// 21/89/200 EMA Cloud\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nvar string EMAGroupName = 'EMA Cloud'\ni_fastEMALength = input.int(21, title = 'Fast EMA length', step = 1, group = EMAGroupName\ni_midEMALength = input.int(89, title = 'Mid EMA length', step = 1, group = EMAGroupName\ni_slowEMALength = input.int(200, title ='Slow EMA length', step = 10, group = EMAGroupName\nfEMA = ta.ema(close, i_fastEMALength)\nmEMA = ta.ema(close, i_midEMALength)\nsEMA = ta.ema(close, i_slowEMALength)\nplotFEMA = plot(fEMA, 'FAST EMA', color= color.new(color.green, 0), linewidth = 2\nplotMEMA = plot(mEMA, 'MID EMA', color= color.new(color.white, 0), linewidth = 2,\nplotSEMA = plot(sEMA, 'SLOW EMA', color= color.new(color.red, 0), linewidth = 2, \nfill(plotFEMA, plotSEMA, color=fEMA > sEMA ?  color.new(color.green, 80) :  color.new\n// B-Xtrender @Puppytherapy\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nvar string BXTenderGroupName = 'B-XTENDER INPUTS'\nshort_l1 = input(5, title='Short - L1', group = BXTenderGroupName)\nshort_l2 = input(20, title='Short - L2', group = BXTenderGroupName)\nshort_l3 = input(15, title='Short - L3', group = BXTenderGroupName)\nlong_l1 = input(20, title='Long - L1', group = BXTenderGroupName)\nlong_l2 = input(15, title='Long - L2', group = BXTenderGroupName)\nshortTermXtrender = ta.rsi(ta.ema(close, short_l1) - ta.ema(close, short_l2), short_l3\nlongTermXtrender = ta.rsi(ta.ema(close, long_l1), long_l2) - 50\n// shortXtrenderCol = shortTermXtrender > 0 ? shortTermXtrender > shortTermXtrender[1] ? color.lime \n// plot(shortTermXtrender, color=shortXtrenderCol, style=plot.style_columns, linewidth=1, title='B-X\nt3(src, len) =>\n    xe1_1 = ta.ema(src, len)\n    xe2_1 = ta.ema(xe1_1, len)\n    xe3_1 = ta.ema(xe2_1, len)\n    xe4_1 = ta.ema(xe3_1, len)\n    xe5_1 = ta.ema(xe4_1, len)\n    xe6_1 = ta.ema(xe5_1, len)\n    b_1 = 0.7\n    c1_1 = -b_1 * b_1 * b_1\n    c2_1 = 3 * b_1 * b_1 + 3 * b_1 * b_1 * b_1\n    c3_1 = -6 * b_1 * b_1 - 3 * b_1 - 3 * b_1 * b_1 * b_1\n    c4_1 = 1 + 3 * b_1 + b_1 * b_1 * b_1 + 3 * b_1 * b_1\n    nT3Average_1 = c1_1 * xe6_1 + c2_1 * xe5_1 + c3_1 * xe4_1 + c4_1 * xe3_1\n    nT3Average_1\nmaShortTermXtrender = t3(shortTermXtrender, 5)\n// colShortTermXtrender = maShortTermXtrender > maShortTermXtrender[1] ? color.lime : color.red\n// plot(maShortTermXtrender, color=color.new(#000000, 0), style=plot.style_line, linewidth=3, title=\n// plot(maShortTermXtrender, color=colShortTermXtrender, style=plot.style_line, linewidth=3, title='\nBXTenderLongEntryCondition = maShortTermXtrender > maShortTermXtrender[1] and maShortTermXtrender\nBXTenderShortEntryCondition = maShortTermXtrender < maShortTermXtrender[1] and maShortTermXtrender\nplotshape(BXTenderLongEntryCondition ? maShortTermXtrender : na, location=location.belowbar\nplotshape(BXTenderShortEntryCondition ? maShortTermXtrender : na, location=location.abovebar\n/////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nuptrend = fEMA > mEMA and mEMA > sEMA  \ndntrend = fEMA < mEMA and mEMA < sEMA  \n// Checks for suitable distance between EMAS\nvar string EMADistanceGroupName = 'Minimum Gap Distance Between EMAs'\ni_minDistanceBetweenEMAs = input(78,title=\"Minimum distance between 21, 89 and 200 EMAs\"\nbool EMAUptrendWithDistance = (fEMA > (mEMA + i_minDistanceBetweenEMAs)) and (mEMA\nbool EMADowntrendWithDistance = (fEMA < (mEMA - i_minDistanceBetweenEMAs)) and (mEMA\nfill(plotFEMA, plotSEMA, color = EMAUptrendWithDistance or EMADowntrendWithDistance\n// var string pullBackGroupName = 'EMA Pullback Settings'\n// i_marginAboveOrBelowMidEMA = input(100,title=\"Margin of proximity to middle EMA for pullback dete\n// i_lookbackForEMAPullback = input(8, title=\"Lookback for EMA Pullback\", group=pullBackGroupName)\n// longMidEMAWithMargin = mEMA + i_marginAboveOrBelowMidEMA\n// shortMidEMAWithMargin = mEMA - i_marginAboveOrBelowMidEMA\n// longEMAPullBack = close < longMidEMAWithMargin\n// shortEMAPullBack= close > shortMidEMAWithMargin \n// longPB = ta.barssince(longEMAPullBack) <= i_lookbackForEMAPullback\n// shortPB = ta.barssince(shortEMAPullBack) <= i_lookbackForEMAPullback\n//Check for pullback / pushup into middle EMA calcs\nvar string pullBackGroupName = 'EMA Pullback Settings'\nPBperc = input.float(0.5, title = \"% Diff for EMA Pullback\", step = 0.1, group=pullBackGroupName\nPBlength = input.int(8, title = \"Lookback for EMA Pullback\", group=pullBackGroupName\n// Look for a pullback to the middle EMA (LONGS)\nlongPercentDiff = ((low - mEMA) / low) * 100\nlongPBcheck = longPercentDiff <= PBperc\nlongPB = ta.barssince(longPBcheck) <= PBlength\n// Look for a pushup to the middle EMA (SHORTS)\nshortPercentDiff = ((mEMA - high) / mEMA) * 100\nshortPBcheck = shortPercentDiff <= PBperc\nshortPB = ta.barssince(shortPBcheck) <= PBlength\nplotshape(longPB and not longPB[1], \"\", shape.labelup,   location.belowbar, color=\nplotshape(shortPB and not shortPB[1], \"\", shape.labeldown,   location.abovebar, color\nlongCondition = uptrend  and EMAUptrendWithDistance and longPB and BXTenderLongEntryCondition\nshortCondition = dntrend and EMADowntrendWithDistance and shortPB and BXTenderShortEntryCondition\ncloseLong = BXTenderShortEntryCondition\ncloseShort = BXTenderLongEntryCondition\nuseClose = input.bool(true, title = \"Use Close Signal\", group='Trade Direction')\n//define as 0 if do not want to use\ncloseLongCondition = useClose ? closeLong : 0\ncloseShortCondition = useClose ? closeShort :  0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title = \"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title = \"DI Length\", group=\"ADX\")\nadxabove = input(26, title = \"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADX = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title = 'Trade Direction', options\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title = 'Take Profit 1 - Target %', defval=0.5, minval=0.0, step\nq1 = input.int(title = '% Of Position', defval=25, minval=0, group='Take Profit', \n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title = 'Take Profit 2 - Target %', defval=1.5, minval=0.0, step\nq2 = input.int(title = '% Of Position', defval=50, minval=0, group='Take Profit', \n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title = 'Take Profit 3 - Target %', defval=2.5, minval=0.0, step\nq3 = input.int(title = '% Of Position', defval=25, minval=0, group='Take Profit', \n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title = 'Take Profit 4 - Target %', defval=7.5, minval=0.0, step\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title = 'Stop Loss (%)', defval=3.0, minval=0.01, step\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADX)\nshortConditionCalc = (shortCondition and isADX)\n// plotshape(shortConditionCalc, title='Short', style=shape.labeldown, location=location.abovebar, s\n// plotshape(longConditionCalc, title='Long', style=shape.labelup, location=location.belowbar, size=\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title = \"Show Dashboard\", defval=true\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our 12th one is an automated version of the \"The Most Powerful Tradingview Buy Sell Signal Indicator \" strategy from \"Power of Trading\" who doesn't make any official claims but watching how he trades with this, it on the surface looked promising. The strategy author uses this on the 15 min strategy on mostly FOREX. Unfortunately as indicated by the backtest results below, we were not able to substantiate any good positive trading metrics from this, be it Profit, Markdown, Num Of Trades etc. This does seem to do okay with some entries but perhaps adding another indicator to this to filter out more noise might make it better. At least how this strategy is presented now, this is not something I recommend anyone use. This strategy uses a combination of 2 open-source public indicators: SuperTrend by TradingView Internal One-Sided Gaussian Filter w/ Channels By Loxx The SuperTrend indicator and the One-Sided Gaussian Filter complement each other by providing a more complete and accurate picture of market trends. The SuperTrend indicator is used to identify trends. It does this by calculating a moving average of the underlying securities price and then comparing the current price to the moving average. When the current price is above the moving average, the trend is considered bullish, and when it is below, the trend is considered bearish. The One-Sided Gaussian Filter is a mathematical tool that is used to smooth out fluctuations in financial data. It does this by removing random noise from the data, making it easier to identify patterns and trends. When the SuperTrend indicator is used in conjunction with the One-Sided Gaussian Filter, the smoothed price data generated by the filter is used as the input for the SuperTrend calculation. This provides a more accurate representation of market trends and helps to eliminate false signals generated by short-term price movements. As a result, the SuperTrend indicator is able to more accurately identify the underlying trend in the market and provide traders with a cleaner and more reliable signal to act upon. In summary, the SuperTrend indicator and the One-Sided Gaussian Filter complement each other by providing a more accurate and reliable representation of market trends, resulting in improved performance for traders. If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me. Trading Rules 15 min candles FOREX or Crypto Stop loss at swing high/low | 1.5 risk/ratio Long Condition SuperTrend and OSGFC generate buy signal Close Buy on Gaussian generating a sell signal Short Condition SuperTrend and OSGFC generate sell signal Close Buy on Gaussian generating a buy signal"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #12 - OSGFC+SuperTrend - [MYN]', max_bars_back=5000\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n// 5XVKG4ZzVvY\n// Trading Rules: 15 mins, Forex / Crypto\n// SuperTrend and OSGFC generate buy signal\n// Close Buy on Gaussian generating a sell signal\n// Gausian generates sell signal (close signal)\n// One-Sided Gaussian Filter w/ Channels By Loxx\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nimport loxx/loxxexpandedsourcetypes/4\u200aas loxxexpandedsourcetypes\ngreencolor =  #2DD204\nredcolor =  #D2042D \n//ehlers 2-pole super smoother\n_twopoless(float src, int len)=>\n    a1 = 0., b1 = 0.\n    coef1 = 0., coef2 = 0., coef3 = 0.\n    filt = 0., trig = 0.\n    a1 := math.exp(-1.414 * math.pi / len)\n    b1 := 2 * a1 * math.cos(1.414 * math.pi / len)\n    coef2 := b1\n    coef3 := -a1 * a1\n    coef1 := 1 - coef2 - coef3\n    filt := coef1 * src + coef2 * nz(filt[1]) + coef3 * nz(filt[2])\n    filt := bar_index < 3 ? src : filt\n    filt\n    _gaussian(size, x)=>\n    out = (math.exp(-x * x * 9 / ((size + 1) * (size + 1))))\n    out\n//calc fibonacci numbers 0, 1, 1, 2, 3, 5, 8, 13, 21 ... etc\n_fiblevels(len)=>\n    arr_levels = array.new_float(len, 0.)\n    t1 = 0, t2 = 1\n    nxt = t1 + t2\n    for i = 0 to len - 1 \n        array.set(arr_levels, i, nxt)\n        t1 := t2\n        t2 := nxt\n        nxt := t1 + t2\n    arr_levels\n    //calc weights given fibo numbers and how many fibos chosen\n_gaussout(levels)=>\n    perin = array.size(levels)\n    arr_gauss = matrix.new<float>(perin, perin, 0.)\n    for k = 0 to array.size(levels) - 1 \n        sum = 0.\n        for i = 0 to perin - 1 \n            if (i >= array.get(levels, k)) \n                break\n            matrix.set(arr_gauss, i, k, _gaussian(array.get(levels, k), i))\n            sum += matrix.get(arr_gauss, i, k)\n        for i = 0 to perin - 1\n            if (i >= array.get(levels, k)) \n                break\n            temp = matrix.get(arr_gauss, i, k) / sum\n            matrix.set(arr_gauss, i, k, temp)\n    arr_gauss   \n//calc moving average applying fibo numbers\n_smthMA(level, src, per)=>\n    sum = 0.\n    lvltemp = _fiblevels(per)\n    gtemp = _gaussout(lvltemp)\n    for i = 0 to matrix.rows(gtemp) - 1\n        sum += matrix.get(gtemp, i, level) * nz(src[i])\n    sum\nsmthtype = input.string(\"Kaufman\", \"Heiken-Ashi Better Smoothing\", options = [\"AMA\"\nsrcoption = input.string(\"Close\", \"Source\", group= \"One-Sided Gaussian Filter w/ Channels\"\n     options = \n     [\"Close\", \"Open\", \"High\", \"Low\", \"Median\", \"Typical\", \"Weighted\", \"Average\", \n     \"HA Close\", \"HA Open\", \"HA High\", \"HA Low\", \"HA Median\", \"HA Typical\", \"HA Weighted\"\n     \"HAB Close\", \"HAB Open\", \"HAB High\", \"HAB Low\", \"HAB Median\", \"HAB Typical\", \n     smthper = input.int(10, \"Guassian Levels Depth\", maxval = 100, group=  \"Basic Settings\"\nextrasmthper = input.int(10, \"Extra Smoothing (2-Pole Ehlers Super Smoother) Period\"\natrper = input.int(21, \"ATR Period\", group = \"Basic Settings\")\nmult = input.float(.628, \"ATR Multiplier\", group = \"Basic Settings\")\ncolorbars = input.bool(true, \"Color bars?\", group = \"UI Options\")\nshowsignals = input.bool(true, \"Show signals?\", group = \"UI Options\")\nkfl=input.float(0.666, title=\"* Kaufman's Adaptive MA (KAMA) Only - Fast End\", group\nksl=input.float(0.0645, title=\"* Kaufman's Adaptive MA (KAMA) Only - Slow End\", group\namafl = input.int(2, title=\"* Adaptive Moving Average (AMA) Only - Fast\", group = \namasl = input.int(30, title=\"* Adaptive Moving Average (AMA) Only - Slow\", group =\nhaclose = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, \nhaopen = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, open\nhahigh = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, high\nhalow = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, low\nhamedian = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period,\nhatypical = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period\nhaweighted = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period\nhaaverage = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period\nfloat src = switch srcoption\n    \"Close\" => loxxexpandedsourcetypes.rclose()\n    \"Open\" => loxxexpandedsourcetypes.ropen()\n    \"High\" => loxxexpandedsourcetypes.rhigh()\n    \"Low\" => loxxexpandedsourcetypes.rlow()\n    \"Median\" => loxxexpandedsourcetypes.rmedian()\n    \"Typical\" => loxxexpandedsourcetypes.rtypical()\n    \"Weighted\" => loxxexpandedsourcetypes.rweighted()\n    \"Average\" => loxxexpandedsourcetypes.raverage()\n    \"Average Median Body\" => loxxexpandedsourcetypes.ravemedbody()\n    \"Trend Biased\" => loxxexpandedsourcetypes.rtrendb()\n    \"Trend Biased (Extreme)\" => loxxexpandedsourcetypes.rtrendbext()\n    \"HA Close\" => loxxexpandedsourcetypes.haclose(haclose)\n    \"HA Open\" => loxxexpandedsourcetypes.haopen(haopen)\n    \"HA High\" => loxxexpandedsourcetypes.hahigh(hahigh)\n    \"HA Low\" => loxxexpandedsourcetypes.halow(halow)\n    \"HA Median\" => loxxexpandedsourcetypes.hamedian(hamedian)\n    \"HA Typical\" => loxxexpandedsourcetypes.hatypical(hatypical)\n    \"HA Weighted\" => loxxexpandedsourcetypes.haweighted(haweighted)\n    \"HA Average\" => loxxexpandedsourcetypes.haaverage(haaverage)\n    \"HA Average Median Body\" => loxxexpandedsourcetypes.haavemedbody(haclose, haopen\n    \"HA Trend Biased\" => loxxexpandedsourcetypes.hatrendb(haclose, haopen, hahigh,\n    \"HA Trend Biased (Extreme)\" => loxxexpandedsourcetypes.hatrendbext(haclose, haopen\n    \"HAB Close\" => loxxexpandedsourcetypes.habclose(smthtype, amafl, amasl, kfl, ksl\n    \"HAB Open\" => loxxexpandedsourcetypes.habopen(smthtype, amafl, amasl, kfl, ksl\n    \"HAB High\" => loxxexpandedsourcetypes.habhigh(smthtype, amafl, amasl, kfl, ksl\n    \"HAB Low\" => loxxexpandedsourcetypes.hablow(smthtype, amafl, amasl, kfl, ksl)\n    \"HAB Median\" => loxxexpandedsourcetypes.habmedian(smthtype, amafl, amasl, kfl,\n    \"HAB Typical\" => loxxexpandedsourcetypes.habtypical(smthtype, amafl, amasl, kfl\n    \"HAB Weighted\" => loxxexpandedsourcetypes.habweighted(smthtype, amafl, amasl, \n    \"HAB Average\" => loxxexpandedsourcetypes.habaverage(smthtype, amafl, amasl, kfl\n    \"HAB Average Median Body\" => loxxexpandedsourcetypes.habavemedbody(smthtype, amafl\n    \"HAB Trend Biased\" => loxxexpandedsourcetypes.habtrendb(smthtype, amafl, amasl\n    \"HAB Trend Biased (Extreme)\" => loxxexpandedsourcetypes.habtrendbext(smthtype,\n    => haclose\nlmax = smthper + 1\nout1 = _smthMA(smthper, src, lmax)\nout = _twopoless(out1, extrasmthper)\nsig = out[1]\ncolorout = out > sig ? greencolor : redcolor\natr = ta.atr(atrper)\nsmax = out + atr * mult\nsmin = out - atr * mult\nplot(smax, color = bar_index % 2 ?  color.silver : na, linewidth = 1)\nplot(smin, color = bar_index % 2 ?  color.silver : na, linewidth = 1)\nplot(out, \"GMA\", color = colorout, linewidth = 4)\nbarcolor(colorbars ? colorout : na)\ngoLong = ta.crossover(out, sig)\ngoShort = ta.crossunder(out, sig)\nplotshape(goLong and showsignals, title = \"Long\", color =  color.yellow, textcolor\nplotshape(goShort and showsignals, title = \"Short\", color =  color.fuchsia, textcolor\nalertcondition(goLong, title=\"Long\", message=\"One-Sided Gaussian Filter w/ Channels [Loxx]: Lon\nalertcondition(goShort, title=\"Short\", message=\"One-Sided Gaussian Filter w/ Channels [Loxx]: Sho\nOSGFCLongEntry = goLong\nOSGFCShortgEntry = goShort\ni_numLookbackBarsOSGFC = input(0,title=\"Number of bars to look back to validate Trend\"\nOSGFCLongEntryFinal = goLong and ta.barssince(OSGFCShortgEntry) > i_numLookbackBarsOSGFC\nOSGFCShortgEntryFinal = goShort and ta.barssince(OSGFCLongEntry) > i_numLookbackBarsOSGFC\nOSGFCLongClose = OSGFCShortgEntry\nOSGFCShortClose = OSGFCLongEntry\n// SuperTrend (TradingView Interal)\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\natrPeriod1 = input(10, \"ATR Length\", group=\"SuperTrend\")\nfactor = input.float(3.0, \"Factor\", step = 0.01)\n[supertrend1, direction1] = ta.supertrend(factor, atrPeriod1)\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction1 < 0 ? supertrend1 : na, \"Up Trend\", color =  color.green\ndownTrend = plot(direction1 < 0 ? na : supertrend1, \"Down Trend\", color =  color.red\nfill(bodyMiddle, upTrend,  color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend,  color.new(color.red, 90), fillgaps=false)\nsuperTrendLongEntry = direction1 < 0 \nsuperTrendShortEntry = direction1 > 0 \ni_numLookbackBarsST = input(0,title=\"Number of bars to look back to validate Trend\"\nsuperTrendLongEntryFinal = superTrendLongEntry and ta.barssince(superTrendShortEntry\nsuperTrendShortEntryFinal = superTrendShortEntry and ta.barssince(superTrendLongEntry\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nlongCondition = OSGFCLongEntryFinal and superTrendLongEntryFinal \nshortCondition = OSGFCShortgEntryFinal and superTrendShortEntryFinal \n//define as 0 if do not want to use\ncloseLongCondition = OSGFCLongClose \ncloseShortCondition = OSGFCShortClose \n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=100, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=999, minval=0.01, group\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "Hello my friend! I'm uploading the code for your strategy. I have included a feature in the settings menu called \"Entry Direction\" that you can use to isolate only longs, only shorts or have both directions at the same time for the backtesting. I have set the strategy to only open 1 position at a time, it will not open a new position unless the previous position is closed. If you want to remove that just let me know. The green/red triangles that you will see plotting on the chart are the potential entry signals, you can turn them off from the style panel in the settings menu. In the inputs tab besides the strategy settings you also have all the relevant parameters for the three indicators used."}, {"role": "assistant", "content": "//@version=5\nstrategy('smplondonclinic Strategy', shorttitle='SMPLC Strategy', overlay=true, pyramiding\ndirection   = input.string(title='Entry Direction', defval='Long', options=['Long'\nTPPerc = input.float(title='Take Profit (%)', minval=0.0, step=0.1, defval=0.5, group\nSLPerc = input.float(title='Stop Loss (%)', minval=0.0, step=0.1, defval=0.5, group\nperiod = input(20, 'CCI period',group = \"TREND MAGIC\")\ncoeff = input(1, 'ATR Multiplier',group = \"TREND MAGIC\")\nAP = input(5, 'ATR Period',group = \"TREND MAGIC\")\nATR = ta.sma(ta.tr, AP)\nsrctm = close\nupT = low - ATR * coeff\ndownT = high + ATR * coeff\nMagicTrend = 0.0\nMagicTrend := ta.cci(srctm, period) >= 0 ? upT < nz(MagicTrend[1]) ? nz(MagicTrend\ncolor1 = ta.cci(srctm, period) >= 0 ?  #0022FC :  #FC0400\nplot(MagicTrend, color=color1, linewidth=3)\ntmb = ta.cci(srctm, period) >= 0 and close>MagicTrend\ntms = ta.cci(srctm, period) <= 0 and close<MagicTrend\n//MACD\nres           = input.timeframe(\"\",  \"Indicator TimeFrame\", group = \"MACD\")\nfast_length   = input.int(title=\"Fast Length\", defval=12, group = \"MACD\")\nslow_length   = input.int(title=\"Slow Length\", defval=26, group = \"MACD\")\nsrc           = input.source(title=\"Source\", defval=close, group = \"MACD\")\nsignal_length = input.int(title=\"Signal Smoothing\", minval = 1, maxval = 999, defval\nsma_source    = input.string(title=\"Oscillator MA Type\", defval=\"EMA\", options=[\"SMA\"\nsma_signal    = input.string(title=\"Signal Line MA Type\", defval=\"EMA\", options=[\"SMA\"\nfast_ma = request.security(syminfo.tickerid, res, sma_source == \"SMA\" ? ta.sma(src\nslow_ma = request.security(syminfo.tickerid, res, sma_source == \"SMA\" ? ta.sma(src\nmacd = fast_ma - slow_ma\nsignal = request.security(syminfo.tickerid, res, sma_signal == \"SMA\" ? ta.sma(macd\nhist = macd - signal\ntrend_up   = macd > signal\ntrend_dn   = macd < signal\ncross_UP   = signal[1] >= macd[1] and signal < macd\ncross_DN   = signal[1] <= macd[1] and signal > macd\ncross_UP_A = (signal[1] >= macd[1] and signal < macd) and macd > 0\ncross_DN_B = (signal[1] <= macd[1] and signal > macd) and macd < 0\n//UT Bot\nsrcut = close\nshowut = input.bool(false, 'Show UT Bot Labels', group = \"UT BOT\")\nkeyvalue = input.float(2, title='Key Vaule. \\'This changes the sensitivity\\'', step\natrperiod = input(7, title='ATR Period', group = \"UT BOT\")\nxATR = ta.atr(atrperiod)\nnLoss = keyvalue * xATR\nxATRTrailingStop = 0.0\niff_1 = srcut > nz(xATRTrailingStop[1], 0) ? srcut - nLoss : srcut + nLoss\niff_2 = srcut < nz(xATRTrailingStop[1], 0) and srcut[1] < nz(xATRTrailingStop[1], \nxATRTrailingStop := srcut > nz(xATRTrailingStop[1], 0) and srcut[1] > nz(xATRTrailingStop\npos = 0\niff_3 = srcut[1] > nz(xATRTrailingStop[1], 0) and srcut < nz(xATRTrailingStop[1], \npos := srcut[1] < nz(xATRTrailingStop[1], 0) and srcut > nz(xATRTrailingStop[1], 0\nxcolor = pos == -1 ?  color.red : pos == 1 ?  color.green :  color.blue\n//plot(xATR, color=xcolor, title='Trailing Stop')\nbuy = ta.crossover(srcut, xATRTrailingStop)\nsell = ta.crossunder(srcut, xATRTrailingStop)\nbarcolor = srcut > xATRTrailingStop\nplotshape(showut ? buy:na, title='Buy', text='Buy', style=shape.labelup, location=\nplotshape(showut ? sell:na, title='Sell', text='Sell', style=shape.labeldown, color\n//barcolor(barcolor ? color.green : color.red)\ngoLong = buy and tmb and cross_UP\ngoShort = sell and tms and cross_DN\nplotshape(goLong, location=location.bottom, style=shape.triangleup, color= color.lime\nplotshape(goShort, location=location.top, style=shape.triangledown, color= color.red\npercentAsPoints(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100.0 * strategy.position_avg_price\npercentAsPrice(pcnt) =>\n    strategy.position_size != 0 ? (pcnt / 100.0 + 1.0) * strategy.position_avg_price\ncurrent_position_size = math.abs(strategy.position_size)\ninitial_position_size = math.abs(ta.valuewhen(strategy.position_size[1] == 0.0, strategy.position_size\nTP = strategy.position_avg_price + percentAsPoints(TPPerc) * syminfo.mintick * strategy.position_size\nSL = strategy.position_avg_price - percentAsPoints(SLPerc) * syminfo.mintick * strategy.position_size\nvar long = false\nvar short = false\nif direction == 'Long' \n    long := goLong\n    short := false\nif direction == 'Short'\n    short := goShort\n    long := false\nif direction == 'Both' \n    long := goLong\n    short := goShort\nif long and strategy.opentrades == 0\n    strategy.entry(id='Long', direction=strategy.long)\nif short and strategy.opentrades == 0\n    strategy.entry(id='Short', direction=strategy.short)\nif strategy.position_size > 0\n    strategy.exit('TPSL', from_entry='Long', qty=initial_position_size, limit=TP, \nif strategy.position_size < 0\n    strategy.exit('TPSL2', from_entry='Short', qty=initial_position_size, limit=TP"}]}
{"messages": [{"role": "user", "content": "#23 on the Myth-Busting bench, we are automating the \"Best Funded Account Trading Strategy (Pass EVERY Challenge!)\" strategy from \"Trade with Pat\" who claims this strategy will pass every trading challenge out there. This strategy uses 3 open source indicators. 2 EMA's. The first one (Slow) is set to a length of 40 and a fast EMA which is set to 12. This strategy uses the crossover of the fast( 12) EMA over the Slow EMA ( 40 ) as the primary means to enter a long position. The opposite when the fast EMA crosses under the slow EMA as a means to indicate a short position. This strategy uses the DPO (Detrended Price Oscillaor) from the Uptrend Price DPO indicator in the same way we would traditionally use a stochastic or moving average convergence/divergence indicator like the MACD . Basically, the DPO helps evaluate and estimate the length of the price cycle from peak to peek or through to trough and in this strategy confirms entry of a long / short condition complimenting the EMA crossover/crossunders. And as always, If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me. This strategy uses a combination of 2 open-source public indicators: EMA x2 ( 40 and 12) Untrend Price DPO indicator by jTradeuh Trading Rules 1 or 4 hour candles Stop loss at previous highest-high (Short) and lowest-low (Long). Take Profit 2 - 2.5 the risk Strategy Template includes open source code from the following:  Performance Summary Dashboard by @VertMT  Time Of Day Window by @ddctv  Monthly Table Performance Dashboard by @QuantNomad"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #23 - 2xEMA+DPO- [MYN]', max_bars_back=5000, overlay\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// indicators:\n// EMA 40\n// EMA 12\n// Untrend Price DPO indicator ( jTradeuh ), on style  untick the DPOvalue\n// Entry rules:\n// Longs: EMA 12 have to cross EMA 40 and need to be above it and the Untrend price DPO indicator ha\n// Shorts: EMA 12 have to cross EMA 40 and need to be under it and the Untrend price DPO indicator h\n// SL recent swing high/low\n// TP 2.5 risk reward ratio.\n// Second confluence using Untrend Price DPO \n// 2 EMA\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlen1 = input.int(40, minval=1, title=\"Length\", group=\"EMA 1\")\nsrc1 = input(close, title=\"Source\")\noffset1 = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nout1 = ta.ema(src1, len1)\nplot(out1, title=\"EMA 1\", color= color.white, offset=offset1, linewidth=2)\nlen2 = input.int(12, minval=1, title=\"Length\", group=\"EMA 2\")\nsrc2 = input(close, title=\"Source\")\noffset2 = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nout2 = ta.ema(src2, len2)\nplot(out2, title=\"EMA 2\", color= color.yellow, offset=offset2, linewidth=2)\nemaLongEntry = ta.crossover(source1=out2 , source2 =out1 ) \nemaShortEntry = ta.crossunder(source1=out2 , source2 =out1 ) \n//  Uptrend Price DPO indicator\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nperiod_ = input.int(21, title='Period', minval=1,group=\"UpTrend DPO\")\nisCentered = input(false)\nbarsback = period_ / 2 + 1\nma = ta.sma(close, period_)\ndpo = isCentered ? close[barsback] - ma : close - ma[barsback]\nsma = ta.ema(dpo, 30)\nCOLOR = dpo > 0 ?  color.lime :  color.red\n//plot(sma, offset=isCentered ? -barsback : 0, title='DPO', color=COLOR, style=plot.style_histogram)\n//hline(0, title='Zero')\n// Last 2 bars at least need to be green\nupTrenndDPOEntryLong = dpo > 0 and dpo[1] > 0 and dpo[2] > 0\n// Last 2 bars at least need to be red\nupTrendDPOEntryShort = dpo < 0 and dpo[1] < 0 and dpo[2] < 0\n// Put Your Strategy Rules Below\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongCondition =  emaLongEntry and upTrenndDPOEntryLong         // default: false\nshortCondition = emaShortEntry and upTrendDPOEntryShort         // default: false\n//define as 0 if do not want to have a conditional close\ncloseLongCondition = false      // default: 0\ncloseShortCondition = false    // default: 0\n// EMA Filter\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_emaFilterEnabled = input.bool(defval = false , title = \"Enable EMA Filter\", tooltip\ni_emaLength = input.int(200, title=\"EMA Length\", minval=1, group =\"EMA Filter\")\ni_emaSource = input.source(close,\"EMA Source\" , group =\"EMA Filter\")\nemaValue = i_emaFilterEnabled ? ta.ema(i_emaSource, i_emaLength) : na\nbool isEMAFilterEnabledAndCloseAboveMA = i_emaFilterEnabled ? i_emaSource > emaValue\nbool isEMAFilterEnabledAndCloseBelowMA = i_emaFilterEnabled ? i_emaSource < emaValue\n// ADX Filter\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_adxFilterEnabled = input.bool(defval = false , title = \"Enable ADX Filter\", tooltip\ni_adxVariant = input.string('ORIGINAL', title='ADX Variant', options=['ORIGINAL', \ni_adxSmoothing = input.int(14, title=\"ADX Smoothing\", group=\"ADX Filter\")\ni_adxDILength = input.int(14, title=\"DI Length\", group=\"ADX Filter\")\ni_adxLowerThreshold = input.float(25, title=\"ADX Threshold\", step=.5, group=\"ADX Filter\"\ncalcADX_Masanakamura(int _len) =>\n    _smoothedTrueRange = 0.0\n    _smoothedDirectionalMovementPlus = 0.0\n    _smoothed_directionalMovementMinus = 0.0\n    _trueRange = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs\n    _directionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high\n    _directionalMovementMinus = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz\n    _smoothedTrueRange := nz(_smoothedTrueRange[1]) - nz(_smoothedTrueRange[1]) / \n    _smoothedDirectionalMovementPlus := nz(_smoothedDirectionalMovementPlus[1]) - \n    _smoothed_directionalMovementMinus := nz(_smoothed_directionalMovementMinus[1]\n    DIP = _smoothedDirectionalMovementPlus / _smoothedTrueRange * 100\n    DIM = _smoothed_directionalMovementMinus / _smoothedTrueRange * 100\n    _DX = math.abs(DIP - DIM) / (DIP + DIM) * 100\n    adx = ta.sma(_DX, _len)\n    [DIP, DIM, adx]\n[DIPlusO, DIMinusO, ADXO] = ta.dmi(i_adxDILength, i_adxSmoothing)\n[DIPlusM, DIMinusM, ADXM] = calcADX_Masanakamura(i_adxDILength)\nadx = i_adxFilterEnabled and i_adxVariant == \"ORIGINAL\" ? ADXO : ADXM\nbool isADXFilterEnabledAndAboveThreshold = i_adxFilterEnabled ? adx > i_adxLowerThreshold\n// Start / End Time Periods\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_startPeriodEnabled = input.bool(true, 'Start', group='Date Range', inline='Start Period'\ni_startPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\ni_endPeriodEnabled = input.bool(true, 'End', group='Date Range', inline='End Period'\ni_endPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nisStartPeriodEnabledAndInRange = i_startPeriodEnabled ? i_startPeriodTime <= time \nisEndPeriodEnabledAndInRange = i_endPeriodEnabled ? i_endPeriodTime >= time : true\n// Time-Of-Day Window\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired from https://www.tradingview.com/script/3BmID7aW-Highlight-Trading-Window-Simple-Hours-Time-of-Day-Filter\ni_timeFilterEnabled = input.bool(defval = false , title = \"Enable Time-Of-Day Window\"\ni_timeZone = input.string(title=\"Select Local Time Zone\", defval=\"GMT-5\", options=\ni_betweenTime = input.session('0700-0900',  title = \"Time Filter\", group=\"Time Window\"\nisWithinWindowOfTime(_position) =>                                                  \n    currentTimeIsWithinWindowOfTime = not na(time(timeframe.period, _position + ':1234567'\nbool isTimeFilterEnabledAndInRange = i_timeFilterEnabled ? isWithinWindowOfTime(i_betweenTime\nisStartEndPeriodsAndTimeInRange = isStartPeriodEnabledAndInRange and isEndPeriodEnabledAndInRange\n// Trade Direction and State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_tradeDirection = input.string('Long and Short', title='Trade Direction', options\n// Todo Add logic to reenter trade only if condition is still met only on TP\n//i_reenterPosition = input.bool(defval=true, title='Re-Enter Position on TP' , group='Trade Directi\n//longConditionFinal = i_reenterPosition ? longCondition : longCondition and not longCondition[1]\n//shortConditionFinal = i_reenterPosition ? shortCondition : shortCondition and not shortCondition[1\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\nlongConditionFinal = (longCondition and isADXFilterEnabledAndAboveThreshold and isEMAFilterEnabledAndCloseAboveMA\nshortConditionFinal = (shortCondition and isADXFilterEnabledAndAboveThreshold and \n// Trade Entry variables (not in position yet)\nbool openingLongPosition = longConditionFinal and not (strategy.opentrades.size(strategy.opentrades\nbool openingShortPosition = shortConditionFinal and not (strategy.opentrades.size(\nbool openingAnyPosition = openingLongPosition or openingShortPosition\nfloat closePriceWhenPositionOpened = ta.valuewhen(openingAnyPosition,close,0)\n// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Todo: Consider moving the strategy.entry calls above where the TP/SL close orders so that close o\nvar groupStopLoss = \"\ud83d\uded1 Stop Loss\"\ni_useStopLoss = input.bool (title=\"Use Stop Loss\", defval = true, group=groupStopLoss\ni_typeOfStopLoss = input.string (title=\"Type Of Stop Loss\", defval=\"Last Swing High/Low\"\ni_fixedPercentSL = input.float(title='Fixed %', defval=1, minval=0, step=0.5, group\ni_swingHighLowLookbackSL = input.int(21, title=\"Swing High/Low Lookback\", group=groupStopLoss\ni_atrLengthSL = input.int(title=\"ATR Length\", defval=14, minval = 1, inline=\"ATR SL\"\ni_atrMultiplierSL = input.float(title=\"ATR Multiplier\", defval=1, minval = 0, step\n// Fixed Percent Stop Loss\nfloat fixedPercentSLPriceWhenLongPositionEntered = ta.valuewhen(openingLongPosition\nfloat fixedPercentSLPriceWhenShortPositionEntered = ta.valuewhen(openingShortPosition\n// Swing High/Low Stop Loss\nfloat swingLowPriceWhenLongPostionEntered = ta.valuewhen(openingLongPosition, source\nfloat swingHighPriceWhenShortPositionEntered = ta.valuewhen(openingShortPosition, \n// Debug Start\n// drawLabel(_offset, _pivot, _style, _color) =>\n//     if not na(_pivot)\n//         label.new(bar_index[_offset], _pivot, str.tostring(_pivot, format.mintick), style=_style,\n// drawLabel(i_swingHighLowLookbackSL, ta.pivothigh(high, i_swingHighLowLookbackSL, i_swingHighLowLo\n// drawLabel(i_swingHighLowLookbackSL, ta.pivotlow(low, i_swingHighLowLookbackSL, i_swingHighLowLook\n// Debug End\n//ATR\n//todo determine if close should be source for both long/short or if high/low should be used?\nfloat ATRSLPriceWhenLongPositionEntered = ta.valuewhen(openingLongPosition, close \nfloat ATRSLPriceWhenShortPositionEntered = ta.valuewhen(openingShortPosition, close\n//plot(close + (ta.atr(i_atrLengthSL) * i_atrMultiplierSL), color=color.new(color.green, 0))\n//plot(close - (ta.atr(i_atrLengthSL) * i_atrMultiplierSL), color=color.new(color.red, 0))\nf_calculateStopLoss(string direction, string typeOfStopLoss) =>\n    // TODO init these to be 0 and \"\" as slPriceLong/Short is referenced by TP Risk:Reward calculation\n    float slOrderClosePrice = na  \n    string slOrderComment = na\n    switch typeOfStopLoss\n        \"Fixed %\" =>\n            slOrderClosePrice := direction == \"long\" ? fixedPercentSLPriceWhenLongPositionEntered\n            slOrderComment := direction == \"long\" ? \"SL Fixed % Long\" : \"SL Fixed % Short\"\n        \"Last Swing High/Low\" =>\n            slOrderClosePrice := direction == \"long\" ? swingLowPriceWhenLongPostionEntered\n            slOrderComment := direction == \"long\" ? \"SL Swing Low Long\" : \"SL Swing High Short\"\n        \"ATR\" =>                     \n            slOrderClosePrice := direction == \"long\" ? ATRSLPriceWhenLongPositionEntered\n            slOrderComment := direction == \"long\" ? \"SL ATR Long\" : \"SL ATR Short\"\n            [slOrderClosePrice,slOrderComment]\n        [slPriceLong, slCommentLong] = f_calculateStopLoss( \"long\",i_typeOfStopLoss)  \n[slPriceShort, slCommentShort] = f_calculateStopLoss(\"short\",i_typeOfStopLoss)  \nslLongCondition = close <= slPriceLong\nslShortCondition = close >= slPriceShort\n// Take Profit \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nvar groupTakeProfit = \"\ud83d\udfe2 Take Profit\"\ni_useTakeProfit = input.bool (title=\"Use Take Profit\", defval = true, group=groupTakeProfit\ni_typeOfTakeProfit = input.string (title=\"Type Of Take Profit\", defval=\"Risk:Reward Ratio\"\ni_fixedPercentTP = input.float(title='Single Fixed %', defval=1, minval=0, step=0.5\ni_takeProfitTargetPercent1 = input.float(title='Take Profit 1 - Target %', defval=\ni_takeProfitQuantityPercent1 = input.int(title='% Of Position', defval=100, minval\ni_takeProfitTargetPercent2 = input.float(title='Take Profit 2 - Target %', defval=\ni_takeProfitQuantityPercent2 = input.int(title='% Of Position', defval=100, minval\ni_takeProfitTargetPercent3 = input.float(title='Take Profit 3 - Target %', defval=\ni_takeProfitQuantityPercent3 = input.int(title='% Of Position', defval=100, minval\ni_takeProfitTargetPercent4 = input.float(title='Take Profit 4 - Target %', defval=\ni_RiskRewardRatioTP = input.float(title=\"Risk:Reward Ratio 1:#\", defval=2.5, minval\ni_atrLengthTP = input.int(title=\"ATR Length\", defval=14, minval = 1, inline=\"ATR TP\"\ni_atrMultiplierTP = input.float(title=\"ATR Multiplier\", defval=1, minval = 0, step\n// Single Fixed Percent Take Profit\nfloat fixedPercentTPPriceWhenLongPositionEntered = ta.valuewhen(openingLongPosition\nfloat fixedPercentTPPriceWhenShortPositionEntered = ta.valuewhen(openingShortPosition\n// Multiple\n// Risk:Reward Ratio Take Profit\ntpRRPriceWhenLongPositionEntered = closePriceWhenPositionOpened + ((closePriceWhenPositionOpened\ntpRRPriceWhenShortPositionEntered = closePriceWhenPositionOpened + ((closePriceWhenPositionOpened\n//ATR\n//todo determine if close should be source for both long/short or if high/low should be used?\nfloat ATRTPPriceWhenLongPositionEntered = ta.valuewhen(openingLongPosition, close \nfloat ATRTPPriceWhenShortPositionEntered = ta.valuewhen(openingShortPosition, close\n// plot(close + (ta.atr(i_atrLengthTP) * i_atrMultiplierTP), color=color.new(color.green, 0))\n// plot(close - (ta.atr(i_atrLengthTP) * i_atrMultiplierTP), color=color.new(color.red, 0))\nf_calculateTakeProfit(string direction, string typeOfTakeProfit) =>\n    float tpOrderClosePrice = na  \n    string tpOrderComment = na\n    switch typeOfTakeProfit\n        \"Single Fixed %\" =>\n            tpOrderClosePrice := direction == \"long\" ? fixedPercentTPPriceWhenLongPositionEntered\n            tpOrderComment := direction == \"long\" ? \"TP Single Fixed % Long\" : \"TP Single Fixed % Short\"\n        \"Multiple Fixed %\" =>\n            tpOrderClosePrice := na\n            tpOrderComment := \"\"\n        \"Risk:Reward Ratio\" =>\n            tpOrderClosePrice := direction == \"long\" ? tpRRPriceWhenLongPositionEntered\n            tpOrderComment := direction == \"long\" ? \"TP R:R Long\" : \"TP R:R Short\"\n        \"ATR\" =>                             \n            tpOrderClosePrice := direction == \"long\" ? ATRTPPriceWhenLongPositionEntered\n            tpOrderComment := direction == \"long\" ? \"TP ATR Long\" : \"TP ATR Short\"\n            [tpOrderClosePrice,tpOrderComment]\n        [tpPriceLong, tpCommentLong] = f_calculateTakeProfit( \"long\",i_typeOfTakeProfit)  \n[tpPriceShort, tpCommentShort] = f_calculateTakeProfit(\"short\",i_typeOfTakeProfit)\ntpLongCondition = close >= tpPriceLong\ntpShortCondition = close <= tpPriceShort\n// Functions\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Plotting\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//Plot SL and TP\ni_plotTPSL=input(true, title=\"Plot TP and SL\", group='Plotting')\nslbp=plot(i_plotTPSL and i_useStopLoss and strategy.position_size > 0 ? slPriceLong\ntpbp=plot(i_plotTPSL and i_useTakeProfit and strategy.position_size > 0 ? tpPriceLong\nepbp=plot(i_plotTPSL and strategy.position_size > 0 ? strategy.position_avg_price \nfill(slbp, epbp, color= color.new(color.red, 90))\nfill(tpbp, epbp, color= color.new(color.green, 90))\nslsp=plot(i_plotTPSL and i_useStopLoss and strategy.position_size < 0 ? slPriceShort\ntpsp=plot(i_plotTPSL and i_useTakeProfit and strategy.position_size < 0 ? tpPriceShort\nepsp=plot(i_plotTPSL and strategy.position_size < 0 ? strategy.position_avg_price \nfill(slsp, epsp, color= color.new(color.red, 90))\nfill(tpsp, epsp, color= color.new(color.green, 90))\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_leverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ni_percentOfEquityToTrade = input.float(100, \"% of Equity to Stake Per Trade\", minval\ncontracts = (i_percentOfEquityToTrade * strategy.equity / close * i_leverage)\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_alertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = i_alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nif isStartEndPeriodsAndTimeInRange\n    if longConditionFinal \n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionFinal\n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        if i_useTakeProfit\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n        if i_typeOfTakeProfit == \"Multiple Fixed %\"\n            strategy.exit('TP1', qty_percent=i_takeProfitQuantityPercent1, profit=\n            strategy.exit('TP2', qty_percent=i_takeProfitQuantityPercent2, profit=\n            strategy.exit('TP3', qty_percent=i_takeProfitQuantityPercent3, profit=\n            strategy.exit('i_takeProfitTargetPercent4', profit=per(i_takeProfitTargetPercent4\n        else\n            strategy.close('Long', comment=tpCommentLong, when=tpLongCondition)\n            strategy.close('Short', comment=tpCommentShort, when=tpShortCondition)\n        if i_useStopLoss \n        strategy.close('Long', comment=slCommentLong, when=slLongCondition)\n        strategy.close('Short', comment=slCommentShort, when=slShortCondition)\n            // Conditional Closes\n    strategy.close('Long', comment='Conditional Close Long', when=closeLongCondition\n    strategy.close('Short', comment='Conditional Close Short', when=closeShortCondition\n// Global Dashboard Variables\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Dashboard Table Text Size\ni_tableTextSize = input.string(title=\"Dashboard Size\", defval=\"Small\", options=[\"Auto\"\ntable_text_size(s) =>\n    switch s\n        \"Auto\"   => size.auto   \n        \"Huge\"   => size.huge   \n        \"Large\"  => size.large  \n        \"Normal\" => size.normal \n        \"Small\"  => size.small\n        => size.tiny\ntableTextSize = table_text_size(i_tableTextSize)\n/// Performance Summary Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\ni_showDashboard = input.bool(title=\"Performance Summary\", defval=true, group=\"Dashboards\"\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif i_showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.top_right, 1, 15, border_width=1)\n       if barstate.islastconfirmedhistory\n        // Update table\n        lastTime = strategy.position_size == 0 ? strategy.closedtrades.exit_time(strategy.closedtrades\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", lastTime) \n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (lastTime - strategy.closedtrades.entry_time(0)) / \n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow\n// Monthly Table Performance Dashboard By @QuantNomad\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_showMonthlyPerformance = input.bool(true, 'Monthly Performance', group='Dashboards'\ni_monthlyReturnPercision = 2\nif i_showMonthlyPerformance\n    new_month = month(time) != month(time[1])\n    new_year  = year(time)  != year(time[1])\n        eq = strategy.equity\n        bar_pnl = eq / eq[1] - 1\n        cur_month_pnl = 0.0\n    cur_year_pnl  = 0.0\n        // Current Monthly P&L\n    cur_month_pnl := new_month ? 0.0 : \n                     (1 + cur_month_pnl[1]) * (1 + bar_pnl) - 1 \n        // Current Yearly P&L\n    cur_year_pnl := new_year ? 0.0 : \n                     (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1  \n        // Arrays to store Yearly and Monthly P&Ls\n    var month_pnl  = array.new_float(0)\n    var month_time = array.new_int(0)\n        var year_pnl  = array.new_float(0)\n    var year_time = array.new_int(0)\n        last_computed = false\n        if (not na(cur_month_pnl[1]) and (new_month or barstate.islastconfirmedhistory\n        if (last_computed[1])\n            array.pop(month_pnl)\n            array.pop(month_time)\n                    array.push(month_pnl , cur_month_pnl[1])\n        array.push(month_time, time[1])\n        if (not na(cur_year_pnl[1]) and (new_year or barstate.islastconfirmedhistory))\n        if (last_computed[1])\n            array.pop(year_pnl)\n            array.pop(year_time)\n                    array.push(year_pnl , cur_year_pnl[1])\n        array.push(year_time, time[1])\n        last_computed := barstate.islastconfirmedhistory ? true : nz(last_computed[1])\n        // Monthly P&L Table    \n    var monthly_table = table(na)\n        if (barstate.islastconfirmedhistory)\n        monthly_table := table.new(position.bottom_right, columns = 14, rows = array.size\n            table.cell(monthly_table, 0,  0, \"\",     bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 1,  0, \"Jan\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 2,  0, \"Feb\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 3,  0, \"Mar\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 4,  0, \"Apr\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 5,  0, \"May\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 6,  0, \"Jun\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 7,  0, \"Jul\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 8,  0, \"Aug\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 9,  0, \"Sep\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 10, 0, \"Oct\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 11, 0, \"Nov\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 12, 0, \"Dec\",  bgcolor =  #cccccc, text_size=tableTextSize\n        table.cell(monthly_table, 13, 0, \"Year\", bgcolor =  #999999, text_size=tableTextSize\n            for yi = 0 to array.size(year_pnl) - 1\n            table.cell(monthly_table, 0,  yi + 1, str.tostring(year(array.get(year_time\n                        y_color = array.get(year_pnl, yi) > 0 ? color.new( color.teal, transp\n            table.cell(monthly_table, 13, yi + 1, str.tostring(math.round(array.get\n                    for mi = 0 to array.size(month_time) - 1\n            m_row   = year(array.get(month_time, mi))  - year(array.get(year_time,\n            m_col   = month(array.get(month_time, mi)) \n            m_color = array.get(month_pnl, mi) > 0 ? color.new( color.teal, transp\n                        table.cell(monthly_table, m_col, m_row, str.tostring(math.round(array.get"}]}
{"messages": [{"role": "user", "content": "The Rocket Grid Algorithm is a trading strategy that enables traders to engage in both long and short selling strategies. The script allows traders to backtest their strategies with a date range of their choice, in addition to selecting the desired strategy - either SMA Based Crossunder or SMA Based Crossover. The script is a combination of trend following and short-term mean reversing strategies. Trend following involves identifying the current market trend and riding it for as long as possible until it changes direction. This type of strategy can be used over a medium- to long-term time horizon, typically several months to a few years. Short-term mean reversing, on the other hand, involves taking advantage of short-term price movements that deviate from the average price. This type of strategy is usually applied over a much shorter time horizon, such as a few days to a few weeks. By rapidly entering and exiting positions, the strategy seeks to capture small, quick gains in volatile market conditions. Overall, the script blends the best of both worlds by combining the long-term stability of trend following with the quick gains of short-term mean reversing, allowing traders to potentially benefit from both short-term and long-term market trends. Traders can configure the start and end dates, months, and years, and choose the length of the data they want to work with. Additionally, they can set the percentage grid and the upper and lower destroyers to manage their trades effectively. The script also calculates the Simple Moving Average of the chosen data length and plots it on the chart. The trigger for entering a trade is defined as a crossunder or crossover of the close price with the Simple Moving Average. Once the trigger is activated, the script calculates the total percentage of the side and creates a grid range. The grid range is then divided into ten equal parts, with each part representing a unique grid level. The script keeps track of each grid level, and once the close price reaches the grid level, it opens a trade in the specified direction. The equity management strategy in the script involves a dynamic allocation of equity to each trade. The first order placed uses 10% of the available equity, while each subsequent order uses 1% less of the available equity. This results in the allocation of 9% for the second order, 8% for the third order, and so on, until a maximum of 10 open trades. This approach allows for risk management and can help to limit potential losses. Overall, the Rocket Grid Algorithm is a flexible and powerful trading strategy that can be customized to meet the specific needs of individual traders. Its user-friendly interface and robust backtesting capabilities make it an excellent tool for traders looking to enhance their trading experience."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551       \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551       \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \n// \u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551       \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551  \n// \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d        \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u255d  \n                                                                                                    //@version=5\nstrategy(\n     title = 'Rocket Grid Algorithm - The Quant Science', \n     overlay = true,\n     initial_capital = 10000, \n     commission_type = strategy.commission.percent, \n     commission_value = 0.07, \n     pyramiding = 10,\n     default_qty_type = strategy.percent_of_equity,\n     process_orders_on_close=true\n     )\n// #################################################################################################\nlong  = input.bool(defval = false, title = \"Long Strategy   |\", inline = \"Strategy\"\nshort = input.bool(defval = false, title = \"Short Selling Strategy  \", inline = \"Strategy\"\n// #################################################################################################\nstartDate   = input.int(title=\"Start Date\", defval=1, minval=1, maxval=31, group =\nstartMonth  = input.int(title=\"Start Month\", defval=1, minval=1, maxval=12, group \nstartYear   = input.int(title=\"Start Year\", defval=2018, minval=1800, maxval=2100,\nendDate     = input.int(title=\"End Date\", defval=31, minval=1, maxval=31, group = \nendMonth    = input.int(title=\"End Month\", defval=12, minval=1, maxval=12, group =\nendYear     = input.int(title=\"End Year\", defval=2023, minval=1800, maxval=2100, group\ninDateRange = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\n// #################################################################################################\nlenght_data = input.int(defval = 10, title = \"Lenght: \", minval = 0, group = \"Lenght Configuration\"\n// #################################################################################################\nsma     = ta.sma(close, lenght_data)\n// #################################################################################################\nten_grid        = input.bool(defval = false, title = \"Enable Strategy\", tooltip = \npercentagegrid  = input.float(defval = 0.50, minval = 0, step = 0.10, title = \"Percentage grid: \"\nstop_loss       = input.float(defval = 2.00, minval = 0, step = 0.10, title = \"Lower destroyer: \"\ntake_profit     = input.float(defval = 2.00, minval = 0, step = 0.10, title = \"Upper destroyer: \"\n// #################################################################################################\nvar float high_start = 0 \nvar float high_end   = 0\ntrigger_event_sma1  = ta.crossunder(close, sma)  and barstate.isconfirmed\ntrigger_event_sma2  = ta.crossover(close,  sma)  and barstate.isconfirmed\nTriggerGrid(type) =>\n        switch type\n        'SMA Based Crossunder'   => trigger_event_sma1==true\n        'SMA Based Crossover'    => trigger_event_sma2==true\ntype_input = input.string(\n     'SMA Based Crossunder',\n     title = \"Select strategy: \",\n     options = [\n         'SMA Based Crossunder', \n         'SMA Based Crossover'\n         ],\n     group = \"Trigger definition\"\n     )\ntrigger_entry = TriggerGrid(type_input) and strategy.opentrades==0 \np_trigger_event       = ta.valuewhen(trigger_entry, close, 0)\ntotal_percentage_side = 10 * percentagegrid\nif trigger_entry==true\n    high_start := p_trigger_event + ((p_trigger_event * total_percentage_side)/100\n    high_end   := p_trigger_event - ((p_trigger_event * total_percentage_side)/100\ngrid_range = high_start - high_end\nvar float grid_1  = 0\nvar float grid_2  = 0\nvar float grid_3  = 0\nvar float grid_4  = 0\nvar float grid_5  = 0\nvar float grid_6  = 0\nvar float grid_7  = 0\nvar float grid_8  = 0\nvar float grid_9  = 0\nvar float grid_10 = 0\nvar float grid_11  = 0\nvar float grid_12  = 0\nvar float grid_13  = 0\nvar float grid_14  = 0\nvar float grid_15  = 0\nvar float grid_16  = 0\nvar float grid_17  = 0\nvar float grid_18  = 0\nvar float grid_19  = 0\nvar float grid_20  = 0\nvar float factor = 0 \nvar float p = 0\nif ten_grid == true and trigger_entry==true \n    factor := grid_range / 20\n    p := p_trigger_event\n    // UP GRID\n    grid_1  := (p + (factor * 1)) \n    grid_2  := (p + (factor * 2)) \n    grid_3  := (p + (factor * 3)) \n    grid_4  := (p + (factor * 4)) \n    grid_5  := (p + (factor * 5))\n    grid_6  := (p + (factor * 6)) \n    grid_7  := (p + (factor * 7)) \n    grid_8  := (p + (factor * 8)) \n    grid_9  := (p + (factor * 9))\n    grid_10 := (p + (factor * 10))\n    // DOWN GRID\n    grid_11  := (p - (factor * 1)) \n    grid_12  := (p - (factor * 2)) \n    grid_13  := (p - (factor * 3)) \n    grid_14  := (p - (factor * 4)) \n    grid_15  := (p - (factor * 5))\n    grid_16  := (p - (factor * 6)) \n    grid_17  := (p - (factor * 7)) \n    grid_18  := (p - (factor * 8)) \n    grid_19  := (p - (factor * 9))\n    grid_20  := (p - (factor * 10))\nvar float new_ten_grid_1  = 0 \nvar float new_ten_grid_2  = 0 \nvar float new_ten_grid_3  = 0 \nvar float new_ten_grid_4  = 0 \nvar float new_ten_grid_5  = 0 \nvar float new_ten_grid_6  = 0 \nvar float new_ten_grid_7  = 0 \nvar float new_ten_grid_8  = 0 \nvar float new_ten_grid_9  = 0 \nvar float new_ten_grid_10 = 0\nvar float new_ten_grid_11  = 0 \nvar float new_ten_grid_12  = 0 \nvar float new_ten_grid_13  = 0 \nvar float new_ten_grid_14  = 0 \nvar float new_ten_grid_15  = 0 \nvar float new_ten_grid_16  = 0 \nvar float new_ten_grid_17  = 0 \nvar float new_ten_grid_18  = 0 \nvar float new_ten_grid_19  = 0 \nvar float new_ten_grid_20  = 0 \ndestroyall = new_ten_grid_20 - (new_ten_grid_20 * stop_loss / 100)\ndes_function = ta.crossunder(close, destroyall)\ntakeprofitlevel = new_ten_grid_10 + (new_ten_grid_10 * take_profit / 100)\ndes_function2 = ta.crossover(close, takeprofitlevel)\nvar float lots_up1  = 0\nvar float lots_up2  = 0\nvar float lots_up3  = 0\nvar float lots_up4  = 0\nvar float lots_up5  = 0\nvar float lots_up6  = 0\nvar float lots_up7  = 0\nvar float lots_up8  = 0\nvar float lots_up9  = 0\nvar float lots_up10 = 0\nvar float lots_down1  = 0\nvar float lots_down2  = 0\nvar float lots_down3  = 0\nvar float lots_down4  = 0\nvar float lots_down5  = 0\nvar float lots_down6  = 0\nvar float lots_down7  = 0\nvar float lots_down8  = 0\nvar float lots_down9  = 0\nvar float lots_down10 = 0\nif trigger_entry==true and ten_grid==true and inDateRange and strategy.opentrades==\n    new_ten_grid_1   := grid_1\n    new_ten_grid_2   := grid_2\n    new_ten_grid_3   := grid_3\n    new_ten_grid_4   := grid_4\n    new_ten_grid_5   := grid_5\n    new_ten_grid_6   := grid_6\n    new_ten_grid_7   := grid_7\n    new_ten_grid_8   := grid_8\n    new_ten_grid_9   := grid_9\n    new_ten_grid_10  := grid_10\n    new_ten_grid_11  := grid_11\n    new_ten_grid_12  := grid_12\n    new_ten_grid_13  := grid_13\n    new_ten_grid_14  := grid_14\n    new_ten_grid_15  := grid_15\n    new_ten_grid_16  := grid_16\n    new_ten_grid_17  := grid_17\n    new_ten_grid_18  := grid_18\n    new_ten_grid_19  := grid_19\n    new_ten_grid_20  := grid_20\n    lots_up1  := (((strategy.equity / close) * 10) /100)\n    lots_up2  := (((strategy.equity / close) * 9)  /100)\n    lots_up3  := (((strategy.equity / close) * 8)  /100)\n    lots_up4  := (((strategy.equity / close) * 7)  /100)\n    lots_up5  := (((strategy.equity / close) * 6)  /100)\n    lots_up6  := (((strategy.equity / close) * 5)  /100)\n    lots_up7  := (((strategy.equity / close) * 4)  /100)\n    lots_up8  := (((strategy.equity / close) * 3)  /100)\n    lots_up9  := (((strategy.equity / close) * 2)  /100)\n    lots_up10 := (((strategy.equity / close) * 1)  /100)\n    if long == true \n        if new_ten_grid_1\n            strategy.entry(id = \"O #1\",  direction = strategy.long, qty = lots_up1\n        if new_ten_grid_2\n            strategy.entry(id = \"O #2\",  direction = strategy.long, qty = lots_up2\n        if new_ten_grid_3\n            strategy.entry(id = \"O #3\",  direction = strategy.long, qty = lots_up3\n        if new_ten_grid_4\n            strategy.entry(id = \"O #4\",  direction = strategy.long, qty = lots_up4\n        if new_ten_grid_5\n            strategy.entry(id = \"O #5\",  direction = strategy.long, qty = lots_up5\n        if new_ten_grid_6\n            strategy.entry(id = \"O #6\",  direction = strategy.long, qty = lots_up6\n        if new_ten_grid_7\n            strategy.entry(id = \"O #7\",  direction = strategy.long, qty = lots_up7\n        if new_ten_grid_8\n            strategy.entry(id = \"O #8\",  direction = strategy.long, qty = lots_up8\n        if new_ten_grid_9\n            strategy.entry(id = \"O #9\",  direction = strategy.long, qty = lots_up9\n        if new_ten_grid_10\n            strategy.entry(id = \"O #10\", direction = strategy.long, qty = lots_up10\n    if short == true \n        if new_ten_grid_1 \n            strategy.entry(id = \"O #1\",  direction = strategy.short, qty = lots_up1\n        if new_ten_grid_2\n            strategy.entry(id = \"O #2\",  direction = strategy.short, qty = lots_up2\n        if new_ten_grid_3 \n            strategy.entry(id = \"O #3\",  direction = strategy.short, qty = lots_up3\n        if new_ten_grid_4 \n            strategy.entry(id = \"O #4\",  direction = strategy.short, qty = lots_up4\n        if new_ten_grid_5 \n            strategy.entry(id = \"O #5\",  direction = strategy.short, qty = lots_up5\n        if new_ten_grid_6 \n            strategy.entry(id = \"O #6\",  direction = strategy.short, qty = lots_up6\n        if new_ten_grid_7 \n            strategy.entry(id = \"O #7\",  direction = strategy.short, qty = lots_up7\n        if new_ten_grid_8 \n            strategy.entry(id = \"O #8\",  direction = strategy.short, qty = lots_up8\n        if new_ten_grid_9 \n            strategy.entry(id = \"O #9\",  direction = strategy.short, qty = lots_up9\n        if new_ten_grid_10 \n            strategy.entry(id = \"O #10\", direction = strategy.short, qty = lots_up10\nif des_function or des_function2 or close <= destroyall or close >= takeprofitlevel\n    strategy.close_all(\">>>> Destroyed Grid <<<<\")\n// #################################################################################################\nfill(plot(grid_1, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_2, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_2, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_3, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_3, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_4, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_4, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_5, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 90))\nfill(plot(grid_1, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_6, color =  color.new(color.rgb(0, 255, 132), 95)), \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_6, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_7, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_7, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_8, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_8, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_9, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_9, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_10, color =  color.new(color.rgb(0, 255, 132), 95)), \n         color =  color.new(#00ff08, 90))\nfill(plot(grid_11, color =  color.new(#ff3c00, 95)), \n     plot(grid_12, color =  color.new(#fd3d36, 95)),  \n         color =  color.new(#ff0000, 80))\nfill(plot(grid_12, color =  color.new(#ff0000, 95)),  \n     plot(grid_13, color =  color.new(#ff0000, 95)),  \n         color =  color.new(#ff0000, 85))\nfill(plot(grid_13, color =  color.new(#ff0000, 95)),  \n     plot(grid_14, color =  color.new(#ff0000, 95)),  \n         color =  color.new(#ff0000, 85))\nfill(plot(grid_14, color =  color.new(#ff0000, 95)), \n     plot(grid_15, color =  color.new(#ff0000, 95)),  \n         color =  color.new(#ff0000, 90))\nfill(plot(grid_11, color =  color.new(#ff0000, 95)),  \n     plot(grid_16, color =  color.new(#ff0800, 95)), \n         color =  color.new(#ff4800, 80))\nfill(plot(grid_16, color =  color.new(#ff1100, 95)),  \n     plot(grid_17, color =  color.new(#ff2600, 95)),  \n         color =  color.new(#ff3300, 80))\nfill(plot(grid_17, color =  color.new(#ff0000, 95)), \n     plot(grid_18, color =  color.new(#ff0000, 95)),  \n         color =  color.new(#ff3c00, 85))\nfill(plot(grid_18, color =  color.new(#ff3300, 95)),  \n     plot(grid_19, color =  color.new(#ff3c00, 95)),  \n         color =  color.new(#ff3300, 85))\nfill(plot(grid_19, color =  color.new(#ff3c00, 95)), \n     plot(grid_20, color =  color.new(#ff0800, 95)), \n         color =  color.new(#ff1e00, 90))\n// #################################################################################################\nif strategy.equity <= 0 \n    runtime.error(\" BANKRUPTCY: BACKTEST RETURN LOSS > EQUITY !!! \")\n// #################################################################################################"}]}
{"messages": [{"role": "user", "content": "Last Price minus Open Price Intraday Volume  Change in price from day Open price to Last Price indicate the stock price  movement. Last Price  minus Open Price Intraday Volume indicator is framed on volume change during change in price from day Open price to Last Price. It takes into account the average intraday volume based on intraday length of bars and actual volume attributed to change in price from day Open Price to Last Price. The indicator reflects the change in trend .By analyzing the position of price on the basis of average change in volume during intraday with that of volume attributed to change in price from day open Price to Last price one may decide upon the course of trade. DISCLAIMER: For educational and entertainment purposes only. Nothing in this content should be interpreted as financial advice or a recommendation to buy or sell any sort of security or investment including all types of crypto."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 avsr90\n//@version=5\nstrategy(title=\"Lp-Op vol\",shorttitle=\"LPV\", max_bars_back = 5000,overlay=false,format\n//Resolutions\nResn=input.timeframe(defval=\"\",title=\"resolution\")\nResn1=input.timeframe(defval=\"D\",title=\"resolution\")\n//Intraday Open and Last Price and Last price- Open Price calculations.\nLast_Price=math.round_to_mintick(close)\nOpen_Price = request.security(syminfo.tickerid ,Resn1,close[1],barmerge.gaps_off, barmerge.lookahead_on\nOp_Cl=math.round_to_mintick(Last_Price-Open_Price)\n//length from Intra Day Open Price \n Nifnum= ta.change(Open_Price)\nLength_Intraday=int(math.max(1, nz(ta.barssince(Nifnum)) + 1))\n//Input for Length for Volume \nLength_Vol=input(defval=20, title=\"L for Vol\")\n// Last Price- Open price Volume, Average Intraday Last price-Open Price Volume \n//and  Volume Bars  calculations.\nOp_Cl_Vol=(Op_Cl*volume)\nAvg_Vol_Opcl=ta.sma(Op_Cl_Vol,Length_Intraday)\nVol_Bars=ta.sma(volume,Length_Vol)\n//Plots \nplot(Op_Cl_Vol,color=Op_Cl_Vol>0 ?  color.green: color.red,title=\"OPCLV\")\nplot(Avg_Vol_Opcl, title=\"Avg Vol\", color= color.fuchsia)\nplot(Vol_Bars, title=\"Vol Bars\", color= color.yellow)\n//Strategy parameters \nstartst=timestamp(2015,10,1)\nstrategy.entry(\"lo\",strategy.long,when= ta.crossover(Op_Cl_Vol,Avg_Vol_Opcl) and ta.crossover\nstrategy.entry(\"sh\",strategy.short,when=ta.crossunder(Op_Cl_Vol,Avg_Vol_Opcl)and ta.crossunder"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our 11th one is an automated version of the \"Magic Trading Strategy : Most Profitable Indicator : 1 Minute Scalping Strategy Crypto\" strategy from \"Fx MENTOR US\" who doesn't make any official claims but given the indicators he was using, it looked like on the surface that this might actually work. The strategy author uses this on the 1 minute and 3 minute timeframes on mostly FOREX and Heiken Ashi candles but as the title of his strategy indicates is designed for Crypto. So who knows.. To backtest this accurately and get a better picture we resolved the Heiken Ashi bars to standard candlesticks . Even so, I was unable to sustain any consistency in my results on either the 1 or 3 min time frames and both FOREX and Crypto. 10000% Busted. This strategy uses a combination of 3 open-source public indicators: Trend Magic by KivancOzbilgic Squeeze Momentum by LazyBear Cumulative Delta Volume by LonesomeTheBlue Trend Magic consists of two main indicators to validate momentum and volatility.  It uses an ATR like a trailing Stop to determine the overarching momentum and CCI as a means to validate volatility.  Together these are used as the primary indicator in this strategy.  When the CCI is above 0 this is confirmation of a volatility event is occurring with affirmation based upon current momentum (ATR).    The CCI volatility indicator gets confirmation by the the Cumulative Delta Volume indicator which calculates the difference between buying and selling pressure. Volume Delta is calculated by taking the difference of the volume that traded at the offer price and the volume that traded at the bid price.  The more volume that is traded at the bid price, the more likely there is momentum in the market. And lastly the Squeeze Momentum indicator which uses a combination of Bollinger Bands, Keltner Channels and Momentum are used to again confirm momentum and volatility. During periods of low volatility, Bollinger bands narrow and trade inside Keltner channels. They can only contract so much before it can\u2019t contain the energy it\u2019s been building. When the Bollinger bands come back out, it explodes higher.  When we see the histogram bar exploding into green above 0 that is a clear confirmation of increased momentum and volatile.  The opposite (red) below 0 is true when there are low periods.  This indicator is used as a means to really determine when there is premium selling plays going on leading to big directional movements again confirming the positive or negative momentum and volatility direction. If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me. Trading Rules 1 - 3 min candles FOREX or Crypto Stop loss at swing high/low | 1.5 risk/ratio Long Condition Trend Magic line is Blue ( CCI is above 0) and above the current close on the bar Squeeze Momentum's histogram bar is green/lime Cumulative Delta Volume line is green Short Condition Trend Magic line is Red ( CCI is below 0) and below the current close on the bar Squeeze Momentum's histogram bar is red/maroon Cumulative Delta Volume line is peach"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #11 - TrendMagic+SqzMom+CDV - [MYN]', max_bars_back\n// HA to Regular Candlestick resolover\nuseHA = input.bool(true, \"Use Heiken Ashi\")\nCLOSE = close\nOPEN = open\nHIGH = high\nLOW = low\nCLOSE := useHA ? (OPEN + CLOSE + HIGH + LOW) / 4 : CLOSE\nOPEN := useHA ? na(OPEN[1]) ? (OPEN + CLOSE) / 2: (OPEN[1] + CLOSE[1]) / 2 : OPEN\nHIGH := useHA ? math.max(HIGH, math.max(OPEN, CLOSE)) : HIGH\nLOW := useHA ? math.min(LOW, math.min(OPEN, CLOSE)) : LOW\nisCrypto = input.bool(true, \"Is Crypto?\")\n// Functions\nf_priorBarsSatisfied(_objectToEval, _numOfBarsToLookBack) => \n    returnVal = false\n    for i = 0 to _numOfBarsToLookBack\n        if (_objectToEval[i] == true)\n            returnVal = true\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n// Trend Magic by KivancOzbilgic\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nperiod = input(20, 'CCI period')\ncoeff = input(2, 'ATR Multiplier')\nAP = input(5, 'ATR Period')\nATR = ta.sma(ta.tr, AP)\nsrc = CLOSE\nupT = LOW - ATR * coeff\ndownT = HIGH + ATR * coeff\nMagicTrend = 0.0\nMagicTrend := ta.cci(src, period) >= 0 ? upT < nz(MagicTrend[1]) ? nz(MagicTrend[1\ncolor1 = ta.cci(src, period) >= 0 ?  #0022FC :  #FC0400\nplot(MagicTrend, color=color1, linewidth=3)\nalertcondition(ta.cross(CLOSE, MagicTrend), title='Cross Alert', message='Price - MagicTrend Crossing!'\nalertcondition(ta.crossover(LOW, MagicTrend), title='CrossOver Alarm', message='BUY SIGNAL!'\nalertcondition(ta.crossunder(HIGH, MagicTrend), title='CrossUnder Alarm', message=\ni_numLookbackBarsTM = input(17,title=\"Number of bars to look back to validate Trend Mag\n//trendMagicEntryLong = trendMagicEntryConditionLong and f_priorBarsSatisfied(trendMagicEntryConditi\n//trendMagicEntryShort = trendMagicEntryConditionShort and f_priorBarsSatisfied(trendMagicEntryCondi\ntrendMagicEntryConditionLong = ta.cci(src, period) >= 0 and src > MagicTrend + (isCrypto\ntrendMagicEntryConditionShort = ta.cci(src, period) < 0 and src < MagicTrend - (isCrypto\ntrendMagicEntryLong = trendMagicEntryConditionLong and ta.barssince(trendMagicEntryConditionShort\ntrendMagicEntryShort = trendMagicEntryConditionShort and ta.barssince(trendMagicEntryConditionLong\n// Squeeze Momentum by LazyBear\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlength = input(10, title='BB Length', group=\"Squeeze Momentum\")\nmult = input(2.0, title='BB MultFactor')\nlengthKC = input(10, title='KC Length')\nmultKC = input(1.5, title='KC MultFactor')\nuseTrueRange = input(true, title='Use TrueRange (KC)')\n// Calculate BB\nsource = CLOSE\nbasis = ta.sma(source, length)\ndev = multKC * ta.stdev(source, length)\nupperBB = basis + dev\nlowerBB = basis - dev\n// Calculate KC\nma = ta.sma(source, lengthKC)\nrange_1 = useTrueRange ? ta.tr : HIGH - LOW\nrangema = ta.sma(range_1, lengthKC)\nupperKC = ma + rangema * multKC\nlowerKC = ma - rangema * multKC\nsqzOn = lowerBB > lowerKC and upperBB < upperKC\nsqzOff = lowerBB < lowerKC and upperBB > upperKC\nnoSqz = sqzOn == false and sqzOff == false\nval = ta.linreg(source - math.avg(math.avg(ta.highest(HIGH, lengthKC), ta.lowest(LOW\niff_1 = val > nz(val[1]) ?  color.lime :  color.green\niff_2 = val < nz(val[1]) ?  color.red :  color.maroon\nbcolor = val > 0 ? iff_1 : iff_2\nscolor = noSqz ?  color.blue : sqzOn ?  color.black :  color.gray\n//plot(val, color=bcolor, style=plot.style_histogram, linewidth=4)\n//plot(0, color=scolor, style=plot.style_cross, linewidth=2)\ni_numLookbackBarsSM = input(14,title=\"Number of bars to look back to validate Sqz Mom t\n//sqzmomEntryLong = val > 0 and f_priorBarsSatisfied(val > 0,i_numLookbackBarsSM)\n//sqzmomEntryShort = val < 0 and f_priorBarsSatisfied(val < 0,i_numLookbackBarsSM)\nsqzmomEntryConditionLong = val > 0 \nsqzmomEntryConditionShort = val < 0\nsqzmomEntryLong = sqzmomEntryConditionLong and ta.barssince(sqzmomEntryConditionShort\nsqzmomEntryShort = sqzmomEntryConditionShort and ta.barssince(sqzmomEntryConditionLong\n// Cumulative Delta Volume by LonesomeTheBlue\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlinestyle = input.string(defval='Candle', title='Style', options=['Candle', 'Line'\nhacandle = input(defval=true, title='Heikin Ashi Candles?')\nshowma1 = input.bool(defval=false, title='SMA 1', inline='ma1')\nma1len = input.int(defval=50, title='', minval=1, inline='ma1')\nma1col = input.color(defval= color.lime, title='', inline='ma1')\nshowma2 = input.bool(defval=false, title='SMA 2', inline='ma2')\nma2len = input.int(defval=200, title='', minval=1, inline='ma2')\nma2col = input.color(defval= color.red, title='', inline='ma2')\nshowema1 = input.bool(defval=false, title='EMA 1', inline='ema1')\nema1len = input.int(defval=50, title='', minval=1, inline='ema1')\nema1col = input.color(defval= color.lime, title='', inline='ema1')\nshowema2 = input.bool(defval=false, title='EMA 2', inline='ema2')\nema2len = input.int(defval=200, title='', minval=1, inline='ema2')\nema2col = input.color(defval= color.red, title='', inline='ema2')\ncolorup = input.color(defval= color.lime, title='Body', inline='bcol')\ncolordown = input.color(defval= color.red, title='', inline='bcol')\nbcolup = input.color(defval= #74e05e, title='Border', inline='bocol')\nbcoldown = input.color(defval= #ffad7d, title='', inline='bocol')\nwcolup = input.color(defval= #b5b5b8, title='Wicks', inline='wcol')\nwcoldown = input.color(defval= #b5b5b8, title='', inline='wcol')\ntw = HIGH - math.max(OPEN, CLOSE)\nbw = math.min(OPEN, CLOSE) - LOW\nbody = math.abs(CLOSE - OPEN)\n_rate(cond) =>\n    ret = 0.5 * (tw + bw + (cond ? 2 * body : 0)) / (tw + bw + body)\n    ret := nz(ret) == 0 ? 0.5 : ret\n    ret\ndeltaup = volume * _rate(OPEN <= CLOSE)\ndeltadown = volume * _rate(OPEN > CLOSE)\ndelta = CLOSE >= OPEN ? deltaup : -deltadown\ncumdelta = ta.cum(delta)\nfloat ctl = na\nfloat o = na\nfloat h = na\nfloat l = na\nfloat c = na\nif linestyle == 'Candle'\n    o := cumdelta[1]\n    h := math.max(cumdelta, cumdelta[1])\n    l := math.min(cumdelta, cumdelta[1])\n    c := cumdelta\n    ctl\nelse\n    ctl := cumdelta\n    ctl\nplot(ctl, title='CDV Line', color= color.new(color.blue, 0), linewidth=2)\nfloat haclose = na\nfloat haopen = na\nfloat hahigh = na\nfloat halow = na\nhaclose := (o + h + l + c) / 4\nhaopen := na(haopen[1]) ? (o + c) / 2 : (haopen[1] + haclose[1]) / 2\nhahigh := math.max(h, math.max(haopen, haclose))\nhalow := math.min(l, math.min(haopen, haclose))\nc_ = hacandle ? haclose : c\no_ = hacandle ? haopen : o\nh_ = hacandle ? hahigh : h\nl_ = hacandle ? halow : l\n//plotcandle(o_, h_, l_, c_, title='CDV Candles', color=o_ <= c_ ? colorup : colordown, bordercolor=\n//plot(showma1 and linestyle == 'Candle' ? ta.sma(c_, ma1len) : na, title='SMA 1', color=ma1col)\n//plot(showma2 and linestyle == 'Candle' ? ta.sma(c_, ma2len) : na, title='SMA 2', color=ma2col)\n//plot(showema1 and linestyle == 'Candle' ? ta.ema(c_, ema1len) : na, title='EMA 1', color=ema1col)\n//plot(showema2 and linestyle == 'Candle' ? ta.ema(c_, ema2len) : na, title='EMA 2', color=ema2col)\ni_numLookbackBarsCDV = input(14,title=\"Number of bars to look back to validate CDV trend\n//cdvEntryLong = o_ < c_ and f_priorBarsSatisfied(o_ < c_,i_numLookbackBarsCDV)\n//cdvEntryShort = o_ > c_ and f_priorBarsSatisfied(o_ > c_,i_numLookbackBarsCDV)\ncdvEntryConditionLong = o_ <= c_\ncdvEntryConditionShort = o_ > c_\ncdvEntryLong = cdvEntryConditionLong and ta.barssince(cdvEntryConditionShort) > i_numLookbackBarsCDV\ncdvEntryShort = cdvEntryConditionShort and ta.barssince(cdvEntryConditionLong) > i_numLookbackBarsCDV\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nlongCondition = trendMagicEntryLong and sqzmomEntryLong and cdvEntryLong\nshortCondition = trendMagicEntryShort and sqzmomEntryShort and cdvEntryShort\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(HIGH)\n    adxdown = -ta.change(LOW)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=2, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=6, minval=0.01, group=\nslLongClose = CLOSE < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = CLOSE > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / CLOSE * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(OPEN) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "**Long Only Strategy** When Price drops below the ATR band below it will enter a buy on the next candle open SL at current price minus ATR* ATR multiplier TP at Mean EMA or if higher than Mean EMA and current candle low is below previous candle low or if price is above ATR NB: I would highly recommend a low fee broker (I use ICmarkets raw spread account) due to the fact that this is a decently high frequency trading strategy you will rack up a lot of commission, if you use and exchange like Bybit or Binance the strategy will not be profitable due to the high commissions."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Bcullen175\n//@version=5\nstrategy(\"ATR Mean Reversion\", overlay=true, initial_capital=100000,default_qty_type\nSLx = input(1.5, \"SL Multiplier\", tooltip = \"Multiplies ATR to widen stop on volatile assests,\nsrc = input(close, title=\"Source\")\nperiod = input.int(10, \"ATR & MA PERIOD\")\nplot(open+ta.atr(period))\nplot(open-ta.atr(period))\nplot((ta.ema(src, period)), title = \"Mean\", color= color.white)\ni_startTime     = input.time(title=\"Start Filter\", defval=timestamp(\"01 Jan 1995 13:30 +0000\"\ni_endTime       = input.time(title=\"End Filter\", defval=timestamp(\"1 Jan 2099 19:30 +0000\"\n// Check filter(s)\nf_dateFilter = time >= i_startTime and time <= i_endTime\natr = ta.atr(period)\n// Check buy/sell conditions\nvar float buyPrice = 0\nbuyCondition    = low < (open-ta.atr(period)) and strategy.position_size == 0 and f_dateFilter\nsellCondition   = (high > (ta.ema(close, period)) and strategy.position_size > 0 and\nstopDistance    = strategy.position_size > 0 ? ((buyPrice - atr)/buyPrice) : na\nstopPrice       = strategy.position_size > 0 ? (buyPrice - SLx*atr): na\nstopCondition   = strategy.position_size > 0 and low < stopPrice\n// Enter positions\nif buyCondition\n    strategy.entry(id=\"Long\", direction=strategy.long)\nif buyCondition[1]\n    buyPrice := open\n// Exit positions\nif sellCondition or stopCondition\n    strategy.close(id=\"Long\", comment=\"Exit\" + (stopCondition ? \"SL=true\" : \"\"))\n    buyPrice := na\n// Draw pretty colors\nplot(buyPrice, color= color.lime, style=plot.style_linebr)\nplot(stopPrice, color= color.red, style=plot.style_linebr, offset=-1)"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our 9th one is an automated version of the \"I Tested The Best 1 Minute Scalping Strategy That Will Blow Your Mind 100 Times\" strategy from \"Profit Now\" who claims to have achieved 36.7% profit scalping XRPUSDT on the 1 minute timeframe in only 15 days. As you can see from the backtest results below, I was unable to substantiate anything remotely close to that that claim on any timeframe or symbol. Myth 10000% busted. This strategy uses a combination of 2 open-source public indicators:  Hull Suite by InSilico and Least Squares Moving Average (LSMA) The Hull Moving Average (HMA) is a faster version of the traditional moving average and is designed to reduce lag and improve the responsiveness of the average to price changes. In this strategy the HMA is used as a trend-following indicator,  When the HMA is rising it is indicative of an upwards trend and when its falling its indicative of a downtrend.  The Least Squares Moving Average (LSMA) used in this strategy is similar to the HMA in that it is designed to reduce lag and improve the responsiveness of the average to price changes.  In this strategy the LSMA is used to also not only identify trends but also confirm signals, it also is used to identify possible changes in the trend and market conditions. When we use these together, the Hull Suite and LSMA indicators provide a complimentary confirmation of trend direction and trend swings.  The Hull Suite helps to identify and confirm trends, while the LSMA aids to confirm signals and identify potential changes in market conditions.  The way this strategy is designed is when the Hull Suite HMA is trending up and the LSMA crosses above the HMA, we enter a long condition.   When the Hull Suite is trending down and the LSMA crosses below the HMA we take a short position.   Because of the low latency of these two indicators this strategy can be used on lower time frames down to 1 minute.   On high volatility crypto on the lowest time frames, a 1:4 Risk Ratio should be used.   A lower less risk ratio should be used on less volatile archetypes of securities. If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #9 - HullSuite+LSMA - [MYN]', max_bars_back=5000, \n// Hull Suite by InSilico\n// Least Squares Moving Average\n// Long \n// Hull Suite is red and LSMA crosses above HUll Suite while red\n// Stop loss latest swing low\n//Short\n// Hull Suite is green and LSMA crosses under HUll Suite while green\n// Stop loss latest swing high\n//1:4 Risk ratio\n// 1 minute timeframe\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n//72iE0gCVjvM\n// LSMA\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//indicator(title = \"Least Squares Moving Average\", shorttitle=\"LSMA\", overlay=true, timeframe=\"\", t\nlength1 = input(title=\"Length\", defval=25, group=\"Least Squares Moving Average (LSMA)\"\noffset1 = input(title=\"Offset\", defval=0)\nsrc1 = input(close, title=\"Source\")\nlsma = ta.linreg(src1, length1, offset1)\nplot(lsma, color= color.white)\n// Hull Suite by InSilico\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//Basic Hull Ma Pack tinkered by InSilico \n//indicator('Hull Suite by InSilico', overlay=true)\n//INPUT\nsrc = input(close, title='Source', group=\"Hull Suite\")\nmodeSwitch = input.string('Hma', title='Hull Variation', options=['Hma', 'Thma', 'Ehma'\nlength = input(55, title='Length(180-200 for floating S/R , 55 for swing entry)')\nlengthMult = input(1.0, title='Length multiplier (Used to view higher timeframes with straight band)'\nuseHtf = input(false, title='Show Hull MA from X timeframe? (good for scalping)')\nhtf = input.timeframe('240', title='Higher timeframe')\nswitchColor = input(true, 'Color Hull according to trend?')\ncandleCol = input(false, title='Color candles based on Hull\\'s Trend?')\nvisualSwitch = input(false, title='Show as a Band?')\nthicknesSwitch = input(1, title='Line Thickness')\ntranspSwitch = input.int(40, title='Band Transparency', step=5)\n//FUNCTIONS\n//HMA\nHMA(_src, _length) =>\n    ta.wma(2 * ta.wma(_src, _length / 2) - ta.wma(_src, _length), math.round(math.sqrt\n//EHMA    \nEHMA(_src, _length) =>\n    ta.ema(2 * ta.ema(_src, _length / 2) - ta.ema(_src, _length), math.round(math.sqrt\n//THMA    \nTHMA(_src, _length) =>\n    ta.wma(ta.wma(_src, _length / 3) * 3 - ta.wma(_src, _length / 2) - ta.wma(_src\n//SWITCH\nMode(modeSwitch, src, len) =>\n    modeSwitch == 'Hma' ? HMA(src, len) : modeSwitch == 'Ehma' ? EHMA(src, len) : \n//OUT\n_hull = Mode(modeSwitch, src, int(length * lengthMult))\nHULL = useHtf ? request.security(syminfo.ticker, htf, _hull) : _hull\nMHULL = HULL[0]\nSHULL = HULL[2]\n//COLOR\nhullColor = switchColor ? HULL > HULL[2] ?  #00ff00 :  #ff0000 :  #ff9800\n//PLOT\n///< Frame\nFi1 = plot(MHULL, title='MHULL', color=hullColor, linewidth=thicknesSwitch, transp\nFi2 = plot(visualSwitch ? SHULL : na, title='SHULL', color=hullColor, linewidth=thicknesSwitch\nalertcondition(ta.crossover(MHULL, SHULL), title='Hull trending up.', message='Hull trending up.'\nalertcondition(ta.crossover(SHULL, MHULL), title='Hull trending down.', message='Hull trending down.'\n///< Ending Filler\nfill(Fi1, Fi2, title='Band Filler', color=hullColor, transp=transpSwitch)\n///BARCOLOR\nbarcolor(color=candleCol ? switchColor ? hullColor : na : na)\n// Long \n// Hull Suite is red and LSMA crosses above HUll Suite while red\n// Stop loss latest swing low\n//Short\n// Hull Suite is green and LSMA crosses under HUll Suite while green\n// Stop loss latest swing high\n//1:4 Risk ratio\nlongEntry = hullColor ==  #ff0000 and ta.crossover(lsma, MHULL )\nshortEntry = hullColor ==  #00ff00 and ta.crossunder(lsma, MHULL)\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nlongCondition = longEntry\nshortCondition = shortEntry\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=100, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=999, minval=0.01, group\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "A simple yet powerful Dollar Cost Averaging (DCA) simulator. You just add the script to your chart, and you'll be able to see: - Every single entry with its size - The evolution of you average price in time (blue line) - The profit and loss areas (where market price < average price the DCA is at loss, and the background is colored in red. At the contrary, where mkt price is > average price, it's profit area and the background is green). - Max drawdown: the point in price and time where the DCA loss is maximum in the considered time interval. The drawdown amount is specified. - Profit (or loss) and total cost at the end of the time interval or at the present day: the script shows how much the DCA is netting at a profit or loss, as well as the total cost of the DCA itself. The parameters are: - Date start and date end: time interval of the DCA simulation - DCA period (you can choose between daily, weekly and monthly) - Week day or month day if you choose those periods - Single operation size (in base currency) - Option to choose a DCA LONG or DCA SHORT (for uber bears) - Option to include an exit strategy that partially closes your position (the % size closed can be chosen as well with the parameter \"exit_close_perc\") every time the DCA realizes a specific gain (choosable with the parameter \"exit_gain_threshold\"). If you choose \"none\" as an exit strategy, the script will assume to never close positions until the end of the period or the present day for simulation purpose. NB: just ignore the TV strategy tester results, all the data are visible on the chart."}, {"role": "assistant", "content": "//@version=5\n//Made by \"Liquidator\", all credits for this script go to him.\nstrategy('dca', overlay=true, pyramiding=10000, calc_on_every_tick=true, process_orders_on_close\nfn_plot_label_below(txt, offset_x) =>\n    x = time + (time - time[1]) * offset_x\n    var label lab = na\n    label.delete(lab)\n    lab := label.new(x=x, y=0, text=txt, xloc=xloc.bar_time, yloc=yloc.belowbar, color\n    label.set_x(lab, x)\nfn_plot_label_above(txt, offset_x) =>\n    x = time + (time - time[1]) * offset_x\n    var label lab = na\n    label.delete(lab)\n    lab := label.new(x=x, y=0, text=txt, xloc=xloc.bar_time, yloc=yloc.abovebar, color\n    label.set_x(lab, x)\nDAILY = 'DAILY'\nWEEKLY = 'WEEKLY'\nMONTHLY = 'MONTHLY'\nmonth_day = input.int(15, minval=1, maxval=28)\nweek_day = input.int(dayofweek.monday, options=[dayofweek.monday, dayofweek.tuesday\ndca_period = input.string(MONTHLY, options=[DAILY, MONTHLY, WEEKLY])\ndca_sigle_size = input(100.0, title='sigle operation size in quote currency ( ex: USD \ndca_long = input(true)\nEXIT_NONE = 'NONE'\nEXIT_GAIN_THRESHOLD = 'GAIN THRESHOLD'\nexit_strategy = input.string(EXIT_NONE, options=[EXIT_NONE, EXIT_GAIN_THRESHOLD])\nexit_gain_threshold = input(1000.0)\nexit_close_perc = input(25)\nstart = timestamp(input(2018, 'start year'), input(1, 'start month'), input(1, 'start day'\nend = timestamp(input(2100, 'end year'), input(1, 'end month'), input(1, 'end day')\ndaily_close = request.security(ticker.new(syminfo.prefix, syminfo.ticker), 'D', close\nnew_day = ta.change(dayofweek)\nis_today = year(timenow) == year(time) and month(timenow) == month(time) and dayofmonth\nis_buy_day = dca_period == WEEKLY and dayofweek == week_day or dca_period == MONTHLY\nposition_cost = strategy.opentrades * dca_sigle_size\n//position_cost = strategy.position_size * strategy.position_avg_price\nposition_value = strategy.position_size * close\nprofit = position_value - position_cost\nfloat max_dd = 0\nmax_dd := math.min(profit, nz(max_dd[1]))\ntrigger = time > start and time < end and is_buy_day and new_day\nclose_dca = time > end or is_today\nif trigger\n    strategy.entry('DCA', direction=dca_long ? strategy.long : strategy.short, qty=\n    if dca_long\n        label.new(x=bar_index, y=0, yloc=yloc.belowbar, size=size.tiny, style=label.style_triangleup\n    else\n        label.new(x=bar_index, y=0, yloc=yloc.abovebar, size=size.tiny, style=label.style_triangledown\nif exit_strategy == EXIT_GAIN_THRESHOLD and ta.crossover(profit, exit_gain_threshold\n    strategy.close('DCA', qty_percent=exit_close_perc)\n    label.new(x=bar_index, y=0, yloc=yloc.abovebar, size=size.tiny, style=label.style_triangledown\nif close_dca\n    strategy.close('DCA', qty_percent=100)\nplot(strategy.position_avg_price, title='average position entry price')\nbgcolor(dca_long ? close < strategy.position_avg_price ?  color.red :  color.green\nif ta.change(max_dd) != 0\n    fn_plot_label_below('max drowdown: ' + str.tostring(max_dd, '#.##'), 0)\nif not close_dca\n    fn_plot_label_above('profit: ' + str.tostring(profit, '#.##') + '\\n' + 'cost:   '"}]}
{"messages": [{"role": "user", "content": "This script provides options for the user to choose: - Start date and End date - Trade time during a day (With UTC offset) - Which days of the week to trade It return a condition if all the date and time conditions are true. It's very easy to integrate with any script."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Dannnnnnny\n//@version=5\nstrategy(title=\"Trade Day-Time Session\", overlay = true)\n//Session=====================================================================\nfromDay = input.int(defval = 1, title = \"From\", minval = 1, maxval = 31, inline=\"1\"\nfromMonth = input.int(defval = 1, title = \"\", minval = 1, maxval = 12,inline=\"1\", group\nfromYear = input.int(defval = 2010, title = \"\", minval = 1970, inline=\"1\", group='Trade Session'\ntoDay = input.int(defval = 31, title = \"To\", minval = 1, maxval = 31, inline=\"2\", group\ntoMonth = input.int(defval = 12, title = \"\", minval = 1, maxval = 12, inline=\"2\",group\ntoYear = input.int(defval = 2099, title = \"\", minval = 1970, inline=\"2\",group='Trade Session'\nstartDate = timestamp(fromYear, fromMonth, fromDay, 00, 00)\nfinishDate = timestamp(toYear, toMonth, toDay, 00, 00)\ndate_cond = time >= startDate and time <= finishDate\ni_sess = input.session(\"0400-1900\", \"Trade time\", group='Trade Session')\nUTC_offset = input.int(3, title='UTC Offset', minval=-10, maxval=13, group='Trade Session'\nUTC_string = 'UTC' + (UTC_offset > 0 ? '+' : '') + (UTC_offset != 0 ? str.tostring(\ntime_cond = time(timeframe.period, i_sess, UTC_string)\nis_trade_mon = input(true, title=\"Trade Monday?\", group='Trade Session')\nis_trade_tue = input(true, title=\"Trade Tuesday?\", group='Trade Session')\nis_trade_wed = input(true, title=\"Trade Wednesday?\", group='Trade Session')\nis_trade_thu = input(true, title=\"Trade Thursday?\", group='Trade Session')\nis_trade_fri = input(true, title=\"Trade Friday?\", group='Trade Session')\nis_trade_sat = input(false, title=\"Trade Saturday?\", group='Trade Session')\nis_trade_sun = input(false, title=\"Trade Sunday?\", group='Trade Session')\nday_cond = false\nif(dayofweek(time_cond, UTC_string) == dayofweek.monday and is_trade_mon)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.tuesday and is_trade_tue)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.wednesday and is_trade_wed)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.thursday and is_trade_thu)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.friday and is_trade_fri)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.saturday and is_trade_sat)\n    day_cond := true\nelse if(dayofweek(time_cond, UTC_string) == dayofweek.sunday and is_trade_sun)\n    day_cond := true\nbgcolor(time == time_cond and day_cond ?  color.new(color.gray,90) : na)\nfinal_time_cond = time == time_cond and day_cond and date_cond\n//=====================================================================\nmaLength= 400\nwma= ta.vwma(hl2,maLength)\nuptrend= ta.rising(wma, 5)\ndowntrend= ta.falling(wma,5)\nplot(wma)\nif(final_time_cond)\n    if uptrend\n        strategy.entry(\"Buy\", strategy.long)\n    else\n        strategy.close(\"Buy\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    User interface improvement."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n//@version=5\nstrategy(\"Reinforced RSI - The Quant Science\",\n     overlay = true,\n     default_qty_type = strategy.percent_of_equity, \n     default_qty_value = 100,\n     pyramiding = 1,\n     currency = currency.EUR, \n     initial_capital = 1000,\n     commission_type = strategy.commission.percent, \n     commission_value = 0.07)\nlenght_rsi = input.int(defval = 14, minval = 1, title = \"RSI lenght: \")\nrsi = ta.rsi(close, length = lenght_rsi)\nrsi_value_check_entry = input.int(defval = 35, minval = 1, title = \"Oversold: \")\nrsi_value_check_exit = input.int(defval = 75, minval = 1, title = \"Overbought: \")\ntrigger = ta.crossunder(rsi, rsi_value_check_entry)\nexit = ta.crossover(rsi, rsi_value_check_exit)\nentry_condition   = trigger \nTPcondition_exit  = exit\nlook = input.int(defval = 30, minval = 0, maxval = 500, title = \"Lookback period: \"\nProbabilities(lookback) =>\n    isActiveLong = false\n    isActiveLong := nz(isActiveLong[1], false)\n    isSellLong = false\n    isSellLong := nz(isSellLong[1], false)\n    int positive_results = 0\n    int negative_results = 0\n    float positive_percentage_probabilities = 0 \n    float negative_percentage_probabilities = 0 \n    LONG = not isActiveLong and entry_condition == true \n    CLOSE_LONG_TP = not isSellLong and TPcondition_exit == true\n    p = ta.valuewhen(LONG, close, 0)\n    p2 = ta.valuewhen(CLOSE_LONG_TP, close, 0)\n    for i = 1 to lookback\n        if (LONG[i])\n            isActiveLong := true\n            isSellLong := false\n        if (CLOSE_LONG_TP[i])\n            isActiveLong := false\n            isSellLong := true\n        if p[i] > p2[i]\n            positive_results += 1\n        else \n            negative_results += 1 \n        positive_relative_probabilities = positive_results / lookback\n        negative_relative_probabilities = negative_results / lookback\n        positive_percentage_probabilities := positive_relative_probabilities * 100\n        negative_percentage_probabilities := negative_relative_probabilities * 100\n    positive_percentage_probabilities\n    probabilities = Probabilities(look) \nlots = strategy.equity/close\nvar float e = 0 \nvar float c = 0 \ntp = input.float(defval = 1.00, minval = 0, title = \"Take profit: \")\nsl = input.float(defval = 1.00, minval = 0, title = \"Stop loss: \")\nif trigger==true and strategy.opentrades==0 and probabilities >= 51\n    e := close\n    strategy.entry(id = \"e\", direction = strategy.long, qty = lots, limit = e) \ntakeprofit = e + ((e * tp)/100)\nstoploss = e - ((e * sl)/100)\nif exit==true\n    c := close \n    strategy.exit(id = \"c\", from_entry = \"e\", limit = c)\nif takeprofit and stoploss \n    strategy.exit(id = \"c\", from_entry = \"e\", stop = stoploss, limit = takeprofit)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added optionable \"Retest\" as entry condition"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Hiubris_Indicators\n//@version=5\nstrategy(title = \"Zazzamira 50-25-25 Trend System\", overlay = true, default_qty_value\n// Open Session\ntz0 = input.string('UTC-5', title=\"Timezone\", inline='tz', group='Time-Range Settings'\nauto_tz = input(true, title=\"Exchange Timezone\", inline='tz', group='Time-Range Settings'\ntz = auto_tz? syminfo.timezone : tz0\ntimeinput = input.session('0830-0915', title=\"Opening Range\", group='Time-Range Settings'\ntses_time = time(timeframe.period, timeinput, tz)\ntses = na(tses_time) ? 0 : 1\nend_t = tses[1] and not tses\nstart_t = tses and not tses[1]\n// Trading Session\nsession = input.session(\"0915-1300\", title=\"Trading Time\")+\":1234567\"\nt = time(timeframe.period, session, tz)\ntrading_session_filter = na(t) ? 0 : 1\nt_exit = time(timeframe.period, \"1500-0000:1234567\", tz)\ntrading_session_exit = na(t_exit) ? 0 : 1\n// Highs Lows - Open sesssion\nh = 0.0\nl = 0.0\nh := start_t ? high : tses and high > h[1] ? high : h[1]\nl := start_t ? low : tses and low < l[1] ? low : l[1]\nr = h-l\nlast_start_n = ta.valuewhen(start_t, bar_index, 0)\n//col = input.color(color.orange, title=\"Levels Color\")\ndraw_level(txt, x, col)=>\n    if start_t\n        line.new (bar_index-4, x, last_start_n[1], x, color=col)\n        label.new(bar_index-10, x, style=label.style_none, text=txt, color=col, textcolor\nl1 = h+r*0.216\nl2 = h+r*0.618\nl3 = h+r*1\nl4 = h+r*1.618\ns1 = l-r*0.216\ns2 = l-r*0.618\ns3 = l-r*1\ns4 = l-r*1.618\nplot(tses? na : h, style=plot.style_linebr, title=\"H\", color= color.green)\nplot(tses? na : l, style=plot.style_linebr, title=\"L\", color= color.green)\nplot(tses? na : l1, style=plot.style_linebr, title=\"Fib 1\", color= color.orange)\nplot(tses? na : l2, style=plot.style_linebr, title=\"Fib 2\", color= color.orange)\nplot(tses? na : l3, style=plot.style_linebr, title=\"Fib 3\", color= color.orange)\nplot(tses? na : l4, style=plot.style_linebr, title=\"Fib 4\", color= color.orange)\nplot(tses? na : s1, style=plot.style_linebr, title=\"Fib 1\", color= color.orange)\nplot(tses? na : s2, style=plot.style_linebr, title=\"Fib 2\", color= color.orange)\nplot(tses? na : s3, style=plot.style_linebr, title=\"Fib 3\", color= color.orange)\nplot(tses? na : s4, style=plot.style_linebr, title=\"Fib 4\", color= color.orange)\n//draw_level('H'     , h[1], color.gray  )\n//draw_level('Fib 23.6% ' , l1, color.yellow)\n//draw_level('Fib 61.8% ' , l2, color.orange)\n//draw_level('Fib 100% '  , l3, color.orange)\n//draw_level('Fib 161.8% ', l4, color.orange)\n//draw_level('H'     , l[1], color.gray  )\n//draw_level('Fib 23.6% ' , s1, color.yellow)\n//draw_level('Fib 61.8% ' , s2, color.orange)\n//draw_level('Fib 100% '  , s3, color.orange)\n//draw_level('Fib 161.8% ', s4, color.orange)\nbgcolor(tses? color.new(color.orange  , 80):na)\nplotshape(ta.crossover (close, h) and not tses and trading_session_filter, textcolor\nplotshape(ta.crossunder(close, l) and not tses and trading_session_filter, textcolor\n// \u2014\u2014\u2014\u2014\u2014 MA \nribbon_grp = \"MA SETTINGS\"\nma(source, length, type) =>\n    type == \"SMA\" ? ta.sma(source, length) : \n     type == \"EMA\" ? ta.ema(source, length) :\n     type == \"SMMA (RMA)\" ? ta.rma(source, length) : \n     type == \"WMA\" ? ta.wma(source, length) :\n     type == \"VWMA\" ? ta.vwma(source, length) :\n     na\n    ma1_type   = input.string(\"EMA\"  , \"\"     , inline=\"MA #1\", options=[\"SMA\", \"EMA\",\nma1_source = input.source(close  , \"\"     , inline=\"MA #1\", group=ribbon_grp)\nma1_length = input.int   (5    , \"\"     , inline=\"MA #1\", minval=1, group=ribbon_grp\nma1 = ma(ma1_source, ma1_length, ma1_type)\nplot(ma1, color =  color.green, title=\"MA \u21161\")\nma2_type   = input.string(\"EMA\"  , \"\"     , inline=\"MA #2\", options=[\"SMA\", \"EMA\",\nma2_source = input.source(close  , \"\"     , inline=\"MA #2\", group=ribbon_grp)\nma2_length = input.int   (13     , \"\"     , inline=\"MA #2\", minval=1, group=ribbon_grp\nma2 = ma(ma2_source, ma2_length, ma2_type)\nplot(ma2, color =  color.orange, title=\"MA \u21162\")\nuse_3 = input(true, title='Use 3rd MA as Entry Condition')\nma3_type   = input.string(\"EMA\"  , \"\"     , inline=\"MA #3\", options=[\"SMA\", \"EMA\",\nma3_source = input.source(close  , \"\"     , inline=\"MA #3\", group=ribbon_grp)\nma3_length = input.int   (34     , \"\"     , inline=\"MA #3\", minval=1, group=ribbon_grp\nma3 = ma(ma3_source, ma3_length, ma3_type)\nplot(ma3, color =  color.blue, title=\"MA \u21163\")\nma4_type   = input.string(\"EMA\"  , \"\"     , inline=\"MA #4\", options=[\"SMA\", \"EMA\",\nma4_source = input.source(close  , \"\"     , inline=\"MA #4\", group=ribbon_grp)\nma4_length = input.int   (50    , \"\"     , inline=\"MA #4\", minval=1, group=ribbon_grp\nma4 = ma(ma4_source, ma4_length, ma4_type)\nplot(ma4, color =  color.red, title=\"MA #4\")\nma_long = ma1>ma2 and ma2>ma3 and ma3>ma4\nma_short= ma1<ma2 and ma2<ma3 and ma3<ma4\nlong0 = ma_long  and trading_session_filter and high<l1 and ta.crossover (close, h\nshort0= ma_short and trading_session_filter and low >s1 and ta.crossunder(close, l\nlong_setup = 0 \nlong_setup:= high>l1? 0 : long0? 1 : long_setup[1]\nlong = low<h and long_setup[1]==1\nif long\n    long_setup := 0\nshort_setup = 0 \nshort_setup:= low<s1? 0 : short0? 1 : short_setup[1]\nshort = high>l and short_setup[1]==1\nif short\n    short_setup := 0\nretest = input(true, title='Use RETEST')\nlongf = retest? long  : long0 \nshortf= retest? short : short0\n// Position Management Tools\npos = 0.0\npos:= longf? 1 : shortf? -1 : pos[1]\nlongCond  = longf  and (pos[1]!= 1 or na(pos[1]))\nshortCond = shortf and (pos[1]!=-1 or na(pos[1]))\n// EXIT FUNCTIONS //\natr = ta.atr(14)\nsl  = input.float(1.0, title=\"Initial Stop Loss ATR\", minval=0, step=0.1)\natr_long  = ta.valuewhen(longCond , atr, 0)\natr_short = ta.valuewhen(shortCond, atr, 0)\ntp_long  = l3\ntp_short = s3\n// Inprofit\ninprofit_long  = 0\ninprofit_short = 0\ninprofit_long  := pos==0 or longCond ? 0 : high>l1[1]? 1 : inprofit_long [1]\ninprofit_short := pos==0 or shortCond? 0 : low <s1[1]? 1 : inprofit_short[1]\ninprofit_long2  = 0\ninprofit_short2 = 0\ninprofit_long2  := pos==0 or longCond ? 0 : high>l2[1]? 1 : inprofit_long2 [1]\ninprofit_short2 := pos==0 or shortCond? 0 : low <s2[1]? 1 : inprofit_short2[1]\n// Trailing Stop Loss\ntrail_long = 0.0, trail_short = 0.0\ntrail_long  := long0 ? h : longCond ? high : high>trail_long[1]? high : pos<1 ? 0  \ntrail_short := short0? l : shortCond? low  : low<trail_short[1]? low : pos>-1 ? 99999\ntrail_long_final1   = trail_long  - sl * atr_long \ntrail_short_final1  = trail_short + sl * atr_short\ntrail_long_final2   = trail_long  - r * 0.236\ntrail_short_final2  = trail_short + r * 0.236\ntrail_long_final3   = trail_long  - r * 0.382\ntrail_short_final3  = trail_short + r * 0.382\nsl_long  = inprofit_long2 ? trail_long_final3  : inprofit_long ? trail_long_final2\nsl_short = inprofit_short2? trail_short_final3 : inprofit_short? trail_short_final2\n// Position Adjustment\nlong_sl  = low <sl_long[1]  and pos[1]== 1\nshort_sl = high>sl_short[1] and pos[1]==-1\nfinal_long_tp  = high>tp_long[1]  and pos[1]== 1\nfinal_short_tp = low <tp_short[1] and pos[1]==-1\nif ((long_sl or final_long_tp) and not shortCond) or ((short_sl or final_short_tp)\n    pos:=0\n    //  Strategy Backtest Limiting Algorithm\ni_startTime = input.time(defval = timestamp(\"01 Sep 2002 13:30 +0000\"), title = \"Backtesting Start Time\"\ni_endTime   = input.time(defval = timestamp(\"30 Sep 2099 19:30 +0000\"), title = \"Backtesting End Time\"\ntimeCond   = (time > i_startTime) and (time < i_endTime)\nequity = strategy.initial_capital + strategy.netprofit\nif equity>0 and timeCond\n    if long0\n        strategy.entry(\"long\" , strategy.long , limit=h)\n    if short0\n        strategy.entry(\"short\", strategy.short, limit=l)\n        strategy.exit(\"SL/TP1\", from_entry = \"long\" , stop=sl_long , limit=l1 , comment_profit\n    strategy.exit(\"SL/TP2\", from_entry = \"long\" , stop=sl_long , limit=l2 , comment_profit\n    strategy.exit(\"SL/TP3\", from_entry = \"long\" , stop=sl_long , limit=l3 , comment_profit\n    strategy.exit(\"SL/TP1\", from_entry = \"short\", stop=sl_short, limit=s1, comment_profit\n    strategy.exit(\"SL/TP2\", from_entry = \"short\", stop=sl_short, limit=s2, comment_profit\n    strategy.exit(\"SL/TP3\", from_entry = \"short\", stop=sl_short, limit=s3, comment_profit\nif high>l1 or not trading_session_filter\n    strategy.cancel('long')\nif low<s1 or not trading_session_filter\n    strategy.cancel('short')\nlong_exit = trading_session_exit and pos[1]== 1\nshort_exit= trading_session_exit and pos[1]==-1\nif (long_exit  and not shortCond) or (short_exit and not longCond)\n    pos:=0\nstrategy.close(\"long\" , when=long_exit  and timeCond, comment=\"Exit\")\nstrategy.close(\"short\", when=short_exit and timeCond, comment=\"Exit\")\n// DEBUGGING\nbgcolor(long ? color.new(color.green  , 80):na)\nbgcolor(short? color.new(color.red    , 80):na)\nbgcolor(false? color.new(color.white  , 80):na)\nbgcolor(false? color.new(color.orange , 80):na)"}]}
{"messages": [{"role": "user", "content": "This strategy search for a moment whe the market make two candles are consistently strong, and open a Sell, searching the imediactly correction, on the new candle. It`s easy to see the bars on the histogram graph. Purple Bars represent the candle variation. when on candle cross ove the Signal line the graph plot an Yellow ci, if the second bar crossover the signal a green circle is ploted and the operation start on start of the next candle.  This strategy can be used in a lot of Stocks and other graphs. many times we need a small time of graph, maybe 1 or 5 minutes because the gain shoud be planned to a midle of the second candle. You need look the stocks you will use. Stocks > 100 dolars isnt great, markets extremly volatly not too. but, Stocks that have a consistently development are very interisting. Look to markets searching maybe 0.5% or 1%. For this moment, I make the development of a Brasilian Real x American Dollar. In 15 Minutes. if you use in small timeframe the results can be better. On this time we make more than 500 trades with a small lot of contracts, without a big percent profitable, but a small profit in each operation, maybe you search more than. To present a real trading system I insert a spreed to present a correct view of the results. Each stock, Index, or crypto there is a specific configuration? my suggestion for new stocks You need choice a stock and using the setup search set over than 70% gain (percent profitable), using a 1% of gain and loss between 1-2% as the exemple (WDO) default I prepare a Brazilian Index 6-signal (6% is variation of a candle of the last candle) 10000- multiplicator (its important to configure diferences betwen a stock and an Indice) gain 3 (this proportion will be set looking you target, how I say, 1% can be good) loss 8 (this proportion will be set with you bankroll management, how I say, maybe 2%, you need evaluate) for maximize operations I use in the 1 or 5 minute graph. Timeframes more large make slowlly results,  (but not unable that you use in a 1 hour or a 1 day.) I make this script by zero. Maybe the code doesnt so organized, but is very easy to understand. If you have any doubts . leave a comment. I hope help you."}, {"role": "assistant", "content": "//@version=4\nstrategy(title=\"GAVAD\", shorttitle=\"GAVAD\", overlay=false, initial_capital=36000)\n////////////////////////////////////////////////////////\n//                                                    //\n//                                                    //\n//                     GAVAD %                        //\n//                                                    //\n//                                                    //\n////////////////////////////////////////////////////////\nSinal = input(6, title=\"Sinal\", type=input.integer, minval=1, maxval=150)\n//Objetivo = input(6, title=\"Objetivo\", type=input.integer, minval=1, maxval=100)\nMultip = input(10000, title=\"Sinal\", type=input.integer, minval=1, maxval=100000)\n//GavadEntrada1 = (close - low [1])/close[1]\n//plot(GavadEntrada1, style=plot.style_line, linewidth=3, color=color.yellow)\n//sombra\n//DownOL = (low - open ) / open * -10000\n//plot(DownOL, style=plot.style_area, linewidth=3, color=color.silver)\n// imprime o GAVAD\nGavadEntrada = (close - close [1])/close[1] * Multip\nplot(GavadEntrada, style=plot.style_histogram, linewidth=3, color= color.purple)\n//linha do Sinal\nplot(Sinal, style=plot.style_line, linewidth=1, color= color.yellow)\n//linha do Objetivo\n//plot(Objetivo, style=plot.style_line, linewidth=1, color=color.white)\nFura1 = GavadEntrada [0] >= Sinal\nFura2 = GavadEntrada [1] >= Sinal\nAlert = Fura1\nplotshape(Alert, style=shape.circle,  location = location.top, color=  color.yellow\nSinalON = Fura1 and Fura2\nplotshape(SinalON, style=shape.circle,  location = location.bottom, color=  color.green\n////////////////////////////////////////////////////////\n//                                                    //\n//                                                    //\n//              CONDI\u00c7\u00d5ES DE OPERACAO                 //\n//                                                    //\n//                                                    //\n////////////////////////////////////////////////////////\nSell_Forte2 = SinalON\n//plotshape(Sell_Forte2, style=shape.xcross, color=color.yellow, location=location.bottom)\n//Call_Forte2 = SinalON\n//plotshape(Call_Forte2, style=shape.xcross, color=color.yellow, location=location.top)\n////////////////////////////////////////////////////////\n//                                                    //\n//                                                    //\n//                    CALENDARIO                      //\n//                                                    //\n//                                                    //\n////////////////////////////////////////////////////////\n//052)\n// trading view solicita que se ja informado data para gerar backtest a partir de tal data\n//come\u00e7a backtest do trading sistem em qual data ?\nano = input(2021, minval=1, title=\"Ano\")\nmes = input(1, minval=1, maxval=12, title=\"Mes\")\ndia = input(1, minval=1, maxval=30, title=\"Dia\")\nhora = input(0, minval=1, maxval=23, title=\"hora\")\nminuto = input(0, minval=1, maxval=59, title=\"minuto\")\nhoraabertura = input(10, minval=1, maxval=23, title=\"hora Inicio Operacao Robo\")\nminutoabertura = input(40, minval=1, maxval=59, title=\"Minuto Encerra Tudo\")\nhoraencerra = input(17, minval=1, maxval=23, title=\"hora Fechamento\")\nminutoencerra = input(50, minval=1, maxval=59, title=\"Minuto Encerra Novas Operacoes\"\nminutofinaliza = input(50, minval=1, maxval=59, title=\"Minuto Encerra Tudo\")\n//valida se o dia de hoje \u00e9 posterior ao dia informado acima\nValidadia = year >= ano and month >= mes and dayofmonth >= dia\n//cria horario de abertura de negocia\u00e7ao, considerar default 10 hs, pois os indicadores ja \nabreloja = year >= ano and month >= mes and dayofmonth >= dia and hour >= horaabertura\n//and minute >= minutoabertura)\n//cria horario de fechamento de todas as negocia\u00e7oes, considerar default 17:00 hs\n//nenhuma ordem pode ser aberta depois dessa data e as abertas devem ser fechadas\nfechaloja = year >= ano and month >= mes and dayofmonth >= dia and hour >= horaencerra\n//and minute >= minutoencerra)\nfechaloja2 = year >= ano and month >= mes and dayofmonth >= dia and hour >= horaencerra\n//and minute >= minutofinaliza)\n//valida horario de negocia\u00e7\u00e3o, pra liberar as operacoes.\nlojaaberta = abreloja == true and fechaloja == false and fechaloja2 == false\n////////////////////////////////////////////////////////\n//                                                    //\n//                                                    //\n//             GERENCIAMENTO DE RISCO                 //\n//                                                    //\n//                                                    //\n////////////////////////////////////////////////////////\n//seta meta mensal\nmeta = input(150000, \"Meta de Lucro\")\nContratos= input(5, \"Contratos\")\n//seta tamanho do lote (ordem inicial-unica)\ntamanhodolote = Contratos\n//seta stop gain final em pontos (metade da barra anterior)\n//gaintotal = input(30, \"Gain\")\ngaintotal = input(3, \"Gain\")\n//seta stop loss final em pontos\nlossmaximo = input(8, \"Loss\")\n//lossmaximo = (open- close)*100\n////////////////////////////////////////////////////////\n//                                                    //\n//                     Checkbox                       //\n//                                                    //\n////////////////////////////////////////////////////////\n//ativacomprasretorno = input(title=\"Ativar Compras Retorno\", type=input.bool , defval=true)\n//ativavendasretorno = input(title=\"Ativar Vendas Retorno\", type=input.bool , defval=true)\n////////////////////////////////////////////////////////\n//                                                    //\n//                                                    //\n//                  COMPRA E VENDA                    //\n//                                                    //\n//                                                    //\n////////////////////////////////////////////////////////\nTradenumber = strategy.closedtrades + 1\nBatemeta = strategy.netprofit < meta\n//COMPRA RETORNO\n//longcondition2 = Validadia and Call_Forte2 and Batemeta\n//strategy.entry(\"Comprar\", strategy.long, tamanhodolote, when=longcondition2, comment=\"[Oper=\" + to\n//strategy.exit(\"Saida Compra\", \"Comprar\", profit=gaintotal, loss=lossmaximo)\n//if (CruzamentoFechaCallGG)\n    //strategy.close(id=\"Comprar\")\n//if (EscapeFechaCall)\n  // strategy.close(id=\"Comprar\")   \n       //plotchar(longcondition2, char=\"C\", location=location.bottom, color=color.lime, transp=0)\n//alertcondition(longcondition2, \"Comprar\", \"Compra R\u00e1pida!\")\n//VENDA RETORNO\nShortcondition2 = Validadia and Sell_Forte2 and Batemeta\nstrategy.entry(\"Vender\", strategy.short, tamanhodolote, when=Shortcondition2, comment\nstrategy.exit(\"Fecha Venda\", \"Vender\", profit=gaintotal, loss=lossmaximo)\n//if (CruzamentoFechaSellGG)\n   // strategy.close(id=\"Vender\")\n//if (EscapeFechaSell)\n   // strategy.close(id=\"Comprar\")  \n//plotchar(CruzamentoFechaSellGG, char=\"Y\", location=location.top, color=color.lime, transp=0) \n//plotchar(longcondition2, char=\"S\", location=location.bottom, color=color.lime, transp=0)\n//alertcondition(longcondition2, \"Vender\", \"Venda R\u00e1pida!\")\n//fim do codigo"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Fixed bug on Reward to Risk Ratio and Take Profit target not calculated properly                                                    Release Notes:                                                    Per suggestion, added option to move stop-loss to breakeven when trade hit X Reward to Risk Ratio."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 PtGambler\n//@version=5\nstrategy(\"2 EMA + Stoch RSI + ATR [Pt]\", shorttitle = \"2EMA+Stoch+ATR\", overlay=true\n// ********************************** Trade Period / Strategy Setting ******************************\nstartY = input(title='Start Year', defval=2011, group = \"Backtesting window\")\nstartM = input.int(title='Start Month', defval=1, minval=1, maxval=12, group = \"Backtesting window\"\nstartD = input.int(title='Start Day', defval=1, minval=1, maxval=31, group = \"Backtesting window\"\nfinishY = input(title='Finish Year', defval=2050, group = \"Backtesting window\")\nfinishM = input.int(title='Finish Month', defval=12, minval=1, maxval=12, group = \nfinishD = input.int(title='Finish Day', defval=31, minval=1, maxval=31, group = \"Backtesting window\"\ntimestart = timestamp(startY, startM, startD, 00, 00)\ntimefinish = timestamp(finishY, finishM, finishD, 23, 59)\n// ******************************************************************************************\ngroup_ema = \"EMA\"\ngroup_stoch = \"Stochastic RSI\"\ngroup_atr = \"ATR Stoploss Finder\"\n// ----------------------------------------- 2 EMA -------------------------------------\nema1_len = input.int(50, \"EMA Length 1\", group = group_ema)\nema2_len = input.int(200, \"EMA Length 2\", group = group_ema)\nema1 = ta.ema(close, ema1_len)\nema2 = ta.ema(close, ema2_len)\nplot(ema1, \"ema1\",  color.white, linewidth = 2)\nplot(ema2, \"ema2\",  color.orange, linewidth = 2)\nema_bull = ema1 > ema2\nema_bear = ema1 < ema2\n// -------------------------------------- Stochastic RSI -----------------------------\nsmoothK = input.int(3, \"K\", minval=1, group = group_stoch)\nsmoothD = input.int(3, \"D\", minval=1, group = group_stoch)\nlengthRSI = input.int(14, \"RSI Length\", minval=1, group = group_stoch)\nlengthStoch = input.int(14, \"Stochastic Length\", minval=1, group = group_stoch)\nsrc = close\nrsi1 = ta.rsi(src, lengthRSI)\nk = ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)\nd = ta.sma(k, smoothD)\nvar trigger_stoch_OB = k > 80\nvar trigger_stoch_OS = k < 20\nstoch_crossdown = ta.crossunder(k, d)\nstoch_crossup = ta.crossover(k, d)\nP_hi = ta.pivothigh(k,1,1)\nP_lo = ta.pivotlow(k,1,1)\nprevious_high = ta.valuewhen(P_hi, k, 1)\nprevious_low = ta.valuewhen(P_lo, k, 1)\nrecent_high = ta.valuewhen(P_hi, k, 0)\nrecent_low = ta.valuewhen(P_lo, k, 0)\n// --------------------------------------- ATR stop loss finder ------------------------\nlength = input.int(title='Length', defval=14, minval=1, group = group_atr)\nsmoothing = input.string(title='Smoothing', defval='EMA', options=['RMA', 'SMA', 'EMA'\nm = input.float(0.7, 'Multiplier', step = 0.1, group = group_atr)\nsrc1 = input(high, \"Source for upper band\", group = group_atr)\nsrc2 = input(low, \"Source for lower band\", group = group_atr)\nshowatr = input.bool(true, 'Show ATR Bands', group = group_atr)\ncollong = input.color( color.purple, 'Long ATR SL', inline='1', group = group_atr\ncolshort = input.color( color.purple, 'Short ATR SL', inline='2', group = group_atr\nma_function(source, length) =>\n    if smoothing == 'RMA'\n        ta.rma(source, length)\n    else\n        if smoothing == 'SMA'\n            ta.sma(source, length)\n        else\n            if smoothing == 'EMA'\n                ta.ema(source, length)\n            else\n                ta.wma(source, length)\na = ma_function(ta.tr(true), length) * m\nup = ma_function(ta.tr(true), length) * m + src1\ndown = src2 - ma_function(ta.tr(true), length) * m\np1 = plot(showatr ? up : na, title='ATR Short Stop Loss', color=colshort)\np2 = plot(showatr ? down : na, title='ATR Long Stop Loss', color=collong)\n// ******************************* Profit Target / Stop Loss ***************************************\nRR = input.float(2.0, \"Reward to Risk ratio (X times SL)\", step = 0.1, group = \"Profit Target\"\nbreakeven = input.bool(true, \"Move SL to breakeven when RR hit\", group = \"Profit Target\"\nbe_RR = input.float(1.0, \"\", inline = 'breakeven', group = \"Profit Target\")\nvar L_PT = 0.0\nvar S_PT = 0.0\nvar L_SL = 0.0\nvar S_SL = 0.0\nvar L_be_PT = 0.0\nvar S_be_PT = 0.0\nBSLE = ta.barssince(strategy.opentrades.entry_bar_index(0) == bar_index)\nentry_price = strategy.position_size != 0 ? strategy.opentrades.entry_price(0) : na\nif strategy.position_size > 0 //and BSLE == 1\n    L_PT := L_PT[1]\n    L_SL := (breakeven and high >= L_be_PT) ? entry_price : L_SL[1]\n    S_PT := close - (up - close)*RR\n    S_SL := up\n    L_be_PT := L_be_PT[1]\n    S_be_PT := close - (up - close)*be_RR\nelse if strategy.position_size < 0 //and BSLE == 1\n    S_PT := S_PT[1]\n    S_SL := (breakeven and low <= S_be_PT) ? entry_price : S_SL[1]\n    L_PT := close + (close-down)*RR\n    L_SL := down\n    S_be_PT := S_be_PT[1]\n    L_be_PT := close + (close-down)*be_RR\nelse if strategy.position_size != 0\n    L_PT := L_PT[1] \n    S_PT := S_PT[1]\nelse\n    L_PT := close + (close-down)*RR\n    L_SL := down\n    S_PT := close - (up - close)*RR\n    S_SL := up\n    L_be_PT := close + (close-down)*be_RR\n    S_be_PT := close - (up - close)*be_RR\nentry_line = plot(entry_price, \"Entry Price\",  color.white, linewidth = 1, style \nL_PT_line = plot(strategy.position_size > 0 and BSLE > 0 ? L_PT : na, \"L PT\",  color.green\nS_PT_line = plot(strategy.position_size < 0 and BSLE > 0 ? S_PT : na, \"S PT\",  color.green\nL_SL_line = plot(strategy.position_size > 0 and BSLE > 0 ? L_SL : na, \"L SL\",  color.red\nS_SL_line = plot(strategy.position_size < 0 and BSLE > 0 ? S_SL : na, \"S SL\",  color.red\nL_be_PT_line = plot(strategy.position_size > 0 and BSLE > 0 ? L_be_PT : na, \"L BE PT\"\nS_be_PT_line = plot(strategy.position_size < 0 and BSLE > 0 ? S_be_PT : na, \"S BE PT\"\nfill(L_PT_line, entry_line, color =  color.new(color.green,90))\nfill(S_PT_line, entry_line, color =  color.new(color.green,90))\nfill(L_SL_line, entry_line, color =  color.new(color.red,90))\nfill(S_SL_line, entry_line, color =  color.new(color.red,90))\n// ---------------------------------- strategy setup -----------------------------------------------\nvar L_entry_trigger1 = false\nvar S_entry_trigger1 = false\nL_entry_trigger1 := ema_bull and close < ema1 and k < 20 and strategy.position_size\nS_entry_trigger1 := ema_bear and close > ema1 and k > 80 and strategy.position_size\nL_entry1 = L_entry_trigger1[1] and stoch_crossup and recent_low > previous_low\nS_entry1 = S_entry_trigger1[1] and stoch_crossdown and recent_high < previous_high\n//debugging\nplot(L_entry_trigger1[1]?1:0, \"L Entry Trigger\")\nplot(stoch_crossup?1:0, \"Stoch Cross Up\")\nplot(recent_low > previous_low?1:0, \"Higher low\")\nplot(S_entry_trigger1[1]?1:0, \"S Entry Trigger\")\nplot(stoch_crossdown?1:0, \"Stoch Cross down\")\nplot(recent_high < previous_high?1:0, \"Lower high\")\nif L_entry1\n    strategy.entry(\"Long\", strategy.long)\nif S_entry1\n    strategy.entry(\"Short\", strategy.short)\nstrategy.exit(\"Exit Long\", \"Long\", limit = L_PT, stop = L_SL, comment_profit = \"Exit Long, PT hit\"\nstrategy.exit(\"Exit Short\", \"Short\", limit = S_PT, stop = S_SL, comment_profit = \"Exit Short, PT hit\"\n//resetting triggers\nL_entry_trigger1 := L_entry_trigger1[1] ? L_entry1 or ema_bear or S_entry1 ? false\nS_entry_trigger1 := S_entry_trigger1[1] ? S_entry1 or ema_bull or L_entry1 ? false\n//Trigger zones\nbgcolor(L_entry_trigger1 ?  color.new(color.green ,90) : na)\nbgcolor(S_entry_trigger1 ?  color.new(color.red,90) : na)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    As there are quite a few lines for different ranges, so added a tiny label at the right most of the plot to denote what plot is this.  As the labels are tiny so added a tooltip (in case if you are seeing it in mobile). Just hover over the label, the bigger tooltip will be shown."}, {"role": "assistant", "content": "// @version=5\n// Open-Range-Breakout strategy\n// No license. Free and Open Source.    \nstrategy('Strategy: ORB', shorttitle=\"ORB\", overlay=true , currency=currency.NONE,\n// Inputs\nperiod = input.int(defval=15, title=\"TimeRange\", tooltip=\"The range in minutes (default: 15m)\"\nsessionInput = input.session(defval=\"0915-0930\", title=\"Time Range\", group=\"ORB settings\"\nhide = input.bool(defval = false, title=\"Hide ORB Range\", group=\"ORB setting\", tooltip\n// SL Related\nslAtrLen = input.int(defval=14, title=\"ATR Period for placing SL\", group=\"StopLoss settings\"\nshowSLLines = input.bool(defval=false, title=\"Show SL lines in chart\", tooltip=\"Show SL lines also as dotted lines in chart. Note\n// Further Filtering\nignoreMementumVolume = input.bool(defval=false, title=\"Ignore Momentum & Volume\", \nrsiLen = input.int(defval=14, title=\"Momentum Period\", group=\"Strengh Settings\", tooltip\nrsiBullish = input.int(defval=50, step=1, title=\"Bullish Momentum\", group=\"Strengh Settings\"\nrsiBearish = input.int(defval=50, step=1, title=\"Bearish Momentum\", group=\"Strengh Settings\"\nvolAvg = input.int(defval=20, step=1, title=\"Volume Average Period\", group=\"Strengh Settings\"\nvolThreshold = input.float(defval=1, step=0.1, title=\"Volume Strengh\", group=\"Strengh Settings\"\ntrendPeriod = input.int(defval=200, step=1, title=\"Trend Period\", group=\"Trend Settings\"\nhideTrend = input.bool(defval = false, title=\"Hide the trend line\", group=\"Trend Settings\"\nhidePDHCL = input.bool(defval = false, title=\"Hide the PDHCL (prev day High Close Low range) & \nhideTable = input.bool(defval = false, title=\"Hide the Summary Table\", tooltip = 'Hide the summary table.'\n// Trade related\nrrRatio = input.float(title='Risk:Reward', step=0.1, defval=2.0, group=\"Trade settings\"\nendOfDay = input.int(defval=1500, title=\"Close all trades, default is 3:00 PM, 1500 hours \nmktAlwaysOn = input.bool(defval=true, title=\"Markets that never closed (Crypto, Forex, Commodi\nlotSize = input.int(title='Lot Size', step=1, defval=1, group=\"Trade settings\")\n// Util method\nis_newbar(res) => \n    timeframe.change(time(res)) != 0\nannotatePlots(txt, val, hide) => \n    if (not hide)\n        var l1 = label.new(bar_index, hidePDHCL ? na : val, txt, style=label.style_label_left\n        label.set_xy(l1, bar_index, hidePDHCL ? na : val)\n// print table\nprintTable(txt) =>\n    var table t = table.new(position.bottom_right, 1, 1)\n    table.cell(t, 0, 0, txt, text_halign = text.align_left, bgcolor =  color.lime\n    // globals\nt = time(timeframe.period, sessionInput + \":1234567\") // everyday\nin_session = not na(t)\nis_first = in_session and not in_session[1]\nis_end_session = in_session[1] and not in_session\ngreen(open, close) => close > open ? true : false\nred(open, close) => close < open ? true : false\nvar float orb_high = na\nvar float orb_low = na\nif is_first\n    orb_high := high\n    orb_low := low\nelse\n    orb_high := orb_high[1]\n    orb_low := orb_low[1]\nif high > orb_high and in_session\n    orb_high := high\nif low < orb_low and in_session\n    orb_low := low\nplot(hide ? na : orb_high, style=plot.style_line, color=orb_high[1] != orb_high ? \nannotatePlots('ORB-H', orb_high, hide)\nplot(hide ? na : orb_low, style=plot.style_line, color=orb_low[1] != orb_low ? na \nannotatePlots('ORB-L', orb_low, hide)\n// PDHCL (Previous Day High Close Low)\n[dh,dl,dc] = request.security(syminfo.ticker, \"D\", [high[1],low[1], close[1]], lookahead\nplot(hidePDHCL ? na : dh, title=\"Prev High\",  color= color.red,  linewidth=2, trackprice\nannotatePlots('PDH', dh, hidePDHCL)\nplot(hidePDHCL ? na : dl, title=\"Prev Low\",  color= color.green,  linewidth=2, trackprice\nannotatePlots('PDL', dl, hidePDHCL)\nplot(hidePDHCL ? na : dc, title=\"Prev Close\",  color= color.black,  linewidth=2, \nannotatePlots('PDC', dc, hidePDHCL)\nplot(hidePDHCL ? na : ta.vwap(close), title=\"VWAP\",  color= color.fuchsia,  linewidth\nannotatePlots('VWAP', ta.vwap(close), hidePDHCL)\n// For SL calculation\natr = ta.atr(slAtrLen)  \nhighestHigh = ta.highest(high, 7)\nlowestLow = ta.lowest(low, 7)\nlongStop = showSLLines ? lowestLow - (atr * 1) : na\nshortStop = showSLLines ? highestHigh + (atr * 1) : na\nplot(longStop, title=\"Buy SL\", color= color.green, style=plot.style_cross)\nplot(shortStop, title=\"Sell SL\", color= color.red, style=plot.style_cross)\nannotatePlots('SL-Long', longStop, showSLLines)\nannotatePlots('SL-Short', shortStop, showSLLines)\n// Momentum: rsi\nrsi = ta.rsi(close, rsiLen)\n// trend: EMA200\nema = ta.ema(close, trendPeriod)\nplot(hideTrend ? na : ema, \"EMA Trend\", color=close > ema ?  color.green :  color.red\nannotatePlots('Trendline', ema, hideTrend)\n// Volume-Weighed Moving Average calculation\nvwmaAvg = ta.vwma(close, volAvg)\nvwma_latest = volume\n// plotshape((barstate.isconfirmed and (vwma_latest > (vwmaAvg * volThreshold))), title='VolumeData'\n// Trade signals\nlongCond = barstate.isconfirmed and (ta.crossover(close, orb_high) or ta.crossover\nshortCond = barstate.isconfirmed and (ta.crossunder(close, orb_low) or ta.crossunder\nplotshape(longCond, title='Breakout', text='BO', location=location.belowbar, style\nplotshape(shortCond, title='Breakout', text='BD', location=location.abovebar, style\n// Trade execute\nh = hour(time('1'), syminfo.timezone)\nm = minute(time('1'), syminfo.timezone)\nhourVal = h * 100 + m\ntotalTrades = strategy.opentrades + strategy.closedtrades\nif (mktAlwaysOn or (hourVal < endOfDay))\n    // Entry\n    var float sl = na\n    var float target = na\n    if (longCond)\n        strategy.entry(\"enter long\", strategy.long, lotSize, limit=na, stop=na, comment\n        sl := longStop\n        target := close + ((close - longStop) * rrRatio)\n        alert('Buy:' + syminfo.ticker + ' ,SL:' + str.tostring(math.floor(sl)) + ', Target:'\n    if (shortCond)\n        strategy.entry(\"enter short\", strategy.short, lotSize, limit=na, stop=na, \n        sl := shortStop\n        target := close - ((shortStop - close) * rrRatio)\n        alert('Sell:' + syminfo.ticker + ' ,SL:' + str.tostring(math.floor(sl)) + \n    // Exit: target or SL\n    if ((close >= target) or (close <= sl))\n        strategy.close(\"enter long\", comment=close < sl ? \"Long SL hit\" : \"Long target hit\"\n    if ((close <= target) or (close >= sl))\n        strategy.close(\"enter short\", comment=close > sl ? \"Short SL hit\" : \"Short target hit\"\nelse if (not mktAlwaysOn)\n    // Close all open position at the end if Day\n    strategy.close_all(comment = \"Close all entries at end of day.\")\n// Plotting table\nif (not hideTable and is_end_session)\n    message =  syminfo.ticker + \" :\\n\\nORB Upper: \" + str.tostring(math.round(orb_high\n    printTable(message)\n    alert(message, alert.freq_once_per_bar_close)"}]}
{"messages": [{"role": "user", "content": "This is a Quarterly Returns version of Monthly Returns in PineScript Strategies by QuantNomad This script shows a table of Quarterly/Yearly performance of your strategy. It also provides an option to compare with Buy & Hold.  The script can easily integrated to your strategy. All you need to do is copy the table part and paste it at the end of your script Disclaimer Please remember that past performance may not be indicative of future results. This post and the script don\u2019t provide any financial advice."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Dannnnnnny\n//@version=4\nstrategy(title=\"Quarterly Returns in Strategies vs Buy & Hold\", initial_capital= 1000\nmaLength= input(400)\nwma= vwma(hl2,maLength)\nuptrend= rising(wma, 5)\ndowntrend= falling(wma,5)\nplot(wma)\nif uptrend\n    strategy.entry(\"Buy\", strategy.long)\nelse\n    strategy.close(\"Buy\")//\n///////////////////\n// QUARTERLY TABLE //\nenableQuarterlyTable = input(title=\"Enable Quarterly Return table\", type=input.bool\nenableCompareWithMarket = input(title=\"Compare with Market Benchmark\", type=input.bool\ntable_position = input(title=\"Table Position\", type=input.string, defval='bottom_right'\nprecision = 2\nnew_quarter = ceil(month(time)/3)  != ceil(month(time[1])/3)\nnew_year  = year(time)  != year(time[1])\neq = strategy.equity\nbar_pnl = eq / eq[1] - 1\nbar_bh = (close-close[1])/close[1]\ncur_quarter_pnl = 0.0\ncur_year_pnl  = 0.0\ncur_quarter_bh = 0.0\ncur_year_bh  = 0.0\n// Current Quarterly P&L\ncur_quarter_pnl := new_quarter ? 0.0 : \n                 (1 + cur_quarter_pnl[1]) * (1 + bar_pnl) - 1 \ncur_quarter_bh := new_quarter ? 0.0 : \n                 (1 + cur_quarter_bh[1]) * (1 + bar_bh) - 1\n// Current Yearly P&L\ncur_year_pnl := new_year ? 0.0 : \n                 (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1\ncur_year_bh := new_year ? 0.0 : \n                 (1 + cur_year_bh[1]) * (1 + bar_bh) - 1\n// Arrays to store Yearly and Quarterly P&Ls\nvar quarter_pnl  = array.new_float(0)\nvar quarter_time = array.new_int(0)\nvar quarter_bh  = array.new_float(0)\nvar year_pnl  = array.new_float(0)\nvar year_time = array.new_int(0)\nvar year_bh  = array.new_float(0)\nend_time = false\nend_time:= time_close + (time_close - time_close[1]) > timenow or barstate.islastconfirmedhistory\nif (not na(cur_quarter_pnl[1]) and (new_quarter or end_time))\n    if (end_time[1])\n        array.pop(quarter_pnl)\n        array.pop(quarter_time)\n            array.push(quarter_pnl , cur_quarter_pnl[1])\n    array.push(quarter_time, time[1])\n    array.push(quarter_bh , cur_quarter_bh[1])\nif (not na(cur_year_pnl[1]) and (new_year or end_time))\n    if (end_time[1])\n        array.pop(year_pnl)\n        array.pop(year_time)\n            array.push(year_pnl , cur_year_pnl[1])\n    array.push(year_time, time[1])\n    array.push(year_bh , cur_year_bh[1])\n// Quarterly P&L Table    \nvar quarterly_table = table(na)\ngetCellColor(pnl, bh)  => \n    if pnl > 0\n        if bh < 0 or pnl > 2 * bh\n            color.new( color.green, transp = 20)\n        else if pnl > bh\n            color.new( color.green, transp = 50)\n        else\n            color.new( color.green, transp = 80)\n    else\n        if bh > 0 or pnl < 2 * bh\n            color.new( color.red, transp = 20)\n        else if pnl < bh\n            color.new( color.red, transp = 50)\n        else\n            color.new( color.red, transp = 80)\nif (end_time and enableQuarterlyTable)\n    quarterly_table := table.new(table_position, columns = 14, rows = array.size(year_pnl\n    table.cell(quarterly_table, 0,  0, \"\",     bgcolor =  #cccccc)\n    table.cell(quarterly_table, 1,  0, \"Q1\",  bgcolor =  #cccccc)\n    table.cell(quarterly_table, 2,  0, \"Q2\",  bgcolor =  #cccccc)\n    table.cell(quarterly_table, 3,  0, \"Q3\",  bgcolor =  #cccccc)\n    table.cell(quarterly_table, 4,  0, \"Q4\",  bgcolor =  #cccccc)\n    table.cell(quarterly_table, 5,  0, \"Year\", bgcolor =  #999999)\n    for yi = 0 to array.size(year_pnl) - 1\n        table.cell(quarterly_table, 0,  yi + 1, tostring(year(array.get(year_time,\n                y_color = getCellColor(array.get(year_pnl, yi), array.get(year_bh, yi))\n        table.cell(quarterly_table, 5, yi + 1, enableCompareWithMarket ? tostring(\n            for mi = 0 to array.size(quarter_time) - 1\n        m_row   = year(array.get(quarter_time, mi))  - year(array.get(year_time, 0\n        m_col   = ceil(month(array.get(quarter_time, mi)) / 3)\n        m_color = getCellColor(array.get(quarter_pnl, mi), array.get(quarter_bh, mi\n                table.cell(quarterly_table, m_col, m_row, enableCompareWithMarket ?  tostring"}]}
{"messages": [{"role": "user", "content": "Strategy Time!!! Have built this on my earlier published indicator Band-Zigzag-Trend-Follower. This is just one possible implementation of strategy on  Band-Based-Zigzag. \ud83c\udfb2 Notes  Experimental prototype. Not financial advise and strategy not guaranteed to make money despite backtest results  Not created or tested for any specific instrument or timeframe  Test and adopt with own risk  \ud83c\udfb2 Strategy This is trend following strategy built based on Bands and Zigzag. Traits of trend following strategies are  Lower win rate (Yes, thats right)  High risk reward (Compensates low win rate)  Higher drawdown  If market is choppy, trend following methods suffer.  The script implements few points to overcome the negatives such as lower win rate and higher drawdown by actively assessing pivots on the direction of trend along. This helps us take regular profits and exit on time during the end of trend. Most of the other concepts are defined and explained in indicator - Band-Zigzag-Trend-Follower and Band-Based-Zigzag Defining a trend following method is simple. Basic rule of trend following is Buy High and Sell Low (Yes, you heard it right). To explain further - methodology involve finding an established trend which is flying high and join the trend with proper risk and optimal stop. Once you get into the trade, you will not exit unless there is change in the trend. Or in other words, the parameters which you used to define trend has reversed and the trend is not valid anymore. \ud83c\udfaf Using bands When price breaks out of upper bands (example, Bollinger Band , Keltener Channel, or Donchian Channel), with a pre determined length and multiplier, we can consider the trend to be bullish and similarly when price breaks down the lower band, we can consider the trend to be bearish . \ud83c\udfaf Using Pivots Simple logic using zigzag or pivot points is that when price starts making higher highs and higher lows, we can consider this as uptrend. And when price starts making lower highs and lower lows, we can consider this as downtrend. There are few supertrend implementations I have published in the past based on zigzags and pivot points . Drawbacks of both of these methods is that there will be too many fluctuations in both cases unless we increase the reference length. And if we increase the reference length, we will have higher drawdown. \ud83c\udfaf Band Based Zigzag Method   Here we use bands to define our pivot high and pivot low - this makes sure that we are identifying trend only on breakouts as pivots are only formed on breakouts  Our method also includes pivot ratio to cross over 1.0 to be able to consider it as trend. This means, we are waiting for price also to make new high high or lower low before making the decision on trend. But, this helps us ignore smaller pivot movements due to the usage of bands.  I have also implemented few tricks such as sticky bands (Bands will not contract unless there is breakout) and Adaptive Bands (Band will not expand unless price is moving in the direction of band). This makes the trend following method very robust.  To avoid fakeouts, we also use percentB of high/low in comparison with price retracement to define breakout.  \ud83c\udfb2 Settings Settings are fairly simpler and are explained as below. You will find most of the required information in tooltips."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 HeWhoMustNotBeNamed\n//                                       \u2591\u2592             \n//                                  \u2592\u2592\u2592   \u2592\u2592      \n//                              \u2592\u2592\u2592\u2592\u2592     \u2592\u2592      \n//                      \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591     \u2592     \u2592\u2592          \n//                  \u2592\u2592\u2592\u2592\u2592\u2592           \u2592     \u2592\u2592          \n//             \u2593\u2592\u2592\u2592       \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592  \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2592  \u2592       \u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591        \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592\u2592                       \n//    \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592\u2592\u2592                            \n//                 \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592                           \n//                \u2592\u2592\u2592\u2592\u2592 \u2592\u2592\u2592\u2592\u2592                          \n//               \u2591\u2592\u2592\u2592\u2592   \u2592\u2592\u2592\u2592\u2593      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n//              \u2593\u2592\u2592\u2592\u2592     \u2592\u2592\u2592\u2592      \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n//              \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592        \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//             \u2592\u2592\u2592\u2592\u2592       \u2592\u2592\u2592\u2592\u2592       \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//            \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592      \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \n//             \u2592\u2592             \u2592                        \n//@version=5\nstrategy(\"Band-Zigzag - TrendFollower Strategy [Trendoscope]\", \"BZSTF[Trendoscope]\"\n         default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type\n         pyramiding=1, commission_value=0.05, close_entries_rule=\"ANY\", margin_long\n         max_lines_count=500, max_labels_count=500, max_boxes_count=500, use_bar_magnifier\ntradeDirection = input.string(strategy.direction.all, \"Trade Direction\", options=[\n                             group=\"Trade Settings\", tooltip='Use this to filter only long or short trades'\ntradeSettingsTooltip = 'Pullback - On first pullback after trend confirmation\\nBreakout - On first breakout of trend\\Pullba\ntradeType = input.string('Any', 'Trade Type', options=['Pullback', 'Breakout', 'Pullback-Breakout'\ntradeOnBreakout = tradeType == 'Breakout'\ntradeOnPullback = tradeType == 'Pullback'\ntradeOnRetest = tradeType == 'Pullback-Breakout'\ntradeOnAny = tradeType == 'Any'\nuseStopLoss = input.bool(false, 'Use Stop Loss', group='Trade Settings', tooltip =\nstrategy.risk.allow_entry_in(tradeDirection)\nimport HeWhoMustNotBeNamed/ta/1 as eta\nimport HeWhoMustNotBeNamed/arrays/1 as pa\nimport HeWhoMustNotBeNamed/eHarmonicpatternsExtended/6 as hp\nbandType = input.string('Bollinger Bands', '', ['Bollinger Bands', 'Keltner Channel'\nmaType = input.string('sma', '', options=['sma', 'ema', 'hma', 'rma', 'wma', 'vwma'\nmaLength = input.int(20, '', minval = 5, step=5, inline = 'b1', group='Bands')\nmultiplier = input.float(2.0, '', step=0.5, minval=0.5, group='Bands', inline='b1'\nuseTrueRange = input.bool(true, 'Use True Range (For KC only)', group='Bands', tooltip\nsticky = input.bool(true, 'Sticky', group='Bands', tooltip = 'Sticky bands avoids changing the band unless ther\nuseAdaptive = input.bool(true, 'Adaptive', group='Bands', tooltip = 'When selected, lower band will not decrease when \nshowBands = input.bool(true, 'Display Bands', group='Bands', tooltip = 'If selected, displays bands on chart'\nuseLatestPivot = input.bool(true, 'Use Recent Pivot Override', group='Trend', inline\ncurrentTrendInvalidationMultiplier = input.float(1.618, '', 0, 100, 1, group='Trend'\n             tooltip = 'Trend calculation is done on last confirmed pivot. This option provides opportunity to also conside\nfloat upper = 0.0\nfloat lower = 0.0\nfloat middle = 0.0\ntype Pivot\n    float price\n    int bar\n    int bartime\n    int direction\n    float percentB\n    float ratio = 0\ntype Drawing\n    line zigzagLine\n    label zigzagLabel\nunshift(array<Pivot> zigzag, Pivot p)=>\n    if(array.size(zigzag) > 1)\n        lastPivot = array.get(zigzag, 0)\n        llastPivot = array.get(zigzag, 1)\n        p.direction := p.price*p.direction > llastPivot.price*p.direction ? p.direction\n        p.ratio := math.abs(p.price - lastPivot.price)/math.abs(llastPivot.price -\n    array.unshift(zigzag, p)\n    if(array.size(zigzag)>15)\n        array.pop(zigzag)\nshift(array<Drawing> drawings)=>\n    del = array.shift(drawings)\n    line.delete(del.zigzagLine)\n    label.delete(del.zigzagLabel)\nunshift(array<Drawing> drawings, Drawing drawing, int maxItems)=>\n    array.unshift(drawings, drawing)\n    if(array.size(drawings) > maxItems)\n        del = array.pop(drawings)\n        line.delete(del.zigzagLine)\n        label.delete(del.zigzagLabel)\nif(bandType == 'Bollinger Bands')\n    [bmiddle, bupper, blower] = eta.bb(close, maType, maLength, multiplier, sticky\n    upper := bupper\n    lower := blower\n    middle := bmiddle\nif(bandType == 'Keltner Channel')\n    [kmiddle, kupper, klower] = eta.kc(close, maType, maLength, multiplier, useTrueRange\n    upper := kupper\n    lower := klower\n    middle := kmiddle\nif(bandType == 'Donchian Channel')\n    [dmiddle, dupper, dlower] = eta.dc(maLength, false, close, sticky)\n    upper := dupper\n    lower := dlower\n    middle := dmiddle\nvar zigzag = array.new<Pivot>()\nvar trend = 0\nvar currentTrend = 0\nvar currentDir = 0\nvar currentTrendForce = 0\nvar currentTrendExtreme = 0\nif(array.size(zigzag) > 1)\n    recentPivot = array.get(zigzag, 0)\n    lastPivot = array.get(zigzag, 1)\n    currentDir := recentPivot.direction\n    currentTrend := recentPivot.ratio > recentPivot.percentB? int(math.sign(recentPivot\n    trend := lastPivot.ratio > lastPivot.percentB? int(math.sign(lastPivot.direction\n    currentTrendForce := recentPivot.ratio > recentPivot.percentB and recentPivot.\n    var uupper = nz(upper)\nvar llower = nz(lower)\nuupper := currentDir >= 0 or not useAdaptive? upper : math.min(upper, uupper)\nllower := currentDir <= 0 or not useAdaptive? lower : math.max(lower, llower)\npercentBHigh = (high - llower)/(uupper - llower)\npercentBLow = (uupper - low)/(uupper - llower)\naddPivot(zigzag, direction)=>\n    lastRemoved = false\n    price = direction > 0? high : low\n    percentB = direction > 0? percentBHigh : percentBLow\n    Pivot p = Pivot.new(price, bar_index, time, int(direction), percentB)\n    if(array.size(zigzag) == 0)\n        unshift(zigzag, p)\n    else\n        lastPivot = array.get(zigzag, 0)\n        lastPivotDirection = math.sign(lastPivot.direction)\n        if (lastPivotDirection != p.direction)\n            unshift(zigzag, p)\n        if(lastPivotDirection == p.direction and lastPivot.price*direction < p.price\n            array.remove(zigzag, 0)\n            unshift(zigzag, p)\n            lastRemoved := true\n    lastRemoved\n       add_pivots(zigzag, pHigh, pLow)=>\n    count = 0\n    removeLast = false\n    if(array.size(zigzag) == 0)\n        if(pHigh)\n            addPivot(zigzag, 1)\n            count+=1\n        if(pLow)\n            addPivot(zigzag, -1)\n            count+=1\n    else\n        lastPivot = array.get(zigzag, 0)\n        lastDir = math.sign(lastPivot.direction)\n        if(pHigh and lastDir == 1)  or (pLow and lastDir == -1)\n            removeLast := addPivot(zigzag, lastDir)\n            count := removeLast ? count+1 : count\n        if(pHigh and (lastDir == -1)) or (pLow and (lastDir == 1))\n            addPivot(zigzag, -lastDir)\n            count+=1\n    [count, removeLast]\ndraw_zigzag(zigzag, count, removeLast)=>\n    var zigzagDrawings = array.new<Drawing>()\n    if(removeLast and array.size(zigzagDrawings) > 0)\n        shift(zigzagDrawings)\n    if(array.size(zigzag) > count and count >= 1)\n        for i=count to 1\n            startPivot = array.get(zigzag, count)\n            endPivot = array.get(zigzag, count-1)\n            startDirection = startPivot.direction\n            endDirection = endPivot.direction\n            lineColor = endDirection == 2?  color.green : endDirection == -2?  color.red\n            txt = str.tostring(endPivot.ratio*100, format.percent) + \"/\" + str.tostring\n                        ln = line.new(startPivot.bartime, startPivot.price, endPivot.bartime, \n            lbl = label.new(endPivot.bartime, endPivot.price, txt, xloc.bar_time, \n                        Drawing dr = Drawing.new(ln, lbl)\n            unshift(zigzagDrawings, dr, 500)\n    zigzagDrawings\npHigh = high >= uupper\npLow = low <= llower\n[count, removeLast] = add_pivots(zigzag, pHigh, pLow)\ndraw_zigzag(zigzag, count, removeLast)\nplot(showBands? uupper:na, 'Upper',  color.green, 0, plot.style_linebr)\nplot(showBands? llower:na, 'Lower',  color.red, 0, plot.style_linebr)\nvar combinedTrend = 0\ncombinedTrend := trend > 0 or (useLatestPivot and (currentTrendForce > 0))? 1 :\n                 trend < 0 or (useLatestPivot and (currentTrendForce < 0))? -1 : combinedTrend\ncandleColor = combinedTrend > 0?  color.green : combinedTrend < 0 ?  color.red :\nplot(trend, 'Last Pivot Trend', trend >0?  color.green : trend < 0?  color.red :\nplot(currentTrend, 'Current Pivot Trend', currentTrend > 0?  color.green : currentTrend\nplot(currentTrendForce, 'Force Trend', currentTrendForce >0?  color.green : currentTrendForce\nplot(combinedTrend, \"Combined Trend\", candleColor, display = display.data_window)\nplot(currentDir, \"Current Direction\", color=currentDir>0? color.green:currentDir<\nvar allowEntry = false\nallowEntry := ta.crossover(combinedTrend, 0) or ta.crossunder(combinedTrend, 0)? true\nif(combinedTrend > 0)\n    strategy.close(\"Short\")\n    if((tradeOnBreakout and currentDir > 0) or (tradeOnPullback and currentDir < 0\n        allowEntry := false\n        strategy.entry(\"Long\", strategy.long)\n        if useStopLoss\n            strategy.exit(\"ExitLong\", \"Long\", stop=low - (uupper-llower))\nif(combinedTrend < 0)\n    strategy.close(\"Long\")\n    if((tradeOnBreakout and currentDir < 0) or (tradeOnPullback and currentDir > 0\n        allowEntry := false\n        strategy.entry(\"Short\", strategy.short)\n        if useStopLoss\n            strategy.exit(\"ExitShort\", \"Short\", stop=high + (uupper-llower))\nif(combinedTrend == 0)\n    strategy.close_all()\nplot(allowEntry?1:0, 'Allow Entry', display = display.data_window)"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our seventh one we are automating is the \"Magic MACD Indicator: Crazy Accurate Scalping Trading Strategy ( 74% Win Rate )\" strategy from \"TradeIQ\" who claims to have backtested this manually and achieved 427% profit with a 74% winrate over 100 trades in just a 4 months. I was unable to emulate these results consistently accommodating for slippage and commission but even so the results and especially the high win-rate and low markdown is pretty impressive and quite respectable. This strategy uses a combination of 3 open-source public indicators: AK MACD BB v 1.00 by Algokid SSL Hybrid by Mihkel00 Volume Strength Finder by Saravanan_Ragavan This is considered a trend following Strategy.  AK MACD BB is being used as the primary short term trend direction indicator with an interesting approach of using Bollinger Bands to define an upper and lower range and upon the MACD going above the upper Bollinger Bands, it's indicative of an up trend,  where as if the MACD is below the lower Bollinger Band, it's indicative of a down trend.  To eliminate false signals, SSL Hyrbid is used as a trend confirmation filter, confirming and eliminating false signals from the MACD BB.  It does this by validating the price action is above the the EMA and the SSL is positive that is a confirmation of an uptrend. When the price action is below the EMA and the SSL is negative, that is an confirmation of a downtrend.  To avoid taking trades during ranged markets, VSF Buyer's Strength is used so the buyers/sellers strength and must be above 50% or the trade will not be inititiated. Trading Rules 5 min candles but other lower time frames even below 5m work quite well too. Best results can be found by tweaking these 2 input parameters: Number Of bars to look back to ensure MACD isn't above/below Zero Line Number Of bars back to look for SSL pullback Long Entry when these conditions are true AK MACD BB BB issues a new continuation long signal. A new green circle must appear on the indicator and these circles should not be touching across the zero level while they were previously red SSL Hybrid price action closes above the EMA and the line is blue color and then creates a pullback . The pullback is confirmed when the color changes from blue to gray or from blue to red. VSF Buyers strength above 50% at the time the MACD indicator issues a new long signal. Short Entry when these conditions are true AK MACD BB issues a new continuation short signal. A new red circle must appear on the indicator and these circles should not be touching across the zero level while they were previously green SSL Hybrid price action closes below the EMA and the line is red color then it has to create a pullback . The pullback is confirmed when the color changes from red to gray or from red to blue. VSF Sellers strength above 50% at the time the MACD indicator issues a new short signal. Stop Loss at EMA Line with TP Target 1.5x the risk If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #7 - MACDBB+SSL+VSF - [MYN]', max_bars_back=5000, \n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n//nwVqTuPe6yo\n//5 min\n//ak MACD BB by AlgoKid\n//Disable bar colors in style\n//SSL hybrid by mihkel00\n// Style disable all but bar colors and ma baseline\n// Change SSL1 baseline length from 60 to 30 \n// Change SSL1 baseline type from HMA to EMA\n//volume strength Finder by Saravanan\n// Get rid of bar colors on style\n// Trading Rules\n// SSL Hybrid.  \n// Buy only when price action is closed above the EMA and the line is blue color.\n// Sell priace action must be closed below the EMA and the line is red color\n// Volume Indicator\n// Buy when Buyers strength / volume is higher than sellers volume\n// Opposite\n// General trading rules\n// Short\n// Price action must be moving below the EMA and then it has to create a pullback .  The pullback is\n// If the price action is touching the EMA but the line does not change the color, the pullback is n\n// Once we have this pullback we're going to be waiting for the MACD to issue a new continuation sho\n// Sellers strength above 50% at the time the MACD indiactor issues a new short signal.\n// Stop Loss at EMA line 1:1.5 risk ratio.\n// Functions universal to strategy\n    f_priorBarsSatisfied(_objectToEval, _numOfBarsToLookBack) => \n    returnVal = false\n    for i = 0 to _numOfBarsToLookBack\n        if (_objectToEval[i] == true)\n            returnVal = true\n// AK MACD BB v 1.00 by Algokid\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//indicator('AK MACD BB v 1.00')\nlength = input.int(10, minval=1, title='BB Periods',group=\"AK MACD BB\")\ndev = input.float(1, minval=0.0001, title='Deviations')\n//MACD\nfastLength = input.int(12, minval=1)\nslowLength = input.int(26, minval=1)\nsignalLength = input.int(9, minval=1)\nfastMA = ta.ema(close, fastLength)\nslowMA = ta.ema(close, slowLength)\nmacd = fastMA - slowMA\n//BollingerBands\nStd = ta.stdev(macd, length)\nUpper = Std * dev + ta.sma(macd, length)\nLower = ta.sma(macd, length) - Std * dev\n//Band1 = plot(Upper, color=color.new(color.gray, 0), style=plot.style_line, linewidth=2, title='Upp\n//Band2 = plot(Lower, color=color.new(color.gray, 0), style=plot.style_line, linewidth=2, title='low\n//fill(Band1, Band2, color=color.new(color.blue, 75), title='Fill')\nmc = macd >= Upper ?  color.lime :  color.red\n// Indicator\n//plot(macd, color=mc, style=plot.style_circles, linewidth=3)\nzeroline = 0\n//plot(zeroline, color=color.new(color.orange, 0), linewidth=2, title='Zeroline')\n//buy\n//barcolor(macd > Upper ? color.yellow : na)\n//short\n//barcolor(macd < Lower ? color.aqua : na)\n//needs improvments \nMACDBBNumBarsBackToLookForMACDToBelowZero = input(1, title=\"Number Of bars to look back to ensure MACD isn't \n// Sell when MACD to issue a new continuation short signal.  A new red circle must appear on the ind\nMACDBBENtryShort = mc ==  color.red and macd < zeroline and f_priorBarsSatisfied(\n// Buy when MACD to issue a new continuation long signal.  A new green circle must appear on the ind\nMACDBBENtryLong = mc ==  color.lime and macd > zeroline and f_priorBarsSatisfied(\n// SSL Hybrid by Mihkel00\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//AK MACD BB \n//created by Algokid , February 24,2015\n//@version=5\n//By Mihkel00\n// This script is designed for the NNFX Method, so it is recommended for Daily charts only. \n// Tried to implement a few VP NNFX Rules\n// This script has a SSL / Baseline (you can choose between the SSL or MA), a secondary SSL for cont\n// Alerts added for Baseline entries, SSL2 continuations, Exits.\n// Baseline has a Keltner Channel setting for \"in zone\" Gray Candles\n// Added \"Candle Size > 1 ATR\" Diamonds from my old script with the criteria of being within Baselin\n// Credits\n// Strategy causecelebre https://www.tradingview.com/u/causecelebre/\n// SSL Channel ErwinBeckers https://www.tradingview.com/u/ErwinBeckers/\n// Moving Averages jiehonglim https://www.tradingview.com/u/jiehonglim/\n// Moving Averages  everget https://www.tradingview.com/u/everget/\n// \"Many Moving Averages\" script  Fractured https://www.tradingview.com/u/Fractured/\n//indicator('SSL Hybrid', overlay=true)\nshow_Baseline = input(title='Show Baseline', defval=true, group=\"SSL Hybrid\")\nshow_SSL1 = input(title='Show SSL1', defval=false)\nshow_atr = input(title='Show ATR bands', defval=true)\n//ATR\natrlen = input(14, 'ATR Period')\nmult = input.float(1, 'ATR Multi', step=0.1)\nsmoothing = input.string(title='ATR Smoothing', defval='WMA', options=['RMA', 'SMA'\nma_function(source, atrlen) =>\n    if smoothing == 'RMA'\n        ta.rma(source, atrlen)\n    else\n        if smoothing == 'SMA'\n            ta.sma(source, atrlen)\n        else\n            if smoothing == 'EMA'\n                ta.ema(source, atrlen)\n            else\n                ta.wma(source, atrlen)\natr_slen = ma_function(ta.tr(true), atrlen)\n////ATR Up/Low Bands\nupper_band = atr_slen * mult + close\nlower_band = close - atr_slen * mult\n////BASELINE / SSL1 / SSL2 / EXIT MOVING AVERAGE VALUES\nmaType = input.string(title='SSL1 / Baseline Type', defval='EMA', options=['SMA', \nlen = input(title='SSL1 / Baseline Length', defval=30)\nSSL2Type = input.string(title='SSL2 / Continuation Type', defval='JMA', options=['SMA'\nlen2 = input(title='SSL 2 Length', defval=5)\n//\nSSL3Type = input.string(title='EXIT Type', defval='HMA', options=['DEMA', 'TEMA', \nlen3 = input(title='EXIT Length', defval=15)\nsrc = input(title='Source', defval=close)\n//\ntema(src, len) =>\n    ema1 = ta.ema(src, len)\n    ema2 = ta.ema(ema1, len)\n    ema3 = ta.ema(ema2, len)\n    3 * ema1 - 3 * ema2 + ema3\nkidiv = input.int(defval=1, maxval=4, title='Kijun MOD Divider')\njurik_phase = input(title='* Jurik (JMA) Only - Phase', defval=3)\njurik_power = input(title='* Jurik (JMA) Only - Power', defval=1)\nvolatility_lookback = input(10, title='* Volatility Adjusted (VAMA) Only - Volatility lo\n//MF\nbeta = input.float(0.8, minval=0, maxval=1, step=0.1, title='Modular Filter, General Filter Only - Beta'\nfeedback = input(false, title='Modular Filter Only - Feedback')\nz = input.float(0.5, title='Modular Filter Only - Feedback Weighting', step=0.1, minval\n//EDSMA\nssfLength = input.int(title='EDSMA - Super Smoother Filter Length', minval=1, defval\nssfPoles = input.int(title='EDSMA - Super Smoother Filter Poles', defval=2, options\n//----\n//EDSMA\nget2PoleSSF(src, length) =>\n    PI = 2 * math.asin(1)\n    arg = math.sqrt(2) * PI / length\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(arg)\n    c2 = b1\n    c3 = -math.pow(a1, 2)\n    c1 = 1 - c2 - c3\n    ssf = 0.0\n    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])\n    ssf\nget3PoleSSF(src, length) =>\n    PI = 2 * math.asin(1)\n    arg = PI / length\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(1.738 * arg)\n    c1 = math.pow(a1, 2)\n    coef2 = b1 + c1\n    coef3 = -(c1 + b1 * c1)\n    coef4 = math.pow(c1, 2)\n    coef1 = 1 - coef2 - coef3 - coef4\n    ssf = 0.0\n    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[\n    ssf\nma(type, src, len) =>\n    float result = 0\n    if type == 'TMA'\n        result := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)\n        result\n    if type == 'MF'\n        ts = 0.\n        b = 0.\n        c = 0.\n        os = 0.\n        //----\n        alpha = 2 / (len + 1)\n        a = feedback ? z * src + (1 - z) * nz(ts[1], src) : src\n        //----\n        b := a > alpha * a + (1 - alpha) * nz(b[1], a) ? a : alpha * a + (1 - alpha\n        c := a < alpha * a + (1 - alpha) * nz(c[1], a) ? a : alpha * a + (1 - alpha\n        os := a == b ? 1 : a == c ? 0 : os[1]\n        //----\n        upper = beta * b + (1 - beta) * c\n        lower = beta * c + (1 - beta) * b\n        ts := os * upper + (1 - os) * lower\n        result := ts\n        result\n    if type == 'LSMA'\n        result := ta.linreg(src, len, 0)\n        result\n    if type == 'SMA'  // Simple\n        result := ta.sma(src, len)\n        result\n    if type == 'EMA'  // Exponential\n        result := ta.ema(src, len)\n        result\n    if type == 'DEMA'  // Double Exponential\n        e = ta.ema(src, len)\n        result := 2 * e - ta.ema(e, len)\n        result\n    if type == 'TEMA'  // Triple Exponential\n        e = ta.ema(src, len)\n        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)\n        result\n    if type == 'WMA'  // Weighted\n        result := ta.wma(src, len)\n        result\n    if type == 'VAMA'  // Volatility Adjusted\n        /// Copyright \u00a9 2019 to present, Joris Duyck (JD)\n        mid = ta.ema(src, len)\n        dev = src - mid\n        vol_up = ta.highest(dev, volatility_lookback)\n        vol_down = ta.lowest(dev, volatility_lookback)\n        result := mid + math.avg(vol_up, vol_down)\n        result\n    if type == 'HMA'  // Hull\n        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt\n        result\n    if type == 'JMA'  // Jurik\n        /// Copyright \u00a9 2018 Alex Orekhov (everget)\n        /// Copyright \u00a9 2017 Jurik Research and Consulting.\n        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase\n        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)\n        alpha = math.pow(beta, jurik_power)\n        jma = 0.0\n        e0 = 0.0\n        e0 := (1 - alpha) * src + alpha * nz(e0[1])\n        e1 = 0.0\n        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])\n        e2 = 0.0\n        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow\n        jma := e2 + nz(jma[1])\n        result := jma\n        result\n    if type == 'Kijun v2'\n        kijun = math.avg(ta.lowest(len), ta.highest(len))  //, (open + close)/2)\n        conversionLine = math.avg(ta.lowest(len / kidiv), ta.highest(len / kidiv))\n        delta = (kijun + conversionLine) / 2\n        result := delta\n        result\n    if type == 'McGinley'\n        mg = 0.0\n        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow\n        result := mg\n        result\n    if type == 'EDSMA'\n        zeros = src - nz(src[2])\n        avgZeros = (zeros + zeros[1]) / 2\n        // Ehlers Super Smoother Filter \n        ssf = ssfPoles == 2 ? get2PoleSSF(avgZeros, ssfLength) : get3PoleSSF(avgZeros\n        // Rescale filter in terms of Standard Deviations\n        stdev = ta.stdev(ssf, len)\n        scaledFilter = stdev != 0 ? ssf / stdev : 0\n        alpha = 5 * math.abs(scaledFilter) / len\n        edsma = 0.0\n        edsma := alpha * src + (1 - alpha) * nz(edsma[1])\n        result := edsma\n        result\n    result\n///SSL 1 and SSL2\nemaHigh = ma(maType, high, len)\nemaLow = ma(maType, low, len)\nmaHigh = ma(SSL2Type, high, len2)\nmaLow = ma(SSL2Type, low, len2)\n///EXIT\nExitHigh = ma(SSL3Type, high, len3)\nExitLow = ma(SSL3Type, low, len3)\n///Keltner Baseline Channel\nBBMC = ma(maType, close, len)\nuseTrueRange = input(true)\nmulty = input.float(0.2, step=0.05, title='Base Channel Multiplier')\nKeltma = ma(maType, src, len)\nrange_1 = useTrueRange ? ta.tr : high - low\nrangema = ta.ema(range_1, len)\nupperk = Keltma + rangema * multy\nlowerk = Keltma - rangema * multy\n//Baseline Violation Candle\nopen_pos = open * 1\nclose_pos = close * 1\ndifference = math.abs(close_pos - open_pos)\natr_violation = difference > atr_slen\nInRange = upper_band > BBMC and lower_band < BBMC\ncandlesize_violation = atr_violation and InRange\n//plotshape(candlesize_violation, color=color.new(color.white, 0), size=size.tiny, style=shape.diamo\n//SSL1 VALUES\nHlv = int(na)\nHlv := close > emaHigh ? 1 : close < emaLow ? -1 : Hlv[1]\nsslDown = Hlv < 0 ? emaHigh : emaLow\n//SSL2 VALUES\nHlv2 = int(na)\nHlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]\nsslDown2 = Hlv2 < 0 ? maHigh : maLow\n//EXIT VALUES\nHlv3 = int(na)\nHlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]\nsslExit = Hlv3 < 0 ? ExitHigh : ExitLow\nbase_cross_Long = ta.crossover(close, sslExit)\nbase_cross_Short = ta.crossover(sslExit, close)\ncodiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na\n//COLORS\nshow_color_bar = input(title='Color Bars', defval=true)\ncolor_bar = close > upperk ?  #00c3ff : close < lowerk ?  #ff0062 :  color.gray\ncolor_ssl1 = close > sslDown ?  #00c3ff : close < sslDown ?  #ff0062 : na\n//PLOTS\n//plotarrow(codiff, colorup=color.new(#00c3ff, 20), colordown=color.new(#ff0062, 20), title='Exit Ar\np1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4, title='MA Baseline'\n//DownPlot = plot(show_SSL1 ? sslDown : na, title='SSL1', linewidth=3, color=color_ssl1, transp=10)\nbarcolor(show_color_bar ? color_bar : na)\n//up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title='Baseline Upper Channel')\n//low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title='Basiline Lower Channel')\n//fill(up_channel, low_channel, color=color_bar, transp=90)\n////SSL2 Continiuation from ATR\natr_crit = input.float(0.9, step=0.1, title='Continuation ATR Criteria')\nupper_half = atr_slen * atr_crit + close\nlower_half = close - atr_slen * atr_crit\nbuy_inatr = lower_half < sslDown2\nsell_inatr = upper_half > sslDown2\nsell_cont = close < BBMC and close < sslDown2\nbuy_cont = close > BBMC and close > sslDown2\nsell_atr = sell_inatr and sell_cont\nbuy_atr = buy_inatr and buy_cont\natr_fill = buy_atr ?  color.green : sell_atr ?  color.purple :  color.white\n//LongPlot = plot(sslDown2, title='SSL2', linewidth=2, color=atr_fill, style=plot.style_circles, tra\n//u = plot(show_atr ? upper_band : na, '+ATR', color=color.new(color.white, 80))\n//l = plot(show_atr ? lower_band : na, '-ATR', color=color.new(color.white, 80))\n//ALERTS\nalertcondition(ta.crossover(close, sslDown), title='SSL Cross Alert', message='SSL1 has crossed.'\nalertcondition(ta.crossover(close, sslDown2), title='SSL2 Cross Alert', message='SSL2 has crossed.'\nalertcondition(sell_atr, title='Sell Continuation', message='Sell Continuation.')\nalertcondition(buy_atr, title='Buy Continuation', message='Buy Continuation.')\nalertcondition(ta.crossover(close, sslExit), title='Exit Sell', message='Exit Sell Alert.'\nalertcondition(ta.crossover(sslExit, close), title='Exit Buy', message='Exit Buy Alert.'\nalertcondition(ta.crossover(close, upperk), title='Baseline Buy Entry', message='Base Buy Alert.'\nalertcondition(ta.crossover(lowerk, close), title='Baseline Sell Entry', message='Base Sell Alert.'\n// Buy only when price action is closed above the EMA and the line is blue color.\nSSLHybridEntryLong1 = src > BBMC and color_bar ==  #00c3ff\n// Sell only when action must be closed below the EMA and the line is red color\nSSLHybridEntryShort1 = src < BBMC and color_bar ==  #ff0062\nsslHybridNumBarsBackToLookForPullBack = input(4, title=\"Number Of bars back to look for SSL pullback\"\n// Buy when Price action must be moving above the EMA and then it has to create a pullback .  The pu\nSSLHybridEntryLong2 = color_bar ==  #00c3ff  and (f_priorBarsSatisfied(color_bar \n// Sell when Price action must be moving below the EMA and then it has to create a pullback .  The p\nSSLHybridEntryShort2 = color_bar ==  #ff0062  and (f_priorBarsSatisfied(color_bar\nSSLHybridEntryLong = SSLHybridEntryLong1 and SSLHybridEntryLong2 \nSSLHybridEntryShort = SSLHybridEntryShort1 and SSLHybridEntryShort2 \n// Price action must be moving below the EMA and then it has to create a pullback .  The pullback is\n// If the price action is touching the EMA but the line does not change the color, the pullback is n\n// Volume Strength Finder by Saravanan_Ragavan\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Saravanan_Ragavan\n//@version=5\n//indicator('Volume Strength Finder', 'VSF', overlay=true)\nT1 = time(timeframe.period, '0915-0916:23456')\nT2 = time(timeframe.period, '0915-1530:23456')\nY = bar_index\nZ1 = ta.valuewhen(T1, bar_index, 0)\nL = Y - Z1 + 1\nSSPV = 0.00\nSSNV = 0.00\npdw = 0.00\nndw = 0.00\ntotal_w = 0.00\nfor i = 1 to L - 1 by 1\n    total_w := high[i] - low[i]\n    positive = close[i] - low[i]\n    negative = high[i] - close[i]\n    pdw := positive / total_w * 100\n    ndw := negative / total_w * 100\n    SSPV := volume[i] * pdw / 100 + SSPV\n    SSNV := volume[i] * ndw / 100 + SSNV\n    SSNV\ntotal_v = SSPV + SSNV\nPos = SSPV / total_v * 100\nNeg = SSNV / total_v * 100\nbgc = SSPV > SSNV ?  color.green : SSPV < SSNV ?  color.red :  color.white\n//barcolor(bgc)\nvar table sDisplay = table.new(position.top_right, 1, 5, bgcolor= color.aqua, frame_width\nif barstate.islast\n    table.cell(sDisplay, 0, 0, 'Today\\'s Volume : ' + str.tostring(total_v), text_color\n    table.cell(sDisplay, 0, 1, 'Buyers Volume: ' + str.tostring(math.round(SSPV)),\n    table.cell(sDisplay, 0, 2, 'Sellers Volume: ' + str.tostring(math.round(SSNV))\n    table.cell(sDisplay, 0, 3, 'Buyers Strength: ' + str.tostring(math.round(Pos))\n    table.cell(sDisplay, 0, 4, 'Sellers Strength: ' + str.tostring(math.round(Neg)\n// Sellers strength above 50% at the time the MACD indiactor issues a new short signal.\nVSFShortEntry = math.round(Neg) > 50\n// Buyers strength above 50% at the time the MACD indiactor issues a new long signal.\nVSFLongEntry = math.round(Pos) > 50\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nlongCondition = SSLHybridEntryLong and VSFLongEntry and MACDBBENtryLong\nshortCondition =SSLHybridEntryShort and VSFShortEntry and MACDBBENtryShort\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=1, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=2, minval=0.01, group=\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "This is a strategy using an index's (SPX, NDX, RUT) Fair Value derived from Net Liquidity. Net Liquidity function is simply: Fed Balance Sheet - Treasury General Account - Reverse Repo Balance Formula for calculating the fair value of and Index using Net Liquidity looks like this: net_liquidity/1000000000/scalar - subtractor The Index Fair Value is then subtracted from the Index value which creates an oscillating diff value. When diff is greater than the overbought threshold, Index is considered overbought and we go short/sell. When diff is less than the oversold signal, Index is considered oversold and we cover/buy. The net liquidity values I calculate outside of TradingView. If you'd like the strategy to work for future dates, you'll need to update the reference to my NetLiquidityLibrary, which I update daily. Parameters: Index: SPX, NDX, RUT Strategy: Short Only, Long Only, Long/Short Inverse (bool): check if using an inverse ETF to go long instead of short. Scalar (float) Subtractor (int) Overbought Threshold (int) Oversold Threshold (int) Start After Date: When the strategy should start trading Close Date: Day to close open trades. I just like it to get complete results rather than the strategy ending with open trades. Optimal Parameters: I've optimized the parameters for each index using the python backtesting library and they are as follows => SPX Scalar: 1.1 Subtractor: 1425 OB Threshold: 0 OS Threshold: -175 NDX Scalar: 0.5 Subtractor: 250 OB Threshold: 0 OS Threshold: -25 RUT Scalar: 3.2 Subtractor: 50 OB Threshold: 25 OS Threshold: -25"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 calebsandfort\n//@version=5\nstrategy(\"Fair Value Strategy Ultimate\", overlay=false, initial_capital = 1000000, \nimport calebsandfort/NetLiquidityLibrary/43\u200aas NetLiquidityLibrary\nfv_index_ticker = input.string(\"SPX\", \"Fair Value Index\", [\"SPX\", \"NDX\", \"RUT\"])\nmode = input.string(\"Long/Short\", \"Strategy\", [\"Short Only\", \"Long Only\", \"Long/Short\"\nscalar = input.float(1.1, \"Scalar\", 0.0, 5.0, .1)\nsubtractor = input.int(1425, \"Subtractor\", step = 25)\nob_threshold = input.int(0, \"OB Threshold\", step = 25)\nos_threshold = input.int(-175, \"OS Threshold\", step = 25)\ninverse = input.bool(false, \"Inverse\")\nstartDate = input.int(title=\"Start Day\", defval=20, minval=1, maxval=31)\nstartMonth = input.int(title=\"Start Month\", defval=12, minval=1, maxval=12)\nstartYear = input.int(title=\"Start Year\", defval=2021, minval=1800, maxval=2100)\n// See if this bar's time happened on/after start date\nafterStartDate = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\nuseCloseDate = input.bool(true, title=\"Use Close Date\")\ncloseDay = input.int(title=\"Close Day\", defval=12, minval=1, maxval=31)\ncloseMonth = input.int(title=\"Close Month\", defval=01, minval=1, maxval=12)\ncloseYear = input.int(title=\"Close Year\", defval=2023, minval=1800, maxval=2100)  \n// See if this bar's time happened on/after end date\nafterEndDate = year == closeYear and month == closeMonth and dayofmonth == closeDay\nnet_liquidity = NetLiquidityLibrary.get_net_liquidity()\nplotchar(net_liquidity, \"net_liquidity\", \"\", location.top)\nindex_fair_value = net_liquidity/1000000000/scalar - subtractor\nindex = request.security(fv_index_ticker, \"D\", close)\ndiff = index - index_fair_value\nplot(index_fair_value > 0 ? diff : na, title = \"Spread\", color =  color.orange, trackprice\nhline(0, title='Zero', color= color.gray, linestyle=hline.style_dotted, linewidth=\nhline(ob_threshold, title='Overbought', color= color.red, linestyle=hline.style_dotted\nhline(os_threshold, title='Oversold', color= color.green, linestyle=hline.style_dotted\noverbought_signal = net_liquidity > 0.0 and (diff[1] < ob_threshold and diff[0] > ob_threshold\noversold_signal = net_liquidity > 0.0 and (diff[1] > os_threshold and diff[0] < os_threshold\nbarcolor(overbought_signal ?  color.purple : oversold_signal ?  color.blue : na)\nqty = (strategy.initial_capital + strategy.netprofit + strategy.openprofit)/close\nqty_adj = strategy.opentrades > 0 ? math.abs(strategy.opentrades.size(0) * 1) : qty\nif (mode == \"Long/Short\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")        \n        else if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (afterStartDate and oversold_signal)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n        else if (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Short Only\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Long Only\")\n    if (inverse)\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n    else\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our fifth one we are automating is one of the strategies from \"The Best 3 Buy And Sell Indicators on Tradingview + Confirmation Indicators ( The Golden Ones ))\" from \"Online Trading Signals (Scalping Channel)\". No formal backtesting was done by them and resuructo messaged me asking if we could validate their claims. Originally, we mimic verbatim the settings Online Trading Signals was using however weren't getting promising results. So before we stopped there we thought we might want to see if this could be improved on. So we adjusted the Renko Assignment modifier from ATR to Traditional and adjusted the value to be higher from 30 to 47. We also decided to try adding another signal confirmation to eliminate some of the ranged market conditions so we choose our favorite, ADX . Also, given we are using this on a higher time-frame we adjusted the G-Channel Trend detection source from close to OHLC4 to get better average price action indication and more accurate trend direction. This strategy uses a combination of 2 open-source public indicators: poki buy and sell Take profit and stop loss by RafaelZioni G-Channel Trend Detection by jaggedsoft Trading Rules 15m - 4h timeframe. We saw best results at the recommended 1 hour timeframe. Long Entry: When POKI triggers a buy signal When G-Channel Trend Detection is in an upward trend (Green) ADX Is above 25 Short Entry: When POKI triggers a sell signal When G-Channel Trend Detection is in an downward trend (red) ADX Is above 25 If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #5 - POKI+GTREND+ADX - [MYN]', max_bars_back=5000,\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n// Q0txMfU623Y\n// Trading Rules\n// 15m - 4 hours.  Ideal 1 hour\n// Poki \n// Remove color plots\n// Change ATR to 30\n// Use Buy/Sell indicators as confirmation\n//  G-TREND\n// Use color to confirm signal with POKI buy/sell indicators\n// To get better results had to:\n// Add an ADX confirmation\n// Changed G-Trend to use OHLC4\n// TP at 2% / SL 15%\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//indicator('poki', shorttitle='poki', overlay=true)\n// Parabolic SAR\nstartMult = input.int(3, minval=0, maxval=10, title='Start - Default = 2 - Multiplied by .01'\nincrement = input.int(3, minval=0, maxval=10, title='Step Setting (Sensitivity) - Default = 2 - Multip\nmaximum = input.int(3, minval=1, maxval=10, title='Maximum Step (Sensitivity) - Default = 2 - Multip\nsus = input(true, 'Show Up Trending Parabolic Sar')\nsds = input(true, 'Show Down Trending Parabolic Sar')\ndisc = input(false, title='Start and Step settings are *.01 so 2 = .02 etc, Maximum Step is *.10 so 2 = .2'\nstartCalc = startMult * .01\nincrementCalc = increment * .01\nmaximumCalc = maximum * .10\nsarUp = ta.sar(startCalc, incrementCalc, maximumCalc)\nsarDown = ta.sar(startCalc, incrementCalc, maximumCalc)\ncolUp = close >= sarDown ?  color.blue : na\ncolDown = close <= sarUp ?  color.red : na\n//plot(sus and sarUp ? sarUp : na, title='Up Trending SAR', style=plot.style_circles, linewidth=2, c\n//plot(sds and sarDown ? sarDown : na, title='Up Trending SAR', style=plot.style_circles, linewidth=\n// Input\nclose_price = close[0]\nlen = input.int(defval=50, minval=1, title='Linear Regression length')\nlinear_reg = ta.linreg(close_price, len, 0)\nlinear_reg_prev = ta.linreg(close[1], len, 0)\nslope = (linear_reg - linear_reg_prev) / timeframe.multiplier\nlength = input.int(title='Bollinger Length', defval=20, minval=1)\nmultiplier = input.float(title='Bollinger Deviation', defval=2, minval=1)\noverbought = input.int(title='Overbought', defval=1, minval=1)\noversold = input.int(title='Oversold', defval=0, minval=0)\ncustom_timeframe = input(title='Use another Timeframe?', defval=false)\nhighTimeFrame = input.timeframe(title='Select The Timeframe', defval='60')\nres1 = custom_timeframe ? highTimeFrame : timeframe.period\nsmabasis = ta.sma(close, length)\nstdev = ta.stdev(close, length)\ncierre = request.security(syminfo.tickerid, res1, close, barmerge.gaps_off)\nalta = request.security(syminfo.tickerid, res1, high, barmerge.gaps_off)\nbaja = request.security(syminfo.tickerid, res1, low, barmerge.gaps_off)\nbasis1 = request.security(syminfo.tickerid, res1, smabasis, barmerge.gaps_off)\nstdevb = request.security(syminfo.tickerid, res1, stdev, barmerge.gaps_off)\ndev = multiplier * stdevb  // stdev(cierre, length)\nupper = basis1 + dev\nlower = basis1 - dev\nbbr = (cierre - lower) / (upper - lower)\n// plot(bbr)\n// // MARCA LAS RESISTENCIAS\npintarojo = 0.0\npintarojo := nz(pintarojo[1])\npintarojo := bbr[1] > overbought and bbr < overbought ? alta[1] : nz(pintarojo[1])\n//p = plot(pintarojo, color=color.new(color.red, 0), style=plot.style_circles, linewidth=2)\n// // MARCA LOS SOPORTES\npintaverde = 0.0\npintaverde := nz(pintaverde[1])\npintaverde := bbr[1] < oversold and bbr > oversold ? baja[1] : nz(pintaverde[1])\n//g = plot(pintaverde, color=color.new(color.blue, 0), style=plot.style_circles, linewidth=2)\n//\nmethod = input.string(defval='Traditional', options=['ATR', 'Traditional', 'Part of Price'\nmethodvalue = input.float(defval=29, minval=0, title='Value')\npricesource = input.string(defval='Close', options=['Close', 'Open / Close', 'High / Low'\nuseClose = pricesource == 'Close'\nuseOpenClose = pricesource == 'Open / Close' or useClose\nuseTrueRange = input.string(defval='Auto', options=['Always', 'Auto', 'Never'], title\nisOscillating = input(defval=true, title='Oscillating')\nnormalize = input(defval=false, title='Normalize')\nvol = useTrueRange == 'Always' or useTrueRange == 'Auto' and na(volume) ? ta.tr : \nop = useClose ? close : open\nhi = useOpenClose ? close >= op ? close : op : high\nlo = useOpenClose ? close <= op ? close : op : low\nif method == 'ATR'\n    methodvalue := ta.atr(math.round(methodvalue))\n    methodvalue\nif method == 'Part of Price'\n    methodvalue := close / methodvalue\n    methodvalue\ncurrclose = float(na)\nprevclose = nz(currclose[1])\nprevhigh = prevclose + methodvalue\nprevlow = prevclose - methodvalue\ncurrclose := hi > prevhigh ? hi : lo < prevlow ? lo : prevclose\ndirection = int(na)\ndirection := currclose > prevclose ? 1 : currclose < prevclose ? -1 : nz(direction\ndirectionHasChanged = ta.change(direction) != 0\ndirectionIsUp = direction > 0\ndirectionIsDown = direction < 0\nbarcount = 1\nbarcount := not directionHasChanged and normalize ? barcount[1] + barcount : barcount\nvol := not directionHasChanged ? vol[1] + vol : vol\nres = barcount > 1 ? vol / barcount : vol\nx = isOscillating and directionIsDown ? -res : res\n//\nz = input(title='period', defval=32)\nn2ma = 2 * ta.wma(close, math.round(z / 2))\nnma = ta.wma(close, z)\ndiff = n2ma - nma\nsqn = math.round(math.sqrt(z))\nn2ma1 = 2 * ta.wma(close[1], math.round(z / 2))\nnma1 = ta.wma(close[1], z)\ndiff1 = n2ma1 - nma1\nsqn1 = math.round(math.sqrt(z))\nn1 = ta.wma(diff, sqn)\nn2 = ta.wma(diff1, sqn)\nc = n1 > n2 ?  color.green :  color.red\n// Conditions\nlongCondPOKI = bool(na)\nshortCondPOKI = bool(na)\nlongCondPOKI := ta.crossover(x, 0)\nshortCondPOKI := ta.crossunder(x, 0)\n// Count your long short conditions for more control with Pyramiding\n// sectionLongs = 0\n// sectionLongs := nz(sectionLongs[1])\n// sectionShorts = 0\n// sectionShorts := nz(sectionShorts[1])\n// if longCond\n//     sectionLongs += 1\n//     sectionShorts := 0\n//     sectionShorts\n// if shortCond\n//     sectionLongs := 0\n//     sectionShorts += 1\n//     sectionShorts\n// Pyramiding\n// pyrl = 1\n// These check to see your signal and cross references it against the pyramiding settings above\n// longCondition = longCond and sectionLongs <= pyrl\n// shortCondition = shortCond and sectionShorts <= pyrl\n// Get the price of the last opened long or short\n// last_open_longCondition = float(na)\n// last_open_shortCondition = float(na)\n// last_open_longCondition := longCondition ? open : nz(last_open_longCondition[1])\n// last_open_shortCondition := shortCondition ? open : nz(last_open_shortCondition[1])\n// // Check if your last postion was a long or a short\n// last_longCondition = float(na)\n// last_shortCondition = float(na)\n// last_longCondition := longCondition ? time : nz(last_longCondition[1])\n// last_shortCondition := shortCondition ? time : nz(last_shortCondition[1])\n// in_longCondition = last_longCondition > last_shortCondition\n// in_shortCondition = last_shortCondition > last_longCondition\n// // Take profit\n// isTPl = input(false, 'Take Profit Long')\n// isTPs = input(false, 'Take Profit Short')\n// tp = input.float(2, 'Take Profit %')\n// long_tp = isTPl and ta.crossover(high, (1 + tp / 100) * last_open_longCondition) and longConditio\n// short_tp = isTPs and ta.crossunder(low, (1 - tp / 100) * last_open_shortCondition) and shortCondi\n// // Stop Loss\n// isSLl = input(false, 'Stop Loss Long')\n// isSLs = input(false, 'Stop Loss Short')\n// sl = 0.0\n// sl := input.float(3, 'Stop Loss %')\n// long_sl = isSLl and ta.crossunder(low, (1 - sl / 100) * last_open_longCondition) and longConditio\n// short_sl = isSLs and ta.crossover(high, (1 + sl / 100) * last_open_shortCondition) and shortCondi\n// // Create a single close for all the different closing conditions.\n// long_close = long_tp or long_sl ? 1 : 0\n// short_close = short_tp or short_sl ? 1 : 0\n// // Get the time of the last close\n// last_long_close = float(na)\n// last_short_close = float(na)\n// last_long_close := long_close ? time : nz(last_long_close[1])\n// last_short_close := short_close ? time : nz(last_short_close[1])\n//\nshowZones = input(true, title='Show Bullish/Bearish Zones')\n// bullish signal rule: \nbullishRule = n1 > linear_reg\n// bearish signal rule: \nbearishRule = n1 <= linear_reg\n// current trading State\nruleState = 0\nruleState := bullishRule ? 1 : bearishRule ? -1 : nz(ruleState[1])\n//bgcolor(showZones ? ruleState == 1 ? color.blue : ruleState == -1 ? color.red : color.gray : na, t\n// Alerts & Signals\n// bton(b) =>\n//     b ? 1 : 0\nplotshape(longCondPOKI, title='Buy Signal', text='B', style=shape.triangleup, location\nplotshape(shortCondPOKI, title='Sell Signal', text='S', style=shape.triangledown, \n//plotshape(long_tp and last_longCondition > nz(last_long_close[1]), text='TP', title='Take Profit L\n//plotshape(short_tp and last_shortCondition > nz(last_short_close[1]), text='TP', title='Take Profi\n//ltp = long_tp and last_longCondition > nz(last_long_close[1]) ? (1 + tp / 100) * last_open_longCon\n//plot(ltp, style=plot.style_cross, linewidth=3, color=color.new(color.white, 0), editable=false)\n//stp = short_tp and last_shortCondition > nz(last_short_close[1]) ? (1 - tp / 100) * last_open_shor\n//plot(stp, style=plot.style_cross, linewidth=3, color=color.new(color.white, 0), editable=false)\n//plotshape(long_sl and last_longCondition > nz(last_long_close[1]), text='SL', title='Stop Loss Lon\n//plotshape(short_sl and last_shortCondition > nz(last_short_close[1]), text='SL', title='Stop Loss \n//lsl = long_sl and last_longCondition > nz(last_long_close[1]) ? (1 - sl / 100) * last_open_longCon\n//plot(lsl, style=plot.style_cross, linewidth=3, color=color.new(color.white, 0), editable=false)\n//ssl = short_sl and last_shortCondition > nz(last_short_close[1]) ? (1 + sl / 100) * last_open_shor\n//plot(ssl, style=plot.style_cross, linewidth=3, color=color.new(color.white, 0), editable=false)\n// alertcondition(bton(longCondition), title='Buy Alert')\n// alertcondition(bton(shortCondition), title='Sell Alert')\n// alertcondition(bton(long_tp and last_longCondition > nz(last_long_close[1])), title='Take Profit \n// alertcondition(bton(short_tp and last_shortCondition > nz(last_short_close[1])), title='Take Prof\n// alertcondition(bton(long_sl and last_longCondition > nz(last_long_close[1])), title='Stop Loss Lo\n// alertcondition(bton(short_sl and last_shortCondition > nz(last_short_close[1])), title='Stop Loss\n/// G-Channel Trend Detection\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//Full credit to AlexGrover: https://www.tradingview.com/script/fIvlS64B-G-Channels-Efficient-Calculation-Of-Upper-Lower-Extremit\n//indicator('G-Channel Trend Detection', shorttitle='G-Trend', overlay=true)\nlengthG = input(100, group=\"G-Channel Trend Detection\")\nsrc = input(ohlc4)\n//----\na = 0.\nb = 0.\na := math.max(src, nz(a[1])) - nz(a[1] - b[1]) / lengthG\nb := math.min(src, nz(b[1])) + nz(a[1] - b[1]) / lengthG\navg = math.avg(a, b)\n//----\ncrossup = b[1] < close[1] and b > close\ncrossdn = a[1] < close[1] and a > close\nbullish = ta.barssince(crossdn) <= ta.barssince(crossup)\ncG = bullish ?  color.lime :  color.red\n//plot(a,\"Upper\",color=color.blue,linewidth=2,transp=100)\n//plot(b,\"Lower\",color=color.blue,linewidth=2,transp=100)\np1 = plot(avg, 'Average', color=cG, linewidth=1, transp=100)\np2 = plot(close, 'Close price', color=cG, linewidth=1, transp=100)\nfill(p1, p2, color=cG, transp=90)\n//showcross = input(true)\n//plotshape(showcross and not bullish and bullish[1] ? avg : na, location=location.absolute, style=s\n//plotshape(showcross and bullish and not bullish[1] ? avg : na, location=location.absolute, style=s\nlongCondGTrend = bullish\nshortCondGTrend = not bullish\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\nlongCondition = longCondPOKI and longCondGTrend\nshortCondition = shortCondPOKI and shortCondGTrend\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = true , title = \"Average Directional Index (ADX)\",\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=2, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=9, minval=0.01, group=\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "Grid-based intraday algorithm that works 50% in trend following and 50% in swing trading. Orders are executed on a grid of 10 levels. The grid levels are dynamic and calculated on the difference between the previous day's open and close. The algorithm makes only long trades based on the following logic:  1. The daily close of the previous day is analyzed, the first condition is met if the previous day was bullish, closing higher than the 'opening.  2. Must pass 'x' number of bars before placing market orders. 3. The range, as the difference between close and open of the previous day must be greater than 'x'. If these three conditions are met then the algorithm will proceed to place long orders. On a total of 10 grid levels, up to five trades are executed per day.  If the current close is above level 1 of the grid (previous day's close) then trend following trading will take place, working on the upper 5 levels. In this case each order is placed starting at level 1 and closed at each level above. If the current close is below level 1 of the grid (previous day's open) then swing trading will be carried out, working on the lower 5 levels. In this case each order is placed starting at level 2 and closed at the upper level. If at the time of order execution the price is above or below the stop loss and take profit levels, the algorithm will cancel the orders and prevent trading.  All orders are closed exclusively for two reasons:  1. If the stop loss or take profit level is confirmed.  2. If the daily session is ended.  UI Interface You can adjust:  1. Backtesting period  2. 'x' number of bars before placing orders at the market (remember to always add 2 to the number you enter in the user interface if you enter 2 then execution will occur at the market opening after the fourth bar). 3. Intercepted price range between close and open of the previous day, avoiding trading on days when the range is too low.  4. Stop loss, level calculated from the 'last lower grid, if the market breaks this level the grid is destroyed and closes all open positions.  5. Take profit, the level calculated from the last upper grid, if the market breaks this level the grid is destroyed and closes all open positions.  The backtesting you see in the example was generated on: BTCUSDTTimeframe 15 min  Stop loss 2% Take profit 2% Minimum bars 3 Size grid range 500  This algorithm can be used only on intraday timeframe."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n//  \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \n//  \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551 \u2588\u2588\u2554\u255d    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551  \n//  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \n//  \u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551   \n//  \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \n                                                                                                    //@version=5\nstrategy(\n     title = 'Hulk Grid Algorithm - The Quant Science', \n     overlay = true,\n     initial_capital = 1000, \n     commission_type = strategy.commission.percent, \n     commission_value = 0.07, \n     pyramiding = 10,\n     default_qty_type = strategy.percent_of_equity\n     )\n// #################################################################################################\nif not timeframe.isintraday\n    runtime.error(\"WRONG TIMEFRAME: Please select an intraday timeframe when use this strategy backtesting.\"\n// #################################################################################################\nstartDate   = input.int(title=\"Start Date\", defval=1, minval=1, maxval=31, group =\nstartMonth  = input.int(title=\"Start Month\", defval=1, minval=1, maxval=12, group \nstartYear   = input.int(title=\"Start Year\", defval=2018, minval=1800, maxval=2100,\nendDate     = input.int(title=\"End Date\", defval=12, minval=1, maxval=31, group = \nendMonth    = input.int(title=\"End Month\", defval=3, minval=1, maxval=12, group = \nendYear     = input.int(title=\"End Year\", defval=2022, minval=1800, maxval=2100, group\ninDateRange = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\n// #################################################################################################\nrequestpastweekclose = request.security(syminfo.tickerid,  \"D\", close[1], gaps = barmerge.gaps_off\nrequestpastweekopen  = request.security(syminfo.tickerid,  \"D\", open[1],  gaps = barmerge.gaps_off\nnewday  = request.security(syminfo.tickerid,  \"D\", close,  gaps = barmerge.gaps_off\n// #################################################################################################\nten_grid        = input.bool(defval = false, title = \"Enable Strategy\", tooltip = \nstop_loss       = input.float(defval = 2.00, step = 0.10, title = \"Stop Loss: \", group\ntake_profit     = input.float(defval = 2.00, step = 0.10, title = \"Take Profit: \",\nperiod_num      = input.int(defval = 3, step = 1, title = \"Minimum Bars: \", group \nsize_grid       = input.float(defval = 200.00, step = 1.00, title = \"Size Grid Range: \"\n// #################################################################################################\nvar float high_start = 0 \nvar float high_end   = 0 \nchecking = requestpastweekclose > requestpastweekopen \nif checking==true\n    high_start := requestpastweekclose\n    high_end   := requestpastweekopen\ngrid_range = high_start - high_end\nperiod = ta.barssince(ta.change(checking==true))==period_num\nTriggerGrid() =>\n    trigger = checking==true and period and grid_range > size_grid and close \n    trigger\ntrigger_entry = TriggerGrid() \nvar float grid_1  = 0\nvar float grid_2  = 0\nvar float grid_3  = 0\nvar float grid_4  = 0\nvar float grid_5  = 0\nvar float grid_6  = 0\nvar float grid_7  = 0\nvar float grid_8  = 0\nvar float grid_9  = 0\nvar float grid_10 = 0\nvar float factor = 0 \nif ten_grid == true and trigger_entry==true and strategy.opentrades==0\n    factor := grid_range / 10\n    // UP GRID\n    grid_1  := (high_start) \n    grid_2  := (high_start + (factor * 1)) \n    grid_3  := (high_start + (factor * 2)) \n    grid_4  := (high_start + (factor * 3)) \n    grid_5  := (high_start + (factor * 4))\n    // DOWN GRID\n    grid_6  := (high_start - (factor * 1)) \n    grid_7  := (high_start - (factor * 2)) \n    grid_8  := (high_start - (factor * 3)) \n    grid_9  := (high_start - (factor * 4))\n    grid_10 := (high_start - (factor * 5))\n// #################################################################################################\nvar tb = table.new(position.bottom_left, 1, 1, bgcolor =  color.new(#00ff08, 74))\nif barstate.isfirst\n    table.cell(tb, 0, 0, \n      'Developed by The Quant Science\u2122'\n      ,text_size = size.normal\n      ,text_color =  color.new(#00ff08, 21))\n// #################################################################################################\nvar float new_ten_grid_1  = 0 \nvar float new_ten_grid_2  = 0 \nvar float new_ten_grid_3  = 0 \nvar float new_ten_grid_4  = 0 \nvar float new_ten_grid_5  = 0 \nvar float new_ten_grid_6  = 0 \nvar float new_ten_grid_7  = 0 \nvar float new_ten_grid_8  = 0 \nvar float new_ten_grid_9  = 0 \nvar float new_ten_grid_10 = 0 \nif ten_grid == true \n    new_ten_grid_1  := grid_1\n    new_ten_grid_2  := grid_2\n    new_ten_grid_3  := grid_3\n    new_ten_grid_4  := grid_4\n    new_ten_grid_5  := grid_5\n    new_ten_grid_6  := grid_6\n    new_ten_grid_7  := grid_7\n    new_ten_grid_8  := grid_8\n    new_ten_grid_9  := grid_9\n    new_ten_grid_10 := grid_10\nelse if ten_grid == false\n    new_ten_grid_1  := na\n    new_ten_grid_2  := na\n    new_ten_grid_3  := na\n    new_ten_grid_4  := na\n    new_ten_grid_5  := na\n    new_ten_grid_6  := na\n    new_ten_grid_7  := na\n    new_ten_grid_8  := na\n    new_ten_grid_9  := na\n    new_ten_grid_10 := na\ndestroyall = new_ten_grid_10 - (new_ten_grid_10 * stop_loss / 100)\ndes_function = ta.crossunder(close, destroyall)\ntakeprofitlevel = new_ten_grid_5 + (new_ten_grid_5 * take_profit / 100)\nvar float lots = 0 \nif trigger_entry==true and ten_grid==true and period and inDateRange\n    lots := (strategy.equity / close) / 5\n    if close > new_ten_grid_1\n        strategy.entry(id = \"O #1\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #2\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #3\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #4\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #5\",  direction = strategy.long, qty = lots, limit \n    if close < new_ten_grid_1\n        strategy.entry(id = \"O #6\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #7\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #8\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #9\",  direction = strategy.long, qty = lots, limit \n        strategy.entry(id = \"O #10\", direction = strategy.long, qty = lots, limit \n    if close > takeprofitlevel\n        strategy.cancel_all()\n    if close < destroyall\n        strategy.cancel_all()\nif new_ten_grid_2 and ten_grid == true\n    strategy.exit(id = \"C #1\", from_entry = \"O #1\", qty = 100, limit = new_ten_grid_2\nif new_ten_grid_3 and ten_grid == true\n    strategy.exit(id = \"C #2\", from_entry = \"O #2\", qty = 100, limit = new_ten_grid_3\nif new_ten_grid_4 and ten_grid == true\n    strategy.exit(id = \"C #3\", from_entry = \"O #3\", qty = 100, limit = new_ten_grid_4\nif new_ten_grid_5 and ten_grid == true\n    strategy.exit(id = \"C #4\", from_entry = \"O #4\", qty = 100, limit = new_ten_grid_5\nif takeprofitlevel and ten_grid == true\n    strategy.exit(id = \"C #5\", from_entry = \"O #5\", qty = 100, limit = takeprofitlevel\nif new_ten_grid_5 and ten_grid == true\n    strategy.exit(id = \"C #6\", from_entry = \"O #6\", qty = 100, limit = new_ten_grid_1\nif new_ten_grid_6 and ten_grid == true\n    strategy.exit(id = \"C #7\", from_entry = \"O #7\", qty = 100, limit = new_ten_grid_6\nif new_ten_grid_7 and ten_grid == true\n    strategy.exit(id = \"C #8\", from_entry = \"O #8\", qty = 100, limit = new_ten_grid_7\nif new_ten_grid_8 and ten_grid == true\n    strategy.exit(id = \"C #9\", from_entry = \"O #9\", qty = 100, limit = new_ten_grid_8\nif new_ten_grid_9 and ten_grid == true\n    strategy.exit(id = \"C #10\", from_entry = \"O #10\", qty = 100, limit = new_ten_grid_9\nif des_function \n    strategy.close_all(\"Destroyed Grid\")\n    strategy.cancel_all()\nif session.islastbar_regular\n    strategy.close_all(\"Dayli Session End\")\nif session.islastbar_regular\n    strategy.cancel_all()\n// #################################################################################################\nfill(plot(grid_1, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_2, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_2, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_3, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_3, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_4, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_4, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_5, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 90))\nfill(plot(grid_1, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_6, color =  color.new(color.rgb(0, 255, 132), 95)), \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_6, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_7, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 80))\nfill(plot(grid_7, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_8, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_8, color =  color.new(color.rgb(0, 255, 132), 95)),  \n     plot(grid_9, color =  color.new(color.rgb(0, 255, 132), 95)),  \n         color =  color.new(#00ff08, 85))\nfill(plot(grid_9, color =  color.new(color.rgb(0, 255, 132), 95)), \n     plot(grid_10, color =  color.new(color.rgb(0, 255, 132), 95)), \n         color =  color.new(#00ff08, 90))\n// #################################################################################################"}]}
{"messages": [{"role": "user", "content": "This is part of a new series we are calling \"Strategy Myth-Busting\" where we take open public manual trading strategies and automate them. The goal is to not only validate the authenticity of the claims but to provide an automated version for traders who wish to trade autonomously. Our fourth one we are automating is one of the strategies from \"I Found The Best 1 Minute Scalping Strategy That Actually Works! ( Beginner Friendly )\" from \"Trade Domination\" who claims to have made 366% profit on the 1 min chart of Solona despite having a 31% win rate in just a few weeks. As you can see from the backtest results below, I was unable to substantiate anything close to that that claim on the same symbol ( SOLUSD ), timeframe (1m) with identical instrument settings that \"Trade Domination\" was demonstrating with. Strategy Busted. If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me. This strategy uses a combination of 2 open-source public indicators: LSMA Hull Suite by InSilico Trading Rules 1 min candles Stop Loss on recent swing High/Low 1:5 Risk Ratio Enter Long LSMA cross above Red Hull Suite line Price has to be above Hull Suite Line Enter Short LSMA crosses under green Hull Suite Line Price has to be below Hull Suite Line"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #4 - LSMA+HULL Crossover - [MYN]', max_bars_back=5000\n///Derek-Multiple-Take-Profit-Strategy-Template-v5-2022-04-03.pine\n// 04-03-2022 Added ADX \n// 08-17-2022 Added Dashboard\nf_security(_symbol, _res, _src, _repaint) => request.security(_symbol, _res, _src[\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n//LSMA - Thicken Line and change to white\n//Hull Suite by InSilico /  Disable show as band.  Make line bolder\n//Trading Rules\n// Enter Long\n// LSMA cross above Red Hull Suite line\n// Price has to be above Hull Suite Line\n// 1:5 Risk Ratio.\n// Stop Loss is recent swing low\n// Take Profit is 5x the risk\n// Enter Short\n// LSMA crosses under green Hull Suite Line\n// Price has to be below Hull Suite Line\n// 1:5 Risk Ratio.\n// Stop Loss is recent swing high\n// Take Profit is 5x The risk\n// Least Squares Moving Average\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//indicator(title = \"Least Squares Moving Average\", shorttitle=\"LSMA\", overlay=true, timeframe=\"\", t\nlength = input(title=\"Length\", defval=25, group=\"LSMA\")\noffset = input(title=\"Offset\", defval=0)\nsrc = input(close, title=\"Source\")\nlsma = ta.linreg(src, length, offset)\nplot(lsma, color= color.white, linewidth=4)\n// Hull Suite by InSilico\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//@version=5\n//Basic Hull Ma Pack tinkered by InSilico \n//indicator('Hull Suite by InSilico', overlay=true)\n//INPUT\nsrcHull = input(close, title='Source', group=\"Hull Suite\")\nmodeSwitch = input.string('Hma', title='Hull Variation', options=['Hma', 'Thma', 'Ehma'\nlengthHull = input(55, title='Length(180-200 for floating S/R , 55 for swing entry)'\nlengthMult = input(1.0, title='Length multiplier (Used to view higher timeframes with straight band)'\nuseHtf = input(false, title='Show Hull MA from X timeframe? (good for scalping)')\nhtf = input.timeframe('240', title='Higher timeframe')\nswitchColor = input(true, 'Color Hull according to trend?')\ncandleCol = input(false, title='Color candles based on Hull\\'s Trend?')\nvisualSwitch = input(false, title='Show as a Band?')\nthicknesSwitch = input(4, title='Line Thickness')\ntranspSwitch = input.int(40, title='Band Transparency', step=5)\n//FUNCTIONS\n//HMA\nHMA(_src, _length) =>\n    ta.wma(2 * ta.wma(_src, _length / 2) - ta.wma(_src, _length), math.round(math.sqrt\n//EHMA    \nEHMA(_src, _length) =>\n    ta.ema(2 * ta.ema(_src, _length / 2) - ta.ema(_src, _length), math.round(math.sqrt\n//THMA    \nTHMA(_src, _length) =>\n    ta.wma(ta.wma(_src, _length / 3) * 3 - ta.wma(_src, _length / 2) - ta.wma(_src\n//SWITCH\nMode(modeSwitch, srcHull, len) =>\n    modeSwitch == 'Hma' ? HMA(srcHull, len) : modeSwitch == 'Ehma' ? EHMA(srcHull,\n//OUT\n_hull = Mode(modeSwitch, srcHull, int(lengthHull * lengthMult))\nHULL = useHtf ? f_security(syminfo.ticker, htf, _hull,false) : _hull\nMHULL = HULL[0]\nSHULL = HULL[2]\n//COLOR\nhullColor = switchColor ? HULL > HULL[2] ?  #00ff00 :  #ff0000 :  #ff9800\n//PLOT\n///< Frame\nFi1 = plot(MHULL, title='MHULL', color=hullColor, linewidth=thicknesSwitch, transp\nFi2 = plot(visualSwitch ? SHULL : na, title='SHULL', color=hullColor, linewidth=thicknesSwitch\nalertcondition(ta.crossover(MHULL, SHULL), title='Hull trending up.', message='Hull trending up.'\nalertcondition(ta.crossover(SHULL, MHULL), title='Hull trending down.', message='Hull trending down.'\n///< Ending Filler\nfill(Fi1, Fi2, title='Band Filler', color=hullColor, transp=transpSwitch)\n///BARCOLOR\nbarcolor(color=candleCol ? switchColor ? hullColor : na : na)\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\n//o0wqgXG6jgI \n/// Enter Long\n// LSMA cross above Red Hull Suite line\n// Price has to be above Hull Suite Line\nenterLong = ta.crossover(lsma, HULL) and hullColor ==  #ff0000 and srcHull > HULL\n// Enter Short\n// LSMA crosses under green Hull Suite Line\n// Price has to be below Hull Suite Line\nenterShort = ta.crossunder(lsma,HULL) and hullColor ==  #00ff00 and srcHull < HULL\nlongCondition = enterLong\nshortCondition = enterShort\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// ADX\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nadxEnabled = input.bool(defval = false , title = \"Average Directional Index (ADX)\"\nadxlen = input(14, title=\"ADX Smoothing\", group=\"ADX\")\nadxdilen = input(14, title=\"DI Length\", group=\"ADX\")\nadxabove = input(25, title=\"ADX Threshold\", group=\"ADX\")\nadxdirmov(len) =>\n    adxup = ta.change(high)\n    adxdown = -ta.change(low)\n    adxplusDM = na(adxup) ? na : (adxup > adxdown and adxup > 0 ? adxup : 0)\n    adxminusDM = na(adxdown) ? na : (adxdown > adxup and adxdown > 0 ? adxdown : 0\n    adxtruerange = ta.rma(ta.tr, len)\n    adxplus = fixnan(100 * ta.rma(adxplusDM, len) / adxtruerange)\n    adxminus = fixnan(100 * ta.rma(adxminusDM, len) / adxtruerange)\n    [adxplus, adxminus]\nadx(adxdilen, adxlen) =>\n    [adxplus, adxminus] = adxdirmov(adxdilen)\n    adxsum = adxplus + adxminus\n    adx = 100 * ta.rma(math.abs(adxplus - adxminus) / (adxsum == 0 ? 1 : adxsum), \nadxsig = adxEnabled ? adx(adxdilen, adxlen) : na\nisADXEnabledAndAboveThreshold = adxEnabled ? (adxsig > adxabove) : true\n//Backtesting Time Period (Input.time not working as expected as of 03/30/2021.  Giving odd start/en\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nuseStartPeriodTime = input.bool(true, 'Start', group='Date Range', inline='Start Period'\nstartPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\nuseEndPeriodTime = input.bool(true, 'End', group='Date Range', inline='End Period'\nendPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nstart = useStartPeriodTime ? startPeriodTime >= time : false\nend = useEndPeriodTime ? endPeriodTime <= time : false\ncalcPeriod = not start and not end\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntradeDirection = input.string('Long and Short', title='Trade Direction', options=[\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp1 = input.float(title='Take Profit 1 - Target %', defval=100, minval=0.0, step=0.5\nq1 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp2 = input.float(title='Take Profit 2 - Target %', defval=100, minval=0.0, step=0.5\nq2 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp3 = input.float(title='Take Profit 3 - Target %', defval=100, minval=0.0, step=0.5\nq3 = input.int(title='% Of Position', defval=100, minval=0, group='Take Profit', inline\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ntp4 = input.float(title='Take Profit 4 - Target %', defval=100, minval=0.0, step=0.5\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nstoplossPercent = input.float(title='Stop Loss (%)', defval=999, minval=0.01, group\nslLongClose = close < strategy.position_avg_price * (1 - stoplossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + stoplossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nleverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nalertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXEnabledAndAboveThreshold)\nshortConditionCalc = (shortCondition and isADXEnabledAndAboveThreshold)\nif calcPeriod\n    if longConditionCalc and tradeDirection != 'Short Only' and isInLongPosition ==\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and tradeDirection != 'Long Only' and isInShortPosition \n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=q1, profit=per(tp1))\n    strategy.exit('TP2', qty_percent=q2, profit=per(tp2))\n    strategy.exit('TP3', qty_percent=q3, profit=per(tp3))\n    strategy.exit('TP4', profit=per(tp4))\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    strategy.close_all(when=closeLongCondition or closeShortCondition, comment='Close Postion'\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "This script is an advanced trading strategy that combines the use of Bollinger Bands, Relative Strength Index (RSI) and Moving Average Convergence Divergence (MACD) indicators to make buy and sell decisions. The script first plots the Bollinger Bands on the chart, with the upper and lower bands of two different standard deviations (1st and 2nd StdDev) outlined with two different colors. The strategy then uses the Bollinger Bands to enter long positions when the closing price crosses above the upper band and enter short positions when the closing price crosses below the lower band. The strategy also uses the RSI and MACD indicators as additional confirmation for buy and sell decisions. The script uses RSI to confirm long entry when RSI crosses above 70 and short entry when RSI crosses below 30. The script uses MACD to confirm long entry when the MACD crosses above the signal line and short entry when the MACD crosses below the signal line. The script also includes code for exiting positions based on different conditions. Long positions are closed when RSI crosses below 50 or the closing price crosses below the middle band of the Bollinger Bands, short positions are closed when RSI crosses above 50 or the closing price crosses above the middle band of the Bollinger Bands. Overall, this script is a comprehensive trading strategy that incorporates multiple technical indicators for making buy and sell decisions and managing positions."}, {"role": "assistant", "content": "//@version=5\n// Bollinger Bands: Madrid : 14/SEP/2014 11:07 : 2.0\n// This displays the traditional Bollinger Bands, the difference is \n// that the 1st and 2nd StdDev are outlined with two colors and two\n// different levels, one for each Standard Deviation\nstrategy(shorttitle='MBB', title='Bollinger Bands', overlay=true, currency=currency.NONE\nsrc = input(close)\nlength = input.int(34, minval=1)\nmult = input.float(2.0, minval=0.001, maxval=50)\nbasis = ta.sma(src, length)\ndev = ta.stdev(src, length)\ndev2 = mult * dev\nupper1 = basis + dev\nlower1 = basis - dev\nupper2 = basis + dev2\nlower2 = basis - dev2\ncolorBasis = src >= basis ?  color.blue :  color.orange\npBasis = plot(basis, linewidth=2, color=colorBasis)\npUpper1 = plot(upper1, color= color.new(color.blue, 0), style=plot.style_circles)\npUpper2 = plot(upper2, color= color.new(color.blue, 0))\npLower1 = plot(lower1, color= color.new(color.orange, 0), style=plot.style_circles\npLower2 = plot(lower2, color= color.new(color.orange, 0))\nfill(pBasis, pUpper2, color= color.new(color.blue, 80))\nfill(pUpper1, pUpper2, color= color.new(color.blue, 80))\nfill(pBasis, pLower2, color= color.new(color.orange, 80))\nfill(pLower1, pLower2, color= color.new(color.orange, 80))\n//Strategy code starts here\nlong_entry = ta.crossover(src, upper1)\nshort_entry = ta.crossunder(src, lower1)\nstrategy.entry(\"Long\", strategy.long, when=long_entry)\nstrategy.entry(\"Short\", strategy.short, when=short_entry)\nif long_entry or close < basis\n    strategy.close(\"Long\", \"Long\") \nif short_entry or close > basis\n    strategy.close(\"Short\", \"Short\") \n//Calculate RSI\nrsiLength = input(14)\nrsiValue = ta.rsi(src, rsiLength)\n// Define RSI conditions for entering and exiting trades\nrsiLong = rsiValue > 70\nrsiShort = rsiValue < 30\n//Enter long position when RSI crosses above 50 and Bollinger Bands long entry condition is met\nstrategy.entry(\"Long\", strategy.long, when=long_entry and rsiLong)\n//Exit long position when RSI crosses below 50 or Bollinger Bands exit condition is met\nstrategy.close(\"Long Exit\", when=rsiShort or close < basis)\n//Enter short position when RSI crosses below 50 and Bollinger Bands short entry condition is met\nstrategy.entry(\"Short\", strategy.short, when=short_entry and rsiShort)\n//Exit short position when RSI crosses above 50 or Bollinger Bands exit condition is met\nstrategy.close(\"Short Exit\", when=rsiLong or close > basis)\n//Calculate MACD\nfastLength = input(12)\nslowLength = input(26)\nmacdLength = input(9)\nmacdValue = ta.macd(src, fastLength, slowLength, macdLength)\n// Define MACD conditions for entering and exiting trades\nmacdLong = ta.crossover(src, macdLength)\nmacdShort = ta.crossunder(src, macdLength)\n//Enter long position when MACD crosses above signal line and RSI and Bollinger Bands long entry con\nstrategy.entry(\"Long\", strategy.long, when=long_entry and rsiLong and macdLong)\n//Exit long position when MACD crosses below signal line or RSI crosses below 50 or Bollinger Bands \nstrategy.close(\"Long Exit\", when=macdShort or rsiShort or close < basis)\n//Enter short position when MACD crosses below signal line and RSI crosses below 50 and Bollinger Ba\nstrategy.entry(\"Short\", strategy.short, when=short_entry and rsiShort and macdShort\n//Exit short position when MACD crosses above signal line or RSI crosses above 50 or Bollinger Bands\nstrategy.close(\"Short Exit\", when=macdLong or rsiLong or close > basis)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Fixed minor bug, which affected Flying Dragon Trend Indicator not showing indicator symbol on Lowest risk level. As Strategy shares the same code base, the fix was implemented also in Strategy code even though Strategy was not broken.                                                    Release Notes:                                                    Updated the chart only.                                                    Release Notes:                                                    Alert function and pivot indicators added. Alerts are enabled when indicators are on. Create Alert on selected equity and timeframe, select on Condition this strategy and alert criteria (for example: Alert () function calls only), Create."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 MarkoP010 2023\n//@version=5\n//The basic idea of the strategy is to select the best set of MAs, types, lenghts and offsets, which\n//Strategy executes by selected risk level either when there is MA crossover with price (Leading MA \n//Strategy plots user selectable Moving Average lines, a colored trend band between the MA lines and\n//The Offset option shifts the selected MA with the set number of steps to the right. That is where \n//Strategy version history:\n//Version 1 - Initial script\n//Version 2 - Bug fix for Lowest risk level to show the indicator\n//Version 3 - Updated graph picture\n//Version 4 - Alert function and pivot indicators added, alerts are enabled when indicators are on. \nstrategy(\"Flying Dragon Trend Strategy\", shorttitle=\"Flying Dragon Trend Strategy\"\n//Moving Averages function\nMA(source, length, type) =>\n    type == \"EMA\" ? ta.ema(source, length) :\n     type == \"HMA\" ? ta.hma(source, length) :\n     type == \"RMA\" ? ta.rma(source, length) :\n     type == \"SMA\" ? ta.sma(source, length) :\n     type == \"SWMA\" ? ta.swma(source) :\n     type == \"VWMA\" ? ta.vwma(source, length) :\n     type == \"WMA\" ? ta.wma(source, length) :\n     na\n//Strategy options\nstrDirection = input.string(defval=\"Both\", title=\"Strategy Direction\", options=[\"Both\"\nstrSelection = strDirection == \"Long\" ? strategy.direction.long : strDirection == \nstrategy.risk.allow_entry_in(strSelection)\nriskLevel = input.string(defval=\"Medium\", title=\"Risk Level\", options=[\"Highest\", \nindicatorsOn = input(defval=true, title=\"Indicators\", inline=\"Options\", tooltip=\"Turn on or off pivot indicators. Strategy executi\nuseStop = input(defval=false, title=\"Use Stop Loss\", inline=\"SL\", group=\"Strategy Options\"\nstopPrct = input.int(defval=10, title=\" %\", minval=0, maxval=100, step=1, inline=\"SL\"\n//Inputs\nma1Type = input.string(defval=\"HMA\", title=\"\", inline=\"MA1\", options=[\"EMA\", \"HMA\"\nma1Length = input.int(defval=35, title=\"\",minval=1, inline=\"MA1\", group=\"Leading Moving Average\"\nma1Source = input(defval=close, title=\"\", tooltip=\"For short timeframes, minutes to hours, instead o\nma1Color  = input(defval= color.purple, title=\"\", inline=\"MA-1\", group=\"Leading Moving Average\"\nma1Offset = input.int(defval=0, title=\"Offset1 Steps\", minval=0, maxval=10, step=1\nma1 = MA(ma1Source, ma1Length, ma1Type)[ma1Offset]\nma2Color  = input(defval= color.lime, title=\"\", inline=\"MA-2\", group=\"Leading Moving Average\"\nma2Offset = input.int(defval=4, title=\"Offset2 Steps\", minval=0, maxval=10, step=1\nma2 = ma1[ma2Offset]\nma3Color  = input(defval= color.aqua, title=\"\", inline=\"MA-3\", group=\"Leading Moving Average\"\nma3Offset = input.int(defval=6, title=\"Offset3 Steps\", minval=0, maxval=10, step=1\nma3 = ma1[ma3Offset]\nma4Type = input.string(defval=\"SMA\", title=\"\", inline=\"MA4\", options=[\"EMA\", \"HMA\"\nma4Length = input.int(defval=22, title=\"\",minval=1, inline=\"MA4\", group=\"Lagging Moving Average\"\nma4Source = input(defval=close, title=\"\", inline=\"MA4\", group=\"Lagging Moving Average\"\nma4Color  = input(defval= color.yellow, title=\"\", inline=\"MA-4\", group=\"Lagging Moving Average\"\nma4Offset = input.int(defval=2, title=\"Offset Steps\", minval=0, maxval=10, step=1,\nma4 = MA(ma4Source, ma4Length, ma4Type)[ma4Offset]\nbandTransp = input.int(defval=60, title=\"Band Transparency\", minval=20, maxval=80,\nuseBand1 = input(defval=true, title=\"Band 1\", inline=\"Band\", group=\"Banding\")\nband1Transp = useBand1 ? bandTransp : 100\nband1clr = ma1 > ma2 ? color.new( #00ff00, transp=band1Transp) : color.new( #ff0000\nuseBand2 = input(defval=true, title=\"Band 2\", inline=\"Band\", group=\"Banding\")\nband2Transp = useBand2 ? bandTransp : 100\nband2clr = ma1 > ma3 ? color.new( #00ff00, transp=band2Transp) : color.new( #ff0000\nuseBand3 = input(defval=true, title=\"Band 3\", tooltip=\"Up trend green, down trend red. Colors get revers\nband3Transp = useBand3 ? bandTransp : 100\nband3clr = ma1 > ma4 ? color.new( #00ff00, transp=band3Transp) : color.new( #ff0000\n//Graphs\npiirto1 = plot(ma1, color = ma1Color, title=\"MA1\")\npiirto2 = plot(ma2, color = ma2Color, title=\"MA2\")\npiirto3 = plot(ma3, color = ma3Color, title=\"MA3\")\npiirto4 = plot(ma4, color = ma4Color, title=\"MA4\")\nfill(piirto1, piirto2, color=band1clr)\nfill(piirto1, piirto3, color=band2clr)\nfill(piirto1, piirto4, color=band3clr)\n//Strategy entry and stop conditions, indicator plot conditions\nlongCondition = riskLevel == \"Highest\" ? ma1Source > ma1 : riskLevel == \"High\" ? ma1Source\nshortCondition = riskLevel == \"Highest\" ? ma1Source < ma1 : riskLevel == \"High\" ? \npivotUp = longCondition and shortCondition[1] and indicatorsOn ? true : na\npivotDown = shortCondition and longCondition[1] and indicatorsOn ? true : na\nplotshape(pivotUp, title=\"Up\", style=shape.triangleup, location=location.belowbar,\nplotshape(pivotDown, title=\"Down\", style=shape.triangledown, location=location.abovebar\nstopLprice = useStop == true ? strategy.position_avg_price * (1-stopPrct) : na\nstopSprice = useStop == true ? strategy.position_avg_price * (1+stopPrct) : na\nif longCondition\n    strategy.entry(\"Long\",strategy.long)\n    strategy.exit(\"Long Stop\", \"Long\", stop=stopLprice)    \nif shortCondition\n    strategy.entry(\"Short\",strategy.short)\n    strategy.exit(\"Short Stop\", \"Short\", stop=stopSprice)\n//Alerts\nif pivotUp\n    alertMessage = syminfo.ticker + ' - ' + timeframe.period + \": Pivot Up!\"\n    alert(alertMessage, alert.freq_once_per_bar_close)\nif pivotDown\n    alertMessage = syminfo.ticker + ' - ' + timeframe.period + \": Pivot Down!\"\n    alert(alertMessage, alert.freq_once_per_bar_close)\n//End"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    - Fixed some small bugs. - Fixed multiple orders on same bar (on big pums/dumps) - Added RSI TF filter (you can use two RSIs with different TF or settings) - Added MFI TF filter  - Added CCI TF filter  - Updated ATR volatility filer - Added option to Enable/Disable visualisation of TP/SL on chart Article with main settings for this strategy is added to my site (see link below)."}, {"role": "assistant", "content": "// Based on Channels Strategy [JoseMetal]\n// Edited by Dimkud\n//@version=5\nstrategy(\"Channels Strategy [Dimkud]\", overlay=true, calc_on_order_fills=true, use_bar_magnifier\n// DIMAK  Static SL/TP - Begin\nGRUPO_statSLTP = \"Static SL/TP\"\nUSEdisplTPSL =  input(defval=false, title='Display Visualisation for TP/SL ?', group\n// Make inputs that set the take profit % (optional)\nvar longProfitPerc = input.float(defval=2.6, title=\"Take Profit (%)\", group=GRUPO_statSLTP\nvar shortProfitPerc = longProfitPerc\nvar longSLPerc = input.float(defval=1.3, title=\"Stop Loss (%)\", group=GRUPO_statSLTP\nvar shortSLPerc = longSLPerc\n// Figure out take profit price  (placed after strategy.entry(\"Abrir Long\", strategy.long) )\nlongExitPrice  = strategy.position_avg_price * (1 + longProfitPerc)\nshortExitPrice = strategy.position_avg_price * (1 - shortProfitPerc)\nlongSLExitPrice  = strategy.position_avg_price * (1 - longSLPerc)\nshortSLExitPrice = strategy.position_avg_price * (1 + shortSLPerc)\n// use tak: limit=shortExitPrice, stop=shortSLExitPrice\nSendSLsingonReal =  input(defval=false, title='Send SL alerts on Real Trading ?', \n// DIMAK  Static SL/TP - END\n// Time filter =================================\ntestPeriod() =>\n    // Testing Start dates\n    grTIME = \"============Time Filter (use for Tests)===============\"\n    testStartYear = input.int(2022, 'Start Year', inline='date1', group=grTIME)\n    testStartMonth = input.int(5, '', inline='date1', group=grTIME)\n    testStartDay = input.int(1, '', inline='date1', group=grTIME)\n    testPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0)\n    //Stop date if you want to use a specific range of dates\n    testStopYear = input.int(2030, 'Stop Year', inline='date2', group=grTIME)\n    testStopMonth = input.int(12, '', inline='date2', group=grTIME)\n    testStopDay = input.int(30, '', inline='date2', group=grTIME)\n    testPeriodStop = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)\n    //time >= testPeriodStart and time < testPeriodStop ? true : false\n    // pass some date\n    testPeriodStop2 =  timestamp(2022,11,7,0,0)\n    testPeriodStop3 =  timestamp(2022,11,9,0,0)\n    (time >= testPeriodStart) and (time < testPeriodStop) and ((time < testPeriodStop2\n// Time filter =================================\n// Two ATR (Volatility Check)\ngrDATR=\"=======Two ATR (Volatility Check) Base Settings=========\"\n//useDATR = input(defval=false, title='Use Two ATR (Volatility Check) ?', group = grDATR)\nlengthDATR = input.int(title='ATR length1 (20)(5)', defval=20, minval=1, group = grDATR\nlength2DATR = input.int(title='ATR length2 (100)(20)', defval=100, minval=1, group\nsmoothingDATR = input.string(title='ATR Smoothing', defval='WMA', options=['RMA', \nDATR_ma_function(sourceDATR, lengthDATR1) =>\n    if smoothingDATR == 'RMA'\n        ta.rma(sourceDATR, lengthDATR1)\n    else\n        if smoothingDATR == 'SMA'\n            ta.sma(sourceDATR, lengthDATR1)\n        else\n            if smoothingDATR == 'EMA'\n                ta.ema(sourceDATR, lengthDATR1)\n            else // WMA\n                ta.wma(sourceDATR, lengthDATR1)\ndatr1 = DATR_ma_function(ta.tr(true), lengthDATR)\ndatr2 = DATR_ma_function(ta.tr(true), length2DATR)\n// ATR Histograme\ndatr_hist = datr1-datr2\n//plot(datr1+0.4, title='ATR', color=color.new(#77C5E1, 0))\n//plot(datr2+0.4, title='ATR', color=color.new(#FF5252, 0))\n//plot(datr_hist, color=color.red, style=plot.style_histogram)\n// block for filters \"ATR1 < ATR2\" BEGIN\n// \"ATR1 < ATR2 - Volatility is Small in last bars, ATR1 > ATR2 - Volatility is High in last bars\"\ngrATR1ATR2 = \"=============== Two ATR (ATR1 <> ATR2)==============\"\nuse_atr1toart2_more_less = input(defval=false, title='Use ATR1 <> ATR2 ? ', group \natr1toart2_more_less = input.string(title='ATR1 to ATR2', defval='ATR1 < ATR2', options\ndatr1todatr3 = use_atr1toart2_more_less and (atr1toart2_more_less == \"ATR1 < ATR2\"\nlongCondition2 = true\nshortCondition2 = true\nif use_atr1toart2_more_less\n    longCondition2 := false\n    shortCondition2 := false\n       longCondition2 := datr1todatr3\n    shortCondition2 := longCondition2 \nelse\n    longCondition2 := true\n    shortCondition2 := true\n// shortCondition2 and longCondition2 is if Fast ATR Must be higher (or Lower) than Slow ATR !!!\n// block for filters \"ATR1 < ATR2\" END\n// ==========================================================================\n// NOTE \"ATR1 < ATR2\" and ( Barssince_Highest/Lowest + falling/rising ) are working separately. But \n// ==========================================================================\n// ========== Two Average True Range ===============================\nc_verde_radiactivo =  color.rgb(0, 255, 0, 0)\nc_verde            =  color.rgb(0, 128, 0, 0)\nc_verde_oscuro     =  color.rgb(0, 80, 0, 0)\nc_rojo_radiactivo  =  color.rgb(255, 0, 0, 0)\nc_rojo             =  color.rgb(128, 0, 0, 0)\nc_rojo_oscuro      =  color.rgb(80, 0, 0, 0)\nnoneColor          =  color.new(color.white, 100)\n// GRUPO_per_pruebas = \"Tests period\"\n// fecha_inicio     = input.time(0, \"Start date\", group=GRUPO_per_pruebas) \n// fecha_fin_usar   = input.bool(false, \"Finish date\", group=GRUPO_per_pruebas, inline=\"fecha_finali\n// fecha_fin        = input.time(timestamp(\"1 Jan 2022\"), \"\", group=GRUPO_per_pruebas, inline=\"fecha\n// vela_en_fecha    = time >= fecha_inicio and (fecha_fin_usar ? time <= fecha_fin : true)\nposicion_abierta = strategy.position_size != 0\nLONG_abierto     = strategy.position_size > 0\nSHORT_abierto    = strategy.position_size < 0\n//== Strategy entry and exit conditions\nGRUPO_P           = \"Main Channel Settings\"\nP_indicador       = input.string(\"Keltner Channel\", \"Indicator\", [\"Bollinger Bands\"\nP_permitir_LONGS  = input.bool(title=\"Use LONGS ?\", group=GRUPO_P, defval=true)\nP_permitir_SHORTS = input.bool(title=\"Use SHORTS ?\", group=GRUPO_P, defval=false)\nP_cond_entrada    = input.string(\"Wick out of band\", \"Enter Condition\", [\"Wick out of band\"\nGRUPO_TPSL       = \"Stop Loss and Take Profit\"\nTP_SL_tipo_SL    = input.string(\"useStaticSLTP\", \"Stop Loss Type\", options=[\"Previous Wick\"\nTP_SL_tipo_TP    = input.string(\"useStaticSLTP\",  \"Take Profit Type\", options=[\"Opposite Band\"\nTPSL_SL_ATR_mult = input.float(title=\"\u2022 (Solo ATR) Multiplicador Stop Loss\", group\nTPSL_TP_ATR_mult = input.float(title=\"\u2022 (Solo ATR) Multiplicador Take Profit\", group\nTPSL_SL_BB_dev   = input.float(title=\"\u2022 (Solo STOP LOSS con BB) Desviaci\u00f3n est\u00e1ndar\"\nTPSL_SL_KC_mult  = input.float(title=\"\u2022 (Solo STOP LOSS con KC) Multiplicador\", group\nTP_SL_TP_dinamico = input.bool(title=\"Take Profit din\u00e1mico\", group=GRUPO_TPSL, defval\nGRUPO_KC  = \"Keltner Channel\"\nKC_length = input.int(title=\"Keltner Long.\", group=GRUPO_KC, defval=14, minval=1, \nKC_mult   = input.float(title=\"Keltner Mult.\", group=GRUPO_KC, defval=1.5, minval=\n[KC_mid, KC_upper, KC_lower]  = ta.kc(close, KC_length, KC_mult, true)\n[_, KC_upper_SL, KC_lower_SL] = ta.kc(close, KC_length, TPSL_SL_KC_mult, true)\nGRUPO_BB  = \"Bollinger Bands\"\nBB_length = input.int(title=\"BB Long. \", group=GRUPO_BB, defval=20, minval=1, inline\nBB_dev   = input.float(title=\"BB Deviation (Desv.)\", group=GRUPO_BB, defval=2.0, minval\n[BB_mid, BB_upper, BB_lower]  = ta.bb(close, BB_length, BB_dev)\n[_, BB_upper_SL, BB_lower_SL] = ta.bb(close, BB_length, TPSL_SL_BB_dev)\n// dimak KC timeframe\n// NOT USED\n// GRUPO_KC_TF  = \"Keltner Channel - Multi TimeFrame\"\n// useTF_KC   = input.bool(false, \"Use KC TimeFrame\", group=GRUPO_KC_TF) \n// KC_TF_length = input.int(title=\"Keltner TF Long:\", group=GRUPO_KC_TF, defval=20, minval=1, inline\n// KC_TF_mult   = input.float(title=\"Keltner TF Mult:\", group=GRUPO_KC_TF, defval=2, minval=0.01, st\n// tf_indicator = input.timeframe(title=\"KC TimeFrame:\", defval = '', group=GRUPO_KC_TF, inline = \"0\n// //EMAi   = ta.ema(close, KC_TF_length)\n// [Keltmiddle, Keltupper, Keltlower] = ta.kc(close, KC_TF_length, KC_TF_mult)\n// KC_TF_upper  = request.security(syminfo.tickerid, tf_indicator, Keltupper, gaps=barmerge.gaps_off\n// KC_TF_lower  = request.security(syminfo.tickerid, tf_indicator, Keltlower, gaps=barmerge.gaps_off\n// //KC_TF_mid = request.security(syminfo.tickerid, tf_indicator, EMAi, gaps=barmerge.gaps_off)\n// // =================================================================\n// longCondition3  = true\n// shortCondition3 = true\n// if (useTF_KC)\n//     longCondition3  := false\n//     shortCondition3 := false\n//     if (P_cond_entrada == \"Mecha fuera de la banda\")\n//         longCondition3  :=  low < KC_TF_lower\n//         shortCondition3 :=  high > KC_TF_upper\n//     else if (P_cond_entrada == \"Mecha fuera de la banda y luego cierre dentro\")\n//         longCondition3  := low[1] < KC_TF_lower and close > KC_TF_lower\n//         shortCondition3 := high[1] > KC_TF_upper and close < KC_TF_upper\n//     else if (P_cond_entrada == \"Cierre fuera de la banda\")\n//         longCondition3  := close < KC_TF_lower\n//         shortCondition3 := close > KC_TF_upper\n//     else // Cierre fuera de la banda y luego cierre dentro\n//         longCondition3  := close[1] < KC_TF_lower and close > KC_TF_lower\n//         shortCondition3 := close[1] > KC_TF_upper and close < KC_TF_upper\n// else \n//     longCondition3  := true\n//     shortCondition3 := true\n// // KC TF\n// plot(KC_TF_upper, \"Banda superior\", color.rgb(3, 81, 92))\n// //plot(KC_TF_mid, \"Media m\u00f3vil\", color.rgb(192, 122, 17))\n// plot(KC_TF_lower, \"Banda inferior\", color.rgb(3, 81, 92))\n// ===============dimak KC timeframe ================  END\n//== Inputs de indicadores\n// ATR\nGRUPO_ATR      = \"ATR (only for ATR SL/TP)\"\n//ATR_referencia = input.source(title=\"ATR Reference\", group=GRUPO_ATR, defval=close, inline=\"atr_ca\nATR_referencia = close\nATR_length     = input.int(title=\"ATR Length\", group=GRUPO_ATR, defval=7, minval=1\nATR            = ta.atr(ATR_length)\nATR_sl         = ATR * TPSL_SL_ATR_mult\nATR_tp         = ATR * TPSL_TP_ATR_mult\nATR_LONG_sl    = ATR_referencia - ATR_sl // Conversely, the lower one can be used as STOP L\nATR_LONG_tp    = ATR_referencia + ATR_tp // The ATR on the candles can be used as TAKE PROF\nATR_SHORT_sl   = ATR_referencia + ATR_sl // \"\"\nATR_SHORT_tp   = ATR_referencia - ATR_tp // For Shorts it's the other way around\n//== Calculation of conditions\n// Assign common variables based on the selected indicator\nbanda_superior = BB_upper\nmedia_movil    = BB_mid\nbanda_inferior = BB_lower\nbanda_extendida_sup_SL = BB_upper_SL\nbanda_extendida_inf_SL = BB_lower_SL\nif (P_indicador == \"Keltner Channel\")\n    banda_superior := KC_upper\n    media_movil    := KC_mid\n    banda_inferior := KC_lower\n    banda_extendida_sup_SL := KC_upper_SL\n    banda_extendida_inf_SL := KC_lower_SL\n// Calcular condiciones de entrada\nlongCondition1  = false\nshortCondition1 = false\nif (P_cond_entrada == \"Wick out of band\")\n    longCondition1  := low < banda_inferior\n    shortCondition1 := high > banda_superior\nelse if (P_cond_entrada == \"Wick out of the band then close in\")\n    longCondition1  := low[1] < banda_inferior and close > banda_inferior\n    shortCondition1 := high[1] > banda_superior and close < banda_superior\nelse if (P_cond_entrada == \"Out-of-band closure\")\n    longCondition1  := close < banda_inferior\n    shortCondition1 := close > banda_superior\nelse // Close out of the band then close in\n    longCondition1  := close[1] < banda_inferior and close > banda_inferior\n    shortCondition1 := close[1] > banda_superior and close < banda_superior\n//== Entrada (deben cumplirse todas para entrar)\n//==================================================================================\n//======Dimak Delay ======================================================================\ni_qtyTimeUnits  = - input.float(1, \"Delay between orders:\", inline = \"1\", minval =\ni_timeUnits     = input.string(\"minutes\", \"\", inline = \"1\", options = [\"seconds\", \nuseDelay   = input.bool(false, \"UseDelay\", group=\"Time_Delay\") \n// \u2014\u2014\u2014\u2014\u2014 Converts current chart timeframe into a float minutes value.\nf_tfInMinutes() => \n    _tfInMinutes = timeframe.multiplier * (\n      timeframe.isseconds ? 1. / 60             :\n      timeframe.isminutes ? 1.                  :\n      timeframe.isdaily   ? 60. * 24            :\n      timeframe.isweekly  ? 60. * 24 * 7        :\n      timeframe.ismonthly ? 60. * 24 * 30.4375  : na)\nf_timeFrom(_from, _qty, _units) =>\n    int _timeFrom = na\n    // Remove any \"s\" letter in the _units argument, so we don't need to compare singular and plural uni\n    _unit = str.replace_all(_units, \"s\", \"\")\n    // Determine if we will calculate offset from the bar's time or from current time.\n    _t = _from == \"bar\" ? time : _from == \"close\" ? time_close : timenow\n    // Calculate time at offset.\n    if _units == \"chart\"\n        // Offset in chart res multiples.\n        _timeFrom := int(_t + (f_tfInMinutes() * 60 * 1000 * _qty))\n    else\n        // Add the required _qty of time _units to the _from starting time.\n        _year   = year(_t)       + (_unit == \"year\"   ? int(_qty) : 0)\n        _month  = month(_t)      + (_unit == \"month\"  ? int(_qty) : 0)\n        _day    = dayofmonth(_t) + (_unit == \"day\"    ? int(_qty) : 0)\n        _hour   = hour(_t)       + (_unit == \"hour\"   ? int(_qty) : 0)\n        _minute = minute(_t)     + (_unit == \"minute\" ? int(_qty) : 0)\n        _second = second(_t)     + (_unit == \"econd\"  ? int(_qty) : 0)\n        // Return the resulting time in ms Unix time format.\n        _timeFrom := timestamp(_year, _month, _day, _hour, _minute, _second)\n// Time delay filter\nvar float lastTradeTime = na\nif nz(ta.change(strategy.position_size), time) != 0\n    // An order has been executed; save the bar's time.\n    lastTradeTime := time\n// If user has chosen to do so, wait `i_qtyTimeUnits` `i_timeUnits` between orders\ndelayElapsed = useDelay ? f_timeFrom(\"close\", i_qtyTimeUnits, i_timeUnits) >= lastTradeTime\n// ==== Dimak Delay End ======================================================================\n// ======================= dimak RSI timeframe   Begin 1111111 ====================\nGRUPO_RSI_TF  = \"==========RSI - Multi TimeFrame [1] ============\"\nlengthRSI = input.int(title=\"RSI TF Long(14):\", group=GRUPO_RSI_TF, defval=14, minval\ntf_rsi_indicator = input.timeframe(\"\",title=\"RSI TimeFrame:\", group=GRUPO_RSI_TF)\nuseRSITFoverSold = input.bool(false, 'Use RSI LONG Range', group=GRUPO_RSI_TF)\noverSoldRSITF = input.int(title='(LONG) RSI is More', group=GRUPO_RSI_TF, defval=30\noverSold2RSITF = input.int(title='& Less', group=GRUPO_RSI_TF, defval=70, minval=1\nuseRSITFFoverBought = input.bool(false, 'Use RSI SHORT Range', group=GRUPO_RSI_TF)\noverBoughtRSITF = input.int(title='(SHORT) RSI is Less', group=GRUPO_RSI_TF, defval\noverBought2RSITF = input.int(title='& More', group=GRUPO_RSI_TF, defval=30, minval\nrsi_tf1 = request.security(syminfo.tickerid, tf_rsi_indicator, ta.rsi(close, lengthRSI\n//=====================================================    \nlongCondition8  = true\nshortCondition8 = true\nif useRSITFoverSold or useRSITFFoverBought\n    longCondition8  := false\n    shortCondition8 := false\n    if useRSITFoverSold and (rsi_tf1 >= overSoldRSITF) and (rsi_tf1 <= overSold2RSITF\n        longCondition8  := true\n        if useRSITFFoverBought and (rsi_tf1 <= overBoughtRSITF)  and (rsi_tf1 >= overBought2RSITF\n        shortCondition8 := true\nelse \n    longCondition8  := true\n    shortCondition8 := true\n//dimak RSI timeframe  END\n//=====================================================\n// ======================= dimak RSI timeframe   Begin 22222222 ====================\nGRUPO_RSI_TF2  = \"==========RSI - Multi TimeFrame [2] ============\"\nlengthRSI2 = input.int(title=\"RSI TF Long(14)[2]:\", group=GRUPO_RSI_TF2, defval=14\ntf_rsi_indicator2 = input.timeframe(\"\",title=\"RSI TimeFrame[2]:\", group=GRUPO_RSI_TF2\nuseRSITFoverSold2 = input.bool(false, 'Use RSI LONG Range[2]', group=GRUPO_RSI_TF2\noverSoldRSITF2 = input.int(title='(LONG) RSI is More[2]', group=GRUPO_RSI_TF2, defval\noverSold2RSITF2 = input.int(title='& Less[2]', group=GRUPO_RSI_TF2, defval=70, minval\nuseRSITFFoverBought2 = input.bool(false, 'Use RSI SHORT Range[2]', group=GRUPO_RSI_TF2\noverBoughtRSITF2 = input.int(title='(SHORT) RSI is Less[2]', group=GRUPO_RSI_TF2, \noverBought2RSITF2 = input.int(title='& More[2]', group=GRUPO_RSI_TF2, defval=30, minval\nrsi_tf2 = request.security(syminfo.tickerid, tf_rsi_indicator2, ta.rsi(close, lengthRSI2\n//=====================================================    \nlongCondition10  = true\nshortCondition10 = true\nif useRSITFoverSold2 or useRSITFFoverBought2 and not na(rsi_tf2)\n    longCondition10  := false\n    shortCondition10 := false\n    if useRSITFoverSold2 and (rsi_tf2 >= overSoldRSITF2) and (rsi_tf2 <= overSold2RSITF2\n        longCondition10  := true\n        if useRSITFFoverBought2 and (rsi_tf2 <= overBoughtRSITF2)  and (rsi_tf2 >= overBought2RSITF2\n        shortCondition10 := true\nelse \n    longCondition10  := true\n    shortCondition10 := true\n//dimak RSI timeframe  END\n//=====================================================\n// ============ dimak \"Money Flow Index\" Filter Timeframe  [111]  =============\nGRUPO_MFI_TF = '===========Money Flow Index Filter TimeFrame [1] ==========='\nlengthMFI = input.int(title='MFI TF Long:', group=GRUPO_MFI_TF, defval=14, minval=\ntf_mfi_indicator = input.timeframe('', title='MFI TimeFrame:', group=GRUPO_MFI_TF)\nuseMFITFoverSold = input.bool(false, 'Use MFI LONG Range', group=GRUPO_MFI_TF)\noverSold = input.int(title='(LONG) MFI is More', group=GRUPO_MFI_TF, defval=10, step\noverSold2 = input.int(title='& Less', group=GRUPO_MFI_TF, defval=60, maxval = 100,\nuseMFITFoverBought = input.bool(false, 'Use MFI SHORT Range', group=GRUPO_MFI_TF)\noverBought = input.int(title='(SHORT) MFI is Less', group=GRUPO_MFI_TF, defval=95,\noverBought2 = input.int(title='& More', group=GRUPO_MFI_TF, defval=50, maxval = 100\nmfi_tf1 = request.security(syminfo.tickerid, tf_mfi_indicator, ta.mfi(hlc3, lengthMFI\n//mfi_tf1-test = ta.mfi(hlc3, lengthMFI)\n// use_mfi_tf1_rising = input.bool(false, 'Use MFI TF Rising ?', group=GRUPO_MFI_TF)\n// mfi_tf1_rising_len = input.int(3, title='MFI TF Rising Bars:', group=GRUPO_MFI_TF, minval=1, maxv\n// use_mfi_tf1_falling = input.bool(false, 'Use MFI TF Falling ?', group=GRUPO_MFI_TF)\n// mfi_tf1_falling_len = input.int(3, title='MFI TF Falling Bars:', group=GRUPO_MFI_TF, minval=1, ma\n// //mfi_tf1_falling = ta.falling(mfi_tf1, mfi_tf1_falling_len)\n// //mfi_tf1_rising = ta.rising(mfi_tf1, mfi_tf1_rising_len)\n// mfi_tf1_falling = ta.falling(ta.mfi(hlc3, lengthMFI), mfi_tf1_falling_len)\n// mfi_tf1_rising = ta.rising(ta.mfi(hlc3, lengthMFI), mfi_tf1_rising_len)\n// mfi_tf1_falling_tf = request.security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_falling, barmer\n// mfi_tf1_rising_tf = request.security(syminfo.tickerid, tf_mfi_indicator, mfi_tf1_rising, barmerge\n//plot(mfi_tf1)\n//plot(mfi_tf2, color=color.new(#f84343, 1))\n// =====================================================    \nlongCondition4 = true\nshortCondition4 = true\n    if useMFITFoverSold or useMFITFoverBought\n    longCondition4 := false\n    shortCondition4 := false\n    if useMFITFoverSold and (mfi_tf1 > overSold) and (mfi_tf1 < overSold2)\n        longCondition4 := true\n          if useMFITFoverBought and (mfi_tf1 < overBought) and (mfi_tf1 > overBought2) \n        shortCondition4 := true\n              // if (use_mfi_tf1_falling and mfi_tf1_falling_tf) or (use_mfi_tf1_rising and mfi_tf1_rising_tf)\n    //     shortCondition4 := true\n                // if (use_mfi_tf1_falling and mfi_tf1_falling_tf) or (use_mfi_tf1_rising and mfi_tf1_rising_tf)\n    //     longCondition4 := true\n        else\n    longCondition4 := true\n    shortCondition4 := true\n   // dimak MFI timeframe [111] END\n// =====================================================\n// ============ dimak \"Money Flow Index\" Filter Timeframe  [222]  =============\nGRUPO_MFI_TF2 = '===========Money Flow Index Filter TimeFrame [2] ==========='\nlengthMFI2 = input.int(title='MFI TF Long:[2]', group=GRUPO_MFI_TF2, defval=14, minval\ntf_mfi_indicator2 = input.timeframe('', title='MFI TimeFrame[2]:', group=GRUPO_MFI_TF2\nuseMFITFoverSold2 = input.bool(false, 'Use MFI LONG Range[2]', group=GRUPO_MFI_TF2\noverSold12 = input.int(title='(LONG) MFI is More[2]', group=GRUPO_MFI_TF2, defval=\noverSold22 = input.int(title='& Less[2]', group=GRUPO_MFI_TF2, defval=60, maxval =\nuseMFITFoverBought2 = input.bool(false, 'Use MFI SHORT Range[2]', group=GRUPO_MFI_TF2\noverBought12 = input.int(title='(SHORT) MFI is Less[2]', group=GRUPO_MFI_TF2, defval\noverBought22 = input.int(title='& More[2]', group=GRUPO_MFI_TF2, defval=50, maxval\nmfi_tf2 = request.security(syminfo.tickerid, tf_mfi_indicator2, ta.mfi(hlc3, lengthMFI2\n// =====================================================    \nlongCondition5 = true\nshortCondition5 = true\n    if useMFITFoverSold2 or useMFITFoverBought2\n    longCondition5 := false\n    shortCondition5 := false\n    if useMFITFoverSold2 and (mfi_tf2 >= overSold12) and (mfi_tf2 <= overSold22)\n        longCondition5 := true\n          if useMFITFoverBought2 and (mfi_tf2 <= overBought12) and (mfi_tf2 >= overBought22\n        shortCondition5 := true\n            else\n    longCondition5 := true\n    shortCondition5 := true\n   // dimak MFI timeframe [222]  END\n// =====================================================\n// ======================= dimak CCI timeframe   Begin 1111111 ====================\nGRUPO_CCI_TF  = \"==========CCI - Multi TimeFrame [1] ============\"\nlengthCCI = input.int(title=\"CCI TF Long(14):\", group=GRUPO_CCI_TF, defval=14, minval\ntf_CCI_indicator = input.timeframe(\"\",title=\"CCI TimeFrame:\", group=GRUPO_CCI_TF)\nuseCCITFoverSold = input.bool(false, 'Use CCI LONG Range', group=GRUPO_CCI_TF)\noverSoldCCITF = input.int(title='(LONG) CCI is More', group=GRUPO_CCI_TF, defval=-400\noverSold2CCITF = input.int(title='& Less', group=GRUPO_CCI_TF, defval=400, minval=\nuseCCITFFoverBought = input.bool(false, 'Use CCI SHORT Range', group=GRUPO_CCI_TF)\noverBoughtCCITF = input.int(title='(SHORT) CCI is Less', group=GRUPO_CCI_TF, defval\noverBought2CCITF = input.int(title='& More', group=GRUPO_CCI_TF, defval=10, minval\nCCI_tf1 = request.security(syminfo.tickerid, tf_CCI_indicator, ta.cci(close, lengthCCI\n//=====================================================    \nlongCondition15  = true\nshortCondition15 = true\nif useCCITFoverSold or useCCITFFoverBought\n    longCondition15  := false\n    shortCondition15 := false\n    if useCCITFoverSold and (CCI_tf1 >= overSoldCCITF) and (CCI_tf1 <= overSold2CCITF\n        longCondition15  := true\n        if useCCITFFoverBought and (CCI_tf1 <= overBoughtCCITF)  and (CCI_tf1 >= overBought2CCITF\n        shortCondition15 := true\nelse \n    longCondition15  := true\n    shortCondition15 := true\n//dimak CCI timeframe  END\n//=====================================================\n// ===================================================================================\nlong_conditions = longCondition1 and longCondition2  and longCondition4  and longCondition5\nentrar_en_LONG  = P_permitir_LONGS and long_conditions and testPeriod() and ATR > \nshort_conditions = shortCondition1 and shortCondition2  and shortCondition4  and shortCondition5\nentrar_en_SHORT  = P_permitir_SHORTS and short_conditions and testPeriod() and ATR\nvar LONG_take_profit  = 0.0\nvar LONG_stop_loss    = 0.0\nvar SHORT_take_profit = 0.0\nvar SHORT_stop_loss   = 0.0\n//if (entrar_en_LONG and not posicion_abierta and delayElapsed)\nif (entrar_en_LONG and not posicion_abierta and delayElapsed and ((strategy.closedtrades\n    strategy.entry(\"L\", strategy.long, alert_message=\"enter_cycle\")\n //else if (entrar_en_SHORT and not posicion_abierta and delayElapsed)\nelse if (entrar_en_SHORT and not posicion_abierta and delayElapsed and ((strategy.closedtrades\n    strategy.entry(\"S\", strategy.short, alert_message=\"enter_cycle\")\nSHORT_stop_loss   := TP_SL_tipo_SL == \"useStaticSLTP\" ? shortSLExitPrice : TP_SL_tipo_SL\nSHORT_take_profit := TP_SL_tipo_TP == \"useStaticSLTP\" ? shortExitPrice : TP_SL_tipo_TP\n    LONG_stop_loss   := TP_SL_tipo_SL == \"useStaticSLTP\" ? longSLExitPrice : TP_SL_tipo_SL\nLONG_take_profit := TP_SL_tipo_TP == \"useStaticSLTP\" ? longExitPrice : TP_SL_tipo_TP\nif barstate.ishistory or SendSLsingonReal   \n    strategy.exit(\"CL\", \"L\", limit=LONG_take_profit, stop=LONG_stop_loss, alert_message\n    strategy.exit(\"CS\", \"S\", limit=SHORT_take_profit, stop=SHORT_stop_loss, alert_message\n// use {{strategy.order.alert_message}} in Alerts\n// Not using by Dimak\nif (posicion_abierta and TP_SL_TP_dinamico)\n    if (LONG_abierto)\n        LONG_take_profit := TP_SL_tipo_TP == \"Opposite Band\" ? banda_superior : TP_SL_tipo_TP\n        strategy.exit(\"Cerrar Long\", \"Abrir Long\", limit=LONG_take_profit, stop=LONG_stop_loss\n    else\n        SHORT_take_profit := TP_SL_tipo_TP == \"Opposite Band\" ? banda_inferior : TP_SL_tipo_TP\n        strategy.exit(\"Cerrar Short\", \"Abrir Short\", limit=SHORT_take_profit, stop\n//== Ploteo en pantalla\nbgcolor(entrar_en_LONG ?  color.new(color.green, 90) : entrar_en_SHORT ?  color.new\n// ATR\nplot(TP_SL_tipo_TP == \"ATR\" ? ATR_LONG_tp : na, style=plot.style_stepline, color= \nplot(TP_SL_tipo_SL == \"ATR\" ? ATR_LONG_sl : na, style=plot.style_stepline, color= \nplot(TP_SL_tipo_TP == \"ATR\" ? ATR_SHORT_tp : na, style=plot.style_stepline, color=\nplot(TP_SL_tipo_SL == \"ATR\" ? ATR_SHORT_sl : na, style=plot.style_stepline, color=\n// Canal y media\nplot(banda_superior, \"Banda superior\",  color.aqua)\nplot(media_movil, \"Moving Average\",  color.orange)\nplot(banda_inferior, \"Banda inferior\",  color.aqua)\n// Bandas extendidas\nplot(TP_SL_tipo_SL == \"Extended Band\" ? banda_extendida_sup_SL : na, \"Banda superior extendida (Stop Loss)\"\nplot(TP_SL_tipo_SL == \"Extended Band\" ? banda_extendida_inf_SL : na, \"Banda inferior extendida (Stop Loss)\"\ndisplTPSL = not USEdisplTPSL ? display.none : display.all\n// visual TP SL\navg_position_price_plot = plot(series=strategy.position_size != 0 ? strategy.position_avg_price\nLONG_tp_plot            = plot(strategy.position_size > 0 and longExitPrice > 0.0 \nLONG_sl_plot            = plot(strategy.position_size > 0 and longSLExitPrice > 0.0\nfill(avg_position_price_plot, LONG_tp_plot, color= color.new(color.olive, 90), display\nfill(avg_position_price_plot, LONG_sl_plot, color= color.new(color.maroon, 90), display\nSHORT_tp_plot            = plot(strategy.position_size < 0 and shortExitPrice > 0.0\nSHORT_sl_plot            = plot(strategy.position_size < 0 and shortSLExitPrice > \nfill(avg_position_price_plot, SHORT_tp_plot, color= color.new(color.olive, 90), display\nfill(avg_position_price_plot, SHORT_sl_plot, color= color.new(color.maroon, 90),"}]}
{"messages": [{"role": "user", "content": "Long entry: PSAR gives buy signal BBPT prints green histogram ZLSMA is below the price ZLSMA has uptrend SL is smaller than the max SL Optional Sessions and EMA filters Short entry PSAR gives sell signal BBPT prints red histogram ZLSMA is above the price ZLSMA has downtrend  SL is smaller than the max SL Optional Sessions and EMA filters SL: Placed below ZLSMA + offset on long Placed above ZLSMA + offset on short TP1: 1x the SL by default Takes no profit by default, 50% is also a good setting TP2: 2x the SL by default Take out all remaining position size. If price reaches TP1, the SL is set to the entry price."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Rolan_Kruger\n//@version=5\nstrategy(\"PSAR BBPT ZLSMA\",\"PBZ\", overlay=true,default_qty_type = strategy.percent_of_equity\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// PSAR BUY/SELL\nstart = input.float(title='Start', step=0.00005, defval=0.05, group = \"PSAR\")\nincrement = input.float(title='Increment', step=0.00005, defval=0.05, group = \"PSAR\"\nmaximum = input.float(title='Maximum', step=0.01, defval=0.13, group = \"PSAR\")\nwidth = input.int(title='Point Width', minval=1, defval=20, group = \"PSAR\")\nhighlightStartPoints = input(title='Highlight Start Points ?', defval=false, group\npsar = ta.sar(start, increment, maximum)\ndir = psar < close ? 1 : -1\npsarColor = psar < close ?  #3388bb :  #fdcc02\nplotshape(dir == 1 and dir[1] == -1 and highlightStartPoints ? psar : na, title='Buy'\nplotshape(dir == -1 and dir[1] == 1 and highlightStartPoints ? psar : na, title='Sell'\nbarcolor(dir == 1 ?  color.green :  color.red, display = display.none)\nPSAR_Buy = dir == 1 and dir[1] == -1\nPSAR_Sell = dir == -1 and dir[1] == 1\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// ZLSMA\nlength = input(title='Length', defval=50,group = \"ZLSMA\")\noffset = input(title='Offset', defval=0,group = \"ZLSMA\")\nsrc = input(close, title='Source',group = \"ZLSMA\")\nlsma = ta.linreg(src, length, offset)\nlsma2 = ta.linreg(lsma, length, offset)\neq = lsma - lsma2\nzlsma = lsma + eq\nplot(zlsma, color= color.new(color.yellow, 0), linewidth=3)\nZLSMA_Buy = close > zlsma and open > zlsma and low > zlsma and high > zlsma\nZLSMA_Sell = close < zlsma and open < zlsma and low < zlsma and high < zlsma\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// BBPT\n//\nswitch_bbpt = input.bool(false, \"Switch BBPT conditionals\",group =\"Bull Bear Power Trend\"\nlength1 = 8\n//\nBullTrend_hist = 0.0\nBearTrend_hist = 0.0\nBullTrend = (close - ta.lowest(low, 50)) / ta.atr(5)\nBearTrend = (ta.highest(high, 50) - close) / ta.atr(5)\nBearTrend2 = -1 * BearTrend\nTrend = BullTrend - BearTrend\nif BullTrend < 2\n    BullTrend_hist := BullTrend - 2\n    BullTrend_hist\nif BearTrend2 > -2\n    BearTrend_hist := BearTrend2 + 2\n    BearTrend_hist\n//alexgrover-Regression Line Formula\nx = bar_index\ny = Trend\nx_ = ta.sma(x, length1)\ny_ = ta.sma(y, length1)\nmx = ta.stdev(x, length1)\nmy = ta.stdev(y, length1)\nc = ta.correlation(x, y, length1)\nslope = c * (my / mx)\ninter = y_ - slope * x_\nreg_trend = x * slope + inter\n//\nBBPT_Buy = BearTrend_hist\nBBPT_Sell = BullTrend_hist\nif switch_bbpt\n    BBPT_Buy := BullTrend_hist\n    BBPT_Sell := BearTrend_hist\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Sessions\nenable_sessions = input.bool(false, \"Enable Sessions for strategy\", group = \"Sessions\"\nbgColor = input.bool(false, \"Activate High/Low View\", group = \"Sessions\")\nLondonColor =  color.new(color.green, 90)\nNYColor =  color.new(color.red, 90)\nAsiaColor =  color.new(color.yellow, 90)\nSydneyColor =  color.new(color.blue, 90)\n///Sessions\nres = input.timeframe(\"D\", \"Resolution\", [\"D\",\"W\",\"M\"], group = \"Sessions\")\nlondon = input.session(\"0300-1200:1234567\", \"London Session\", group = \"Sessions\")\nny = input.session(\"0800-1700:1234567\", \"New York Session\", group = \"Sessions\")\ntokyo = input.session(\"2000-0400:1234567\", \"Tokyo Session\", group = \"Sessions\")\nsydney = input.session(\"1700-0200:1234567\", \"Sydney Session\", group = \"Sessions\")\n//Bars\nis_newbar(sess) =>\n    t = time(res, sess, \"America/New_York\")\n    na(t[1]) and not na(t) or t[1] < t\nis_session(sess) =>\n    not na(time(timeframe.period, sess, \"America/New_York\"))\n    //London\nLondon = input.bool(false, \"London Session\")\nlondonNewbar = is_newbar(london)\nlondonSession = is_session(london)\nfloat londonLow = na\nlondonLow := if londonSession\n    if londonNewbar\n        low\n    else\n        math.min(londonLow[1],low)\nelse\n    londonLow\nfloat londonHigh = na\nlondonHigh := if londonSession\n    if londonNewbar\n        high\n    else\n        math.max(londonHigh[1],high)\nelse\n    londonHigh\nplotLL = plot(londonLow, color= color.new(#000000, 100))\nplotLH = plot(londonHigh, color= color.new(#000000, 100))\nfill(plotLL, plotLH, color = londonSession and London and bgColor ? LondonColor : \nbgcolor(londonSession and London and not bgColor ? LondonColor : na)\n//New York\nNY = input.bool(false, \"New York Session\")\nnyNewbar = is_newbar(ny)\nnySession = is_session(ny)\nfloat nyLow = na\nnyLow := if nySession\n    if nyNewbar\n        low\n    else\n        math.min(nyLow[1],low)\nelse\n    nyLow\nfloat nyHigh = na\nnyHigh := if nySession\n    if nyNewbar\n        high\n    else\n        math.max(nyHigh[1],high)\nelse\n    nyHigh\nplotNYL = plot(nyLow, color= color.new(#000000, 100))\nplotNYH = plot(nyHigh, color= color.new(#000000, 100))\nfill(plotNYL, plotNYH, color = nySession and NY and bgColor ? NYColor : na)\nbgcolor(nySession and NY and not bgColor ? NYColor : na)\n//Tokyo\nTokyo = input.bool(false, \"Tokyo Session\")\ntokyoNewbar = is_newbar(tokyo)\ntokyoSession = is_session(tokyo)\nfloat tokyoLow = na\ntokyoLow := if tokyoSession\n    if tokyoNewbar\n        low\n    else\n        math.min(tokyoLow[1],low)\nelse\n    tokyoLow\nfloat tokyoHigh = na\ntokyoHigh := if tokyoSession\n    if tokyoNewbar\n        high\n    else\n        math.max(tokyoHigh[1],high)\nelse\n    tokyoHigh\nplotTL = plot(tokyoLow, color= color.new(#000000, 100))\nplotTH = plot(tokyoHigh, color= color.new(#000000, 100))\nfill(plotTL, plotTH, color = tokyoSession and Tokyo and bgColor ? AsiaColor : na)\nbgcolor(tokyoSession and Tokyo and not bgColor ? AsiaColor : na)\n//Sydney\nSydney = input.bool(false, \"Sydney Session\")\nsydneyNewbar = is_newbar(sydney)\nsydneySession = is_session(sydney)\nfloat sydneyLow = na\nsydneyLow := if sydneySession\n    if sydneyNewbar\n        low\n    else\n        math.min(sydneyLow[1],low)\nelse\n    sydneyLow\nfloat sydneyHigh = na\nsydneyHigh := if sydneySession\n    if sydneyNewbar\n        high\n    else\n        math.max(sydneyHigh[1],high)\nelse\n    sydneyHigh\nplotSL = plot(sydneyLow, color= color.new(#000000, 100))\nplotSH = plot(sydneyHigh, color= color.new(#000000, 100))\nfill(plotSL, plotSH, color = sydneySession and Sydney and bgColor ? SydneyColor : \nbgcolor(sydneySession and Sydney and not bgColor ? SydneyColor : na)\nLondon_ok = London and londonSession\nNY_ok = NY and nySession\nTokyo_ok = Tokyo and tokyoSession\nSydney_ok = Sydney and sydneySession\nin_session = true\nif London_ok or NY_ok or Tokyo_ok or Sydney_ok and enable_sessions\n    in_session := true\nelse if enable_sessions == true\n    in_session := false\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// EMA Filter\nema_filter = input.bool(false, \"Enable EMA filter\", group = \"EMA\")\nema_lenght = input.int(50, \"EMA lenght\", group = \"EMA\")\nema1 = ta.ema(close, ema_lenght)\nplot(ema1, \"EMA\",  color.white, 3)\nEMA_Buy = true\nEMA_Sell = true\nif ema_filter == true\n    EMA_Buy := close > ema1\n    EMA_Sell := ema1 > close\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// ZLSMA angle calc\nzlsma_angle_filter = input.bool(true, \"ZLSMA angle filter\", group = \"ZLSMA\")\nZLSMA_Up = true\nZLSMA_Down = true\nif zlsma_angle_filter == true\n    ZLSMA_Up := 1 < (zlsma - zlsma[1])\n    ZLSMA_Down := -1 > (zlsma - zlsma[1])\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// SL/TP\n// Assumes quote currency is FIAT as with BTC/USDT pair\nmax_sl = input.float(0.2, \"Max SL size in %\", group = \"SL/TP\", minval = 0.1, tooltip\nzlsma_offset = input.float(0.02, title=\"ZLSMA SL offset in %\", group = \"SL/TP\",maxval\ntp1_multi = input.float(1, title=\"TP 1 multiplier\", group = \"SL/TP\")\ntp2_multi = input.float(2, title=\"TP 2 multiplier\", group = \"SL/TP\")\ntp1_persentage = input.float(0.001, \"Persentage of trade close on TP1\", group =\"SL/TP\"\n// SL too big check\nsl_check = ((math.abs(close - zlsma))/close * 100) + zlsma_offset\nsl_ok = true\nif sl_check > max_sl\n    sl_ok := false\n// ZLSMA SL and TP\nnot_in_trade = strategy.position_size == 0\ncheck_if_long = PSAR_Buy and ZLSMA_Buy and BBPT_Buy and EMA_Buy and ZLSMA_Up and sl_ok\ncheck_if_short = PSAR_Sell and ZLSMA_Sell and BBPT_Sell and EMA_Sell and ZLSMA_Down\nvar float sl = 0.0\nvar float tp1 = 0.0\nvar float tp2 = 0.0\nif check_if_long and not_in_trade\n    sl := ((close - zlsma)/close * 100) + zlsma_offset\n    tp1 := (((close - zlsma)/close * 100) + zlsma_offset)*tp1_multi\n    tp2 := (((close - zlsma)/close * 100) + zlsma_offset)*tp2_multi\nif check_if_short and not_in_trade\n    sl := ((zlsma - close)/close * 100) + zlsma_offset\n    tp1 := (((zlsma - close)/close * 100) + zlsma_offset)*tp1_multi\n    tp2 := (((zlsma - close)/close * 100) + zlsma_offset)*tp2_multi\n// FUNCTIONS\n// Stochastic\nf_stochastic() =>\n    stoch = ta.stoch(close, high, low, 14)\n    stoch_K = ta.sma(stoch, 3)\n    stoch_D = ta.sma(stoch_K, 3)\n    stRD = ta.crossunder(stoch_K, stoch_D)\n    stGD = ta.crossover(stoch_K, stoch_D)\n    [stoch_K, stoch_D, stRD, stGD]\n// VARIABLES\n[bbMiddle, bbUpper, bbLower] = ta.bb(close, 20, 2)\n[stoch_K, stoch_D, stRD, stGD] = f_stochastic()\n// ORDERS\n// Active Orders\n// Check if strategy has open positions\ninLong = strategy.position_size > 0\ninShort = strategy.position_size < 0\n// Check if strategy reduced position size in last bar\nlongClose = strategy.position_size < strategy.position_size[1]\nshortClose = strategy.position_size > strategy.position_size[1]\n// Entry Conditions\n// Enter long when during last candle these conditions are true:\n// Candle high is greater than upper Bollinger Band\n// Stochastic K line crosses under D line and is oversold\nlongCondition = PSAR_Buy and ZLSMA_Buy and BBPT_Buy and EMA_Buy and ZLSMA_Up and sl_ok\n// Enter short when during last candle these conditions are true:\n// Candle low is lower than lower Bollinger Band\n// Stochastic K line crosses over D line and is overbought\nshortCondition = PSAR_Sell and ZLSMA_Sell and BBPT_Sell and EMA_Sell and ZLSMA_Down\n// Exit Conditions\n// Calculate Take Profit \nlongTP1 = strategy.position_avg_price * ((100 + tp1)/100)\nlongTP2 = strategy.position_avg_price * ((100 + tp2)/100)\nshortTP1 = strategy.position_avg_price * ((100 - tp1)/100)\nshortTP2 = strategy.position_avg_price * ((100 - tp2)/100)\n// Calculate Stop Loss\n// Initialise variables\nvar float longSL = 0.0\nvar float shortSL = 0.0\n// When not in position, set stop loss using close price which is the price used during backtesting\n// When in a position, check to see if the position was reduced on the last bar\n// If it was, set stop loss to position entry price. Otherwise, maintain last stop loss value\nlongSL := if inLong and ta.barssince(longClose) < ta.barssince(longCondition)\n    strategy.position_avg_price\nelse if inLong\n    longSL[1]\nelse\n    close * ((100 - sl)/100)\nshortSL := if inShort and ta.barssince(shortClose) < ta.barssince(shortCondition)\n    strategy.position_avg_price\nelse if inShort\n    shortSL[1]\nelse\n    close * ((100 + sl)/100)\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// STRATEGY EXECUTION\n// Manage positions\nif not_in_trade and longCondition\n    strategy.entry(\"Long\", strategy.long)\nstrategy.exit(\"TP1/SL\", from_entry=\"Long\", qty_percent=tp1_persentage, limit=longTP1\nstrategy.exit(\"TP2/SL\", from_entry=\"Long\", limit=longTP2, stop=longSL)\nif not_in_trade and shortCondition\n    strategy.entry(\"Short\", strategy.short)\nstrategy.exit(\"TP1/SL\", from_entry=\"Short\", qty_percent=tp1_persentage, limit=shortTP1\nstrategy.exit(\"TP2/SL\", from_entry=\"Short\", limit=shortTP2, stop=shortSL)"}]}
{"messages": [{"role": "user", "content": "Ride Bull Trends Via Stochastic with Special Rules for Heavy Bullish Bias TLDR: Long Only Trend Indicator Where you are always entered Long if the stochastic is over the lower band line and the price is above the Donchian Chanel high. Exit when Stochastic RSI is below the lower band.  Indicators: Filter = Trend/Bullish indicator is Donchian of ema(high) this is set as the highest ema(high, 6) in the last 30 candles. this can be adjusted to fit the market as desired.       **indicator prints green background when the filter condition is satisfied*** Entry Exit = enter when the Stoch RSI is above the given lower trend band. This value is set at 35 but can be adjusted according to risk tolerance and market conditions.  Logic: this indicator allows  a trader to be present during bullish/parabolic trends by only triggering if the close is > than the highest 6 candle average high over the last 30 candles. This filter requires the market to be in a generally bullish posture. If the market is in this condition the stochastic RSI indicator value offers a good gauge of price action and only goes significantly down if price trends below the average range of the rsi period. This filters out noise and keeps a trader from over trading on inconsequential corrections while responding fairly quickly to changes in general trend direction. the response is fast enough to produce an unprofitable amount of false signals if the bull market filter is not implemented. However when used in combination the signals return desirable results in bull trending markets. Hope this Helps. Happy Trades.  -Snarky Puppy"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 SnarkyPuppy\n//@version=5\nstrategy(\"Filtered Stoch\", overlay=false, default_qty_value = 100, default_qty_type\n/////high filter...upper donchian channel of ema... or highest ema for a given amount of candles\nfilter_ema_len= input(6)\nema_donchian_len = input(30)\nema=ta.highest(ta.ema(high,filter_ema_len),ema_donchian_len)\n////////////////////////basic stoch rsi with max val 100 and min val 0.. entry above lowerband prese\nsmoothK = input.int(7, \"K\", minval=1)\nsmoothD = input.int(4, \"D\", minval=1)\nlengthRSI = input.int(14, \"RSI Length\", minval=1)\nlengthStoch = input.int(14, \"Stochastic Length\", minval=1)\nsrc = input(close, title=\"RSI Source\")\nrsi1 = ta.rsi(src, lengthRSI)\nk = math.min(100, math.max(0,ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK\nd = math.max(math.min(ta.sma(k, smoothD),80),35)\nplot(k, \"K\", color= #2962FF)\nplot(d, \"D\", color= #FF6D00)\nh0 = hline(80, \"Upper Band\", color= #787B86)\nhline(50, \"Middle Band\", color= color.new(#787B86, 50))\nlowerband=input(35)\nh11 = hline(lowerband, \"Lower Band\", color= #787B86)\nfill(h0, h11, color= color.rgb(33, 150, 243, 90), title=\"Background\")\nematrend= close>ema ? 1 : 0\nbgcolor(ematrend==1? color.rgb(76, 175, 79, 80):na)\nlongCondition = k>lowerband and ematrend==1\nif (longCondition)\n    strategy.entry(\"Up\", strategy.long)\nshortCondition =  ta.crossunder(k,lowerband)\nif (shortCondition)\n    strategy.close(\"Up\", shortCondition)"}]}
{"messages": [{"role": "user", "content": "TLDR: This is a long only trend following system that uses highest and lowest values of three trend following indicators to form a \"cloud\". Enter when the candle high crosses above the highest band. Close if the low or close crosses below the lowest band. 3 indicators  1. Kaufman Adaptive moving Average - set at 20 2. Hull Moving Average (of the Kaufman Adaptive moving average) - set at 20   3. SuperTrend - I believe this is set at 5 periods and 3*atr but this can be changed Cloud the upper band is the highest of the 3 indicators the lower band is the lowest of the 3 indicators Entry and Exit: Enter when the high crosses above the upper band of the cloud.  (This means you will only get a long signal if the high was previously below the upper band of the cloud and then crosses over.) Exit when the low crosses below the lower band of the cloud . (This means that this rule will only close if the low was previously above the upper band and then crosses under) The \"Exit\" may not trigger if the low (the wick) never gets above the band. In this case the long order will close if the closing price is below the cloud. Logic Kaufamn is the best moving average i have found at responding to changes in volatility. This means it moves up or down quickly during expansive moves but becoming very flat during relative choppiness. However, getting flat causes the the Kaufman AMA to trigger a lot of false signals when volatility is transitioning from high to low. This is why the Hull moving average (with its rounded turns) keeps a lot of the false continuations contained because usually prices need to decisively move higher in order to over come the Hull moving average which continues to increase/decrease during the candles after an expansive move.  The super trend places a stagnant floor and ceiling which acts as a great stoploss or trigger as price action attempts to trend in a certain direction. The super trend allows for the user to adjust the likely hood of this cloud indicator changing from  bullish to bearish based on the volatility of the asset that is being analyzed.  individually all of these are great. Together the trader can use this cloud to create a trend following or anlysis system that captures the bulk of moves. Not my best explanation but this indicator is actually pretty simple.  Hope this helps. Happy Trades -Snarky Puppy"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 SnarkyPuppy\n//@version=5\nstrategy(\"HKST Cloud\", overlay=true, default_qty_type= strategy.percent_of_equity, \n////////////////nAMA\nLengthkaufman = input(20) \nxPrice = ohlc4\nxvnoise = math.abs(xPrice - xPrice[1])\nnfastend = 0.666\nnslowend = 0.0645\nnsignal = math.abs(xPrice - xPrice[Lengthkaufman])\nnnoise = math.sum(xvnoise, Lengthkaufman)\nnefratio = nnoise != 0? nsignal / nnoise : 0\nnsmooth = math.pow(nefratio * (nfastend - nslowend) + nslowend, 2) \nnAMA =  float(0)\nnAMA := nz(nAMA[1]) + nsmooth * (xPrice - nz(nAMA[1]))\n//plot(nAMA,color=color.red)\n///short=input(true)\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n////////hull moving average\nhull_len=input(20)\nhull= ta.hma(nAMA,hull_len)\n///////atr trail\natr_factor=input(2)\natr_period=input(5)\n[supertrend, direction] = ta.supertrend(atr_factor,atr_period)\n/////////cloud\nband1= math.max(supertrend,hull,nAMA)\nband2= math.min(supertrend,hull,nAMA)\nb1=plot(band1, \"band1\", color =  color.rgb(76, 175, 79, 85), style=plot.style_linebr\nb2=plot(band2, \"band2\", color =  color.rgb(255, 82, 82, 78), style=plot.style_linebr\nfill(b1,b2, color.rgb(12, 50, 186, 75))\nlongCondition = ta.crossover(high,band1) //or ta.crossover(low,band2)\nif (longCondition)\n    strategy.entry(\"Up\", strategy.long)\nshortCondition =  ta.crossunder(low,band2) or close<band2\nif (shortCondition) \n    strategy.close(\"Up\", shortCondition)"}]}
{"messages": [{"role": "user", "content": "The Ichimoku Cloud is a collection of technical indicators that show support and resistance levels, as well as momentum and trend direction. It does this by taking multiple averages and plotting them on a chart. It also uses these figures to compute a \u201ccloud\u201d that attempts to forecast where the price may find support or resistance in the future. The Ichimoku Cloud was developed by Goichi Hosoda, a Japanese journalist, and published in the late 1960s. It provides more data points than the standard candlestick chart. While it seems complicated at first glance, those familiar with how to read the charts often find it easy to understand with well-defined trading signals. The Ichimoku Cloud is composed of five lines or calculations, two of which comprise a cloud where the difference between the two lines is shaded in. The lines include a nine-period average, a 26-period average, an average of those two averages, a 52-period average, and a lagging closing price line. The cloud is a key part of the indicator. When the price is below the cloud, the trend is down. When the price is above the cloud, the trend is up. The above trend signals are strengthened if the cloud is moving in the same direction as the price. For example, during an uptrend, the top of the cloud is moving up, or during a downtrend, the bottom of the cloud is moving down. DMI is simple to interpret. When +DI > - DI, it means the price is trending up. On the other hand, when -DI > +DI, the trend is weak or moving on the downside. The ADX does not give an indication of the direction but about the strength of the trend. Typically values of ADX above 25 mean that the trend is steeply moving up or down, based on the -DI and +DI positioning. This script aims to capture swings in the DMI, and thus, in the trend of the asset, using a contrarian approach. Trading on high values of ADX, the strategy tries to spot extremely oversold and overbought conditions. Values of ADX above 45 may suggest that the trend has overextended and is maybe about to reverse. This strategy combines the Ichimoku Cloud with the ADX indicator to better enter trades. Long orders are placed when these basic signals are triggered. Long Position: Tenkan-Sen is above the Kijun-Sen Chikou-Span is above the close of 26 bars ago Close is above the Kumo Cloud MACD line crosses over the signal line -DI is greater than +DI ADX is greater than 45 Close Position: 3% increase trailing 3% decrease trailing The script is backtested from December 2022 and provides good returns.  A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Coinrule\n//@version=5\nstrategy('Ichimoku Cloud with ADX with Trailing Stop Loss',\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=100,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 1, 1, 0, 0)\n// Inputs\nts_bars = input.int(9, minval=1, title='Tenkan-Sen Bars')\nks_bars = input.int(26, minval=1, title='Kijun-Sen Bars')\nssb_bars = input.int(52, minval=1, title='Senkou-Span B Bars')\ncs_offset = input.int(26, minval=1, title='Chikou-Span Offset')\nss_offset = input.int(26, minval=1, title='Senkou-Span Offset')\nlong_entry = input(true, title='Long Entry')\nshort_entry = input(true, title='Short Entry')\nmiddle(len) => math.avg(ta.lowest(len), ta.highest(len))\n// Ichimoku Components\ntenkan = middle(ts_bars)\nkijun = middle(ks_bars)\nsenkouA = math.avg(tenkan, kijun)\nsenkouB = middle(ssb_bars)\n// Plot Ichimoku Kinko Hyo\nplot(tenkan, color= color.new(#0496ff, 0), title='Tenkan-Sen')\nplot(kijun, color= color.new(#991515, 0), title='Kijun-Sen')\nplot(close, offset=-cs_offset + 1, color= color.new(#459915, 0), title='Chikou-Span'\nsa = plot(senkouA, offset=ss_offset - 1, color= color.new(color.green, 0), title='Senkou-Span A'\nsb = plot(senkouB, offset=ss_offset - 1, color= color.new(color.red, 0), title='Senkou-Span B'\nfill(sa, sb, color=senkouA > senkouB ?  color.green :  color.red, title='Cloud color'\nss_high = math.max(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\nss_low = math.min(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\n// ADX\n[pos_dm, neg_dm, avg_dm] = ta.dmi(14, 14)\n// Entry/Exit Signals\ntk_cross_bull = tenkan > kijun\ntk_cross_bear = tenkan < kijun\ncs_cross_bull = ta.mom(close, cs_offset - 1) > 0\ncs_cross_bear = ta.mom(close, cs_offset - 1) < 0\nprice_above_kumo = close > ss_high\nprice_below_kumo = close < ss_low\nbullish = tk_cross_bull and cs_cross_bull and price_above_kumo and avg_dm < 45 and \nbearish = tk_cross_bear and cs_cross_bear and price_below_kumo and avg_dm > 45 and \n// Configure trail stop level with input options\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nshortStopPrice = 0.0\nlongStopPrice := if strategy.position_size > 0\n    stopValue = close * (1 - longTrailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\nstrategy.entry('Long', strategy.long, when=bullish and long_entry and timePeriod)\nstrategy.exit('Long', stop = longStopPrice, limit = shortStopPrice)\n//strategy.entry('Short', strategy.short, when=bearish and short_entry and timePeriod)\n//strategy.exit('Short', stop = longStopPrice, limit = shortStopPrice)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    A slight correction in the credits due to additional contributions in the script development.                                                    Release Notes:                                                    Addition of comments and tooltips for improved code readability and user-friendliness, as well as some minor algorithmic tweaks to improve backtest results."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Good-Vibe\n//@version=5\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Strategy Settings\nstrategy('Super 8 - 30M BTC',\n// The overlay parameter is set to true, which means that the strategy will be plotted on top of the\n overlay = true,\n// The default_qty_value parameter is set to 0, meaning that the position size will be calculated ba\n default_qty_value = 0,\n// The initial_capital parameter is set to 10000, which is the starting capital for the strategy\n initial_capital = 10000,\n// The pyramiding parameter is set to 0, because it will be controlled by the script\n pyramiding = 0,\n// The commission_value parameter is set to 0.04, which represents a 0.04% commission for each trade\n commission_value = 0.05,\n// The commission_type parameter is set to strategy.commission.percent, which means that the commiss\n commission_type = strategy.commission.percent,\n// The process_orders_on_close parameter is set to true, which means that orders will be executed at\n process_orders_on_close = true,\n// The margin_long parameter is set to 100, which represents the margin requirement for long positio\n margin_long = 100,\n// The margin_short parameter is set to 100, which represents the margin requirement for short posit\n margin_short = 100,\n// The use_bar_magnifier parameter is set to false, which means that the chart will not use a bar ma\n use_bar_magnifier = false)\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Inputs\n// \u2014\u2014\u2014\u2014\u2014 Source input\n// Define the position to take (long, short, or both)\nPosition = input.string('Both', 'Long / Short', options = ['Long', 'Short', 'Both'\n// \u2014\u2014\u2014\u2014\u2014 EMA inputs\n// Define the slow and fast EMA lengths\nsEma_Length = input.int(775, 'Slow EMA Length', minval = 0, step = 25, group = 'EXPONENTIAL MOVING AVERAGE'\nfEma_Length = input.int(125, 'Fast EMA Length', minval = 0, step = 25, group = 'EXPONENTIAL MOVING AVERAGE'\n// \u2014\u2014\u2014\u2014\u2014 ADX inputs\n// Define the ADX parameters\nADX_len = input.int(28, 'ADX Length', minval = 1, group = 'AVERAGE DIRECTIONAL INDEX'\nADX_smo = input.int(10, 'ADX Smoothing', minval = 1, group = 'AVERAGE DIRECTIONAL INDEX'\nth = input.float(23, 'ADX Threshold', minval = 0, step = 0.5, group = 'AVERAGE DIRECTIONAL INDEX'\n// \u2014\u2014\u2014\u2014\u2014 SAR inputs\n// Define the SAR parameters\nSst = input.float(0.08, 'SAR star', minval = 0.01, step = 0.01, group = 'PARABOLIC SAR'\nSinc = input.float(0.04, 'SAR inc', minval = 0.01, step = 0.01, group = 'PARABOLIC SAR'\nSmax = input.float(0.4, 'SAR max', minval = 0.01, step = 0.01, group = 'PARABOLIC SAR'\n// \u2014\u2014\u2014\u2014\u2014 MOVING AVERAGE CONVERGENCE DIVERGENCE\n// Define the MACD and the MAC-Z parameters\nMACD_options = input.string('MAC-Z', 'MACD OPTION', options = ['MACD', 'MAC-Z'], group\nfastLength = input.int(24, 'MACD Fast MA Length', minval = 1, group = 'MOVING AVERAGE CONVERGENCE DIVERGENCE'\nslowLength = input.int(54, 'MACD Slow MA Length', minval = 1, group = 'MOVING AVERAGE CONVERGENCE DIVERGENCE'\nsignalLength = input.int(14, 'MACD Signal Length', minval = 1, group = 'MOVING AVERAGE CONVERGENCE DIVERGENCE'\nlengthz = input.int(14, 'Z-VWAP Length', minval = 1, group = 'MOVING AVERAGE CONVERGENCE DIVERGENCE'\nlengthStdev = input.int(11, 'StDev Length', minval = 1, group = 'MOVING AVERAGE CONVERGENCE DIVERGENCE'\nA = input.float(0.1, \"MAC-Z constant A\", minval = -2.0, maxval = 2.0, step = 0.1, \nB = input.float(1.0, \"MAC-Z constant B\", minval = -2.0, maxval = 2.0, step = 0.1, \n// \u2014\u2014\u2014\u2014\u2014 Volume inputs for entries condition and for calculate quantities later\n// Define volume factor and simple moving average length for volume condition\nvolume_f = input.float(1.1, 'Volume Factor', minval = 0, step = 0.1, group = 'VOLUME CONDITION'\nsma_Length = input.int(89, 'SMA Volume Length', minval = 1, group = 'VOLUME CONDITION'\n// \u2014\u2014\u2014\u2014\u2014 Bollinger Bands inputs\n// Define inputs for Bollinger Bands\nBB_Length = input.int(40, 'BB Length', minval = 1, group = 'BOLLINGER BANDS', tooltip\nBB_mult = input.float(2.0, 'BB Multiplier', minval = 0.1, step = 0.1, group = 'BOLLINGER BANDS'\nbbMinWidth01 = input.float(5.0, 'Min. BB Width % (New Position)', minval = 0, step\nbbMinWidth02 = input.float(2.0, 'Min. BB Width % (Pyramiding)', minval = 0, step =\n// \u2014\u2014\u2014\u2014\u2014 Take Profit / Trailing Stop input\n// Define take profit/trailing stop options and parameters\nTP_options = input.string('Both', 'Take Profit Option', options = ['Normal', 'Donchian'\ntp = input.float(1.8, 'Take Profit %', minval = 0, step = 0.1, group = 'TAKE PROFIT / TRAILING STOP'\ntrailOffset = input.float(0.3, 'Trail offset %', minval = 0, step = 0.1, group = 'TAKE PROFIT / TRAILING STOP'\n// \u2014\u2014\u2014\u2014\u2014 TP Donchian Channel Input\n// Define Donchian Channel period for take profit option\nDClength = input.int(52, title='Donchian Channel Period', minval = 1, group='TAKE PROFIT / TRAILING STOP'\n// \u2014\u2014\u2014\u2014\u2014 Stop Loss input\n// Define stop loss options and parameters\nSL_options = input.string('Both', 'Stop Loss Option', options = ['Normal', 'ATR', \nsl = input.float(9.0, 'Stop Loss %', minval = 0, step = 0.5, group = 'STOP LOSS', \n// \u2014\u2014\u2014\u2014\u2014 SL ATR Inputs\n// Define ATR period and multiplier for ATR stop loss option\natrPeriodSl = input.int(14, title='ATR Period', minval = 0, group='STOP LOSS', tooltip\nmultiplierPeriodSl = input.float(13.5, 'ATR Multiplier', minval = 0, step = 0.5, group\n// \u2014\u2014\u2014\u2014\u2014 Risk input\n// Define maximum risk percentage\nRisk = input.float(5, 'Max. Risk %', tooltip = \"Set the maximum percentage of account balance you\n// \u2014\u2014\u2014\u2014\u2014 Pyramiding\n// Define pyramiding options and parameters\nPyr = input.int(3, 'Max. Pyramiding', tooltip = \"Set the maximum number of trades you are willing \nStepEntry = input.string('Incremental', 'Step Entry Mode', tooltip = \"Select the way you want to add new trades\"\nbbBetterPrice = input.float(1.1, 'Min. Better Price %', tooltip = \"Set the minimum better price percentage you want \n// \u2014\u2014\u2014\u2014\u2014 Backtest input\n// Setting the start date for the backtesting period as January 1, 2000 at 1:00 UTC\nStartDate = timestamp('01 Jan 2000 01:00 +000')\n// Setting the start of the trading period for the backtest, using the start date above as the defau\ntestPeriodStart = input.time(StartDate, 'Start of Trading', tooltip = \"Set the start date and time of the backtesting pe\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Average Price Variable\n// Setting the average price variable to the close price of each candle, and using the strategy's av\nfloat AveragePrice = close\nAveragePrice := nz(strategy.position_avg_price, close)\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Exponential Moving Average\n// Calculating the slow and fast Exponential Moving Averages (EMAs) using the close price\nsEMA = ta.ema(close, sEma_Length)\nfEMA = ta.ema(close, fEma_Length)\n// Setting the conditions for a long or short signal based on the relationship between the fast and \nbool EMA_longCond = na\nbool EMA_shortCond = na\nEMA_longCond := fEMA > sEMA and sEMA > sEMA[1]\nEMA_shortCond := fEMA < sEMA and sEMA < sEMA[1]\n// Plotting the EMAs on the chart and coloring them based on the long and short conditions\nEMA_color = EMA_longCond ?  color.new(color.green, 50) : EMA_shortCond ?  color.new\nplot(sEMA, 'Slow EMA', EMA_color, 3)\nplot(fEMA, 'Fast EMA', EMA_color, 2)\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 ADX\n// Calculating the Directional Indicator Plus (+DI), Directional Indicator Minus (-DI), and Average \n[DIPlus, DIMinus, ADX] = ta.dmi(ADX_len, ADX_smo)\n// Setting the conditions for a long or short signal based on the relationship between +DI and -DI a\nbool ADX_longCond = na\nbool ADX_shortCond = na\nADX_longCond := DIPlus > DIMinus and ADX > th\nADX_shortCond := DIPlus < DIMinus and ADX > th\n// Coloring the bars on the chart based on the long and short conditions\nADX_color = ADX_longCond ?  color.new(color.green, 25) : ADX_shortCond ?  color.new\nbarcolor(color = ADX_color, title = 'ADX')\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 SAR\n// Calculating the Parabolic SAR (SAR) based on the parameters set for step, max, and acceleration f\nSAR = ta.sar(Sst, Sinc, Smax)\n// Setting the conditions for a long or short signal based on the relationship between the SAR value\nbool SAR_longCond = na\nbool SAR_shortCond = na\nSAR_longCond := SAR < close\nSAR_shortCond := SAR > close\n// Plotting the SAR on the chart and coloring it based on the long and short conditions\nplot(SAR, 'SAR', SAR_longCond ?  color.new(color.green, 50) :  color.new(color.red\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 MACD\n// Calculating the Moving Average Convergence Divergence (MACD) and its signal line, as well as the \n// Define three variables lMACD, sMACD, and hist by calling the ta.macd() function using the 'close'\n[lMACD, sMACD, hist] = ta.macd(close, fastLength, slowLength, signalLength)\n// \u2014\u2014\u2014\u2014\u2014 MAC-Z calculation\n// Define a function calc_zvwap(pds) that calculates the z-score of the volume-weighted average pric\ncalc_zvwap(pds) =>\n    mean = math.sum(volume * close, pds) / math.sum(volume, pds) \n    vwapsd = math.sqrt(ta.sma(math.pow(close - mean, 2), pds))\n    (close - mean) / vwapsd\n// Define float variables\nfloat zscore = na\nfloat fastMA = na\nfloat slowMA = na\nfloat macd = na\nfloat macz = na\nfloat signal = na\nfloat histmacz = na\n// Call the function calc_zvwap(lengthz) to calculate the z-score of the VWAP for a given period 'le\nzscore := calc_zvwap(lengthz)\n// Calculate the simple moving averages of the 'close' prices using 'fastLength' and 'slowLength' pe\nfastMA := ta.sma(close, fastLength)\nslowMA := ta.sma(close, slowLength)\n// Assign the 'lMACD' variable to 'macd'\nmacd := lMACD\n// Calculate 'macz' by multiplying the z-score by a constant 'A', \n// adding the 'macd' value, and dividing by the product of the standard deviation of the 'close' pri\nmacz := (zscore * A) + (macd / (ta.stdev(close, lengthStdev) * B))\n// Calculate the simple moving average of the 'macz' values over a period 'signalLength' and assign \nsignal := ta.sma(macz, signalLength)\n// Calculate the difference between 'macz' and 'signal' and assign it to 'histmacz'\nhistmacz := macz - signal\n// \u2014\u2014\u2014\u2014\u2014 MACD conditions\n// Define two boolean variables 'MACD_longCond' and 'MACD_shortCond'\nbool MACD_longCond = na\nbool MACD_shortCond = na\n// If 'MACD_options' is equal to 'MACD', check if the 'hist' value is greater than 0 and assign the \n// otherwise, check if 'histmacz' is greater than 0 and assign the result to 'MACD_longCond'\nMACD_longCond := MACD_options == 'MACD' ? hist > 0 : histmacz > 0\n// If 'MACD_options' is equal to 'MACD', check if the\nMACD_shortCond :=  MACD_options == 'MACD' ? hist < 0 : histmacz < 0\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Bollinger Bands\n// \u2014\u2014\u2014\u2014\u2014 BB calculation\n// Calculates the middle, upper and lower bands using the Bollinger Bands technical analysis indicat\n[BB_middle, BB_upper, BB_lower] = ta.bb(close, BB_Length, BB_mult)\n// \u2014\u2014\u2014\u2014\u2014 Bollinger Bands width\n// Calculates the width of the Bollinger Bands\nfloat BB_width = na\nBB_width := (BB_upper - BB_lower) / BB_middle\n// \u2014\u2014\u2014\u2014\u2014 Long Bollinger Bands conditions\n// Defines the conditions for entering a long position using Bollinger Bands\n// New Longs\nbool BB_long01 = na\nBB_long01 := Position != 'Short' and not ADX_shortCond and ta.crossunder(low, BB_lower\n// Pyramiding Longs\nbool BB_long02 = na\nBB_long02 := Position != 'Short' and not ADX_shortCond and ta.crossunder(low, BB_lower\n// \u2014\u2014\u2014\u2014\u2014 Short Bollinger Bands conditions\n// Defines the conditions for entering a short position using Bollinger Bands\n// New Shorts\nbool BB_short01 = na\nBB_short01 := Position != 'Long' and not ADX_longCond and ta.crossover(high, BB_upper\n// Pyramiding Shorts\nbool BB_short02 = na\nBB_short02 := Position != 'Long' and not ADX_longCond and ta.crossover(high, BB_upper\n// \u2014\u2014\u2014\u2014\u2014 Bollinger Bands plotting\n// Plots the Bollinger Bands on the chart.\nu_BB = plot(BB_upper, 'Upper Bollinger Band', EMA_color, 2)\nl_BB = plot(BB_lower, 'Lower Bollinger Band', EMA_color, 2)\nfill(u_BB, l_BB, title = 'Bollinger Band Background', color = fEMA > sEMA ?  color.new\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Volume\n// Defines conditions for long and short positions based on volume\nbool VOL_longCond = na\nbool VOL_shortCond = na\nVOL_longCond := volume > ta.sma(volume, sma_Length) * volume_f\nVOL_shortCond := VOL_longCond\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Strategy\n// Defines the long and short conditions for entering a trade based on multiple indicators and volum\nbool longCond = na\nlongCond := Position != 'Short' and EMA_longCond and ADX_longCond and SAR_longCond\nbool shortCond = na\nshortCond := Position != 'Long' and EMA_shortCond and ADX_shortCond and SAR_shortCond\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Take Profit\n// \u2014\u2014\u2014\u2014\u2014 Donchian Channels Calculation\n// Calculates the Donchian Channels for determining take profit levels\nfloat DClower = na\nfloat DCupper = na\nfloat DCbasis = na\nDClower := ta.lowest(DClength)\nDCupper := ta.highest(DClength)\nDCbasis := math.avg(DCupper, DClower)\n// \u2014\u2014\u2014\u2014\u2014 Take Profit Conditions\n// Determines the take profit levels based on the selected options\nfloat longPriceProfit = na\nfloat shortPriceProfit = na\nif TP_options == 'Both'\n// Calculate the long and short take profit levels if both options are selected\n    longPriceProfit := math.max(DCupper, (1 + (tp / 100)) * AveragePrice)\n    shortPriceProfit := math.min(DClower, (1 - (tp / 100)) * AveragePrice)\nelse if TP_options == 'Normal'\n// Calculate the normal take profit levels if that option is selected\n    longPriceProfit := (1 + (tp / 100)) * AveragePrice\n    shortPriceProfit := (1 - (tp / 100)) * AveragePrice\nelse if TP_options == 'Donchian'\n// Calculate the Donchian take profit levels if that option is selected\n    longPriceProfit := math.max(DCupper, AveragePrice)\n    shortPriceProfit := math.min(DClower, AveragePrice)\n// \u2014\u2014\u2014\u2014\u2014 Take Profit Plotting\n// Plot the take profit levels on the chart\nplot(strategy.position_size > 0 ? longPriceProfit : strategy.position_size < 0 ? shortPriceProfit\n 'Take Profit', strategy.position_size > 0 ?  color.new(color.blue, 30) :  color.new\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 ATR Stop Loss\n// \u2014\u2014\u2014\u2014\u2014 ATR Calculation\n// Calculate the ATR stop loss levels\nfloat ATR_SL_Long = low - ta.atr(atrPeriodSl) * multiplierPeriodSl\nfloat ATR_SL_Short = high + ta.atr(atrPeriodSl) * multiplierPeriodSl\nfloat longStopPrev = nz(ATR_SL_Long[1], ATR_SL_Long)\nfloat shortStopPrev = nz(ATR_SL_Short[1], ATR_SL_Short)\nATR_SL_Long := open > longStopPrev ? math.max(ATR_SL_Long, longStopPrev) : ATR_SL_Long\nATR_SL_Short := open < shortStopPrev ? math.min(ATR_SL_Short, shortStopPrev) : ATR_SL_Short\n// \u2014\u2014\u2014\u2014\u2014 Price Stop\n// Calculate the price stop levels\nfloat longPriceStop = na\nfloat shortPriceStop = na\nif SL_options == 'Both'\n// Calculate the long and short price stop levels if both options are selected\n    longPriceStop := math.max(ATR_SL_Long, (1 - (sl / 100)) * AveragePrice)\n    shortPriceStop := math.min(ATR_SL_Short, (1 + (sl / 100)) * AveragePrice)\nelse if SL_options == 'Normal'\n// Calculate the normal price stop levels if that option is selected\n    longPriceStop := (1 - (sl / 100)) * AveragePrice\n    shortPriceStop := (1 + (sl / 100)) * AveragePrice\nelse if SL_options == 'ATR'\n// Calculate the ATR price stop levels if that option is selected\n    longPriceStop := ATR_SL_Long\n    shortPriceStop := ATR_SL_Short\n// \u2014\u2014\u2014\u2014\u2014 Variable Stop Loss %\n// Calculate the variable stop loss percentage levels\nfloat slPercentLong = na\nslPercentLong := (math.max(0, (AveragePrice - longPriceStop)) / AveragePrice) * 100\nfloat slPercentShort = na\nslPercentShort := (math.max(0, (shortPriceStop - AveragePrice)) / AveragePrice) * \n// \u2014\u2014\u2014\u2014\u2014 Stop Loss plotting\n// Plots the stop loss level based on the current position size and whether it's a long or short pos\n// Uses circles to visualize the stop loss level\nplot(strategy.position_size > 0 ? longPriceStop : strategy.position_size < 0 ? shortPriceStop\n 'Stop Loss', strategy.position_size > 0 ?  color.new(color.aqua, 80) :  color.new\n// \u2014\u2014\u2014\u2014\u2014 Average price plotting\n// Plots the average price of the current position, using a cross to visualize the price level\n// Uses different colors depending on whether it's a long or short position\nplot(ta.change(strategy.position_avg_price) ? strategy.position_avg_price : na,\n 'Average price', strategy.position_size > 0 ?  color.new(color.aqua, 20) :  color.new\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Backtest\n// Define the variable \"Equity\" and assign it the value of \"strategy.equity\"\nfloat Equity = strategy.equity\n// Define the variable \"Balance\" and assign it the sum of \"strategy.initial_capital\" and \"strategy.n\nfloat Balance = strategy.initial_capital + strategy.netprofit\n// Define the variable \"RealizedPnL\" and assign it the value of \"strategy.netprofit\"\nfloat RealizedPnL = strategy.netprofit\n// Define the variable \"Floating\" and assign it the value of \"strategy.openprofit\"\nfloat Floating = strategy.openprofit\n// Calculate the percentage of \"Floating\" relative to \"Balance\" and assign it to \"PFloating\"\nfloat PFloating = (Floating / Balance) * 100\n// Calculate the percentage of \"RealizedPnL\" relative to \"strategy.initial_capital\" and assign it to\nfloat PRealizedPnL = (RealizedPnL / strategy.initial_capital) * 100\n// Calculate the sum of \"Floating\" and \"RealizedPnL\" and assign it to \"URealizedPnL\"\nfloat URealizedPnL = Floating + RealizedPnL\n// Calculate the percentage of \"URealizedPnL\" relative to \"strategy.initial_capital\" and assign it t\nfloat PURealizedPnL = ((URealizedPnL) / strategy.initial_capital) * 100\n// Calculate the profit factor by dividing \"strategy.grossprofit\" by \"strategy.grossloss\" and assign\nfloat ProfitFactor = strategy.grossprofit / strategy.grossloss\n// Calculate the position size by multiplying \"strategy.position_size\" and \"strategy.position_avg_pr\nfloat PositionSize = strategy.position_size * strategy.position_avg_price\n// Calculate the cash by subtracting the product of \"nz(PositionSize)\" and \"marginRate\" from \"Balanc\nfloat Cash = Balance\n// Calculate the profitability by dividing \"strategy.wintrades\" by the sum of \"strategy.wintrades\" a\nfloat Profitability = (strategy.wintrades / (strategy.wintrades + strategy.losstrades\n// Calculate the leverage parameter by dividing the absolute value of \"PositionSize\" by \"Balance\" an\nfloat LeverageParameter = math.abs(nz(PositionSize / Balance))\n// Calculate the trading time by subtracting \"strategy.closedtrades.entry_time(0)\" from \"time_close\"\nint TradingTime = time_close - strategy.closedtrades.entry_time(0)\n// \u2014\u2014\u2014\u2014\u2014 Creating the Table\n// Create a table with a specific format and assign it to a variable\nvar InfoPanel = table.new(position.bottom_left, 2, 10, border_width = 1)\n// Define a function for the table formatting\nftable(_table_id, _column, _row, _text, _bgcolor) =>\n    table.cell(_table_id, _column, _row, _text, 0, 0,  color.black, text.align_left\n// Function to convert time in milliseconds to string format\ntfString(int timeInMs) =>\n    // convert to seconds\n    float s = timeInMs / 1000\n    // convert to minutes     \n    float m = s / 60\n    // convert to hours            \n    float h = m / 60\n    // convert to days          \n    float d = h / 24\n    // convert to months      \n    float mo = d / 30.416\n    // get minutes     \n    int tm = math.floor(m % 60)\n    // get hours \n    int tr = math.floor(h % 24)\n    // get days\n    int td = math.floor(d % 30.416)\n    // get months\n    int tmo = math.floor(mo % 12)\n    // get years\n    int ys = math.floor(d / 365)    \n    // Format the time in the appropriate string format\n    string result = switch\n        // if time interval is 1 month, return \"1M\"\n        d == 30 and tr == 10 and tm == 30 => \"1M\" \n        // if time interval is 1 week, return \"1W\"\n        d == 7  and tr == 0  and tm == 0  => \"1W\" \n        =>\n            // get the years string\n            string  yStr  = ys  ? str.tostring(ys)  + \"Y \"  : \"\"\n            // get the months string\n            string  moStr = tmo ? str.tostring(tmo) + \"M \"  : \"\"\n            // get the days string\n            string  dStr  = td  ? str.tostring(td)  + \"D \"  : \"\"\n            // get the hours string\n            string  hStr  = tr  ? str.tostring(tr)  + \"H \"  : \"\"\n            // get the minutes string\n            string  mStr  = tm  ? str.tostring(tm)  + \"min\" : \"\"\n            // concatenate all the strings to get the final result string\n            yStr + moStr + dStr + hStr + mStr\n// This code is using the ftable function to create a table of information in a panel.\n// Display equity information in the info panel using the ftable function\nftable(InfoPanel, 0, 0, 'Equity: ',  #9598a1)\n// Display current position information in the info panel using the ftable function\nftable(InfoPanel, 0, 1, 'Position: ',  #9598a1)\n// Display available cash information in the info panel using the ftable function\nftable(InfoPanel, 0, 2, 'Cash: ',  #9598a1)\n// Display floating profit/loss information in the info panel using the ftable function\nftable(InfoPanel, 0, 3, 'Floating: ',  #9598a1)\n// Display realized profit/loss information in the info panel using the ftable function\nftable(InfoPanel, 0, 4, 'Realized PnL: ' ,  #9598a1)\n// Display unrealized profit/loss information in the info panel using the ftable function\nftable(InfoPanel, 0, 5, 'Unrealized PnL: ' ,  #9598a1)\n// Display leverage information in the info panel using the ftable function\nftable(InfoPanel, 0, 6, 'Leverage: ' ,  #9598a1)\n// Display profitability information in the info panel using the ftable function\nftable(InfoPanel, 0, 7, 'Profitability: ' ,  #9598a1)\n// Display profit factor information in the info panel using the ftable function\nftable(InfoPanel, 0, 8, 'Profit Factor: ' ,  #9598a1)\n// Display trading time information in the info panel using the ftable function\nftable(InfoPanel, 0, 9, 'Time of Trading: ',  #9598a1)\n// Display equity value with currency information in the info panel using the ftable function\nftable(InfoPanel, 1, 0, str.tostring(Equity, '#.##') + ' ' + syminfo.currency, Equity\n// Display position size with base currency information in the info panel using the ftable function\nftable(InfoPanel, 1, 1, str.tostring(strategy.position_size, '#.#####') + ' ' + syminfo.basecurrency\n// Display available cash with currency information in the info panel using the ftable function\nftable(InfoPanel, 1, 2, str.tostring(Cash, '#.##') + ' ' + syminfo.currency, Cash \n// Display percentage of floating profit/loss information in the info panel using the ftable functio\nftable(InfoPanel, 1, 3, str.tostring(PFloating, '#.##') + ' %', PFloating >= 0 ?  \n// Display percentage of realized profit/loss information in the info panel using the ftable functio\nftable(InfoPanel, 1, 4, str.tostring(PRealizedPnL, '#.##') + ' %' , PRealizedPnL >=\n// Display percentage of unrealized profit/loss information in the info panel using the ftable funct\nftable(InfoPanel, 1, 5, str.tostring(PURealizedPnL, '#.##') + ' %', PURealizedPnL \n// Show leverage parameter in the info panel\nftable(InfoPanel, 1, 6, str.tostring(LeverageParameter, '#.##') + ' x', math.round\n// Show profitability percentage in the info panel\nftable(InfoPanel, 1, 7, str.tostring(Profitability, '#.##') + ' %', Profitability \n// Show the profit factor in the info panel\nftable(InfoPanel, 1, 8, str.tostring(ProfitFactor, '#.###'), ProfitFactor >= 1 ?  \n// Show the time of trading in the info panel in human-readable format\nftable(InfoPanel, 1, 9, tfString(TradingTime),  #9598a1)\n// \u2014\u2014\u2014\u2014\u2014 Long / Short quantities according to risk\n// Define a function that calculates the factor sum of a number\nfSum(_Num)=>\n    (math.pow(_Num, 2) + _Num) / 2\n// Calculate long and short quantities based on different scenarios\nfloat QuantityLong = na\nfloat QuantityShort = na\n// The QuantityLong and QuantityShort variables represent the calculated position sizes based on dif\nif StepEntry == 'Normal'\n    QuantityLong := (1 / Pyr) * (Balance / close) * ((Risk / 100) / (slPercentLong\n    QuantityShort := (1 / Pyr) * (Balance / close) * ((Risk / 100) / (slPercentShort\nelse\n    QuantityLong := ((strategy.opentrades + 1) / (fSum(Pyr))) * (Balance / close) \n    QuantityShort := ((strategy.opentrades + 1) / (fSum(Pyr))) * (Balance / close)\n// \u2014\u2014\u2014\u2014\u2014 Long alert message\n// Define long alert messages with placeholders\nstring LongMessage = na\nLongMessage := '{\"code\": \"ENTER-LONG_OKEX-SWAP__Super-8_30M_1234567890\", \"qty\":\"' \nstring XLongMessage = na\nXLongMessage := '{\"code\": \"EXIT-LONG_OKEX-SWAP__Super-8_30M_1234567890\", \"qty\":\"' \n// \u2014\u2014\u2014\u2014\u2014 Short alert message\n// Define short alert messages with placeholders\nstring ShortMessage = na\nShortMessage := '{\"code\": \"ENTER-SHORT_OKEX-SWAP__Super-8_30M_1234567890\", \"qty\":\"'\nstring XShortMessage = na\nXShortMessage := '{\"code\": \"EXIT-SHORT_OKEX-SWAP__Super-8_30M_1234567890\", \"qty\":\"'\n// The LongMessage and ShortMessage variables are strings that define the alert messages for the lon\n// including placeholders for dynamic values like the current close price and the calculated positio\n// The XLongMessage and XShortMessage variables represent messages to close out long and short posit\n// Copy and paste this message on the alert box:\n// {{strategy.order.alert_message}}\n// Copy and paste this url on the WebHook box:\n// https://wundertrading.com/bot/exchange \n// \u2014\u2014\u2014\u2014\u2014 Entering long positions\n// Check if it's time to start the test period and if there are less open trades than the maximum al\nif time >= testPeriodStart and strategy.opentrades < Pyr\n    // Main long entries\n    // Check if the long condition is met or if the upper Bollinger Band is crossed and if there are no \n    // If the conditions are met, execute the long entry with the desired quantity and alert message\n    if  (longCond or BB_long01) and strategy.opentrades == 0\n     or (longCond or BB_long01) and strategy.position_size < 0\n     or (longCond or BB_long01) and close < strategy.opentrades.entry_price(strategy.opentrades\n        strategy.order('Long', strategy.long, qty = QuantityLong, alert_message = \n    // BB long entries\n    // Check if the upper Bollinger Band is crossed and a long position is already open and if the price\n    // If the conditions are met, execute the long entry with the desired quantity and alert message\n    if BB_long02 and strategy.position_size > 0\n     and close < strategy.opentrades.entry_price(strategy.opentrades - 1) * (1 - (\n        strategy.order('Long', strategy.long, qty = QuantityLong, alert_message = \n// \u2014\u2014\u2014\u2014\u2014 Entering short positions\n// Check if it's time to start the test period and if there are less open trades than the maximum al\nif time >= testPeriodStart and strategy.opentrades < Pyr\n    // Main short entries\n    // Check if the short condition is met or if the lower Bollinger Band is crossed and if there are no\n    // If the conditions are met, execute the short entry with the desired quantity and alert message\n    if  (shortCond or BB_short01) and strategy.opentrades == 0\n     or (shortCond or BB_short01) and strategy.position_size > 0\n     or (shortCond or BB_short01) and close > strategy.opentrades.entry_price(strategy.opentrades\n        strategy.order('Short', strategy.short, qty = QuantityShort, alert_message\n    // BB short entries\n    // Check if the lower Bollinger Band is crossed and a short position is already open and if the pric\n    // If the conditions are met, execute the short entry with the desired quantity and alert message\n    if BB_short02 and strategy.position_size < 0\n     and close > strategy.opentrades.entry_price(strategy.opentrades - 1) * (1 + (\n        strategy.order('Short', strategy.short, qty = QuantityShort, alert_message\n// \u2014\u2014\u2014\u2014\u2014 Closing positions with first long TP\n// Check if there is a long position open\nif strategy.position_size > 0\n    // If there is, check if a trailing offset is set\n    if trailOffset > 0\n    // If there is a trailing offset, execute the exit with a trailing stop\n        strategy.exit('TPl', 'Long', trail_price = longPriceProfit, \n                                     trail_offset = ((trailOffset / 100) * high) /\n                                     stop = longPriceStop, \n                                     comment_profit = 'TPl', \n                                     comment_loss = 'SLl', alert_message = XLongMessage\n    else\n    // If there is no trailing offset, execute the exit with a limit and stop loss\n        strategy.exit('TPl', 'Long', limit = longPriceProfit, \n                                     stop = longPriceStop, \n                                     comment_profit = 'TPl', \n                                     comment_loss = 'SLl', \n                                     alert_message = XLongMessage)\n// \u2014\u2014\u2014\u2014\u2014 Canceling long exit orders to avoid simultaneity with re-entry\n// This code block cancels any previously set long exit orders if the Bollinger Bands indicate a pot\nif BB_long02 and strategy.position_size > 0\n    strategy.cancel('TPl')\n// \u2014\u2014\u2014\u2014\u2014 Closing positions with first short TP\n// This code block checks if the strategy has a short position and if so, it closes it with a traili\nif strategy.position_size < 0\n    if trailOffset > 0\n        strategy.exit('TPs', 'Short', trail_price = shortPriceProfit, \n                                      trail_offset = ((trailOffset / 100) * low) /\n                                      stop = shortPriceStop, \n                                      comment_profit = 'TPs', \n                                      comment_loss = 'SLs', \n                                      alert_message = XShortMessage)\n    else\n        strategy.exit('TPs', 'Short', limit = shortPriceProfit, \n                                      stop = shortPriceStop, \n                                      comment_profit = 'TPs', \n                                      comment_loss = 'SLs', \n                                      alert_message = XShortMessage)\n// \u2014\u2014\u2014\u2014\u2014 Canceling short exit orders to avoid simultaneity with re-entry\n// This code block cancels any previously set short exit orders if the Bollinger Bands indicate a po\nif BB_short02 and strategy.position_size < 0\n    strategy.cancel('TPs')"}]}
{"messages": [{"role": "user", "content": "Release Notes:                        New filter for the strategy: Rsi Sometimes some positions could be closed due to breakeven and then we loose a trend move. For this reason I decided to add this filter for re enter on the movement:  If close is still in a Up Trend (this is given by the SuperTrend indicator), Rsi crosses above oversold zone and the previous position was closed by breakeven, we enter into a long position again, using a new stop loss given by atr stoploss and also a breakeven/take profit of 0.75 points of risk/reward If close is still in a Down Trend (this is given by the SuperTrend indicator), Rsi crosses under overbought zone and the previous position was closed by breakeven, we enter into a short position again, using a new stop loss given by atr stoploss and also a breakeven/take profit of 0.75 points of risk/reward  Strategy as an indicator:  Green and Red triangles added as long or short signals Green point added for showing first Take profit and Break even price White point added for showing Stop loss price  Do not forget you can deactivate trades on chart in style options for getting a cleaner view of the strategy.                                                    Release Notes:                                                    Some bugs fixed                                                    Release Notes:                        Position calculator added In settings, you can enter the amount in usd of your account and the amount in percentage for risking per trade of the account. You will see this value in green color in the upper left corner that shows the amount in usd to use for risking the specific percentage of your account.                             Release Notes:                                                    A simple change. Now you can choose what\u00b4s the stop loss source :)"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Developed by \u00a9 StrategiesForEveryone\n//@version=5\nstrategy(\"SuperTrend Strategy with Rsi filter for BTCUSD 4H\", overlay=true, process_orders_on_close\n// ------ Inputs for calculating position --------\ninitial_actual_capital = input.float(defval=100, title = \"Enter initial/current capital\"\nrisk_c = input.float(2.5, '% account risk per trade', step=1, group = \"Calculate position\"\n// ------ Date filter (obtained from ZenAndTheArtOfTrading) ---------\ninitial_date = input.time(title=\"Initial date\", defval=timestamp(\"10 Feb 2014 13:30 +0000\"\nfinal_date   = input.time(title=\"Final date\", defval=timestamp(\"01 Jan 2030 19:30 +0000\"\ndateFilter(int st, int et) => time >= st and time <= et\ncolorDate = input.bool(defval=false, title=\"Date background\", tooltip = \"Add color to the period of time of the strategy t\nbgcolor(colorDate and dateFilter(initial_date, final_date) ? color.new( color.blue\n// --------------- Rsi filter------------------\noverbought = input.int(70, title='Over bought line rsi', minval=50, maxval=100, group\noversold = input.int(30, title='Over sold line rsi', minval=0, maxval=50, group = \nperiods = input.int(6, title='Rsi Length', minval=1, maxval=200, group = \"Rsi\", inline\nrsi_filter = ta.rsi(close, periods)\nshow_rsi = input.bool(defval = false, title = \"Show Rsi ?\", group = \"Appearance\")\nplot(show_rsi ? rsi_filter : na, title = \"Rsi\", color =  color.rgb(255, 255, 255)\nhline(show_rsi ? overbought : na, color= color.rgb(0, 132, 255))\nhline(show_rsi ? oversold : na, color= color.rgb(0, 132, 255))\n// ------------ Super Trend ----------\natrPeriod = input(9, \"ATR Length SuperTrend\")\nfactor = input.float(2.5, \"Factor SuperTrend\", step = 0.05)\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\nshow_supertrend = input.bool(defval = false, title=\"Show supertrend ?\", group = \"Appearance\"\nbodyMiddle = plot(show_supertrend ? ((open + close) / 2) : na, display=display.none\nupTrend = plot(show_supertrend and direction < 0 ? supertrend : na, \"Up Trend\", color\ndownTrend = plot(show_supertrend and direction > 0 ? supertrend : na, \"Down Trend\"\nfill(bodyMiddle, upTrend,  color.new(color.green, 95), fillgaps=false, title = \"Supertrend background\"\nfill(bodyMiddle, downTrend,  color.new(color.red, 95), fillgaps=false, title = \"Supertrend background\"\nup_trend_plot = direction < 0\ndown_trend_plot = direction > 0\n// ---------- Atr stop loss (obtained from garethyeo)\nlong_rsi_plot = ta.crossover(rsi_filter, oversold) and up_trend_plot\nshort_rsi_plot = ta.crossunder(rsi_filter, overbought) and down_trend_plot\nlong_supertrend_plot=ta.crossover(close, supertrend)\nshort_supertrend_plot=ta.crossunder(close, supertrend)\nsource_atr = input(close, title='Source', group = \"Atr stop loss\", inline = \"A\")\nlength_atr = input.int(14, minval=1, title='Period', group = \"Atr stop loss\" , inline\nmultiplier = input.float(1.5, minval=0.1, step=0.1, title='Atr multiplier', group \nshortStopLoss = source_atr + ta.atr(length_atr) * multiplier\nlongStopLoss = source_atr - ta.atr(length_atr) * multiplier\nshow_stoploss = input.bool(defval=true, title=\"Draw stop loss ?\", group = \"Appearance\"\n// --------- Stop loss based in last swing high/low --------\nhigh_bars = input.int(defval = 10, title = \"Highest price bars: \", group = \"Swing highs/lows stop losses\"\nlow_bars = input.int(defval = 10, title = \"Lowest price bars: \", group = \"Swing highs/lows stop losses\"\nstop_high = ta.highest(high, high_bars)\nstop_low = ta.lowest(low, low_bars)\n// --------- Stop loss source selection ---------------\nstoploss_type = input.string(defval = \"Atr stop loss\", title = \"Stop loss source\",\nif stoploss_type == \"Atr stop loss\"\n    shortStopLoss := source_atr + ta.atr(length_atr) * multiplier\n    longStopLoss := source_atr - ta.atr(length_atr) * multiplier\nif stoploss_type == \"Swing high/low\"\n    shortStopLoss := stop_high\n    longStopLoss := stop_low\n// Ploting stop losses\nplot(show_stoploss and long_supertrend_plot or show_stoploss and long_rsi_plot ? longStopLoss\nplot(show_stoploss and short_supertrend_plot or show_stoploss and short_rsi_plot ?\n// ------------- Money management --------------\nstrategy_contracts = strategy.equity / close\ndistance_sl_atr_long = -1 * (longStopLoss - close) / close\ndistance_sl_atr_short = (shortStopLoss - close) / close\nrisk = input.float(2.5, '% Account risk per trade for backtesting', step=1, group \nlong_amount = strategy_contracts * (risk / 100) / distance_sl_atr_long\nshort_amount = strategy_contracts * (risk / 100) / distance_sl_atr_short\n// ---------- Risk management ---------------\nrisk_reward_breakeven_long= input.float(title=\"Risk/reward for breakeven long\", defval\nrisk_reward_take_profit_long= input.float(title=\"Risk/reward for take profit long\"\nrisk_reward_breakeven_short= input.float(title=\"Risk/reward for break even short\",\nrisk_reward_take_profit_short= input.float(title=\"Risk/reward for take profit short\"\ntp_percent=input.float(title=\"% of trade for first take profit\", defval=50, step=5\n// ------------ Trade conditions ---------------\nuse_rsi_filter = input.bool(defval=true, title=\"Use Re-entry filter ?\", group = \"Re-entry filter\"\nbought = strategy.position_size > 0\nsold = strategy.position_size < 0\nup_trend = direction < 0\ndown_trend = direction > 0\nlong_rsi_entry = ta.crossover(rsi_filter, oversold) and up_trend and strategy.openprofit\nshort_rsi_entry = ta.crossunder(rsi_filter, overbought) and down_trend and strategy.openprofit\nlong_supertrend=ta.crossover(close, supertrend)\nshort_supertrend=ta.crossunder(close, supertrend)\nvar float sl_long = na\nvar float sl_short = na \nvar float be_long = na\nvar float be_short = na\nvar float tp_long = na\nvar float tp_short = na\nif not bought\n    be_long:=na\n    sl_long:=na\n    tp_long:=na\nif not sold\n    be_short\n    sl_short:=na\n    tp_short\nlong_positions = input.bool(defval = true, title = \"Long positions ?\", group = \"Positions management\"\nshort_positions = input.bool(defval = true, title = \"Short positions ?\", group = \"Positions management\"\n// ---------- Strategy -----------\n// Long position \nif not bought and long_supertrend and dateFilter(initial_date, final_date) and long_positions\n    sl_long:=longStopLoss           \n    long_stoploss_distance = close - longStopLoss\n    be_long := close + long_stoploss_distance * risk_reward_breakeven_long\n    tp_long:=close+(long_stoploss_distance*risk_reward_take_profit_long)\n    strategy.entry('L', strategy.long, long_amount, alert_message = \"Long\")\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and high > be_long\n    sl_long := strategy.position_avg_price\n    strategy.exit(\"Tp\", \"L\", stop=sl_long, limit=tp_long, qty_percent=tp_percent)\n    strategy.exit('Exit', 'L', stop=sl_long)\nif bought and short_supertrend\n    strategy.close(\"L\", comment=\"CL\")\n// Short position\nif not sold and short_supertrend and dateFilter(initial_date, final_date) and short_positions\n    sl_short:=shortStopLoss\n    short_stoploss_distance=shortStopLoss - close  \n    be_short:=((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\n    tp_short:=((short_stoploss_distance*risk_reward_take_profit_short)-close)*-1\n    strategy.entry(\"S\", strategy.short, short_amount, alert_message = \"Short\")\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)\nif sold and low < be_short \n    sl_short:=strategy.position_avg_price\n    strategy.exit(\"Tp\", \"S\", stop=sl_short, limit=tp_short, qty_percent=tp_percent\n    strategy.exit(\"Exit\", \"S\", stop=sl_short)    \nif sold and long_supertrend\n    strategy.close(\"S\", comment=\"CS\") \n// ---------- Draw positions and signals on chart (strategy as an indicator) -------------\nif high>tp_long\n    tp_long:=na\nif low<tp_short\n    tp_short:=na\nif high>be_long\n    be_long:=na\nif low<be_short\n    be_short:=na\nshow_position_on_chart = input.bool(defval=true, title=\"Draw position on chart ?\",\nposition_price = plot(show_position_on_chart? strategy.position_avg_price : na, style\nsl_long_price = plot(show_position_on_chart and bought ? sl_long : na, style = plot.style_linebr\nsl_short_price = plot(show_position_on_chart and sold ? sl_short : na, style = plot.style_linebr\ntp_long_price = plot(strategy.position_size>0 and show_position_on_chart? tp_long \ntp_short_price = plot(strategy.position_size<0 and show_position_on_chart? tp_short\nbreakeven_long = plot(strategy.position_size>0 and high<be_long and show_position_on_chart\nbreakeven_short = plot(strategy.position_size<0 and low>be_short and show_position_on_chart\nshow_break_even_on_chart = input.bool(defval=true, title=\"Draw first take profit/breakeven price on chart ?\nlong_stoploss_distance = close - longStopLoss\nshort_stoploss_distance=shortStopLoss - close\nbe_long_plot = close + long_stoploss_distance * risk_reward_breakeven_long\nbe_short_plot =((short_stoploss_distance*risk_reward_breakeven_short)-close)*-1\nplot(show_break_even_on_chart and long_supertrend_plot or show_break_even_on_chart\nplot(show_break_even_on_chart and short_supertrend_plot or show_break_even_on_chart\nposition_profit_long = plot(bought and show_position_on_chart and strategy.openprofit\nposition_profit_short = plot(sold and show_position_on_chart and strategy.openprofit\nfill(plot1 = position_price, plot2 = position_profit_long, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = position_profit_short, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = sl_long_price, color =  color.new(color.red,\nfill(plot1 = position_price, plot2 = sl_short_price, color =  color.new(color.red\nfill(plot1 = position_price, plot2 = tp_long_price, color =  color.new(color.green\nfill(plot1 = position_price, plot2 = tp_short_price, color =  color.new(color.green\nshow_signals = input.bool(defval=true, title=\"Draw signals on chart ?\", group = \"Appearance\"\nplotshape(show_signals ? long_supertrend : na, style = shape.triangleup, location \nplotshape(show_signals ? short_supertrend : na, style = shape.triangledown, location\nplotshape(show_signals ? long_rsi_entry : na, style = shape.triangleup, location =\nplotshape(show_signals ? short_supertrend : na, style = shape.triangledown, location\n// --------------- Position amount calculator -------------\nleverage_x = input.float(defval = 10, title = \"Leverage X\", group = \"Calculate position\"\ncontracts_amount_c = initial_actual_capital / close\ndistance_sl_long_c = -1 * (longStopLoss - close) / close \ndistance_sl_short_c = (shortStopLoss - close) / close\nlong_amount_c = (close * (contracts_amount_c * (risk_c / 100) / distance_sl_long_c\nshort_amount_c = (close * (contracts_amount_c * (risk_c / 100) / distance_sl_short_c\nplot(long_supertrend or long_rsi_entry ? long_amount_c : na, color =  color.rgb(136\nplot(short_supertrend or short_rsi_entry ? short_amount_c : na, color =  color.rgb"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    update Order size from 50% to 10% of equity,  is usually more realistic for each strategy.                                                    Release Notes:                                                    update script format  and remarks for properties.                                                    Release Notes:                                                    add alert. 1. when in living trading, Enter after freq_once_per_bar_close 2. when in living trading, SL and TP should use freq_once_per_bar 3. you can compare with trade_list of backtest result thx for @jeroenderouw92 feedback. \ud83d\ude80                                                    Release Notes:                                                    fix a mistake"}, {"role": "assistant", "content": "// \u00a9 liwei666\n//@version=5\n// # ========================================================================= #\n// #                   |   Strategy  |\n// # ========================================================================= #\nstrategy(\n title                = \"ATR_RSI_Strategy v2[liwei666]\",\n shorttitle           = \"ATR_RSI_Strategy\",\n overlay              =  true,\n max_lines_count                 =  500, \n max_labels_count                =  500, \n max_boxes_count                 =  500,\n max_bars_back = 5000,\n initial_capital = 10000,\n default_qty_type=strategy.percent_of_equity, \n default_qty_value=10, commission_type=strategy.commission.percent, pyramiding=1, \n commission_value=0.05\n )\n// # ========================================================================= #\n// #                   |   Strategy  |\n// # ========================================================================= #\natr_length  = input.int(26, \"atr_length\", minval = 6, maxval = 100, step=1)\natr_ma_length = input.int(45, \"atr_ma_length\", minval = 6, maxval = 100, step=1)\nrsi_length = input.int(15, \"rsi_length\", minval = 6, maxval = 100, step=1)\nrsi_entry = input.int(10, \"rsi_entry\", minval = 6, maxval = 100, step=1)\natr_ma_norm_min = input.float(0.3, \"atr_ma_norm_min\", minval = 0.1, maxval = 0.5, step\natr_ma_norm_max = input.float(0.7, \"atr_ma_norm_max\", minval = 0.5, maxval = 1, step\ntrailing_percent= input.float(1.5, \"trailing_stop_percent\", minval = 0.1, maxval = \nvar rsi_buy = 50 + rsi_entry\nvar rsi_sell = 50 - rsi_entry\nsma_norm_h_45() => \n    source = high\n    n = 45\n    sma = ta.sma(source, n) \n    sma_norm = (sma - ta.lowest(sma, n)) / (ta.highest(sma,n) - ta.lowest(sma, n))\n    sma_norm\natr_value = ta.atr(atr_length)\natr_ma = ta.sma(atr_value, atr_ma_length) \nrsi_value = ta.rsi(close, length = rsi_length) \natr_ma_norm = atr_ma / close * 100\nsma_norm = sma_norm_h_45()\nvar intra_trade_high = 0.0\nvar intra_trade_low = 0.0\nvar long_sl = 0.0\nvar long_tp = 0.0\nvar short_sl = 0.0\nvar short_tp = 0.0\nif strategy.position_size == 0\n    intra_trade_high := high\n    intra_trade_low := low\n    // when in living trading, enter after freq_once_per_bar_close\n    if atr_ma_norm >= atr_ma_norm_min and atr_ma_norm <= atr_ma_norm_max\n        if atr_value > atr_ma\n            if rsi_value > rsi_buy\n                strategy.entry(\"B1\", strategy.long, limit = close + 5 )\n                alert(\"Long B1\", alert.freq_once_per_bar_close)\n            else if rsi_value < rsi_sell\n                strategy.entry(\"S1\", strategy.short, limit = close - 5 )\n                alert(\"Short S1\", alert.freq_once_per_bar_close)\nelse if strategy.position_size > 0\n    intra_trade_high := math.max(intra_trade_high, high)\n    intra_trade_low := low\n    long_sl := intra_trade_high * (1 - trailing_percent / 100)\n    long_tp := strategy.position_avg_price * 1.03\n    strategy.exit(\"Exit B1\", from_entry=\"B1\", stop = long_sl, limit = long_tp)\nelse if strategy.position_size < 0\n    intra_trade_high := high\n    intra_trade_low := math.min(intra_trade_low, low) \n    short_sl := intra_trade_low * (1 + trailing_percent / 100)\n    short_tp := strategy.position_avg_price * 0.94\n    strategy.exit(\"Exit S1\", from_entry=\"S1\", stop = short_sl, limit = short_tp)\n// when in living trading, SL and TP should use freq_once_per_bar\n// you can compare with trade_list of backtest result\n// long Exit alert\nif strategy.position_size > 0 and low < long_sl\n    alert(\"B1 Stop_loss\", alert.freq_once_per_bar)\nelse if strategy.position_size > 0 and high > long_tp\n    alert(\"B1 Take_profit\", alert.freq_once_per_bar) \n// short Exit alert\nif strategy.position_size < 0 and high > short_sl\n    alert(\"S1 Stop_loss\", alert.freq_once_per_bar)\nelse if strategy.position_size > 0 and low < short_tp\n    alert(\"S1 Take_profit\", alert.freq_once_per_bar)"}]}
{"messages": [{"role": "user", "content": "Open Drive is a market profile concept introduced by Jim Dalton. It occurs when the price moves directionally and persistently for the first 30 minutes from the cash market open. It is necessary\u00a0to use 30-minute bars as there needs to be enough time to measure an extreme move of the cash open. This means there will be fewer trades than other strategies using faster time periodicities. The script finds open drives from these time points 0700/ 0800 and 1300/1430. The entry signal also has a breakout threshold using the 5-bar high and 5-bar low to only take trades moving away from the prior 5-bar range. This weeds out most mid-range trades and small range expansion bars. If the price has had a strong move from the open and has broken either below the prior 5-bar low or above the prior 5-bar high by an amount equal to the prior 5-bar range a trade is entered in the direction of the move. The Exit criteria; exit after 3 bars which is 90mins when using a 30min periodicity. Note, this script is shared to show that momentum generated on or around the cash open tends to persist. The entry and exits of this strategy are quite naive but there are plenty of ways to take more aggressive entries on faster time frames when an open drive occurs. The times chosen for this strategy will suit stock index futures mainly. The user can experiment with other futures products and their corresponding pit/ cash open hours. Google \"open drive market profile\" for more information on open drives and market profile concepts. Happy trading!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Marcns_\n//@version=5\n// a script that highlights open drives around cash market opens throughout the day\n// this indicator identifies the following cash open, open drives 0700 - 0715 / 0800 - 0815 / 1300 -\n// an open drive is when a cash market opens and price runs either up or down away from the opening \n// and often identify a trend session\nstrategy(\"Open Drive\", commission_type =  strategy.commission.cash_per_contract, commission_value\n// open drive filter times - all times GMT\neu_sev = time(timeframe.period, \"0700-0715\", \"GB\")\neu_eig = time(timeframe.period, \"0800-0815\", \"GB\")\nus_one = time(timeframe.period, \"1300-1315\", \"GB\")\nus_two = time(timeframe.period, \"1430-1445\", \"GB\")\n// identify bar that opens at low and closes at high + vice versa \n// bar needs to open at one extreme and close at another \nTrndExThreshold_Open = 0.15\nTrndExThreshold_Close = 0.15\n// add a bar range expansion filter - range of bar correlates to volume, high volume = wider range. \nfbhi = ta.highest(5)\nfblo = ta.lowest(5)\nfbr = (fbhi - fblo)\nRangeEx_up = 0.0\nif high >= (fbhi[1] + fbr[1])\n    RangeEx_up := 1.0\nelse\n    na\n// range ex down\nRangeEx_do = 0.0\nif low <= (fblo[1] - fbr[1]) \n    RangeEx_do := 1.0\nelse\n    na\n//#1 open within 5% of low\nOpenAtLow = 0.0 \nif (close > open) and (open-low) / (high-low) < TrndExThreshold_Open\n    OpenAtLow := 1.0\nelse \n    na \n//#2 close within 5% of high\n    CloseAtHigh = 0.0\nif (close > open) and (high-close) / (high-low) < TrndExThreshold_Close\n    CloseAtHigh := 1.0\nelse\n    na \nOD_Up = 0.0\nif (OpenAtLow + CloseAtHigh + RangeEx_up == 3.0) and ( eu_sev or eu_eig or us_one \n    OD_Up := 1\nelse\n    na\nplot(OD_Up, title = \"OD_up\")\nOpenAtHigh = 0.0 \nif (close < open) and (high-open) / (high-low) < TrndExThreshold_Open\n    OpenAtHigh := 1.0\nelse \n    na \n//#2 close within 5% of high\n    CloseAtLow = 0.0\nif (close < open) and (close-low) / (high-low) < TrndExThreshold_Close\n    CloseAtLow := 1.0\nelse\n    na \nOD_Down = 0.0\nif (OpenAtHigh + CloseAtLow + RangeEx_do == 3.0) and ( eu_sev or eu_eig or us_one \n    OD_Down := -1\nelse\n    na\nplot(OD_Down, title = \"OD_down\", color =  color.red)\n//3sma\nma = ta.sma(close,3)\n// one time framing - highlight bars the make a series of lower highs or higher lows to identify tre\n// one time frame up \notf_u = 0.0\nif close > ma and close[1] > ma[1]\n    otf_u := 1\nelse\n    na\n// one time frame down \notf_d = 0.0\nif close < ma and close[1] < ma[1]\n    otf_d := 1\nelse\n    na\n//bgcolor(otf_u ? color.rgb(76, 175, 79, 70) : na)\n//bgcolor(otf_d ? color.rgb(255, 82, 82, 66) : na)\n// record high and low of entry bar into variable for absolute stop\n// buy stop\nbs = 0.0\nif OD_Up\n    bs := low[1]\nelse\n    na\n// sell stop\nss = 0.0\nif OD_Down\n    ss := high[1]\nelse\n    na\n// strategy entry and exits \n// long\nif OD_Up\n    strategy.entry(\"el\", strategy.long, 2)\nif ta.barssince(OD_Up)> 3 \n    strategy.exit(id = \"ex\" , from_entry = \"el\", limit = close)\n// short \nif OD_Down\n    strategy.entry(\"es\", strategy.short, 2)\nif ta.barssince(OD_Down)> 3\n    strategy.exit(id = \"ex\" , from_entry = \"es\", limit = close)"}]}
{"messages": [{"role": "user", "content": "We are presenting you feature for strategies in Pine Script. This function/pine script is about NOT opening trades on selected days. Real usage is for bank holidays or volatile days (PPI, CPI, Interest Rates etc.) in United States and United Kingdom from 2020 to 2030 (10 years of dates of bank holidays in mentioned countries above). Strategy is simple - SMA crossover of two lengts 14 and 28 with close source. In pine script you can see we picked US and GB bank holidays. If you add this into your strategy, your bot will not open trades on those days. You must make it a rule or a condition. We use it as a rule in opening long/short trades.  You can also add some of your prefered dates, here is just example of our idea. If you want to add your preffered days you can find them on any site like forexfactory, myfxbook and so on. But don\u2019t forget to add function \u201ctime_tradingday ! = YourChoosedDate\u201d as it is writen lower in the pine script. Sometimes the date is substituted for a different day, because the day of the holiday is on Saturday or Sunday. Made with \u2764\ufe0f for this community. If you have any questions or suggestions, let us know. The script is for informational and educational purposes only. Use of the script does not constitutes professional and/or financial advice. You alone the sole responsibility of evaluating the script output and risks associated with the use of the script. In exchange for using the script, you agree not to hold zeusbottrading TradingView user liable for any possible claim for damages arising from any decision you make based on use of the script."}, {"role": "assistant", "content": "//Made by @zeusbottrading with <3\n//@version=5\nstrategy(\"Selected Dates Filter by @zeusbottrading\", overlay=true)\n//USA Holidays\n_0_1UdateNYdayO = timestamp(2020,1,1)\n_0_2UdateMartinLuther = timestamp(2020,1,20)\n_0_3UdateWashington = timestamp(2020,2,17)\n_0_4UdateMemorial = timestamp(2020,5,25)\n_0_5UdateJuneteenthIndependencedayO = timestamp(2020,6,19)\n_0_6UdateIndependencedayO = timestamp(2020,7,3)\n_0_7UdateLabor = timestamp(2020,9,7)\n_0_8UdateColombus = timestamp(2020,10,12)\n_0_9UdateVeteransO = timestamp(2020,11,11)\n_0_10UdateThanksgiving = timestamp(2020,11,26)\n_0_11UdateChristmasO = timestamp(2020,12,25)\n_1_1UdateNYdayO= timestamp(2021,1,1)\n_1_2UdateMartinLuther = timestamp(2021,1,18)\n_1_3UdateWashington = timestamp(2021,2,15)\n_1_4UdateMemorial = timestamp(2021,5,31)\n_1_5UdateJuneteenthIndependencedayO = timestamp(2021,6,19)\n_1_6UdateIndependencedayO = timestamp(2021,7,4)\n_1_7UdateLabor = timestamp(2021,9,6)\n_1_8UdateColombus = timestamp(2021,10,11)\n_1_9UdateVeteransO = timestamp(2021,11,11)\n_1_10UdateThanksgiving = timestamp(2021,11,25)\n_1_11UdateChristmasO = timestamp(2021,12,25)\n_2_1UdateNYdayO= timestamp(2022,1,1)\n_2_2UdateMartinLuther = timestamp(2022,1,17)\n_2_3UdateWashington = timestamp(2022,2,21)\n_2_4UdateMemorial = timestamp(2022,5,30)\n_2_5UdateJuneteenthIndependencedayO = timestamp(2022,6,19)\n_2_6UdateIndependencedayO = timestamp(2022,7,4)\n_2_7UdateLabor = timestamp(2022,9,5)\n_2_8UdateColombus = timestamp(2022,10,10)\n_2_9UdateVeteransO = timestamp(2022,11,11)\n_2_10UIdateThanksgiving = timestamp(2022,11,25)\n_2_11UdateChristmasO = timestamp(2022,12,25)\n_3_1UdateNYdayO= timestamp(2023,1,1)\n_3_2UdateMartinLuther = timestamp(2023,1,16)\n_3_3UdateWashington = timestamp(2023,2,20)\n_3_4UdateMemorial = timestamp(2023,5,29)\n_3_5UdateJuneteenthIndependencedayO = timestamp(2023,6,19)\n_3_6UdateIndependencedayO = timestamp(2023,7,4)\n_3_7UdateLabor = timestamp(2023,9,4)\n_3_8UdateColombus = timestamp(2023,10,9)\n_3_9UdateVeteransO = timestamp(2023,11,11)\n_3_10UdateThanksgiving = timestamp(2023,11,23)\n_3_11UdateChristmasO = timestamp(2023,12,25)\n_4_1UdateNYdayO= timestamp(2024,1,1)\n_4_2UdateMartinLuther = timestamp(2024,1,15)\n_4_3UdateWashington = timestamp(2024,2,19)\n_4_4UdateMemorial = timestamp(2024,5,27)\n_4_5UdateJuneteenthIndependencedayO = timestamp(2024,6,19)\n_4_6UdateIndependencedayO = timestamp(2024,7,4)\n_4_7UdateLabor = timestamp(2024,9,2)\n_4_8UdateColombus = timestamp(2024,10,14)\n_4_9UdateVeteransO = timestamp(2024,11,11)\n_4_10UdateThanksgiving = timestamp(2024,11,28)\n_4_11UdateChristmasO = timestamp(2024,12,25)\n_5_1UdateNYdayO= timestamp(2025,1,1)\n_5_2UdateMartinLuther = timestamp(2025,1,20)\n_5_3UdateWashington = timestamp(2025,2,17)\n_5_4UdateMemorial = timestamp(2025,5,26)\n_5_5UdateJuneteenthIndependencedayO = timestamp(2025,6,19)\n_5_6UdateIndependencedayO = timestamp(2025,7,4)\n_5_7UdateLabor = timestamp(2025,9,1)\n_5_8UdateColombus = timestamp(2025,10,13)\n_5_9UdateVeteransO = timestamp(2025,11,11)\n_5_10UdateThanksgiving = timestamp(2025,11,27)\n_5_11UdateChristmasO = timestamp(2025,12,25)\n_6_1UdateNYdayO= timestamp(2026,1,1)\n_6_2UdateMartinLuther = timestamp(2026,1,19)\n_6_3UdateWashington = timestamp(2026,2,16)\n_6_4UdateMemorial = timestamp(2026,5,25)\n_6_5UdateJuneteenthIndependencedayO = timestamp(2026,6,19)\n_6_6UdateIndependencedayO = timestamp(2026,7,4)\n_6_7UdateLabor = timestamp(2026,9,7)\n_6_8UdateColombus = timestamp(2026,10,12)\n_6_9UdateVeteransO = timestamp(2026,11,11)\n_6_10UdateThanksgiving = timestamp(2026,11,26)\n_6_11UdateChristmasO = timestamp(2026,12,25)\n_7_1UdateNYdayO = timestamp(2027, 1, 1)\n_7_2UdateMartinLuther = timestamp(2027, 1, 18)\n_7_3UdateWashington = timestamp(2027, 2, 15)\n_7_4UdateMemorial = timestamp(2027, 5, 31)\n_7_5UdateJuneteenthIndependencedayO = timestamp(2027,6,18)\n_7_6UdateIndependencedayO = timestamp(2027, 7, 5)\n_7_7UdateLabor = timestamp(2027, 9, 6)\n_7_8UdateColombus = timestamp(2027, 10, 11)\n_7_9UdateVeteransO = timestamp(2027, 11, 11)\n_7_10UdateThanksgiving = timestamp(2027, 11, 25)\n_7_11UdateChristmasO = timestamp(2027, 12, 24)\n_8_1UdateNYdayO = timestamp(2027, 12, 31)\n_8_2UdateMartinLuther = timestamp(2028, 1, 17)\n_8_3UdateWashington = timestamp(2028, 2, 21)\n_8_4UdateMemorial = timestamp(2028, 5, 29)\n_8_5UdateJuneteenthIndependencedayO = timestamp(2028,6,19)\n_8_6UdateIndependencedayO = timestamp(2028, 7, 4)\n_8_7UdateLabor = timestamp(2028, 9, 4)\n_8_8UdateColombus = timestamp(2028, 10, 9)\n_8_9UdateVeteransO = timestamp(2028, 11, 10)\n_8_10UdateThanksgiving = timestamp(2028, 11, 23)\n_8_11UdateChristmasO = timestamp(2028, 12, 25)\n_9_1UdateNYdayO = timestamp(2029, 1, 1)\n_9_2UdateMartinLuther = timestamp(2029, 1, 15)\n_9_3UdateWashington = timestamp(2029, 2, 19)\n_9_4UdateMemorial = timestamp(2029, 5, 28)\n_9_5UdateJuneteenthIndependencedayO = timestamp(2029,6,19)\n_9_6UdateIndependencedayO = timestamp(2029, 7, 4)\n_9_7UdateLabor = timestamp(2029, 9, 3)\n_9_8UdateColombus = timestamp(2029, 10, 8)\n_9_9UdateVeteransO = timestamp(2029, 11, 12)\n_9_10UdateThanksgiving = timestamp(2029, 11, 22)\n_9_11UdateChristmasO = timestamp(2029, 12, 25)\n_30_1UdateNYdayO = timestamp(2030,1,1)\n_30_2UdateMartinLuther = timestamp(2030,1,21)\n_30_3UdateWashington = timestamp(2030,2,18)\n_30_4UdateMemorial = timestamp(2030,5,27)\n_30_5UdateJuneteenthIndependencedayO = timestamp(2030,6,19)\n_30_6UdateIndependencedayO = timestamp(2030,7,4)\n_30_7UdateLabor = timestamp(2030,9,2)\n_30_8UdateColombus = timestamp(2030,10,14)\n_30_9UdateVeteransO = timestamp(2030,11,11)\n_30_10UdateThanksgiving = timestamp(2030,11,28)\n_30_11UdateChristmasO = timestamp(2030,12,25)\n//GB Bank Holidays\n_0_1GdateNYday = timestamp(2020,1,1)\n_0_2GdateGoodFriday = timestamp(2020,4,10)\n_0_3GdateEasterMonday = timestamp(2020,4,13)\n_0_4GdateEarlyMay = timestamp(2020,5,8)\n_0_5GdateSpring = timestamp(2020,5,25)\n_0_6GdateSummer = timestamp(2020,8,31)\n_0_7GdateBoxingsubs = timestamp(2020,12,28)\n_0_8GdateChristmas = timestamp(2020,12,25)\n_1_1GdateNYday = timestamp(2021,1,1)\n_1_2GdateGoodFriday = timestamp(2021,4,2)\n_1_3GdateEasterMonday = timestamp(2021,4,5)\n_1_4GdateEarlyMay = timestamp(2021,5,3)\n_1_5GdateSpring = timestamp(2021,5,31)\n_1_6GdateSummer = timestamp(2021,8,30)\n_1_7GdateBoxingsubs = timestamp(2021,12,27)\n_1_8GdateChristmassubs = timestamp(2021,12,28)\n_2_1GdateNYdaysubs = timestamp(2022,1,3)\n_2_2GdateGoodFriday = timestamp(2022,4,15)\n_2_3GdateEasterMonday = timestamp(2022,4,18)\n_2_4GdateEarlyMay = timestamp(2022,5,2)\n_2_5GdateSpring = timestamp(2022,6,2)\n_2_6GdatePlatinum = timestamp(2022,6,3)\n_2_7GdateSummer = timestamp(2022,8,29)\n_2_8GdateElizabeth = timestamp(2022,9,19)\n_2_9GdateChristmas = timestamp(2022,12,25)\n_2_10GdateBoxing = timestamp(2022,12,26)\n_2_11GdateChristmassubs = timestamp(2022,12,27)\n_3_1GdateNYdaysubs = timestamp(2023,1,2)\n_3_2GdateGoodFriday = timestamp(2023,4,7)\n_3_3GdateEasterMonday = timestamp(2023,4,10)\n_3_4GdateEarlyMay = timestamp(2023,5,1)\n_3_5GdateKingCharles = timestamp(2023,5,8)\n_3_6GdateSpring = timestamp(2023,5,29)\n_3_7GdateSummer = timestamp(2023,8,28)\n_3_8GdateChristmas = timestamp(2023,12,25)\n_3_9GdateBoxing = timestamp(2023,12,26)\n_4_1GdateNYdaysubs = timestamp(2024,1,1)\n_4_2GdateGoodFriday = timestamp(2024,3,29)\n_4_3GdateEasterMonday = timestamp(2024,4,1)\n_4_4GdateEarlyMay = timestamp(2024,5,6)\n_4_5GdateSpring = timestamp(2024,5,27)\n_4_6GdateSummer = timestamp(2024,8,26)\n_4_7GdateChristmas = timestamp(2022,12,25)\n_4_8GdateBoxing = timestamp(2024,12,26)\n_5_1GdateNYdaysubs = timestamp(2025,1,1)\n_5_2GdateGoodFriday = timestamp(2025,4,18)\n_5_3GdateEasterMonday = timestamp(2025,4,21)\n_5_4GdateEarlyMay = timestamp(2025,5,5)\n_5_5GdateSpring = timestamp(2025,5,26)\n_5_6GdateSummer = timestamp(2025,8,25)\n_5_7GdateChritsmas = timestamp(2025,12,25)\n_5_8GdateBoxing = timestamp(2025,12,26)\n_6_1GdateNYdaysubs = timestamp(2026,1,1)\n_6_2GdateGoodFriday = timestamp(2026, 4,3)\n_6_3GdateEasterMonday = timestamp(2026, 4,6)\n_6_4GdateEarlyMay = timestamp(2026, 5, 4)\n_6_5GdateSpring = timestamp(2026, 5, 25)\n_6_6GdateSummer = timestamp(2026, 8, 31)\n_6_7GdateChritsmas = timestamp(2026, 12, 25)\n_6_8GdateBoxing = timestamp(2026, 12, 28)\n_7_1GdateNYdaysubs = timestamp(2027, 1, 1)\n_7_2GdateGoodFriday = timestamp(2027, 3, 27)\n_7_3GdateEasterMonday = timestamp(2027, 3, 29)\n_7_4GdateEarlyMay = timestamp(2027, 5, 3)\n_7_5GdateSpring = timestamp(2027, 5, 31)\n_7_6GdateSummer = timestamp(2027, 8, 30)\n_7_7GdateChritsmas = timestamp(2027, 12, 27)\n_7_8GdateBoxing = timestamp(2027, 12, 28)\n_8_1GdateNYdaysubs = timestamp(2028, 1, 3)\n_8_2GdateGoodFriday = timestamp(2028, 4, 14)\n_8_3GdateEasterMonday = timestamp(2028, 4, 17)\n_8_4GdateEarlyMay = timestamp(2028, 5, 1)\n_8_5GdateSpring = timestamp(2028, 5, 29)\n_8_6GdateSummer = timestamp(2028, 8, 28)\n_8_7GdateChritsmas = timestamp(2028, 12, 25)\n_8_8GdateBoxing = timestamp(2028, 12, 26)\n_9_1GdateNYdaysubs = timestamp(2029, 1, 1)\n_9_2GdateGoodFriday = timestamp(2029, 4, 30)\n_9_3GdateEasterMonday = timestamp(2029, 4, 2)\n_9_4GdateEarlyMay = timestamp(2029, 5, 7)\n_9_5GdateSpring = timestamp(2029, 5, 28)\n_9_6GdateSummer = timestamp(2029, 8, 27)\n_9_7GdateChritsmas = timestamp(2029, 12, 25)\n_9_8GdateBoxing = timestamp(2029, 12, 26)\n_30_1GdateNYdaysubs = timestamp(2030, 1, 1)\n_30_2GdateGoodFriday = timestamp(2030, 4, 19)\n_30_3GdateEasterMonday = timestamp(2030, 4, 22)\n_30_4GdateEarlyMay = timestamp(2030, 5, 6)\n_30_5GdateSpring = timestamp(2030, 5, 27)\n_30_6GdateSummer = timestamp(2030, 8, 26)\n_30_7GdateChritsmas = timestamp(2030, 12, 25)\n_30_8GdateBoxing = timestamp(2030, 12, 26)\n//YourChoosedDate = timestamp(YEAR,MONTH,DAY)\n//LongCondition = timestamp =! YourChoosedDate\n        //That's how you add Another date to your long condition\n//here we wrote every\nlogicdates = time_tradingday != _0_1UdateNYdayO and time_tradingday != _0_2UdateMartinLuther\n//example on basic strategy of sma crossover\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition and logicdates) //we added the rule of logicdates\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nif (shortCondition and logicdates) //we added the rule of logicdates\n    strategy.entry(\"My Short Entry Id\", strategy.short)\n//plotbackground\n//as you can see our idea works it is red on background on selected days as on picture\nbgcolor(logicdates ? na :  color.rgb(255, 82, 82, 53))"}]}
{"messages": [{"role": "user", "content": "One of the ways I go when I develop strategies is by reducing the number of parameters and removing fixed parameters and levels. In this strategy, I'm trying to create an RSI indicator with a dynamic length.  Length is computed based on the correlation between Price and its momentum. You can set min and max values for the RSI, and if the correlation is close to 1, we'll be at a min RSI value. When it's -1, we'll be at the max level.  I got this idea from Sofien Kaabar's book.  The strategy is super simple, and there might be much room for improvement.  Performance on the deep backtesting is not excellent, so I think the strategy needs some filters for regimes, etc.  Thanks to @MUQWISHI for helping me code it. Disclaimer Please remember that past performance may not indicate future results. Due to various factors, including changing market conditions, the strategy may no longer perform as well as in historical backtesting. This post and the script don\u2019t provide any financial advice."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Dynamic RSI Momentum\", \"DRM Strategy\", process_orders_on_close = true, default_qty_type\n// +++++++++++++++++++++\n// ++      INPUT      ++ \n// +++++++++++++++++++++\n// Momentum\nlen = input.int(10, \"Momentum Length\", 1,      group = \"Dynamic RSI Momentum\")\nsrc = input.source(close, \"Source\",   group = \"Dynamic RSI Momentum\")\nmin_rsi = input.int(20, \"Min RSI\", group = \"Dynamic RSI Momentum\")\nmax_rsi = input.int(50, \"Max RSI\", group = \"Dynamic RSI Momentum\")\nupLvl = input.float(70, \"OverBought\", 0, 100, group = \"Dynamic RSI Momentum\")\ndnLvl = input.float(30, \"OverSold\",   0, 100, group = \"Dynamic RSI Momentum\")\n// +++++++++++++++++++++\n// ++   CALCULATION   ++ \n// +++++++++++++++++++++\n// RMA Function\nrmaFun(src, len) =>\n    sma   = ta.sma(src, len) \n    alpha = 1/len\n    sum   = 0.0\n    sum  := na(sum[1]) ? sma : alpha * src + (1 - alpha) * nz(sum[1])\n// RSI Function \nrsiFun(src, len) =>     \n    100 - 100 / (1 + rmaFun(src - src[1] > 0 ? src - src[1] : 0, len) / \n                     rmaFun(src[1] - src > 0 ? src[1] - src : 0, len))\n// Momentum\nmomVal = src - src[len]\n// Calculation Price vs Momentum\ncorr  = ta.correlation(src, momVal, len)\ncorr := corr > 1 or corr < -1 ? float(na) : corr\nrsiLen = 0\nrsiLen := int(min_rsi + nz(math.round((1 - corr) * (max_rsi-min_rsi) / 2, 0), 0))\nrsiMom = rsiFun(src, rsiLen)\n// +++++++++++++++++++++\n// ++    STRATEGY     ++ \n// +++++++++++++++++++++\nlong  = ta.crossover(rsiMom, dnLvl)\nshort = ta.crossunder(rsiMom, upLvl) \n// +++> Long <+++++\nif long and not na(rsiMom)\n    strategy.entry(\"Long\", strategy.long)\n// +++> Short <+++++\nif short and not na(rsiMom)\n    strategy.entry(\"Short\", strategy.short)\n// +++++++++++++++++++++\n// ++      PLOT       ++ \n// +++++++++++++++++++++\nplot(rsiMom, \"Dynamic RSI Momentum\", rsiMom < dnLvl ?  color.green : rsiMom > upLvl\nhline(50, \"Mid Line\",  color.gray)\nupperLine = hline(upLvl, \"Upper Line\",  color.gray)\nlowerLine = hline(dnLvl, \"Lower Line\",  color.gray)\nfill(upperLine, lowerLine,  color.new(color.purple, 90), \"Background Fill\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    added a vwap filter                                                    Release Notes:                                                    added: filters: -ema cross -ichimoku cloud -lux candlespattern channel -support and resistance break -mavilimw -ift-cci based exits: -using atr band -using a trailing atr                                                    Release Notes:                                                    fix label                                                    Release Notes:                                                    added range for backtest                                                    Release Notes:                                                    fix backtest                                                    Release Notes:                                                    added 2 additional supertrend filter for those who would like to test the triple supertrend strategy sorry for the UI i am working on it to make it more user friendly.                                                    Release Notes:                                                    updated UI                                                    Release Notes:                                                    added a % base trailing stop loss exit filter                                                    Release Notes:                                                    fix input for %                                                    Release Notes:                                                    added the option to use a trailing % take profit with price deviation ( similar to 3commas)                                                    Release Notes:                                                    A                                                    Release Notes:                                                    started working on UI                                                    Release Notes:                                                    a                                                    Release Notes:                                                    a                                                    Release Notes:                                                    added margin auto calculation                                                    Release Notes:                                                    auto calculation did not work                                                    Release Notes:                                                    a                                                    Release Notes:                                                    a                                                    Release Notes:                                                    a                                                    Release Notes:                                                    a"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 mathlabel\n//@version=5\nstrategy(\"My strategy\", overlay=true,  default_qty_type = strategy.percent_of_equity\n//\n////////////////////////////////////////////////////////////////////////////////\n// BACKTESTING RANGE\n// From Date Inputs\nfromDay = input.int(defval=1, title='From Day', minval=1, maxval=31)\nfromMonth = input.int(defval=1, title='From Month', minval=1, maxval=12)\nfromYear = input.int(defval=2019, title='From Year', minval=1970)\nfromHour =input.int(defval = 1, title = 'from hour',minval = 0 ,maxval =24 )\nfromMinute=input.int(defval = 1, title = 'from minute',minval = 0 ,maxval =60 )\nfromSecond=input.int(defval = 1, title = 'from second',minval = 0 ,maxval =60 )\n// To Date Inputs\ntoDay = input.int(defval=1, title='To Day', minval=1, maxval=31)\ntoMonth = input.int(defval=1, title='To Month', minval=1, maxval=12)\ntoYear = input.int(defval=2100, title='To Year', minval=1970)\n// Calculate start/end date and time condition\nstartDate = timestamp(fromYear, fromMonth, fromDay,fromHour, fromMinute,fromSecond\nfinishDate = timestamp(toYear, toMonth, toDay, 00, 00)\ntime_cond = time >= startDate and time <= finishDate\n//////////////////////////////////////////////////\nlong_only=input.bool(false)\nshort_only=input.bool(false)\nlongLossPerc = input.float(title='Long Stop Loss (%)', minval=0.0, step=0.01, defval\nshortLossPerc = input.float(title='Short Stop Loss (%)', minval=0.0, step=0.01, defval\nuse_supertrend_filter=input.bool(true)\natrPeriod = input(10, \"supertrend ATR Length\")\nfactor = input.float(3.0, \"supertrend Factor\", step = 0.01)\nuse_stochastic_filter = input.bool(false)\nstochlenght= input(14,'stochlenght')\noversold_level = input(title = ' stoch Oversold', defval = 20)\noverbought_level = input(title = 'stoch Overbought', defval = 80)\nuse_supertrend2_filter=input.bool(false)\natrPeriod2 = input(7, \"supertrend2 ATR Length\")\nfactor2 = input.float(3, \"supertrend2 Factor\", step = 0.01)\nuse_supertrend3_filter=input.bool(false)\natrPeriod3 = input(11, \"supertrend3 ATR Length\")\nfactor3 = input.float(2, \"supertrend3 Factor\", step = 0.01)\nuse_cci_filter=input.bool(false)\ncci_l = input(50, title='CCI Period Length')\natr_l = input(5, title=' CCI ATR Length')\nuse_vwap_filter=input.bool(false)\nvar anchor = input.string(defval = \"Session\", title=\"Anchor Period\",\n options=[\"Session\", \"Week\", \"Month\", \"Quarter\", \"Year\", \"Decade\", \"Century\", \"Earnings\"\nuse_chaikin_money_flow_filter=input.bool(false)\nlength = input(20, title='chaikin lenght')\nuse_ema_cross_filter=input.bool(false)\nshortlen = input.int(9, \"Short MA Length for cross filter\", minval=1)\nlonglen = input.int(21, \"Long MA Length for cross filter\", minval=1)\nuse_ichimoku_filter=input.bool(false)\nconversionPeriods = input.int(9, minval=1, title='ichimoku convertion periods')\nbasePeriods = input.int(26, minval=1, title = 'ichimoku base periods')\nuse_luxcandlepatternchannel_filter=input.bool(false)\nlengthw = input.int(14, 'lux candlestick pattern Trend Length'\n  , minval = 0)\nalpha = input.float(50, 'lux candlestick pattern Convergence'\n  , minval = 0\n  , maxval = 100)\nsmooth = input.int(7, 'lux candlestick pattern Smooth'\n  , minval = 1)\nuse_support_an_dresistance_break_filter=input.bool(false)\nleftBars = input(15, title='support and resistance Left Bars ')\nrightBars = input(15, title='support and resistance Right Bars')\nuse_mavilimw_filter=input.bool(false)\nfmal = input(3,title = 'mavilimw fast ma') \nsmal = input(5,title = 'mavilimw slow ma')\nuse_mfi_filter=input.bool(false)\nlength1 = input.int(title=\"mfi Length\", defval=14, minval=1, maxval=2000)\nsignalLength = input(title='mfi Signal Length', defval=9)\nuse_ift_cci_filter=input.bool(false)\nccilength = input(5, title = 'cci lenght')\nwmalength =input(9, title = 'cci WMA lenght')\nplottrama=input.bool(false, title=\"Show Lux TRAMA\")\nuse_LUX_trama_filter=input.bool(false)\nlengths = input(99,title='Trama lenght')\nuse_macd_filter=input.bool(false)\nma_fast=ta.sma(close,input(14,title='ma fast for macd filter'))\nma_slow=ta.sma(close,input(28, title='ma slowfor macd filter'))\nuse_ema200_filter= input.bool(false)\nplotAverage = input.bool(true, title=\"Plot EMA200\")\n//exits\nuse_trailing_stop_loss=input.bool( false,title = 'use indicator exits (atr band, trailing atr or bo\nuse_atr_bands_exits=input.bool(false)\nstopLossFactor = input(2.0, \"ATR Stop Loss Factor\")\ntakeProfitFactor = input(1.5, \"ATR Take Profit Factor\")\natr = ta.atr(input(10, 'atr band period'))\nuse_trailing_atr_exits=input.bool(false)\nAtr1 = input.int(defval=5, title='trailing Atr exit Period', minval=1, maxval=500)\nHhv1 = input.int(defval=10, title='trailing ATR exit HHV Period', minval=1, maxval\nMult1 = input.float(defval=2.5, title='trailing exit ATR Multiplier', minval=0.1)\nuse_bollinger_exits=input.bool(false)\nlengthss = input(20, title='bollinger lenght')\nmult = input.float(2.0, minval=0.001, maxval=50, title=\"bollinger StdDev\")\noffset = input.int(0, \"bollinger Offset\", minval = -500, maxval = 500)\nuse_percent_base_trailing_stop_exits=input.bool(false,group = '% trailing stop loss'\ntrailStop = input.float(title=' traling Stop Loss (%)', minval=0.0, step=0.01, defval\nenableTrailing = input.bool(false, 'Enable % take profit Trailing',group = '% trailing Take Profit'\nlongTakeProfitPerc2 = input.float(0.5, 'Long trailing Take Profit %', minval=0.01,\nshortTakeProfitPerc2 = input.float(0.5, 'Short trailing Take Profit %', minval=0.01\nLtrailingTakeProfitDeviationPerc = input.float(defval = 1.0, title = 'long Trailing Take Profit Deviation %'\nStrailingTakeProfitDeviationPerc = input.float(defval = 1.0, title = 'Short Trailing Take Profit Deviation %'\nuse_fix_perc_take_profit=input.bool(false, 'use a fix % take profit ',group = ' fixed % Take Profit'\nlongprofitPerc = input.float(title='fixed Long profit (%) if not using indicator exit\nshortprofitPerc = input.float(title='fixed Short profit (%) if not using indicator exi\nclose_position_when_oposite_signal=input.bool(false)\n// Calculate supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\nupTrend = plot(use_supertrend_filter? (direction < 0 ? supertrend : na) : na, \"Up Trend\"\ndownTrend = plot(use_supertrend_filter ? (direction < 0? na : supertrend):na, \"Down Trend\"\nlong_supertrend_filter= (direction < 0 ? supertrend : na)\nshort_supertrend_filter= (direction < 0? na : supertrend)\n// Calculate supertrend 2\n[supertrend2, direction2] = ta.supertrend(factor2, atrPeriod2)\nupTrend2 = plot(use_supertrend2_filter? (direction2 < 0 ? supertrend2 : na) : na, \ndownTrend2 = plot(use_supertrend2_filter ? (direction2 < 0? na : supertrend2):na, \nlong_supertrend2_filter= (direction2 < 0 ? supertrend2 : na)\nshort_supertrend2_filter= (direction2 < 0? na : supertrend2)\n// Calculate supertrend 3\n[supertrend3, direction3] = ta.supertrend(factor3, atrPeriod3)\nupTrend3 = plot(use_supertrend2_filter? (direction3 < 0 ? supertrend3 : na) : na, \ndownTrend3 = plot(use_supertrend2_filter ? (direction3 < 0? na : supertrend3):na, \nlong_supertrend3_filter= (direction3 < 0 ? supertrend3 : na)\nshort_supertrend3_filter= (direction3 < 0? na : supertrend3)\n//--trama--\nsrc =(close)\nama = 0.\nhh = math.max(math.sign(ta.change(ta.highest(lengths))), 0)\nll = math.max(math.sign(ta.change(ta.lowest(lengths)) * -1), 0)\ntc = math.pow(ta.sma(hh or ll ? 1 : 0, lengths), 2)\nama := nz(ama[1] + tc * (src - ama[1]), src)\nplot(plottrama?ama : na, 'Plot',  color.new(#ff1100, 0), 2)\nlong_LUX_trama_filter= (close > ama)\nshort_LUX_trama_filter= (close < ama)\n// highest high\nhighest = ta.highest(high, stochlenght)\n// lowest low\nlowest = ta.lowest(low, stochlenght)\n// stochastic oscillator\nstochastic_K = ((close - lowest) / (highest - lowest)) * 100\nstochastic_D = ta.sma(stochastic_K, 3)\nlong_stoch_filter =ta.crossover( stochastic_K , oversold_level) and stochastic_K[1\nshort_stoch_filter = ta.crossunder(stochastic_K , overbought_level) and stochastic_K\n//ATR band upline and bottome line.\nupline = open + (atr* takeProfitFactor)\nbottomline = open -(atr*stopLossFactor)\nplot(use_atr_bands_exits ? upline : na, color= color.white)\nplot(use_atr_bands_exits ? bottomline:na, color= color.white)\n// Calculate stop loss and take profit levels\nstopLoss = stopLossFactor * atr\ntakeProfit = takeProfitFactor * atr\n//input macd\n[macdLine, signalLine, histLine]= ta.macd(close,12,26,9)\nlong_macd_filter= (macdLine > signalLine) and ta.crossover(ma_fast,ma_slow)\nshort_macd_filter= (macdLine < signalLine) and ta.crossunder(ma_fast,ma_slow)\n// ema 200\nema1= ta.ema(close,1)\nema2= ta.ema(close,200)\nbarsincecrossup =ta.barssince(close >ema2)\nbarsincecrossdw=ta.barssince(close <ema2)\nlong_ema_filter = (close > ema2 and close[1] > ema2 )\nshort_ema_filter= (close<ema2 and  close[1]<ema2)\nplot(plotAverage ? ta.ema(close, 200) : na, title=\"Exponential Average\")\n// mfi\nsrc1 = hlc3\nmf = ta.mfi(src1, length1)\nsignal = ta.ema(mf, signalLength)\nlong_mfi_filter= ta.crossover(mf, signal) ? mf : na\nshort_mfi_filter=  ta.crossunder(mf, signal) ? mf : na\n//cci\nlevel = 0\nsd_length = 20\ncci = ta.cci(src, cci_l)\natr2 = ta.atr(atr_l)\nvar st = 0.\nif cci >= level\n    st := low - atr\n    st\nif cci <= level\n    st := high + atr\n    st\nvar tu = 0.\nvar td = 0.\nvar optimal_line = 0.\nif cci >= level and cci[1] < level\n    tu := td[1]\n    tu\nif cci <= level and cci[1] > level\n    td := tu[1]\n    td\nif cci > level\n    tu := low - atr2\n    if tu < tu[1] and cci[1] >= level\n        tu := tu[1]\n        tu\nif cci < level\n    td := high + atr2\n    if td > td[1] and cci[1] <= level\n        td := td[1]\n        td\noptimal_line := math.max(tu, td)\n// Creating a Price Channel, \navg_st8 = ta.ema(st, 8)\navg_st13 = ta.ema(st, 13)\navg_st21 = ta.ema(st, 21)\navg_st34 = ta.ema(st, 21)\navg_st55 = ta.ema(st, 55)\navg_st89 = ta.ema(st, 89)\navg_st144 = ta.ema(st, 144)\navg_st233 = ta.ema(st, 233)\naverage_weighting = (optimal_line + avg_st8 + avg_st13 + avg_st21 + avg_st34 + avg_st55\nbasis = ta.sma(average_weighting, sd_length)\ndevs = ta.stdev(average_weighting, sd_length)\nupperS = basis + devs\nlowerS = basis - devs\nplot(use_cci_filter ? basis: na, 'Basis', color= color.new(#872323, 0))\np3 = plot(use_cci_filter ? upperS : na, 'UpperS', color= color.new(color.teal, 0)\np4 = plot(use_cci_filter ? lowerS: na ,'LowerS', color= color.new(color.teal, 0))\nlong_cci_filter= ta.crossover(close,upperS) \nshort_cci_filter= ta.crossunder(close,lowerS) \n//wvap\nsrcv =  hlc3\nstdevMult_1 = (0)\nif barstate.islast and ta.cum(volume) == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nnew_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on\nnew_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on\nnew_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on,\nisNewPeriod = switch anchor\n    \"Earnings\"  => not na(new_earnings)\n    \"Dividends\" => not na(new_dividends)\n    \"Splits\"    => not na(new_split)\n    \"Session\"   => timeframe.change(\"D\")\n    \"Week\"      => timeframe.change(\"W\")\n    \"Month\"     => timeframe.change(\"M\")\n    \"Quarter\"   => timeframe.change(\"3M\")\n    \"Year\"      => timeframe.change(\"12M\")\n    \"Decade\"    => timeframe.change(\"12M\") and year % 10 == 0\n    \"Century\"   => timeframe.change(\"12M\") and year % 100 == 0\n    => false\nisEsdAnchor = anchor == \"Earnings\" or anchor == \"Dividends\" or anchor == \"Splits\"\nif na(src[1]) and not isEsdAnchor\n    isNewPeriod := true\nfloat vwapValue = na\nfloat upperBandValue1 = na\nfloat lowerBandValue1 = na\nfloat upperBandValue2 = na\nfloat lowerBandValue2 = na\nfloat upperBandValue3 = na\nfloat lowerBandValue3 = na\nif not (timeframe.isdwm)\n    [_vwap, _stdevUpper, _] = ta.vwap(src, isNewPeriod, 1)\n    vwapValue := _vwap\n    stdevAbs = _stdevUpper - _vwap\n    upperBandValue1 := _vwap + stdevAbs * stdevMult_1\n    lowerBandValue1 := _vwap - stdevAbs * stdevMult_1\nplot(use_vwap_filter  ?vwapValue : na, title=\"VWAP\", color= #2962FF)\nlong_vwap_filter= close > vwapValue\nshort_vwap_filter = close < vwapValue\n//chaikin money flow \nvar cumVol = 0.\ncumVol += nz(volume)\nif barstate.islast and cumVol == 0\n    runtime.error(\"No volume is provided by the data vendor.\")\nad = close==high and close==low or high==low ? 0 : ((2*close-low-high)/(high-low))\nmf2 = math.sum(ad, length) / math.sum(volume, length)\nlong_chaikin_money_flow_filter= mf2> 0\nshort_chaikin_money_flow_filter =  mf2<0\n// ema cross\nema4=ta.ema(close,shortlen)\nema5=ta.ema(close,longlen)\nlong_ema_cross_filter= ta.crossover(ema4,ema5)\nshort_ema_cross_filter=ta.crossunder(ema4,ema5)\nplot(use_ema_cross_filter? ema4 : na)\nplot(use_ema_cross_filter ? ema5 : na)\n//ichimku cloud\nmiddleDonchian(Length) =>\n    lower = ta.lowest(Length)\n    upper = ta.highest(Length)\n    math.avg(upper, lower)\nlaggingSpan2Periods = 52\ndisplacement = 26\nTenkan = middleDonchian(conversionPeriods)\nKijun = middleDonchian(basePeriods)\nxChikou = close\nSenkouA = middleDonchian(laggingSpan2Periods)\nSenkouB = (Tenkan[basePeriods] + Kijun[basePeriods]) / 2\nplot(use_ichimoku_filter ? Tenkan : na, color= color.new(color.red, 0), title='Tenkan'\nplot(use_ichimoku_filter ? Kijun : na, color= color.new(color.blue, 0), title='Kijun'\nplot(use_ichimoku_filter ? xChikou : na, color= color.new(color.teal, 0), title='Chikou'\nA = plot(use_ichimoku_filter ? SenkouA[displacement]: na, color= color.new(color.purple\nB = plot(use_ichimoku_filter ? SenkouB : na, color= color.new(color.green, 0), title\nlong_ichimoku_filter= close > SenkouA[displacement] and close> SenkouB \nshort_ichimoku_filter= close < SenkouA[displacement] and close< SenkouB \n// lux candlestick pattern\n//Settings\n//-----------------------------------------------------------------------------{\n//Patterns\nenable_hammer = true\nenable_ihammer = true\nenable_shooting =true\nenable_hanging = true\nenable_bulleng = false\nenable_beareng = false\nenable_wm = true\nenable_bm = true\n  //Style\nbull_css =  #0cb51a\navg_css = #ff5d00\nbear_css =  #ff1100\nfade = 200\n//-----------------------------------------------------------------------------}\n//Variables/Functions\n//-----------------------------------------------------------------------------{\nn = bar_index\no = open,h = high,l = low,c = close\natrw = ta.atr(20) / 2 \nstw = ta.stoch(c, c, c, lengthw)\ndowntrendw = stw < 50\nuptrendw = stw > 50\nd = math.abs(c - o)\nlbl(y, txt, direction, tlt)=> \n    label.new(  n, y, txt\n          , size = size.tiny\n          , style = direction == 1 ? label.style_cross : label.style_cross\n          , color = direction == 1 ? bull_css : bear_css\n          , textcolor =  color.white\n          , tooltip = tlt )\n//-----------------------------------------------------------------------------}\n//Tooltips\n//-----------------------------------------------------------------------------{\nvar hammer_tlt = \"The hammer candlestick pattern is formed of a short body with a long lower wick, and is found at th\n  + \"\\n\" + \"\\nA hammer shows that although there were selling pressures during the day, ultimately a strong buy\nvar ihammer_tlt = \"The inverted hammer is a similar pattern than the hammer pattern. The only difference being that th\n  + \"\\n\" + \"\\nIt indicates a buying pressure, followed by a selling pressure that was not strong enough to driv\nvar bulleng_tlt = \"The bullish engulfing pattern is formed of two candlesticks. The first candle is a short red body t\n  + \"\\n\" + \"\\nThough the second day opens lower than the first, the bullish market pushes the price up, culmina\nvar wm_tlt = \"The white marubozu is a single candles formation formed after a downtrend and indicating a bullish \n  + \"\\n\" + \"\\nThis candlestick has a long bullish body with no upper or lower shadows, reflecting a strong buyi\n  var shooting_tlt = \"The shooting star is the same shape as the inverted hammer, but is formed in an uptrend: it has a s\n  + \"\\n\" + \"\\nUsually, the market will gap slightly higher on opening and rally to an intra-day high before \nvar hanging_tlt = \"The hanging man is the bearish equivalent of a hammer; it has the same shape but forms at the end o\n  + \"\\n\" + \"\\nIt indicates that there was a significant sell-off during the day, but that buyers were able to p\nvar beareng_tlt = \"A bearish engulfing pattern occurs at the end of an uptrend. The first candle has a small green bod\n  + \"\\n\" + \"\\nIt signifies a peak or slowdown of price movement, and is a sign of an impending market downturn.\nvar bm_tlt = \"The black marubozu is a single candles formation formed after an uptrend and indicating a bearish r\n  + \"\\n\" + \"\\nThis candlestick has a long bearish body with no upper or lower shadows, reflecting a strong sell\n//-----------------------------------------------------------------------------}\n//Pattern Rules\n//-----------------------------------------------------------------------------{\nhammer = downtrendw and math.min(o, c) - l > 2 * d and h - math.max(c, o) < d / 4\nihammer = downtrendw and h - math.max(o, c) > 2 * d and math.min(c, o) - l < d / 4\nshooting = uptrendw and h - math.max(o, c) > 2 * d and math.min(c, o) - l < d / 4\nhanging = uptrendw and math.min(o, c) - l > 2 * d and h - math.max(c, o) < d / 4\nbulleng = downtrendw and c > o and c[1] < o[1] and c > o[1] and d > atr\nbeareng = uptrendw and c < o and c[1] > o[1] and c < o[1] and d > atr\nwm = c > o and h - math.max(o, c) + math.min(o, c) - l < d / 10 and d > atr and downtrendw\nbm = c < o and h - math.max(o, c) + math.min(o, c) - l < d / 10 and d > atr and uptrendw\n//-----------------------------------------------------------------------------}\n//Channel\n//-----------------------------------------------------------------------------{\nvar max = h\nvar min = l\n//Bullish Patterns\nif hammer and use_luxcandlepatternchannel_filter\n    max += alpha / 100 * (c - max)\n    lbl(low, 'H', 1, hammer_tlt)\n    if ihammer and use_luxcandlepatternchannel_filter\n    max += alpha / 100 * (c - max)\n    lbl(low, 'IH', 1, ihammer_tlt)\nif bulleng and enable_bulleng\n    max += alpha / 100 * (c - max)\n    lbl(low, 'BE', 1, bulleng_tlt)\nif wm and use_luxcandlepatternchannel_filter\n    max += alpha / 100 * (c - max)\n    lbl(low, 'WM', 1, wm_tlt)\n//Bearish Patterns\nif shooting and use_luxcandlepatternchannel_filter\n    min += alpha / 100 * (c - min)\n    lbl(high, 'SS', 0, shooting_tlt)\nif hanging and use_luxcandlepatternchannel_filter\n    min += alpha / 100 * (c - min)\n    lbl(high, 'HM', 0, hanging_tlt)\nif beareng and enable_beareng\n    min += alpha / 100 * (c - min)\n    lbl(high, 'BE', 0, beareng_tlt)\nif bm and use_luxcandlepatternchannel_filter\n    min += alpha / 100 * (c - min)\n    lbl(high, 'BM', 0, bm_tlt)\nmax := math.max(c, max)\nmin := math.min(c, min)\nsmooth_max = ta.ema(max, smooth)\nsmooth_min = ta.ema(min, smooth)\navg = math.avg(smooth_max, smooth_min)\n//-----------------------------------------------------------------------------}\n//Plots\n//-----------------------------------------------------------------------------{\nvar os = 0\nos := c > smooth_max ? 1 : c < smooth_min ? 0 : os\nvar fade_max = 0\nfade_max := os == 0 ? fade_max + 1 : 0\nvar fade_min = 0\nfade_min := os == 1 ? fade_min + 1 : 0\nplot_0 = plot(use_luxcandlepatternchannel_filter? smooth_max : na, 'Upper', bull_css\nplot_1 = plot(use_luxcandlepatternchannel_filter? avg : na, 'Average', avg_css)\nplot_2 = plot(use_luxcandlepatternchannel_filter? smooth_min : na, 'Lower', bear_css\ncss1 = color.from_gradient(use_luxcandlepatternchannel_filter? fade_max : na, 0, fade\ncss2 = color.from_gradient(use_luxcandlepatternchannel_filter? fade_min : na, 0, fade\nlong_luxcandlepatternchannel_filter=hammer or ihammer or wm \nshort_luxcandlepatternchannel_filter= shooting or hanging or bm\n//support and resistance lux\nvolumeThresh = 20\nhighUsePivot = fixnan(ta.pivothigh(leftBars, rightBars)[1])\nlowUsePivot = fixnan(ta.pivotlow(leftBars, rightBars)[1])\nr1 = plot(use_support_an_dresistance_break_filter? highUsePivot : na, color=ta.change\ns1 = plot(use_support_an_dresistance_break_filter? lowUsePivot : na, color=ta.change\n//Volume %\nshorts = ta.ema(volume, 5)\nlongs = ta.ema(volume, 10)\nosc = 100 * (shorts - longs) / longs\nshort_support_an_dresistance_break_filter=close[1] < lowUsePivot and close < lowUsePivot\nlong_support_an_dresistance_break_filter=close[1]> highUsePivot and close > highUsePivot\n//mavilimw\ntmal = fmal + smal\nFmal = smal + tmal\nFtmal = tmal + Fmal\nSmal = Fmal + Ftmal\nM1 = ta.wma(close, fmal)\nM2 = ta.wma(M1, smal)\nM3 = ta.wma(M2, tmal)\nM4 = ta.wma(M3, Fmal)\nM5 = ta.wma(M4, Ftmal)\nMAVW = ta.wma(M5, Smal)\ncol1 = MAVW > MAVW[1]\ncol3 = MAVW < MAVW[1]\ncolorM = col1 ?  color.blue : col3 ?  color.red :  color.yellow\nplot(use_mavilimw_filter? MAVW : na, color=colorM, linewidth=2, title='MAVW')\nM12 = ta.wma(close, 3)\nM22 = ta.wma(M12, 5)\nM32 = ta.wma(M22, 8)\nM42 = ta.wma(M32, 13)\nM52 = ta.wma(M42, 21)\nMAVW2 = ta.wma(M52, 34)\nlong_mavilimw_filter= ta.crossover(MAVW, MAVW[1])\nshort_mavilimw_filter=ta.crossunder(MAVW, MAVW[1])\n//ift-cc1\nCCI = true\nv11 = 0.1 * (ta.cci(close, ccilength) / 4)\nv21 = ta.wma(v11, wmalength)\nINV1 = (math.exp(2 * v21) - 1) / (math.exp(2 * v21) + 1)\nrsilength = 5\nv12 = 0.1 * (ta.rsi(close, rsilength) - 50)\nv22 = ta.wma(v12, wmalength)\nINV2 = (math.exp(2 * v22) - 1) / (math.exp(2 * v22) + 1)\nstochlength = 5\nv1 = 0.1 * (ta.stoch(close, high, low, stochlength) - 50)\nv2 = ta.wma(v1, wmalength)\nINVLine = (math.exp(2 * v2) - 1) / (math.exp(2 * v2) + 1)\nlong_ift_cci_filter=CCI and INV1 > 0.5\nshort_ift_cci_filter=CCI and INV1 <  -0.5\n//MFI\nmfilength = 5\nsourcse = hlc3\nup = math.sum(volume * (ta.change(sourcse) <= 0 ? 0 : sourcse), mfilength)\nlo = math.sum(volume * (ta.change(sourcse) >= 0 ? 0 : sourcse), mfilength)\nmfii = 100.0 - 100.0 / (1.0 + up / lo)\nv13 = 0.1 * (mfii - 50)\nv23 = ta.wma(v13, wmalength)\nINV3 = (math.exp(2 * v23) - 1) / (math.exp(2 * v23) + 1)\nAVINV = (INV1 + INV2 + INVLine + INV3) / 4\nvar isLong = false\nvar isShort= false\nlong = ((not use_ema_cross_filter or long_ema_cross_filter) and  (not use_LUX_trama_filter\nshort= ((not use_ema_cross_filter or short_ema_cross_filter) and (not use_LUX_trama_filter\nif long\n    isLong := true\n    isShort := false\nif short\n    isLong := false\n    isShort := true\nplotshape(long, title='Buy', text='Buy', style=shape.labelup, location=location.belowbar\nplotshape(short, title='Sell', text='Sell', style=shape.labeldown, location=location.abovebar\n// trailing atr exits\nPrev = ta.highest(high - Mult1 * ta.atr(Atr1), Hhv1)\nta.barssince(close > ta.highest(high - Mult1 * ta.atr(Atr1), Hhv1) and close > close\ncum_1 = ta.cum(1)\nhighest_1 = ta.highest(high - Mult1 * ta.atr(Atr1), Hhv1)\nhighest_2 = ta.highest(high - Mult1 * ta.atr(Atr1), Hhv1)\niff_1 = close > highest_1 and close > close[1] ? highest_2 : Prev\nTS = cum_1 < 16 ? close : iff_1\niff_2 = close < TS ?  color.red :  color.black\nColor = close > TS ?  color.green : iff_2\nplot(use_trailing_atr_exits? TS : na, color=Color, linewidth=3, title='ATR Trailing Stoploss'\nshort_trailing_atr_exits = ta.crossover(close, TS)\nlong_trailing_atr_exits = ta.crossunder(close, TS)\n//trail\nlongStopPricess = 0.0\nshortStopPricess = 0.0\nlongStopPricess := if strategy.position_size > 0\n    stopValue = close * (1 - trailStop)\n    math.max(stopValue, longStopPricess[1])\nelse\n    0\nshortStopPricess := if strategy.position_size < 0\n    stopValue = close * (1 + trailStop)\n    math.min(stopValue, shortStopPricess[1])\nelse\n    999999\n//PLOT TSL LINES\nplot(series=strategy.position_size > 0 and use_percent_base_trailing_stop_exits ? \nplot(series=strategy.position_size < 0 and use_percent_base_trailing_stop_exits? shortStopPricess\n//bollinger\nbasiss = ta.sma(src, lengthss)\ndev = mult * ta.stdev(src, lengthss)\nupper = basiss + dev\nlower = basiss - dev\nplot(use_bollinger_exits ? basiss : na, \"Basis\", color= #FF6D00, offset = offset)\np1 = plot(use_bollinger_exits ? upper : na, \"Upper\", color= #2962FF, offset = offset\np2 = plot(use_bollinger_exits ? lower: na, \"Lower\", color= #2962FF, offset = offset\nlong_atr_bands_exits = close > upline \nshort_atr_bands_exits = close < bottomline\nlong_bollinger_exits= close > upper\nshort_bollinger_exits=close < lower\nlong_atr_exits = close > upline \nshort_atr_exits = close < bottomline\ntakelong = (not use_atr_bands_exits or long_atr_bands_exits) and (not use_bollinger_exits\ntakeshort = (not use_atr_bands_exits or short_atr_bands_exits) and (not use_bollinger_exits\nplotshape(use_atr_bands_exits? takelong : na,title = 'take profit',text='high SL/TP'\nplotshape(use_atr_bands_exits ? takeshort : na,title = 'take profit',text='low SL/TP'\nplotshape(use_bollinger_exits ? takelong: na,title = 'take profit',text='high SL/TP'\nplotshape(use_bollinger_exits ? takeshort: na,title = 'take profit',text='low SL/TP'\n// Determine stop loss price\nlongStopPrice = strategy.position_avg_price * (1 - longLossPerc)\nshortStopPrice = strategy.position_avg_price * (1 + shortLossPerc)\n// Determine take profit price\nlongprofitPrice = strategy.position_avg_price * (1 + longprofitPerc)\nshortprofitPrice = strategy.position_avg_price * (1 - shortprofitPerc)\n// Plot stop loss values for confirmation\nplot(series=strategy.position_size > 0 ? longStopPrice : na, color= color.new(color.red\nplot(series=strategy.position_size < 0 ? shortStopPrice : na, color= color.new(color.red\nplot(use_fix_perc_take_profit and strategy.position_size > 0 ? longprofitPrice : na\nplot(use_fix_perc_take_profit and strategy.position_size < 0 ? shortprofitPrice : \n// trailing tp\nbool openLongPosition = long\nbool openShortPosition = short\nbool longIsActive = openLongPosition or strategy.position_size > 0\nbool shortIsActive = openShortPosition or strategy.position_size < 0\nfloat longTakeProfitPrice2 = na\nlongTakeProfitPrice2 := if longIsActive\n    if openLongPosition and not (strategy.position_size > 0)\n        close * (1 + longTakeProfitPerc2)\n    else\n        nz(longTakeProfitPrice2[1], close * (1 + longTakeProfitPerc2))\nelse\n    na\nfloat shortTakeProfitPrice2 = na\nshortTakeProfitPrice2 := if shortIsActive\n    if openShortPosition and not (strategy.position_size < 0)\n        close * (1 - shortTakeProfitPerc2)\n    else\n        nz(shortTakeProfitPrice2[1], close * (1 - shortTakeProfitPrice2))\nelse\n    na\nfloat longTrailingTakeProfitStepTicks = longTakeProfitPrice2 * LtrailingTakeProfitDeviationPerc\nfloat shortTrailingTakeProfitStepTicks = shortTakeProfitPrice2 * StrailingTakeProfitDeviationPerc\nplot(enableTrailing? longTakeProfitPrice2:na, title='Long Take Profit', color =  \nplot(enableTrailing? shortTakeProfitPrice2 :na, title='Short Take Profit', color =\nlongstoploss= close <longStopPrice \nshortstoploss=close >shortStopPrice \nif longstoploss \n    strategy.close(\"Long Entry\")\nif shortstoploss\n    strategy.close(\"Short Entry\")\nlongCondition = long and not short_only\nif (longCondition and time_cond)\n    strategy.entry(\"Long Entry\", strategy.long)\nshortCondition = short and not long_only\nif (shortCondition and time_cond)\n    strategy.entry(\"Short Entry\", strategy.short)\nif use_trailing_stop_loss \n    if takelong and strategy.position_size > 0 and time_cond or time_cond and close\n        strategy.close(\"Long Entry\")\n    if takeshort and strategy.position_size < 0 and time_cond or time_cond and close\n        strategy.close(\"Short Entry\")\nelse\n    if  time_cond and close < longStopPrice or  time_cond and close > longprofitPrice\n        strategy.close(\"Long Entry\")\n    if time_cond  and close < shortprofitPrice or time_cond and close > shortStopPrice\n        strategy.close(\"Short Entry\")\nif isLong and use_percent_base_trailing_stop_exits \n    strategy.exit(id=\"Close Long\", stop=longStopPricess)\nif isShort and use_percent_base_trailing_stop_exits\n    strategy.exit(id=\"Close Short\", stop=shortStopPricess)\nif isLong and enableTrailing \n    strategy.exit(id = 'Long Take Profit', from_entry = 'Long Entry', limit = close\nif isShort and enableTrailing \n    strategy.exit(id = 'Short Take Profit', from_entry = 'Short Entry', limit = close"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    1. Removed 7SMA as Stoploss and given provision to use EMA/SMA of their choice as StopLoss. 2. Background will be colored on Buy Entry.                                                    Release Notes:                                                    Mistake in Entry criteria, it was referring to crossover in previous candle. Now changed to current candle.                                                    Release Notes:                                                    Added option to choose source(close, high, low, etc) for MA stoploss."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 AbdulRahimShama\n//@version=5\nstrategy('12/26-IT strategy', overlay=true,initial_capital = 100000, calc_on_order_fills\nShow_Only_12_26_Crossover_Entry             = input.bool(true, group = \"Entry_Exit Criteria\"\nShow_12_26_Crossover_and_resistance_Entry   = input.bool(false, group = \"Entry_Exit Criteria\"\nShow_MA_StopLoss                            = input.bool(false, group = \"Entry_Exit Criteria\"\nShow_TSL_StopLoss                           = input.bool(false, group = \"Entry_Exit Criteria\"\nShow_Crossdown_StopLoss                     = input.bool(true, group = \"Entry_Exit Criteria\"\n////////////////////////////////////////////////\n////////////////TARGETS INPUT\n////////////////////////////////////////////////\n////////Target1\nTargetPerc1         = input.float(title=\"Target (%)\", minval=0,defval=5, group=\"Target-1\"\nTargetPrice1        = strategy.position_avg_price * (1 + TargetPerc1)\nTarget1_exit_qty    = input.int(50, group=\"Target-1\",tooltip = \"% qty to sell when Target1 is reached\"\n////////Target2\nTargetPerc2         = input.float(title=\"Target (%)\", minval=0,defval=10, group=\"Target-2\"\nTargetPrice2        = strategy.position_avg_price * (1 + TargetPerc2)\nTarget2_exit_qty    = input.int(100, group=\"Target-2\",tooltip = \"% qty to sell when Target2 is reached\"\n////////////////////////////////////////////////\n////////////////TRAILING STOP LOSS\n////////////////////////////////////////////////\nTSLsource           = input(low, title=\"TSL Source\", group=\"Trailing StopLoss\")\nlongTrailPerc       = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1\nTrailStopPrice = 0.0\nTrailStopPrice := if strategy.position_size > 0\n    sPIVOT_highValue = TSLsource * (1 - longTrailPerc)\n    math.max(sPIVOT_highValue, TrailStopPrice[1])\nelse\n    0\nTSL                 = close < TrailStopPrice\nplot(series=strategy.position_size > 0 and Show_TSL_StopLoss ? TrailStopPrice : na\n////////////////////////////////////////////////\n////////////////Moving Averages\n////////////////////////////////////////////////\nSLmaLength          = input.int(21, group=\"StopLoss MA\")\nSLmaSource          = input(low, group=\"StopLoss MA\")\nma(SLmaSource, length, type) =>\n    switch type\n        \"SMA\" => ta.sma(SLmaSource, SLmaLength)\n        \"EMA\" => ta.ema(SLmaSource, SLmaLength)\nSLmaType            = input.string(\"EMA\", title=\"StopLoss MA\", options=[\"SMA\", \"EMA\"\nSL_MA =             ma(SLmaSource, SLmaLength, SLmaType)\nplot(Show_MA_StopLoss ? SL_MA : na, \"StopLoss for MA\", color= color.rgb(255, 0, 0\nEMA_12              =ta.ema(close, 12)\nEMA_26              =ta.ema(close, 26)\nEMA_21              =ta.ema(close,21)\nplot(EMA_12, title=\"EMA_12\", color= color.rgb(0, 255, 0), offset=0, linewidth=1)\nplot(EMA_26, title=\"EMA_26\", color= color.rgb(0, 0, 255), offset=0, linewidth=2)\nplot(Show_MA_StopLoss ? SL_MA : na, \"StopLoss for MA\", color= color.rgb(255, 0, 0\n////////////////////////////////////////////////\n////////////////RESISTANCE INPUT and PLOTTING\n////////////////////////////////////////////////\nCrossOverLookbackCandles    = input.int(10, group= \"RESISTANCE\")\nresistanceSRC               = input(high, group= \"RESISTANCE\")\nresistanceLEFT              = input(10, group= \"RESISTANCE\")\nresistanceRIGHT             = input(10, group= \"RESISTANCE\")\nhih = ta.pivothigh(resistanceSRC, resistanceLEFT, resistanceRIGHT)\ntop = ta.valuewhen(hih, resistanceSRC[resistanceRIGHT], 0)\nres = plot(top, color=top != top[1] ? na :  color.new(#00ff00, 50), offset=-resistanceLEFT\nEMA_12_Low = ta.lowest(EMA_12, CrossOverLookbackCandles)\nEMA_26_Low = ta.lowest(EMA_26, CrossOverLookbackCandles)\n////////////////////////////////////////////////\n////////////////RSI INPUT and PLOTTING\n////////////////////////////////////////////////\nRSI                 = ta.rsi(close, 14)\nRSILowerRange       = input.int(45, tooltip = \"RSI value should be ABOVE this value for entry\"\nRSIUpperRange       = input.int(70, tooltip = \"RSI value should be BELOW this value for entry\"\n////////////////////////////////////////////////\n////////////////MACD\n////////////////////////////////////////////////\nfast_length         = 12\nslow_length         = 26\nMACD_src            = close\nsignal_length       = 9\nfast_ma             = ta.ema(MACD_src, fast_length)\nslow_ma             = ta.ema(MACD_src, slow_length)\nmacd                = fast_ma - slow_ma\nsignal              = ta.ema(macd, signal_length)\nhist                = macd - signal\n////////////////////////////////////////////////\n////////////////ENTRY CRITERIA\n////////////////////////////////////////////////\nBUYVALUE        = input(100000, tooltip = \"Buy qty displayed on chart will be based on this \nBASEENTRY       = macd > signal and RSI > RSILowerRange and RSI < RSIUpperRange and\nEntry           = ta.crossover(EMA_12, EMA_26) and BASEENTRY\nEntry2          = ta.crossover(close, top) and EMA_12_Low < EMA_26_Low and EMA_12 \n////////////////////////////////////////////////\n////////////////BUY SELL STRATEGY\n////////////////////////////////////////////////\nif ((Entry and Show_Only_12_26_Crossover_Entry))\n    strategy.entry(\"buy\", strategy.long, qty=BUYVALUE/close)\nif (Entry2 and Show_12_26_Crossover_and_resistance_Entry)\n    strategy.entry(\"buy\", strategy.long, qty=BUYVALUE/close)\nstrategy.exit(\"Tg1\", \"buy\", limit=TargetPrice1, qty_percent = Target1_exit_qty)\nstrategy.exit(\"Tg2\", \"buy\", limit=TargetPrice2, qty_percent = Target2_exit_qty)\nif TSL and Show_TSL_StopLoss and close < EMA_12 \n    strategy.close_all (\"sl\")\nif ta.crossunder(EMA_12, EMA_26) and Show_Crossdown_StopLoss\n    strategy.close_all (\"sl\")\nif ta.crossunder(close, SL_MA) and Show_MA_StopLoss\n    strategy.close_all (\"sl\")\nbgcolor(color=((Entry and Show_Only_12_26_Crossover_Entry)) ?  color.new(color.blue"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Unchecked bar magnifier by default as it is throwing error for non premium users. If you are premium user, please select this option from strategy settings.                                                    Release Notes:                                                    Updated strategy default parameter values as per recommendations. Reduced default quantity to 10% from 25%.                                                    Release Notes:                                                    Minor corrections"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 HeWhoMustNotBeNamed\n//                                       \u2591\u2592             \n//                                  \u2592\u2592\u2592   \u2592\u2592      \n//                              \u2592\u2592\u2592\u2592\u2592     \u2592\u2592      \n//                      \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591     \u2592     \u2592\u2592          \n//                  \u2592\u2592\u2592\u2592\u2592\u2592           \u2592     \u2592\u2592          \n//             \u2593\u2592\u2592\u2592       \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592  \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592        \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2592  \u2592       \u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591        \n//   \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592         \n//   \u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592\u2592                       \n//    \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592\u2592\u2592                            \n//                 \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592                           \n//                \u2592\u2592\u2592\u2592\u2592 \u2592\u2592\u2592\u2592\u2592                          \n//               \u2591\u2592\u2592\u2592\u2592   \u2592\u2592\u2592\u2592\u2593      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n//              \u2593\u2592\u2592\u2592\u2592     \u2592\u2592\u2592\u2592      \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n//              \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592        \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//             \u2592\u2592\u2592\u2592\u2592       \u2592\u2592\u2592\u2592\u2592       \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \n//            \u2592\u2592\u2592\u2592\u2592         \u2592\u2592\u2592\u2592\u2592      \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \n//             \u2592\u2592             \u2592                        \n//@version=5\nmaxPatternsLive = 10\ncapital = 1000.0\nstrategy(\"Wolfe Strategy [Trendoscope]\", shorttitle='WS[Trendoscope]', overlay=true\n         default_qty_value=10, commission_type=strategy.commission.percent, pyramiding\n         commission_value=0.05, close_entries_rule=\"ANY\", max_lines_count=500, max_labels_count\n         margin_long=100, margin_short=100)\nimport HeWhoMustNotBeNamed/rzigzag/10 as zigzag\nimport HeWhoMustNotBeNamed/_matrix/5 as ma\nimport HeWhoMustNotBeNamed/arrays/1 as pa\nimport HeWhoMustNotBeNamed/strategy/3 as st\nvar idArray = array.from(1)\ntradeDirection = input.string(strategy.direction.long, \"Trade Direction\", options=\n                             group=\"Trade Settings\", tooltip='Use this to filter only long or short trades'\nminRiskReward = input.float(1.0, 'Minimum RR', group='Trade Settings',  minval=0.5\ntheme = input.string('Dark', title='Theme', options=['Light', 'Dark'], group='Generic'\n         tooltip='Chart theme settings. Line and label colors are generted based on the theme settings. If dark theme\n         'lighter colors are used and if light theme is selected, darker colors are used.'\navoidOverlap = input.bool(false, 'Suppress Overlap', group='Generic',\n         tooltip='Avoids plotting wedge if there is an existing wedge at starting point. This does not avoid nesting \ndrawZigzag = input.bool(true, 'Draw Zigzag', group='Generic', tooltip='Draw zigzag lines and mark pivots within wedge'\nzigzagLength = input.int(8, step=5, minval=3, title='Length', group='Zigzag', tooltip\nzigzagDepth = input.int(250, step=50, minval=50, title='Depth', group='Zigzag', tooltip\nminLevel = input.int(0, \"Min Level\", group='Zigzag', minval =0, tooltip = 'Min Level on recursive zigzag to calculate Wolfe'\nvar themeColors = theme==\"Dark\"? array.from(\n          color.rgb(251, 244, 109),\n          color.rgb(141, 186, 81),\n          color.rgb(74, 159, 245),\n          color.rgb(255, 153, 140),\n          color.rgb(255, 149, 0),\n          color.rgb(0, 234, 211),\n          color.rgb(167, 153, 183),\n          color.rgb(255, 210, 113),\n          color.rgb(119, 217, 112),\n          color.rgb(95, 129, 228),\n          color.rgb(235, 146, 190),\n          color.rgb(198, 139, 89),\n          color.rgb(200, 149, 149),\n          color.rgb(196, 182, 182),\n          color.rgb(255, 190, 15),\n          color.rgb(192, 226, 24),\n          color.rgb(153, 140, 235),\n          color.rgb(206, 31, 107),\n          color.rgb(251, 54, 64),\n          color.rgb(194, 255, 217),\n          color.rgb(255, 219, 197),\n          color.rgb(121, 180, 183)\n         ) : array.from(\n          color.rgb(61, 86, 178),\n          color.rgb(57, 163, 136),\n          color.rgb(250, 30, 14),\n          color.rgb(169, 51, 58),\n          color.rgb(225, 87, 138),\n          color.rgb(62, 124, 23),\n          color.rgb(244, 164, 66),\n          color.rgb(134, 72, 121),\n          color.rgb(113, 159, 176),\n          color.rgb(170, 46, 230),\n          color.rgb(161, 37, 104),\n          color.rgb(189, 32, 0),\n          color.rgb(16, 86, 82),\n          color.rgb(200, 92, 92),\n          color.rgb(63, 51, 81),\n          color.rgb(114, 106, 149),\n          color.rgb(171, 109, 35),\n          color.rgb(247, 136, 18),\n          color.rgb(51, 71, 86),\n          color.rgb(12, 123, 147),\n          color.rgb(195, 43, 173)\n         )\nmaxPatternsReference = 10\nvar pivotBarMatrix = matrix.new<int>()\nvar patternIdArray = array.new<int>()\nvar patternProjections = matrix.new<line>()\nvar patternTradeMatrix = matrix.new<float>()\nwedgeLine(l1StartX, l1StartY, l1EndX, l1EndY, l2StartX, l2StartY, l2EndX, l2EndY, \n    l1t = line.new(l1StartX, l1StartY, l1EndX, l1EndY, color=zgColor, extend=extend.both\n    l2t = line.new(l2StartX, l2StartY, l2EndX, l2EndY, color=zgColor, extend=extend.both\n        startBar = l1StartX\n    endBar = l1EndX\n    l2Start = line.get_price(l2t,startBar)\n    l2End = line.get_price(l2t, endBar)\n    line.set_x1(l2t, startBar)\n    line.set_y1(l2t, l2Start)\n    line.set_x2(l2t, endBar)\n    line.set_y2(l2t, l2End)\n        l1Diff = l1StartY-l1EndY\n    l2Diff = l2Start-l2End\n        width = math.abs(endBar-startBar)\n        closingEndBar = endBar\n    closingEndPrice = l2End\n    closingSoon = false\n        isContracting = math.abs(l1StartY-l2Start) > math.abs(l1EndY-l2End)\n        isNotTriangle = math.sign(l1StartY-l1EndY) == math.sign(l2Start-l2End)\n        isWolfeWedge = isContracting and isNotTriangle\n        if(isWolfeWedge)\n        for i =endBar to endBar+math.min(500, 2*width)\n            l1Price = line.get_price(l1t, i)\n            l2Price = line.get_price(l2t, i)\n            if(lastDir* (l1Price-l2Price) <= 0)\n                closingEndBar := i\n                closingSoon := true\n                closingEndPrice := (l1Price + l2Price)/2\n                break\n            if(closingSoon)\n            line.set_x2(l2t, closingEndBar)\n            line.set_y2(l2t, closingEndPrice)\n            line.set_x2(l1t, closingEndBar)\n            line.set_y2(l1t, closingEndPrice)\n        line.set_extend(l1t, extend.none)\n    line.set_extend(l2t, extend.none)\n    [l1t, l2t, closingEndBar, closingEndPrice, isWolfeWedge and closingSoon]\n    find_wedge(zigzagmatrix, startIndex)=>\n    _5 = matrix.get(zigzagmatrix, startIndex, 0)\n    _5Bar = int(matrix.get(zigzagmatrix, startIndex, 1))\n    lastDir = matrix.get(zigzagmatrix, startIndex, 3)\n    _4 = matrix.get(zigzagmatrix, startIndex+1, 0)\n    _4Bar = int(matrix.get(zigzagmatrix, startIndex+1, 1))\n    _3 = matrix.get(zigzagmatrix, startIndex+2, 0)\n    _3Bar = int(matrix.get(zigzagmatrix, startIndex+2, 1))\n    _2 = matrix.get(zigzagmatrix, startIndex+3, 0)\n    _2Bar = int(matrix.get(zigzagmatrix, startIndex+3, 1))\n    _1 = matrix.get(zigzagmatrix, startIndex+4, 0)\n    _1Bar = int(matrix.get(zigzagmatrix, startIndex+4, 1))\n    isValidDirection = (tradeDirection == strategy.direction.long and lastDir < 0)\n    if(isValidDirection)\n        existingPattern = false\n        for i=0 to matrix.rows(pivotBarMatrix) > 0? matrix.rows(pivotBarMatrix)-1 \n            commonPivotsCount = (_1Bar == matrix.get(pivotBarMatrix, i, 0) ? 1 : 0\n                                 (_2Bar == matrix.get(pivotBarMatrix, i, 1) ? 1 : \n                                 (_3Bar == matrix.get(pivotBarMatrix, i, 2) ? 1 : \n                                 (_4Bar == matrix.get(pivotBarMatrix, i, 3) ? 1 : \n                                 (_5Bar == matrix.get(pivotBarMatrix, i, 4) ? 1 : \n            if ( commonPivotsCount >=3 ) or (avoidOverlap and _1Bar >= matrix.get(\n                existingPattern := true\n                break\n                    if(not existingPattern)\n            basicCondition = lastDir > 0? _2 < math.min(_1, _3, _4, _5) and _5 > math.max\n                                 _2 > math.max(_1, _3, _4, _5) and _5 < math.min(_1\n                                                        if(basicCondition)\n                zgColor = array.pop(themeColors)\n                [l1t, l2t, closingEndBar, closingEndPrice, isWolfeWedge] = wedgeLine\n                array.unshift(themeColors, zgColor)\n                                delete = true\n                if(isWolfeWedge)\n                    id = array.get(idArray, 0)\n                    array.set(idArray, 0, id+1)\n                    ma.unshift(pivotBarMatrix, array.from(_1Bar, _2Bar, _3Bar, _4Bar\n                    pa.unshift(patternIdArray, id, maxPatternsReference)\n                    delete := false\n                    if(drawZigzag)\n                        line.new(_1Bar, _1, _2Bar, _2, color=zgColor, extend=extend.none\n                        line.new(_2Bar, _2, _3Bar, _3, color=zgColor, extend=extend.none\n                        line.new(_3Bar, _3, _4Bar, _4, color=zgColor, extend=extend.none\n                        line.new(_4Bar, _4, _5Bar, _5, color=zgColor, extend=extend.none\n                    lproj = line.new(_1Bar, _1, _4Bar, _4, color=zgColor, extend=extend.right\n                    lProjEndPrice = line.get_price(lproj, closingEndBar)\n                    line.set_x2(lproj, closingEndBar)\n                    line.set_y2(lproj, lProjEndPrice)\n                    line.set_extend(lproj, extend.none)\n                    lclose = line.new(closingEndBar, lProjEndPrice, closingEndBar,\n                    ma.unshift(patternProjections, array.from(lproj, lclose, l2t),\n                    entry = line.get_price(l2t, bar_index+1)\n                    target = lProjEndPrice\n                    stop = closingEndPrice\n                    ma.unshift(patternTradeMatrix, array.from(entry, stop, target,\n                    rr = math.abs(entry-target)/math.abs(entry-stop)\n                    dir = entry > stop? 1 : -1\n                    if(rr >= minRiskReward)\n                        st.bracketOrderWithoutLeverage(str.tostring(id), entry, stop\n                if(delete)\n                    line.delete(l1t)\n                    line.delete(l2t)\nscan_patterns(startIndex, newPivot, zigzagmatrix)=>\n    length = matrix.rows(zigzagmatrix)\n    numberOfPivots=5\n    if(length >= startIndex+5 and newPivot)\n        find_wedge(zigzagmatrix, startIndex)\nsetup(zigzagLength, zigzagDepth)=>\n    [zigzagmatrix, flags] = zigzag.zigzag(zigzagLength, array.from(high, low), numberOfPivots\n    newPivot = array.get(flags, 1)\n    doublePivot = array.get(flags, 2)\n    if(newPivot)\n        mlzigzag = zigzagmatrix\n        level = 1\n        while(matrix.rows(mlzigzag) >= 5)\n            if(level >= minLevel)\n                scan_patterns(1, doublePivot, zigzagmatrix)\n                scan_patterns(0, newPivot,zigzagmatrix)\n            mlzigzag := zigzag.nextlevel(mlzigzag, zigzagDepth)\n            level := level+1\nevaluate()=>\n    for i=array.size(patternIdArray) > 0? array.size(patternIdArray)-1: na to 0\n        id = array.get(patternIdArray, i)\n        l2t = matrix.get(patternProjections, i, 2)\n        entry = matrix.get(patternTradeMatrix, i, 0)\n        stop = matrix.get(patternTradeMatrix, i, 1)\n        target = matrix.get(patternTradeMatrix, i, 2)\n        status = matrix.get(patternTradeMatrix, i, 3)\n        rr = math.abs(entry-target)/math.abs(entry-stop)\n                dir = entry > stop? 1 : -1\n        targetValue = dir > 0? high : low\n        stopValue = dir >0? low : high\n        newStatus = status == 0 and targetValue*dir > entry*dir and rr >=minRiskReward\n                if(targetValue*dir > target*dir) or (newStatus == 1 and close*dir < stop) \n            strategy.cancel(str.tostring(id))\n            array.remove(patternIdArray, i)\n            matrix.remove_row(pivotBarMatrix, i)\n            matrix.remove_row(patternProjections, i)\n            matrix.remove_row(patternTradeMatrix, i)\n            false\n        else if (newStatus == 0)\n            newEntry = line.get_price(l2t, bar_index+1)\n            newRR = math.abs(entry-target)/math.abs(entry-stop)\n            if(newRR >= minRiskReward)\n                strategy.cancel(str.tostring(id))\n                st.bracketOrderWithoutLeverage(str.tostring(id), newEntry, stop, target\n                matrix.set(patternTradeMatrix, i, 0, newEntry)\n                    matrix.set(patternTradeMatrix, i, 3, newStatus)\n            true\nsetup(zigzagLength, zigzagDepth)\nevaluate()"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    This adds my attempt to plot the calculations, if anyone has a better approach please let me know"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 ShayanRastgou\n//@version=5\nstrategy(\"Simple Momentum and Trend, Fixed PnL Strategy for SPY 1D\", overlay=false,\n// Set stop loss and take profit levels\nstopLoss = 50\ntakeProfit = 300\n// Set order size and pyramiding\norderSize = 2\nmaxPositions = 25\n// Define long entry condition\nlongCondition = ta.atr(5) > ta.atr(20) and ta.tsi(close, 13, 25) > 0\nif (longCondition and strategy.position_size < maxPositions)\n    strategy.entry(\"My Long Entry Id\" + str.tostring(bar_index), strategy.long, stop\n// Define short entry condition\nshortCondition = ta.atr(5) > ta.atr(20) and ta.tsi(close, 13, 25) < 0\nif (shortCondition and strategy.position_size < maxPositions)\n    strategy.entry(\"My Short Entry Id\" + str.tostring(bar_index), strategy.short, stop\n// Plot the 5-period ATR\nplot(ta.atr(5), color= color.red, linewidth=2, title=\"5-Period ATR\")\n// Plot the 20-period ATR\nplot(ta.atr(20), color= color.orange, linewidth=2, title=\"20-Period ATR\")\n// Plot the TSI\nplot(ta.tsi(close, 13, 25), color= color.green, linewidth=2, title=\"TSI\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added a condition to evaluate MACD on 5 minute time frame whether it is above zero line or not."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 makarandpatil\n// This strategy is for Bank Nifty instrument and for intraday purpose only\n// It checks for various indicators and gives a buy signal when all conditions are met \n// Bank Nifty when in momentum gives 100-200 points in spot in 5-15 min which is how long the trade \n// Issues - The custom script as per TradingView Pinescripting has an issue of repaint\n// More information on repainting issue in this link - https://www.tradingview.com/pine-script-docs/en/v5\n// Use the script alert only to get notified, however check all the parameters individually before t\n// Also, please perform a backtesting and deep backtesting of this strategy to see if the strategy g\n// The script is made for testing purposes only and is in beta mode. Please use at own risk.\n//@version=5\nstrategy(\"BankNifty_Bullish_Intraday\", overlay=true, margin_long = 100, margin_short\n// Variables\nStochLength = input(14, title=\"Stochastic Length\")\nsmoothK = input(3, title=\"%K Smoothing\")\nsmoothD = input(3, title=\"%D Smoothing\")\n  //INDICATOR CALCULATIONS\n // 1. MACD\n[macdLine, signalLine, histLine] = ta.macd(close[0],12,26,9)\n macd5 = request.security(syminfo.tickerid, \"5\", macdLine)\nmacd15 = request.security(syminfo.tickerid,\"15\",macdLine)\nmacd60 = request.security(syminfo.tickerid,\"60\",macdLine)\n // 2. RSI Calculation\nxRSI = ta.rsi(close, 14)\n // 3. ADX calculation\n[diplus, diminus, adx] = ta.dmi(14,14)\n// plot(adx,color = color.black)\n // 4. Stochastic Calculation\nk = ta.sma(ta.stoch(close, high, low, StochLength), smoothK)\nd = ta.sma(k, smoothD)\n // 5. Bollinger Band calculation\n[middle, upper, lower] = ta.bb(close, 20, 2)\n  //CONDITIONS\n // 1. Conditions for MACD\nmacd5Uptick = macd5[0] > macd5[1]\nmacd15Uptick = macd15[0] > macd15[1]\nmacd60Uptick = macd60[0] >= macd60[1]\n // 2. Condition for xRSI\nRSIStrong = xRSI > 60\n // 3. Condition for ADX\nADXUngali = adx >= 12\n // 4. Condition for Stochastic\nStochPCO = k > d\n // 5. Condition for Bollinger Band\nBBCU = upper > upper [1]\n //Evaluate the long condition\n// longCondition = macd5Uptick and macd15Uptick and RSIStrong and ADXUngali and StochPCO and BBCU\nlongCondition = macd5[0] > 0 and macd5Uptick and macd15Uptick and macd60Uptick and \n// longCondition = macd5Uptick and macd15Uptick and RSIStrong and ADXUngali and StochPCO and BBCU\nif (longCondition)\n    strategy.entry(\"Buy\", strategy.long,alert_message = \"BankNifty_Buy_Momentum\")\nshortCondition = close < ta.ema(close,5)\nif (shortCondition)\n    strategy.entry(\"BuySquareoff\", strategy.short, alert_message = \"BankNifty_Closed_Below_5EMA\""}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added a condition to evaluate MACD on 5 minute time frame whether it is below zero line or not."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 makarandpatil\n// This strategy is for Bank Nifty instrument and for intraday purpose only\n// It checks for various indicators and gives a sell signal when all conditions are met\n// Bank Nifty when in momentum gives 100-200 points in spot in 5-15 min which is how long the trade \n// Issues - The custom script as per TradingView Pinescripting has an issue of repaint\n// More information on repainting issue in this link - https://www.tradingview.com/pine-script-docs/en/v5\n// Use the script alert only to get notified, however check all the parameters individually before t\n// Also, please perform a backtesting and deep backtesting of this strategy to see if the strategy g\n// The script is made for testing purposes only and is in beta mode. Please use at own risk.\n//@version=5\nstrategy(\"BankNifty_Bearish_Intraday\", overlay=true, margin_long=100, margin_short=\n// Variables\nStochLength = input(14, title=\"Stochastic Length\")\nsmoothK = input(3, title=\"%K Smoothing\")\nsmoothD = input(3, title=\"%D Smoothing\")\n//INDICATOR CALCULATIONS\n// 1. MACD\n[macdLine, signalLine, histLine] = ta.macd(close[0],12,26,9)\nmacd5 = request.security(syminfo.tickerid, \"5\", macdLine)\nmacd15 = request.security(syminfo.tickerid,\"15\",macdLine)\nmacd60 = request.security(syminfo.tickerid,\"60\",macdLine)\n// 2. RSI Calculation\nxRSI = ta.rsi(close, 14)\n// 3. ADX calculation\n[diplus, diminus, adx] = ta.dmi(14,14)\n// 4. Stochastic Calculation\nk = ta.sma(ta.stoch(close, high, low, StochLength), smoothK)\nd = ta.sma(k, smoothD)\n// 5. Bollinger Band calculation\n[middle, upper, lower] = ta.bb(close, 20, 2)\n//CONDITIONS\n// 1. Conditions for MACD\nmacd5Downtick = macd5[0] < macd5[1]\nmacd15Downtick = macd15[0] < macd15[1]\nmacd60Downtick = macd60[0] <= macd60[1]\n// 2. Condition for xRSI\nRSIWeak = xRSI < 40\n// 3. Condition for ADX\nADXUngali = adx >= 12\n// 4. Condition for Stochastic\nStochNCO = k < d\n// 5. Condition for Bollinger Band\nBBCD = lower < lower [1]\n//Evaluate the short condition\nshortCondition = macd5[0] < 0 and macd5Downtick and macd15Downtick and macd60Downtick\n// shortCondition = macd5Downtick and macd15Downtick and RSIWeak and ADXUngali and StochNCO\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short, alert_message = \"BankNifty_Sell_Momentum\"\nlongCondition = close > ta.ema(close,5)\nif (longCondition)\n    strategy.entry(\"ShortSquareoff\", strategy.long, alert_message = \"BankNifty_Closed_Above_5EMA\""}]}
{"messages": [{"role": "user", "content": "The relative strength index is a momentum indicator used in technical analysis. It measures the speed and magnitude of a coin's recent price changes to evaluate overvalued or undervalued conditions in the price of that coin. The RSI is displayed as an oscillator (a line graph essentially) on a scale of zero to 100. When the RSI reaches oversold levels, it can provide a signal to go long. When the RSI reaches overbought levels, it can mark a good exit point or alternatively, an entry for a short position. Traditionally, an RSI reading of 70 or above indicates an overbought situation. A reading of 30 or below indicates an oversold condition. A moving average (MA) calculates the average of a selected range of prices, usually closing prices, by the number of periods in that range. Essentially it is used to help smooth out price data by creating a constantly updated average price. The Strategy enters and closes trades when the following conditions are met: Entry Conditions: RSI is greater than 50 MA9 is greater than MA50 RSI increases by 5 Exit Conditions: Price increases by 1% trailing Price decreases by 2% trailing This strategy is back-tested from 1 January 2022 to simulate how the strategy would work in a bear market. The strategy provides good returns. The strategy assumes each order is using 30% of the available coins to make the results more realistic and to simulate you only ran this strategy on 30% of your holdings. A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance."}, {"role": "assistant", "content": "//@version=5\nstrategy(\"RSI and MA Strategy with Trailing Stop Loss and Take Profit\",\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=100,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 1, 1, 0, 0)\nnotInTrade = strategy.position_size <= 0\n//==================================Buy Conditions============================================\n//RSI\nlength = input(14)\nrsi = ta.rsi(close, length)\nbuyCondition1 = rsi > 50\n//MA\nSMA9 = ta.sma(close, 9)\nSMA50 = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nplot(SMA9, color =  color.green)\nplot(SMA50, color =  color.orange)\nplot(SMA100, color =  color.blue)\nbuyCondition2 = SMA9 > SMA50//ta.crossover(SMA9, SMA100)\n//RSI Increase\nincrease = 5\nbuyCondition3 = (rsi > rsi[1] + increase)\nif (buyCondition1 and buyCondition2 and buyCondition3 and timePeriod) //and buyCondition\n    strategy.entry(\"Long\", strategy.long)\n//==================================Sell Conditions============================================\n//Trailing Stop Loss and Take Profit\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\nlongStopPrice = 0.0\nshortStopPrice = 0.0\nlongStopPrice := if strategy.position_size > 0\n    stopValue = close * (1 - longTrailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\nstrategy.exit(id=\"Exit\", stop = longStopPrice, limit = shortStopPrice)"}]}
{"messages": [{"role": "user", "content": "This strategy uses Renko, it generates a signal when there is a reversal in Renko. When using historical data, it provides a good entry and an okay exit. However, in a real-time environment, this strategy is subject to repaint and may produce a false signal. As a result, the backtesting result should not be used as a metric to predict future results. It is highly recommended to forward-test the strategy before using it in real trading. I forward test it from 12/18/2022 to 12/21/2022 in paper trading, using the alert feature in Tradingview. I made 60 trades trading the BTCUSDT BINANCE 3 min with 26 as the param and under the condition that I use 20x margin, compounding my yield, and having 0 trading fee, a steady loss is generated: from $10 to $3.02. This is quite interesting. As if I flip the signal from \"Long\" to \"Short\" and another way too, it will be a steady profit from $10 to $21.85. Hence, if I'm trying to anti-trade the real-time alert signal, the current \"4 Days Result\" will be good. Nevertheless, I still have to forward-test it for longer to see if it will fail eventually. Dive into the setting of the strategy - Margin is the leverage you use. 1 means 1x, 10 means 10x. It affects the backtest yield when you backtest - Compound Yield button is for compound calculation, disable it to go back to normal backtesting - Anti Strategy button is to do the opposite direction trade, when the original strat told you to \"Long\", you \"Short\" instead. Enable it to use the feature - Param is the block size for the Renko chart - Drawdown is just a visual tool for you in case you want to place a stop loss (represent by the semitransparent red area in the chart) - From date Thru Date is to specify the backtest range of the strategy, This feature is turned off by default. It is controlled by the Max Backtest Timeframe which will be explain below - Max Backtest Timeframe control the From date Thru Date function, disable it to enable the From Date Thru Date function Param is the most important input in this strategy as it directly affects performance. It is highly recommended to backtest nearly all the possible parameters before deploying it in real trading. Some factors should be considered: - Price of the asset (like an asset of 1 USD vs an asset of 10000 USD required different param) - Timeframe (1-minute param is different than 1-month param) I believe this is caused by the volatility of the selected timeframe since different timeframe has different volatility. Param should be fine-tuned before usage. Here is the param I'm using: BTCUSDT BINANCE 3min: 26 BTCUSDT BINANCE 5min: 28 BTCUSDT BINANCE 1day: 15 Background of the strategy: - The strategy starts with $10 at the start of backtesting (customizable in setting) - The trading fee is set to 0.00% which is not common for most of the popular exchanges (customizable in setting) - The contract size is not a fixed amount, but it uses your balance to buy it at the open price. If you are using the compound mode, your balance will be your current total balance. If you are using the non-compound mode, it will just use the $10 you start with unless you change the amount you start with. If you are using a margin higher than 1, it will calculate the corresponding contract size properly based on your margin. (Only these options are allowed, you are not able to change them without changing the code)"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"Weird Renko Strat\", overlay=true, initial_capital=10)\nmargin_x = input.float(1, \"Margin(x)\")\ncompound = input.bool(true, \"Compound Yield\")\ncounter = input.bool(false, \"Anti Strategy\")\nparam = input.float(10, \"Param\")\nrenko_tickerid = ticker.renko(syminfo.tickerid, 'Traditional', param)\nrenko_c = request.security(renko_tickerid, timeframe.period, close)\nrenko_o = request.security(renko_tickerid, timeframe.period, open)\nrenko_h = request.security(renko_tickerid, timeframe.period, high)\nrenko_l = request.security(renko_tickerid, timeframe.period, low)\ncolor = renko_o < renko_c ?  color.green :  color.red\ndown = input.float(1, \"Drawdown (%)\")\ndrawdown = down/margin_x\n//Date\nfromMonth = input.int(defval = 1,    title = \"From Month\",  minval = 1, maxval = 12\nfromDay   = input.int(defval = 1,    title = \"From Day\",    minval = 1, maxval = 31\nfromYear  = input.int(defval = 2021, title = \"From Year\",   minval = 1970)\nthruMonth = input.int(defval = 1,    title = \"Thru Month\",  minval = 1, maxval = 12\nthruDay   = input.int(defval = 1,    title = \"Thru Day\",    minval = 1, maxval = 31\nthruYear  = input.int(defval = 2112, title = \"Thru Year\",   minval = 1970)\nshowDate  = input(defval = true, title = \"Show Date Range\")\nstart     = timestamp(fromYear, fromMonth, fromDay, 00, 00)            // backtest start  window\nfinish    = timestamp(thruYear, thruMonth, thruDay, 23, 59)            // backtest finish window\nbutton    = input(defval = true, title = \"Max Backtest Timeframe\")     // use to deactivate window\nwindow()  => time >= start and time <= finish ? true : false           // create function \"within window of time\"\nwindowOn  = if window()\n    true\nelse\n    button\n//Turn on counter\nif counter\n    //Turn on compound\n    if compound\n        //Open Long\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Short\", strategy.short, qty=((strategy.equity/open) * \n        //Open Short\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Long\", strategy.long, qty=((strategy.equity/open) * margin_x\n        //Close Long\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Short\")    \n        //Close Short\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Long\")\n    else\n        //Open Long\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Short\", strategy.short, qty=strategy.initial_capital/open\n        //Open Short\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Long\", strategy.long, qty=strategy.initial_capital/open\n        //Close Long\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Short\")    \n        //Close Short\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Long\")\nelse\n    if compound\n        //Open Long\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Long\", strategy.long, qty=((strategy.equity/open) * margin_x\n        //Open Short\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Short\", strategy.short, qty=((strategy.equity/open) * \n        //Close Long\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Long\")    \n        //Close Short\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Short\")\n    else\n        //Open Long\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Long\", strategy.long, qty=strategy.initial_capital/open\n        //Open Short\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.entry(\"Short\", strategy.short, qty=strategy.initial_capital/open\n        //Close Long\n        if ((renko_c[1] > renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Long\")    \n        //Close Short\n        if ((renko_c[1] < renko_c) and (strategy.equity > 0) and (strategy.equity \n            strategy.close(\"Short\")\nmain = plot(strategy.position_avg_price, style=plot.style_stepline, linewidth=2, color\nsub = plot(strategy.position_entry_name==\"Short\" ? strategy.position_avg_price*(1+\nfill(plot1=main, plot2=sub,color= color.new(color.red, 90),title=\"Unrealized Loss Area\""}]}
{"messages": [{"role": "user", "content": "Long/short strategy that identifies extreme readings on the\u00a0rsi\u00a0as a *momentum signal*, unlike most\u00a0RSI\u00a0strategies the script will look to buy or sell the first pullback in the direction of the extreme\u00a0RSI\u00a0reading. Enters positions on the first pullback to the 5ema(low)/ 5ema(high) and exits at rolling 12 bar high/ low. The rolling high/ low feature means that if the price enters into a prolonged consolidation the profit target will begin to reduce with each new bar. The best trades tend to work within 2-6 bars. Built for use on 5 min intervals on FX, Indexes, and Crypto. Lower than 5 minute time frames tend to be noisier and mean more commissions\u00a0and a higher risk of slippage so the suggested timeframe is 5 mins.\u00a0 Hard stop is X ATR (users can experiment with this) from the position entry price. This can be adjusted in user inputs. There is a lot of slack left in entries and exits but the overall strategy is fairly robust across timeframes and markets and has between 60%-70% win rate with larger winners. Signals that occur from economic news\u00a0volatility\u00a0are best avoided."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Marcns_\n//@version=5\nstrategy(\"M0PB\", commission_value = 0.0004, slippage = 1, initial_capital=30000)\n// commision is equal to approx $3.8 per round trip which is accurate for ES1! futures and slippage \n// *momentum pull back* //\n// long / short strategy that identifies extreme readings on the rsi as a *momentum signal*\n//Strategy buys/ sells a pullback to the 5ema(low)/ 5ema(high) and exits at rolling 12 bar high/ low\n//if price enters into a pronlonged consolidation the profit target will begin to reduce with each n\n// hard stop is X atr's from postion average price. This can be adjusted in user inputs.\n// built for use on 5 min & 1min intervals on: FX, Indexes, Crypto\n// there is a lot of slack left in entries and exits but the overall strategy is fairly robust acros\n// signals that occur from economic news volatility are best avoided.  \n// define rsi\nr = ta.rsi(close,6) \n// find rsi > 90\nb = 0.0\nif r >= 90\n    b := 1.0\nelse\n    na\n// find rsi < 10\ns = 0.0\nif r <= 10\n    s := -1.0\nelse\n    na\n// plot rsi extreme as painted background color\nbgcolor(b ?  color.rgb(255, 82, 82, 49): na)\nbgcolor(s?  color.rgb(76, 175, 79, 51): na)\n// exponential moving averages for entries. note that source is high and low (normally close is def \n//entry short price using high as a source ta.ema(high,5)\nes = ta.ema(high,5)\n//entry long price using low as a source ta.ema(low,5)\nel = ta.ema(low,5)\n// long pullback entry trigger: last period above ema and current low below target ema entry \nlet = 0.0\nif low[1] > el[1] and low <= el\n    let := 1.0\nelse\n    na\n//short entry trigger \"\"\nset = 0.0\nif high[1] < es[1] and high >= es\n    set := -1.0\nelse\n    na\n// create signal \"trade_l\" if RSI > 90 and price pulls back to 5ema(low) within 6 bars\ntrade_l = 0.0\nif ta.barssince(b == 1.0) < 6 and let == 1.0\n    trade_l := 1.0\nelse\n    na\nplot(trade_l, \"l_entry\",  color.green)\n//create short signal \"trade_s\" if rsi < 10 and prices pullback to 5em(high) wihthin 6 bars\ntrade_s = 0.0\nif ta.barssince(s == -1.0) < 6 and set == -1.0\n    trade_s := -1.0\nelse\n    na\nplot(trade_s, \"s_entry\",  color.purple)\n// define price at time of trade_l signal and input value into trade_p to use for stop parems later\ntrade_p = strategy.position_avg_price\n//indentify previous 12 bar high as part of long exit strat\n// this creates a rolling 12 bar high target... a quick move back up will exit at previous swing hig\nph = ta.highest(12)\n// inverse of above for short exit strat - previous lowest low of 12 bars as exit (rolling)\npl = ta.lowest(12)\n// 1.5 atr stop below entry price (trade_p defined earlier) as part of exit strat\natr_inp = input.float(2.75, \"atr stop\", minval = 0.1, maxval = 6.0)\natr = ta.atr(10)\nstop_l = trade_p - (atr* atr_inp)\nstop_s = trade_p + (atr* atr_inp)\n//strat entry long\nstrategy.entry(\"EL\", strategy.long, 2, when = trade_l == 1.0)\n//strat entry short\nstrategy.entry(\"ES\", strategy.short, 2, when = trade_s == -1.0)   \n    //strat long exit\nif strategy.position_size == 2\n    strategy.exit(id = \"ph\", from_entry = \"EL\", qty = 2, limit = ph)\n    if strategy.position_size == 2\n        strategy.close_all(when = low[1] > stop_l[1] and low <= stop_l)\n// strat short exit\nif strategy.position_size == -2\n    strategy.exit(id = \"pl\", from_entry = \"ES\", qty = 2, limit =pl)\n    if strategy.position_size == -2\n        strategy.close_all(when = high[1] < stop_s[1] and high >= stop_s)\n// code below to trail remaining 50% of position //\n //if strategy.position_size == 1 \n        //strategy.exit(id =\"trail\", from_entry = \"EL\", qty = 1, stop = el)"}]}
{"messages": [{"role": "user", "content": "This strategy utilizes two pairs of different Moving Averages, two Volume-Weighted Moving Averages (VWMA) and two Simple Moving Averages (SMA). There is a FAST and SLOW version of each VWMA and SMA.  The concept behind this strategy is that volume is not taken into account when calculating a Simple Moving Average.  Simple Moving Averages are often used to determine the dominant direction of price movement and to help a trader look past any short-term volatility or 'noise' from price movement, and instead determine the OVERALL direction of price movement so that one can trade in that direction (trend-following) or look for opportunities to trade AGAINST that direction (fading). By comparing the different movements of a Volume-Weighted Moving Average against a Simple Moving Average of the same length, a trader can get a better picture of what price movements are actually significant, helping to reduce false signals that might occur from only using Simple Moving Averages. The practical applications of this strategy are identifying dominant directional trends. These can be found when the Volume Weighted Moving Average is moving in the same direction as the Simple Moving Average, and ideally, tracking above it.  This would indicate that there is sufficient volume supporting an uptrend or downtrend, and thus gives traders additional confirmation to potentially look for a trade in that direction. One can initially look for the Fast VWMA to track above the Fast SMA as your initial sign of bullish confirmation (reversed for downtrending markets). Then, when the Fast VWMA crosses over the Slow SMA, one can determine additional trend strength. Finally, when the Slow VWMA crosses over the Slow SMA, one can determine that the trend is truly strong. Traders can choose to look for trade entries at either of those triggers, depending on risk tolerance and risk appetite. Furthermore, this strategy can be used to identify divergence or weakness in trending movements. This is very helpful for identifying potential areas to exit one's trade or even look for counter-trend trades (reversals). These moments occur when the Volume-Weighted Moving Average, either fast or slow, begins to trade in the opposite direction as their Simple Moving Average counterpart.  For instance, if price has been trending upwards for awhile, and the Fast VWMA begins to trade underneath the Fast SMA, this is an indication that volume is beginning to falter. Uptrends need appropriate volume to continue moving with momentum, so when we see volume begin to falter, it can be a potential sign of an upcoming reversal in trend. Depending on how quickly one wants to enter into a movement, one could look for crosses of the Fast VWMA under/over the Fast SMA, crosses of the Fast VWMA over/under the Slow SMA, or crosses over/under of the Slow VWMA and the Slow SMA. This concept was originally published here on TradingView by ProfitProgrammers. Here is a link to his original indicator script:  I have added onto this concept by: converting the original indicator into a strategy tester for backtesting adding the ability to conveniently test long or short strategies, or both adding the ability to calculate dynamic position sizes adding the ability to calculate dynamic stop losses and take profit levels using the Average True Range adding the ability to exit trades based on overbought/oversold crosses of the Stochastic RSI conveniently switch between different thresholds or speeds of the Moving Average crosses to test different strategies on different asset classes easily hook this strategy up to 3Commas for automation via their DCA bot feature  Full credit to ProfitProgrammers for the original concept and idea. Any feedback or suggestions are greatly appreciated."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Copyright \u00a9 2022 by CrackingCryptocurrency\n//@version=5\nstrategy(title=\"VWMA/SMA 3Commas Bot\", shorttitle=\"VWMA/SMA 3,,, Bot\", overlay=true\n   calc_on_every_tick=false, pyramiding=1, calc_on_order_fills=true, process_orders_on_close\n// INPUTS:\ni_strategySettings = 'Strategy Settings'\ni_longTrades = input.bool(defval = true, title = 'Long Trades?', tooltip = 'If enabled, the Strategy will perform Long Trades\ni_shortTrades = input.bool(defval = true, title = 'Short Trades?', tooltip = 'If enabled, the Strategy will perform Short Trade\ni_risk = input.float(defval = 2.0, title = 'Risk Percentage', minval = 0.1, step =\ni_entryType = input.string(defval = 'Fast Crosses', title = 'Entry Signal', options\n tooltip = 'What signal triggers a trade. Fast Crosses are crosses of the Fast VWMA and Fast SMA. Medium Crosse\ni_tpmult = input.float(defval = 1.0, title = 'Take Profit Multiple', step = 0.5, tooltip\ni_slmult = input.float(defval = 1.5, title = 'Stop Loss Multiple', step = 0.5, tooltip\ni_vwmaSettings = 'VWMA/SMA Settings'\ni_lenFastVWMA = input.int(13, title='Fast VWMA Length', minval=1, group = i_vwmaSettings\ni_lenSlowVWMA = input.int(26, title='Slow VWMA Length', minval=1, group = i_vwmaSettings\ni_lenFastSMA = input.int(13, title='Fast SMA Length', minval=1, group = i_vwmaSettings\ni_lenSlowSMA = input.int(26, title='Slow SMA Length', minval=1, group = i_vwmaSettings\ni_src = input(title='Source', defval=close, group = i_vwmaSettings)\n// VWMA/SMA Calculations\nfastSMA = ta.sma(i_src, i_lenFastSMA)\nslowSMA = ta.sma(i_src, i_lenSlowSMA)\nfastVWMA = ta.vwma(i_src, i_lenFastVWMA)\nslowVWMA = ta.vwma(i_src, i_lenSlowVWMA)\n//ATR Calculation\natr = ta.atr(21)\ntp = atr * i_tpmult\nsl = atr * i_slmult\n//  Strategy Backtest Limiting Algorithm\nbacktest_group = 'Backtesting Settings'\ni_startTime = input.time(defval=timestamp('01 Jan 2022 13:30 +0000'), title='Backtesting Start Time'\ni_endTime = input.time(defval=timestamp('31 Dec 2099 19:30 +0000'), title='Backtesting End Time'\ntimeCond = time > i_startTime and time < i_endTime\n// Trading Signals\nfastUpCross = ta.crossover(fastVWMA, fastSMA)\nmediumUpCross = ta.crossover(fastVWMA, slowSMA)\nslowUpCross = ta.crossover(slowVWMA, slowSMA)\nfastDownCross = ta.crossunder(fastVWMA, fastSMA)\nmediumDownCross = ta.crossunder(fastVWMA, slowSMA)\nslowDownCross = ta.crossunder(slowVWMA, slowSMA)\nlongEntry = false\nshortEntry = false\nif i_entryType == 'Fast Crosses' and timeCond\n    longEntry := fastUpCross\n    shortEntry := fastDownCross\nif i_entryType == 'Medium Crosses' and timeCond\n    longEntry := mediumUpCross\n    shortEntry := mediumDownCross\nif i_entryType == 'Slow Crosses' and timeCond\n    longEntry := slowUpCross\n    shortEntry := slowDownCross\n// Stochastic RSI - For Exiting Trades \nstoch_group = 'Stochastic RSI Settings'\nuseStoch = input.bool(defval = true, title = 'Use Stochastic RSI To Exit?', tooltip\nk = ta.sma(ta.stoch(close, high, low, 14), 6)\nd = ta.sma(k, 3)\nstoch_crossunder = ta.crossunder(k, d)\nstoch_crossover = ta.crossover(k, d)\nstoch_ob_crossunder = ta.crossunder(k, d) ? math.avg(k, d) >= 80 : na\nstoch_os_crossover = ta.crossover(k, d) ? math.avg(k, d) <= 20 : na\nexitLong = false\nexitShort = false\nif useStoch\n    exitLong := stoch_ob_crossunder\n    exitShort := stoch_os_crossover\n    // Take Profit and Stop Loss - Here we calculate our Take Profit and Stop Loss Levels at the moment \nlongTakeLevel = 0.0\nlongTakeLevel := slowUpCross ? close + tp : longTakeLevel[1]\nlongStopLevel = 0.0\nlongStopLevel := slowUpCross ? close - sl : longStopLevel[1]\nshortTakeLevel = 0.0\nshortTakeLevel := slowDownCross ? close - tp : shortTakeLevel[1]\nshortStopLevel = 0.0\nshortStopLevel := slowDownCross ? close + sl : shortStopLevel[1]\n// Position Sizing - This is how we calculate our Position Size for our Backtest and for our DCA Bot\ninitialCapital = strategy.initial_capital\nbalance = initialCapital + strategy.netprofit\nrisk = i_risk / 100\nloss = balance * risk\nvalueAtClose = ta.valuewhen(slowUpCross, close, 0)\ndistanceToStop = math.abs(valueAtClose - longStopLevel) / valueAtClose\nvalueAtCloseShort = ta.valuewhen(slowDownCross, close, 0)\ndistanceToStopShort = math.abs(valueAtCloseShort - shortStopLevel) / valueAtCloseShort\npositionSize = (loss / (distanceToStop / valueAtClose)) / valueAtClose\npositionSizeShort = (loss / (distanceToStopShort / valueAtCloseShort)) / valueAtCloseShort\nif positionSize > 1000000\n    positionSize := 1000000\nif positionSize < 0\n    positionSize := 1\nif positionSizeShort > 1000000\n    positionSizeShort := 1000000\nif positionSizeShort < 0\n    positionSizeShort := 1\n// Close Function - This will cause the Bot to close the trade when the specified actions occur. \ncloseFunction = strategy.position_entry_name == 'Long' and high > longTakeLevel or\ncloseFunctionShort = strategy.position_entry_name == 'Short' and low < shortTakeLevel\n//Strategy Stuff\nstrategy.entry('Long', strategy.long, when = longEntry, qty = positionSize)\nstrategy.entry('Short', strategy.short, when = shortEntry, qty = positionSizeShort\nstrategy.exit('Long Exit', from_entry='Long', limit = longTakeLevel, stop = longStopLevel\nstrategy.exit('Short Exit', from_entry = 'Short', limit = shortTakeLevel, stop = shortStopLevel\nstrategy.close('Long', when = closeFunction)\nstrategy.close('Short', when = closeFunctionShort)\n// Automation Stuff \n// Note for Users - Simply replace the JSON messages below with your Bot Message from your 3Commas D\n// If you have any issues with the Bot not sizing your trades up to your correct position size, try \nbuyAlert = '{  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \"email_token\": \"insert your email to\nexitAlert = '{  \"action\": \"close_at_market_price\",  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \naddAlert = '{  \"action\": \"add_funds_in_quote\",  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \"em\nshortAlert = '{  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \"email_token\": \"insert your email to\nexitShortAlert = '{  \"action\": \"close_at_market_price\",  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \naddShortAlert = '{  \"action\": \"add_funds_in_quote\",  \"message_type\": \"bot\",  \"bot_id\": insert your bot id here,  \"em\nif longEntry\n    alert(buyAlert, alert.freq_once_per_bar) \nif shortEntry\n    alert(shortAlert, alert.freq_once_per_bar)\nif closeFunction\n    alert(exitAlert, alert.freq_once_per_bar)\nif closeFunctionShort\n    alert(exitShortAlert, alert.freq_once_per_bar)\nif longEntry\n    alert(addAlert, alert.freq_once_per_bar)\nif shortEntry\n    alert(addShortAlert, alert.freq_once_per_bar)\n// Plots \ns0 = plot(slowSMA, title='Slow SMA', color= color.new(color.red, 0), linewidth=2)\nv0 = plot(slowVWMA, title='Slow VWMA', color= color.new(color.green, 0), linewidth\ns1 = plot(fastSMA, title='Fast SMA', color= color.new(color.fuchsia, 0), linewidth\nv1 = plot(fastVWMA, title='Fast VWMA', color= color.new(color.teal, 0), linewidth\nfill(s0, v0, color=slowSMA < slowVWMA ?  color.new(color.green, 70) :  color.new\nfill(s1, v1, color=fastSMA < fastVWMA ?  color.new(color.teal, 80) :  color.new("}]}
{"messages": [{"role": "user", "content": "This is a time based strategy, designed to enter and exit within the same day of the week, using different hours for entry and exit. The script is long only direction, and it has no risk management inside, so use it with caution. At the same time you can also calculate each individual hour return within a certain day, and make your own idea about the best moments to be enter. In order to filter a bit from the bad trades, I have applied an ATR filter, to check if that volatility is rising in order to help eliminate some of the bad trades when there is no volatility around. For this example, on BTC, it seems that for the last years, on tuesday and thursday, enterring at the beginning of the daily candle, 01:00hours and exit at 00:00 hours, seems to give positive results giving the idea that can be converted in some sort of edge into our favor. However dont take this entirelly for granted and conduct your own searches"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 exlux99\n//@version=5\nstrategy(\"Time Based Crypto DayTrade Strategy\",overlay=true, pyramiding=1, initial_capital\natr= ta.atr(input(13))\natr2=ta.atr(input(7))\natr_filter = false\nif(atr > atr2)\n    atr_filter:=true \nmonday=input.bool(false)\ntuesday=input.bool(true)\nwednesday=input.bool(false)\nthursday=input.bool(true)\nfriday=input.bool(false)\nsaturday=input.bool(false)\nsunday=input.bool(false)\nhour_entry=input(1)\nhour_exit=input(0)\nif(monday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==1 and\n    strategy.close(\"long\", when=  hour==hour_exit)\nif(tuesday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==2 and\n    strategy.close(\"long\", when= hour==hour_exit )\nif(wednesday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==3 and\n    strategy.close(\"long\", when= hour==hour_exit )\nif(thursday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==4 and\n    strategy.close(\"long\", when= hour==hour_exit )\nif(friday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==5 and\n    strategy.close(\"long\", when= hour==hour_exit )\nif(saturday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==6 and\n    strategy.close(\"long\", when= hour==hour_exit )\nif(sunday)\n    strategy.entry(\"long\", strategy.long, when= hour==hour_entry and dayofweek==7 and\n    strategy.close(\"long\", when= hour==hour_exit )"}]}
{"messages": [{"role": "user", "content": "---Overview--- The system buys fear and sells greed. Its relies on a Relative Strength Index (RSI) and moving averages (MA) to find oversold and overbought states. It seems to work best in market conditions where the Bond market has a negative Beta to Stocks. Backtests in a longer Timeframe will clearly show this. ---Parameter--- Frequency: Smothens the RSI curve, helps to \"remember\" recent highs better. RsiFrequency: A Frequency of 40 implies a RSI over the last 40 Bars. BuyZoneDistance: Spacing between the different zones. A wider spacing reduces the amount of signals and icnreases the holding duration. Should be finetuned with tradingcosts in mind. AvgDownATRSum: The multiple of the Average ATR over 20 Bars * amount of opentrades for your average down. I choose the ATR over a fixed percent loss to find more signals in low volatility environments and less in high volatility environments. ---Some of my thoughts--- Be very careful about the good backtesting performance in many US-Stocks because the System had a favourable environment since 1970. Be careful about the survivorship bias as well.  52% of stocks from the S&P500 were removed since 2000. I discount my Annual Results by 5% because of this fact. You will find yourself quite often with very few signals because of the high market correlation. My testing suggests that there is no expected total performance difference between a signal from a bad and a signal from a good market condition but a higher volatility. I am sharing this strategy because i am currently not able to implement it as i want to and i think that meanreversion is starting to be taken more serious by traders. The challange in implementing this strategy is that you need to be invested 100% of the time to retrieve the expected annual performance and to reduce the fat tail risk by market crashes."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 I11L\n//@version=5\nstrategy(\"I11L - Meanreverter 4h\", overlay=false, pyramiding=3, default_qty_value=10000\n frequency = input.int(10)\nrsiFrequency = input.int(40)\nbuyZoneDistance = input.int(5)\navgDownATRSum = input.int(3)\nuseAbsoluteRSIBarrier = input.bool(true)\nbarrierLevel = 50//input.int(50)\nmomentumRSI = ta.rsi(close,rsiFrequency)\nmomentumRSI_slow = ta.sma(momentumRSI,frequency)\n isBuy = momentumRSI < momentumRSI_slow*(1-buyZoneDistance/100) and (strategy.position_avg_price\nisShort = momentumRSI > momentumRSI_slow*(1+buyZoneDistance/100) and (strategy.position_avg_price\nmomentumRSISoftClose = (momentumRSI > momentumRSI_slow) and (momentumRSI > barrierLevel\nisClose = momentumRSISoftClose\nplot(momentumRSI,color=isClose ?  color.red :  momentumRSI < momentumRSI_slow*(1-buyZoneDistance\nplot(momentumRSI_slow,color= color.gray)\nplot(barrierLevel,color=useAbsoluteRSIBarrier ?  color.white :  color.rgb(0,0,0,0\nplot(momentumRSI_slow*(1-buyZoneDistance/100),color= color.gray)\nplot(momentumRSI_slow*(1+buyZoneDistance/100),color= color.gray)\nplot(momentumRSI_slow*(1+(buyZoneDistance*2)/100),color= color.gray)\n// plot(strategy.wintrades - strategy.losstrades)\n  if(isBuy)\n    strategy.entry(\"Buy\",strategy.long, comment=\"#\"+str.tostring(strategy.opentrades\n// if(isShort)\n//     strategy.entry(\"Sell\",strategy.short, comment=\"#\"+str.tostring(strategy.opentrades+1))\nif(isClose)\n    strategy.exit(\"Close\",limit=close)"}]}
{"messages": [{"role": "user", "content": "This is a long term/investment type of strategy designed to have a good idea about where the big trend direction is headed. Its logic, its made entirely on the COT report, mainly from looking into the net non comercial positions aka the speculators. For bullish trend we look that the difference between long non comercial vs short non comercial is higher than 0 For bearish trend we look that the difference between long non comercial vs short non comercial is lower than 0. This is mainly as an educational tool, for a full strategy, I recommend implement other things into it, like technical analysis or risk management. If you have any questions, please let me know !"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 exlux99\n//@version=5\nstrategy(\"EURUSD COT Strategy\",overlay=true)\nlong_noncom   = request.security(\"QUANDL:CFTC/\"+'099741'+'_F_L_ALL|1', \"W\", close) \nshort_noncom  = request.security(\"QUANDL:CFTC/\"+'099741'+'_F_L_ALL|2', \"W\", close) \nnet_noncomercial = long_noncom-short_noncom\nlong = net_noncomercial > 0 \nshort = net_noncomercial < 0 \nstrategy.entry(\"long\",strategy.long,when=long)\nstrategy.entry(\"short\",strategy.short,when=short)"}]}
{"messages": [{"role": "user", "content": "what is \"RSI Divergence Strategy\"? it is a RSI strategy based this indicator:  what it does? it gives buy or sell signals according to RSI Divergences. it also has different variables such as \"take profit\", \"stop loss\" and trailing stop loss. how it does it?  it uses the \"RSI Divergence\" indicator to give signal. For detailed information on how it works, you can visit the link above. The quantity of the inputs is proportional to the rsi values. Long trades are directly traded with \"RSI\" value, while short poses are traded with \"100-RSI\" value. How to use it? The default settings are for scalp strategy but can be used for any type of trading strategy. you can develop different strategies by changing the sections. It is quite simple to use. RSI length is length of RS\u0130 source is source of RS\u0130 RS\u0130 Divergence lenght is length of line on the RSI The \"take profit\", \"stop\" and \"trailing stop\" parts used in the \"buy\" group only affect buys. The \"sell\" group is similarly independent of the variables in the \"buy\" group. The \"zoom\" section is used to enlarge or reduce the indicator. it only changes the appearance, it does not affect the results of the strategy."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 faytterro\n//@version=5\nstrategy(\"RSI Divergence Strategy\", overlay=true, scale = scale.none)\nrsilen=input.int(14, title=\"rsi length\")\nrsisrc=input(close, title=\"source\")\nx=ta.rsi(rsisrc,rsilen)\nlen=input.int(14, title=\"RSI Divergence length\", maxval=500)\ntpb = input.float(25, title=\"take profit\", group = \"buy\", step = 0.5)\nsb = input.float(5, title=\"stop\", group = \"buy\", step = 0.5)\ntsb = input.float(0.25, title=\"trailing stop\", group = \"buy\", step = 0.5)\ntps = input.float(25, title=\"take profit\", group = \"sell\", step = 0.5)\nss =input.float(5, title=\"stop\", group = \"sell\", step = 0.5)\ntss = input.float(0.25, title=\"trailing stop\", group = \"sell\", step = 0.5)\nsrc=close\nextrapolation=0\nzoom=input.int(0, title=\"zoom\", maxval=27, minval=-27)\nhline(300-zoom*10, color= color.rgb(54, 58, 69, 100))\nhline(10, color= color.rgb(54, 58, 69, 100))\n// for ax+b\nxo=0.0\nyo=0.0\nxyo=0.0\nxxo=0.0\nfor i=0 to len-1\n    xo:= xo + i/(len)\n    yo:= yo + x[len-1-i]/(len)\n    xyo:= xyo + i*x[len-1-i]/(len)\n    xxo:= xxo + i*i/(len)\ndnm=ta.lowest(low,200)\ndizi=array.new_float(len*2+1+extrapolation)\nlinedizi=array.new_line()\na=(xo*yo-xyo)/(xo*xo-xxo)\nb=yo-a*xo\nfor i=0 to len-1+extrapolation\n    array.set(dizi,i,a*i+b)\n//// for src\n// for ax+b\nxo2=0.0\nyo2=0.0\nxyo2=0.0\nxxo2=0.0\nfor i=0 to len-1\n    xo2:= xo2 + i/(len)\n    yo2:= yo2 + src[len-1-i]/(len)\n    xyo2:= xyo2 + i*src[len-1-i]/(len)\n    xxo2:= xxo2 + i*i/(len)\ndizi2=array.new_float(len*2+1+extrapolation)\nlinedizi2=array.new_line()\na2=(xo2*yo2-xyo2)/(xo2*xo2-xxo2)\nb2=yo2-a*xo2\nfor i=0 to len-1+extrapolation\n    array.set(dizi2,i,a2*i+b2)\nttk=((array.get(dizi,0)<array.get(dizi,1)) and (array.get(dizi2,0)>array.get(dizi2\n ((array.get(dizi,0)>array.get(dizi,1)) and (array.get(dizi2,0)<array.get(dizi2,1)\ncg=((array.get(dizi,0)<array.get(dizi,1)) and (array.get(dizi2,0)>array.get(dizi2,\ncr=((array.get(dizi,0)>array.get(dizi,1)) and (array.get(dizi2,0)<array.get(dizi2,\nbgcolor(color=(cg and ta.highest(ttk[1],len/2)<1)?  color.rgb(76, 175, 79, 50) : \n (cr and ta.lowest(ttk[1],len/2)>-1)?  color.rgb(255, 82, 82, 50) : na, offset=0,\nplot(x)\n// for ax+b\nxo3=0.0\nyo3=0.0\nxyo3=0.0\nxxo3=0.0\nfor i=0 to len-1\n    xo3:= xo3 + i/(len)\n    yo3:= yo3 + x[len-1-i+(ta.barssince(cg))]/(len)\n    xyo3:= xyo3 + i*x[len-1-i+(ta.barssince(cg))]/(len)\n    xxo3:= xxo3 + i*i/(len)\ndizi3=array.new_float(len*2+1+extrapolation)\nlinedizi3=array.new_line()\na3=(xo3*yo3-xyo3)/(xo3*xo3-xxo3)\nb3=yo3-a3*xo3\nfor i=0 to len-1+extrapolation\n    array.set(dizi3,i,a3*i+b3)\n// for ax+b\nxo4=0.0\nyo4=0.0\nxyo4=0.0\nxxo4=0.0\nfor i=0 to len-1\n    xo4:= xo4 + i/(len)\n    yo4:= yo4 + x[len-1-i+(ta.barssince(cr))]/(len)\n    xyo4:= xyo4 + i*x[len-1-i+(ta.barssince(cr))]/(len)\n    xxo4:= xxo4 + i*i/(len)\ndizi4=array.new_float(len*2+1+extrapolation)\nlinedizi4=array.new_line()\na4=(xo4*yo4-xyo4)/(xo4*xo4-xxo4)\nb4=yo4-a4*xo4\nfor i=0 to len-1+extrapolation\n    array.set(dizi4,i,a4*i+b4)\nline=line.new((last_bar_index-ta.barssince(cg)-len),\n array.get(dizi3,0), \n last_bar_index-ta.barssince(cg),\n array.get(dizi3,len-1), color= color.rgb(0,255,0), width=2)\nline2=line.new((last_bar_index-ta.barssince(cr)-len),\n array.get(dizi4,0), \n last_bar_index-ta.barssince(cr),\n array.get(dizi4,len-1), color= color.rgb(255, 0, 0, 0), width=2)\nline.delete(line[1])\nline.delete(line2[1])\nalert=((array.get(dizi,0)<array.get(dizi,1)) and (array.get(dizi2,0)>array.get(dizi2\n or ((array.get(dizi,0)>array.get(dizi,1)) and (array.get(dizi2,0)<array.get(dizi2\nalertcondition(alert)\nhline(50)\nrs=hline(30)\nrss=hline(70)\nfill(rs, rss, color= color.rgb(126, 87, 194, 90), title=\"RSI Background Fill\")\nlongCondition = cg and ta.highest(ttk[1],len/2)<1 \nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, qty = math.round(x))\n    strategy.exit(\"exit long\", \"Long\", limit = close*(100+tpb)/100 , stop =close*(\nshortCondition = cr and ta.lowest(ttk[1],len/2)>-1 \nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short, qty = math.round(100-x))\n    strategy.exit(\"exit short\", \"Short\", limit = close*(100-tps)/100, stop = close"}]}
{"messages": [{"role": "user", "content": "Plug the breakeven line code into the bottom of your strategy to get visualization of your breakeven price. Line is green when net position is long, red when net short and invisible when strategy is risk neutral. Most useful for strategies which use pyramiding (successive entries in same direction stacked upon each other) as it can be difficult to track where prices needs to return to to allow closing in profit. Disclaimer: the strategy logic is garbage do not use it. It is only there so you can see how Breakeven Line logic is implemented."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Eliza123123\n//@version=5\nstrategy(\"Breakeven Line Demo\", overlay=true, default_qty_type=strategy.percent_of_equity\n pyramiding=999, initial_capital=10000, commission_type=strategy.commission.percent\n// Generic signal (not a viable strategy don't use, just some code I wrote quick for demo purposes o\nred = open > close, green = open < close\nsevenReds = red and red[1] and red[2] and red[3] and red[4] and red[5] and red[6]\nsevenGreens = green and green[1] and green[2] and green[3] and green[4] and green[5\nif sevenReds\n    strategy.entry('Buy', direction=strategy.long)\nif sevenGreens\n    strategy.entry('Sell', direction=strategy.short)\nif (hour == 5 and minute == 0 ) or (hour == 11 and minute == 0) or (hour == 17 and \n    strategy.close_all(\"Close\")\n// Breakeven line for visualising breakeven price on stacked orders.  \nvar breakEvenLine = 0.0\nif strategy.opentrades > 0 \n    breakEvenLine := strategy.position_avg_price\nelse\n    breakEvenLine := 0.0\ncolor breakEvenLineColor = na\nif strategy.position_size > 0\n    breakEvenLineColor :=  #15FF00\nif strategy.position_size < 0\n    breakEvenLineColor :=  #FF000D\nplot(breakEvenLine, color = breakEvenLine and breakEvenLine[1] > 0 ? breakEvenLineColor"}]}
{"messages": [{"role": "user", "content": "An exponential moving average ( EMA ) is a type of moving average (MA) that places a greater weight and significance on the most recent data points. The exponential moving average is also referred to as the exponentially weighted moving average . An exponentially weighted moving average reacts more significantly to recent price changes than a simple moving average simple moving average ( SMA ), which applies an equal weight to all observations in the period. Moving average convergence divergence ( MACD ) is a trend-following momentum indicator that shows the relationship between two moving averages of a security\u2019s price. The MACD is calculated by subtracting the 26-period exponential moving average ( EMA ) from the 12-period EMA . The result of that calculation is the MACD line. A nine-day EMA of the MACD called the \"signal line,\" is then plotted on top of the MACD line, which can function as a trigger for buy and sell signals. Traders may buy the coin when the MACD crosses above its signal line and sell\u2014or short\u2014the security when the MACD crosses below the signal line. Moving average convergence divergence ( MACD ) indicators can be interpreted in several ways, but the more common methods are crossovers, divergences, and rapid rises/falls. The Strategy enters and closes the trade when the following conditions are met: LONG The MACD histogram turns bullish EMA8 is greater than EMA26 EXIT Price increases 3% trailing Price decreases 1% trailing This strategy is back-tested from 1 January 2022 to simulate how the strategy would work in a bear market and provides good returns. Pairs that produce very strong results include AXSUSDT on the 5-minute timeframe. This short timeframe means that this strategy opens and closes trades regularly. Additionally, the trailing stop loss and take profit conditions can also be changed to match your needs. The strategy assumes each order is using 30% of the available coins to make the results more realistic and to simulate you only ran this strategy on 30% of your holdings. A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Coinrule\n//@version=5\nstrategy('Fast EMA above Slow EMA with MACD (by Coinrule)',\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=30,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 1, 1, 0, 0)\nnotInTrade = strategy.position_size <= 0\n// EMAs \nfastEMA = ta.ema(close, 8)\nslowEMA = ta.ema(close, 26)\nplot(fastEMA, color =  color.blue)\nplot(slowEMA, color =  color.green)\n//buyCondition1 = ta.crossover(fastEMA, slowEMA)\nbuyCondition1 = fastEMA > slowEMA\n// DMI and MACD inputs and calculations\n[macd, macd_signal, macd_histogram] = ta.macd(close, 12, 26, 9)\nbuyCondition2 = ta.crossover(macd, macd_signal)\n// Configure trail stop level with input options\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nshortStopPrice = 0.0\nlongStopPrice := if strategy.position_size > 0\n    stopValue = close * (1 - longTrailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\n    if (buyCondition1 and buyCondition2 and notInTrade and timePeriod)\n    strategy.entry(id=\"Long\", direction = strategy.long)\nstrategy.exit(id=\"Exit\", stop = longStopPrice, limit = shortStopPrice)\n//if (sellCondition1 and sellCondition2 and notInTrade and timePeriod)\n//strategy.close(id=\"Close\", when = sellCondition1 or sellCondition2)"}]}
{"messages": [{"role": "user", "content": "Description: A Long only strategy based on breakout from a certain level formed by High price. It has auto-backtesting capabilities (you set ranges for the three main parameters: Lookback, TP and SL; the strategy then goes through different combinations of those parameters and displays a table with results that you can sort by Percentage of profitable trades AND/OR Net profit AND/OR Number of trades). So you can, for example, sort only by Net profit to find combination of parameters that gives highest net profit, or sort by Net profit and Percentage profitable to find a combination of parameters that gives the best balance between profitability and profit. The auto-backtesting also takes into account the commission which is set in % in the inputs (make sure to set the same value in properties of the strategy so that auto-backtesting and real backtesting results match). NOTE: auto-backtesting only find the best combinations and displays them in a table, you will then need to manually set the Lookback, TP and SL inputs for real backtesting to match.   Parameters:  - Lookback -> # of bars for filtering signals; recommended range from 2 to 5 - TP (%) -> take profit; recommended range from 5 to 10 - SL (%) -> stop loss; recommended range from 1 to 5 - Commission (%) -> commission per trade - Min/Max Lookback -> lookback range for auto-backtesting  - Min/Max TP -> take profit range for auto-backtesting  - Min/Max SL -> stop loss range for auto-backtesting  - Percentage profitable -> sort by percentage of profitable trades - Net profit -> sort by net profit - Number of trades -> sort by number of trades"}, {"role": "assistant", "content": "// \u00a9 -_-\n//@version=5\nstrategy(\"[-_-] LBAB\", process_orders_on_close=true, overlay=true, max_labels_count\n// Inputs\nlookback = input.int(2, title=\"Lookback\", minval=2, maxval=15)      \ntp = input.float(5, title=\"TP (%)\", minval=1, maxval=10000)            \nsl = input.float(5, title=\"SL (% from Low)\", minval=1, maxval=100)  \ncom = input.float(0.075, title=\"Commission (%)\", minval=0, maxval=50)\nmin_lookback_tr = input.float(2, title=\"Min Lookback\", minval=1, maxval=500, inline\nmax_lookback_tr = input.float(5, title=\"Max Lookback\", minval=1, maxval=500, inline\nmin_tp_tr = input.float(5, title=\"Min TP (%)\", minval=1, maxval=10000, inline=\"tr_tp\"\nmax_tp_tr = input.float(10, title=\"Max TP (%)\", minval=1, maxval=10000, inline=\"tr_tp\"\nmin_sl_tr = input.float(1, title=\"Min SL (%)\", minval=1, maxval=100, inline=\"tr_sl\"\nmax_sl_tr = input.float(5, title=\"Max SL (%)\", minval=1, maxval=100, inline=\"tr_sl\"\nimp_perc_profit = input.bool(true, title=\"Percentage profitable\", group=\"Optimisation\"\nimp_netprofit = input.bool(false, title=\"Net profit\", group=\"Optimisation\")\nimp_numtrades = input.bool(false, title=\"Number of trades\", group=\"Optimisation\")\ntable_pos = input.string(\"Bottom Right\", title=\"Position\", options=[\"Top Left\", \"Top Center\"\ntable_font_size = input.string(\"Normal\", title=\"Font size\", options=[\"Auto\", \"Tiny\"\n// Table parameters\ntable_pos_ = switch table_pos \n    \"Top Left\" => position.top_left\n    \"Top Center\" => position.top_center\n    \"Top Right\" => position.top_right\n    \"Middle Left\" => position.middle_left\n    \"Middle Center\" => position.middle_center\n    \"Middle Right\" => position.middle_right\n    \"Bottom Left\" => position.bottom_left\n    \"Bottom Center\" => position.bottom_center\n    \"Bottom Right\" => position.bottom_right\ntable_font_size_ = switch table_font_size\n    \"Auto\" => size.auto\n    \"Tiny\" => size.tiny\n    \"Small\" => size.small\n    \"Normal\" => size.normal\n    \"Large\" => size.large\n// Sorting function (first element will be largest)\nsortArr(arr, arr_index) =>\n    n = array.size(arr) - 1 \n    for i = 0 to n - 1\n        for j = 0 to n - i - 1\n            if array.get(arr, j) < array.get(arr, j + 1)\n                temp = array.get(arr, j)\n                temp_index = array.get(arr_index, j)\n                array.set(arr, j, array.get(arr, j + 1))\n                array.set(arr, j + 1, temp)\n                array.set(arr_index, j, array.get(arr_index, j + 1))\n                array.set(arr_index, j + 1, temp_index)\n// Safe checks\nif min_lookback_tr > max_lookback_tr \n    runtime.error(\"Min Lookback must be less than Max Lookback\")\nif min_tp_tr > max_tp_tr \n    runtime.error(\"Min Take Profit must be less than Max Take Profit\")\nif min_sl_tr > max_sl_tr\n    runtime.error(\"Min Stop Loss must be less than Max Stop Loss\")\n// \ntp_min_ = int(min_tp_tr / 1)\ntp_max_ = int(max_tp_tr / 1)\nsl_min_ = int(min_sl_tr / 1)\nsl_max_ = int(max_sl_tr / 1)\n// Size for arrays\narr_size = int((max_lookback_tr - min_lookback_tr + 1) * (tp_max_ - tp_min_ + 1) *\n// Arrays\nvar arr_bi = array.new_int(arr_size, na)           // bar_index of Smash Day\nvar arr_in_pos = array.new_bool(arr_size, false)   // are we in a position?\nvar arr_params = array.new_string(arr_size, \"\")\nvar arr_wonlost = array.new_string(arr_size, \"\")\nvar arr_profit = array.new_float(arr_size, 0)\n// Testing what parameters are best\nindex = 0\n// Lookback\nfor lookback_i = min_lookback_tr to max_lookback_tr\n    // Take profit\n    for tp_i = tp_min_ to tp_max_\n        // Stop loss\n        for sl_i = sl_min_ to sl_max_\n            // Parameters of current iteration\n            lookback_ = lookback_i\n            tp_ = tp_i\n            sl_ = sl_i\n            //\n            if array.get(arr_params, index) == \"\"\n                array.set(arr_params, index, str.tostring(lookback_) + \" \" + str.tostring\n            // Was there an entry?\n            was_edone = false\n            // If entry price reached\n            if not array.get(arr_in_pos, index) and not na(array.get(arr_bi, index\n                if high >= high[bar_index - array.get(arr_bi, index)] and bar_index\n                    array.set(arr_in_pos, index, true)\n                    was_edone := true\n            // If we're in a position\n            if array.get(arr_in_pos, index) and bar_index != array.get(arr_bi, index\n                low_sl = low[bar_index - array.get(arr_bi, index)] * (1 - sl_ / 100\n                high_ep = high[bar_index - array.get(arr_bi, index)]\n                high_tp = high_ep * (1 + tp_ / 100)\n                amount = 100\n                // Stop loss\n                if low <= low_sl\n                    array.set(arr_in_pos, index, false)\n                    array.set(arr_wonlost, index, array.get(arr_wonlost, index) + \n                    array.set(arr_profit, index, array.get(arr_profit, index) - math.abs\n                    array.set(arr_bi, index, na)\n                // Take profit\n                if high >= high_tp\n                    array.set(arr_in_pos, index, false)\n                    array.set(arr_wonlost, index, array.get(arr_wonlost, index) + \n                    array.set(arr_profit, index, array.get(arr_profit, index) + math.abs\n                    array.set(arr_bi, index, na)\n            // Entry condition\n            cond = barstate.isconfirmed and close < low[1] and high[1] < high[lookback_\n            // New entry price\n            if cond and not array.get(arr_in_pos, index)\n                array.set(arr_bi, index, bar_index)\n                        // Update index\n            index := index + 1\n// Checking the results\nvar table t = na\nvar result_index = array.new_int(0, na)\nvar result_arr_winrate = array.new_float(0, na)\nvar result_arr_tradenum = array.new_int(0, na)\nvar sort_array = array.new_float(0, na)\nif (barstate.islast or barstate.islastconfirmedhistory) and na(t)\n    for i = 0 to array.size(arr_params) - 1\n        wins = 0\n        losses = 0\n        arr = array.get(arr_wonlost, i)\n        for j = 0 to str.length(arr) - 1\n            str_ = str.substring(arr, j, j + 1)\n            if str_ == \"0\"\n                losses := losses + 1\n            if str_ == \"1\"\n                wins := wins + 1\n        // Push percentage profitable trades\n        perc_profit = math.round(wins / (wins + losses) * 100, 2)\n        array.push(result_arr_winrate, perc_profit)\n        // Push number of trades\n        trade_num = str.length(array.get(arr_wonlost, i))\n        array.push(result_arr_tradenum, trade_num)\n        // Push index\n        array.push(result_index, i)\n        // For combined sorting                          \n        array.push(sort_array, (imp_netprofit ? array.get(arr_profit, i) : 1) * (imp_perc_profit\n    // Sort\n    sortArr(array.copy(sort_array), result_index)\n    t := table.new(columns=6, rows=13, bgcolor= color.white, border_color= color.new\n    table.cell(t, 0, 0, \"% Profitable\" + (imp_perc_profit ? \" \u2193\" : \"\"), bgcolor=imp_perc_profit\n    table.cell(t, 1, 0, \"Net Profit\" + (imp_netprofit ? \" \u2193\" : \"\"), bgcolor=imp_netprofit\n    table.cell(t, 2, 0, \"# of trades\" + (imp_numtrades ? \" \u2193\" : \"\"), bgcolor=imp_numtrades\n    table.cell(t, 3, 0, \"Lookback\", text_size=table_font_size_)\n    table.cell(t, 4, 0, \"Take Profit %\", text_size=table_font_size_)\n    table.cell(t, 5, 0, \"Stop Loss %\", text_size=table_font_size_)\n    counter = 0\n    forloop_counter = math.min(array.size(result_index) - 1, 10)\n    for i = 0 to forloop_counter\n        i_ = array.get(result_index, i)\n        params_ = str.split(array.get(arr_params, i_), \" \")\n        col_ = color.from_gradient(i, 0, 10,  color.new(color.blue, 75),  color.new\n        table.cell(t, 0, i + 1, str.tostring(array.get(result_arr_winrate, i_)) + \n        table.cell(t, 1, i + 1, str.tostring(math.round(array.get(arr_profit, i_),\n        table.cell(t, 2, i + 1, str.tostring(array.get(result_arr_tradenum, i_)), \n        table.cell(t, 3, i + 1, array.get(params_, 0), bgcolor=col_, text_size=table_font_size_\n        table.cell(t, 4, i + 1, array.get(params_, 1), bgcolor=col_, text_size=table_font_size_\n        table.cell(t, 5, i + 1, array.get(params_, 2), bgcolor=col_, text_size=table_font_size_\n        counter := counter + 1\n    // Warn if timeframe is <= 10 minutes\n    if timeframe.in_seconds(timeframe.period) <= 600\n        table.cell(t, 0, forloop_counter + 2, \"Timeframe might be too low\", bgcolor\n        table.merge_cells(t, 0, forloop_counter + 2, 5, forloop_counter + 2)\n// Strategy\nvar int bi = na\nvar int pos_bi = na\n// Buy condition\ncond = barstate.isconfirmed and close < low[1] and high[1] < high[lookback + 1] and\n// Stop loss, Take profit\nif strategy.position_size[1] == 0 and strategy.position_size > 0 and bar_index != \n    strategy.exit(\"TP/SL\", \"Long\", stop=low[bar_index - bi] * (1 - sl / 100), limit\n    pos_bi := bar_index\n// Buy\nif cond \n    strategy.order(\"Long\", strategy.long, stop=high)\n    bi := bar_index\n// Box\nif strategy.position_size[1] != 0 and strategy.position_size == 0\n    tn = strategy.closedtrades - 1\n    penp = strategy.closedtrades.entry_price(tn)\n    pexp = strategy.closedtrades.exit_price(tn)\n    box.new(pos_bi, math.max(pexp, penp), bar_index, math.min(penp, pexp), border_color"}]}
{"messages": [{"role": "user", "content": "This is a Trend Following strategy based on the Trend Confidence indicator. The goal of this strategy is to be a simple Trend Following strategy, but also to be as precise as possible when it comes to the question 'how confident are we that a linear trend is ongoing?'. For this we calculate the 'confidence' of a linear trend in the past number of closing prices. The idea of this strategy is that past a certain confidence, the ongoing linear trend is more likely to continue than not.  Trend Confidence: The Trend Confidence shows us how strong of a linear trend the price has made in the past number (given by Length parameter) of closing prices. The steepness of the price change makes the Trend Confidence more extreme (more positive for an uptrend or more negative for a downtrend), and the deviation from a straight line makes the Trend Confidence less extreme (brings the confidence closer to 0). This way we can filter out signals by wild/sudden price moves that don't follow a clear linear trend.  Math behind the Trend Confidence: A linear fit is made on the past number of closing prices, using Ordinary Linear Regression. We have the steepness of the linear fit: b in y=a+bx. And we have the standard deviation of the distances from the closing prices to the linear fit: sd. The Trend Confidence is the ratio b/sd. Entries and Exits: For entry and exit points we look at how extreme the Trend Confidence is. The strategy is based on the assumption that past a certain confidence level, the ongoing linear trend is more likely to continue than not.  So when the Trend Confidence passes above the 'Long entry\" threshold, we go Long. After that when the Trend Confidence passes under the 'Long exit' threshold, we exit. The Long entry should be a positive value so that we go Long once a linear uptrend with enough confidence has been detected.  When the Trend Confidence passes below the 'Short entry' threshold, we go Short. After that when the Trend Confidence passes above the 'Short exit' threshold, we exit. The Short entry should be a negative value so that we go Short once a linear downtrend with enough confidence has been detected.  Default Parameters: The strategy is intended for BTC-USD market, 4 hour timeframe. The strategy also works on ETH-USD with similar parameters.  The Length is arbitrarily set at 30, this means we look at the past 30 closing prices to determine a linear trend. Note that changing the length will change the range of Trend Confidence values encountered.  The default entry and exit thresholds for Longs and Shorts do not mirror each other. This is because the BTC-USD market goes up more heavily and more often than it goes down. So the ideal parameters for Longs and Shorts are not the same.  The positive results of the strategy remain when the parameters are slightly changed (robustness check).  The strategy uses 100% equity per trade, but has a 10% stop loss so that a maximum of 10% is risked per trade.  Commission is set at 0.1% as is the highest commission for most crypto exchanges. Slippage is set at 5 ticks, source for this is theblock.co."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 carefulCamel61097\n// ################################################################################################\n// \"This is a trend following strategy that performed very well on the past 5 years\"\n// \"Intended to be used on BTC-USDT, 4hr timeframe\"\n// \"A factor 2 Leverage can be added by changing Order Size to 200% of equity\"\n// \"Higher leverage is not recommended due to big drawdowns\"\n// \"Also seems to work on 1D timeframe, although ideal parameters may be different\"\n// \"Also seems to work on ETH-USDT and some other altcoins, although ideal parameters are different\"\n// ################################################################################################\n//@version=5\nstrategy(\"Trend Following based on Trend Confidence\", overlay=false, pyramiding=1, \n// Inputs\nsource      = input(close)\nsince       = input.time(timestamp('2000-01-01'), title='Start trading interval')\ntill        = input.time(timestamp('2030-01-01'), title='End trading interval')\nlength      = input(30, title='Length')\nlongs_on    = input.bool(true, title='Longs')\nshorts_on   = input.bool(true, title='Shorts')\n// Parameters for best performance 2018 - 2022\n// long_entry  = input.float(0.26, step=0.01, title='Long entry threshold')\n// long_exit   = input.float(-0.10, step=0.01, title='Long exit threshold')\n// short_entry = input.float(-0.24, step=0.01, title='Short entry threshold')\n// short_exit  = input.float(-0.04, step=0.01, title='Short exit threshold')\nlong_entry  = input.float(0.25, step=0.01, title='Long entry threshold')\nlong_exit   = input.float(-0.10, step=0.01, title='Long exit threshold')\nshort_entry = input.float(-0.25, step=0.01, title='Short entry threshold')\nshort_exit  = input.float(-0.05, step=0.01, title='Short exit threshold')\nstop_loss   = input.float(10, step=1, title='Stop loss (percentage)') / 100\n// Trend Confidence\nlinreg = ta.linreg(source, length, 0)\nlinreg_p = ta.linreg(source, length, 0+1)\nx = bar_index\nslope = linreg - linreg_p\nintercept = linreg - x*slope\ndeviationSum = 0.0\nfor i = 0 to length-1\n    deviationSum := deviationSum + math.pow(source[i]-(slope*(x-i)+intercept), 2)\ndeviation = math.sqrt(deviationSum/(length))\nslope_perc = slope / source[0]\ndeviation_perc = deviation / source[0]\ntrend_confidence = slope_perc / deviation_perc\n// Strategy\nin_interval = (time > since) and (time < till)\nsl_long = strategy.position_avg_price * (1 - stop_loss)\nsl_short = strategy.position_avg_price * (1 + stop_loss)\nif in_interval and longs_on and ta.crossover(trend_confidence, long_entry)\n    strategy.entry(\"TC Long Entry\", strategy.long)\n    strategy.exit(\"TC Long Exit\", stop=sl_long)\nif in_interval and longs_on and ta.crossunder(trend_confidence, long_exit)\n    strategy.close(\"TC Long Entry\")\nif in_interval and shorts_on and ta.crossunder(trend_confidence, short_entry)\n    strategy.entry(\"TC Short Entry\", strategy.short)\n    strategy.exit(\"TC Short Exit\", stop=sl_short)\nif in_interval and shorts_on and ta.crossover(trend_confidence, short_exit)\n    strategy.close(\"TC Short Entry\")\n// Plots \nplot(trend_confidence, \"Trend Confidence\",  color.rgb(255, 255, 255))\nplot(long_entry, \"\",  color.rgb(0, 255, 0), linewidth=1)\nplot(long_exit, \"\",  color.rgb(255, 0, 0), linewidth=1)\nplot(short_entry, \"\", color=bar_index % 10 == 0 ?  color.rgb(0, 255, 0) :  #00000000\nplot(short_exit, \"\", color=bar_index % 10 == 0 ?  color.rgb(255, 0, 0) :  #00000000"}]}
{"messages": [{"role": "user", "content": "The Ichimoku Cloud is a collection of technical indicators that show support and resistance levels, as well as momentum and trend direction. It does this by taking multiple averages and plotting them on a chart. It also uses these figures to compute a \u201ccloud\u201d that attempts to forecast where the price may find support or resistance in the future. The Ichimoku Cloud was developed by Goichi Hosoda, a Japanese journalist, and published in the late 1960s. It provides more data points than the standard candlestick chart. While it seems complicated at first glance, those familiar with how to read the charts often find it easy to understand with well-defined trading signals. The Ichimoku Cloud is composed of five lines or calculations, two of which comprise a cloud where the difference between the two lines is shaded in. The lines include a nine-period average, a 26-period average, an average of those two averages, a 52-period average, and a lagging closing price line. The cloud is a key part of the indicator. When the price is below the cloud, the trend is down. When the price is above the cloud, the trend is up. The above trend signals are strengthened if the cloud is moving in the same direction as the price. For example, during an uptrend, the top of the cloud is moving up, or during a downtrend, the bottom of the cloud is moving down. The MACD is a trend following momentum indicator and provides identification of short-term trend direction. In this variation it utilises the 12-period as the fast and 26-period as the slow length EMAs, with signal smoothing set at 9. This strategy combines the Ichimoku Cloud with the MACD indicator to better enter trades. Long/Exit orders are placed when three basic signals are triggered. Long Position: Tenkan-Sen is above the Kijun-Sen Chikou-Span is above the close of 26 bars ago Close is above the Kumo Cloud MACD line crosses over the signal line Exit Position: Price increases 3% trailing Price decreases 3% trailing The script is backtested from 1 June 2022 and provides good returns. The strategy assumes each order is using 30% of the available coins to make the results more realistic and to simulate you only ran this strategy on 30% of your holdings. A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance."}, {"role": "assistant", "content": "//@version=5\nstrategy('Ichimoku Cloud with MACD and Trailing Stop Loss',\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=30,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 6, 1, 0, 0)\n// Inputs\nts_bars = input.int(9, minval=1, title='Tenkan-Sen Bars')\nks_bars = input.int(26, minval=1, title='Kijun-Sen Bars')\nssb_bars = input.int(52, minval=1, title='Senkou-Span B Bars')\ncs_offset = input.int(26, minval=1, title='Chikou-Span Offset')\nss_offset = input.int(26, minval=1, title='Senkou-Span Offset')\nlong_entry = input(true, title='Long Entry')\nshort_entry = input(true, title='Short Entry')\nmiddle(len) => math.avg(ta.lowest(len), ta.highest(len))\n// Ichimoku Components\ntenkan = middle(ts_bars)\nkijun = middle(ks_bars)\nsenkouA = math.avg(tenkan, kijun)\nsenkouB = middle(ssb_bars)\n// Plot Ichimoku Kinko Hyo\nplot(tenkan, color= color.new(#0496ff, 0), title='Tenkan-Sen')\nplot(kijun, color= color.new(#991515, 0), title='Kijun-Sen')\nplot(close, offset=-cs_offset + 1, color= color.new(#459915, 0), title='Chikou-Span'\nsa = plot(senkouA, offset=ss_offset - 1, color= color.new(color.green, 0), title='Senkou-Span A'\nsb = plot(senkouB, offset=ss_offset - 1, color= color.new(color.red, 0), title='Senkou-Span B'\nfill(sa, sb, color=senkouA > senkouB ?  color.green :  color.red, title='Cloud color'\nss_high = math.max(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\nss_low = math.min(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\n// MACD\n[macd, macd_signal, macd_histogram] = ta.macd(close, 12, 26, 9)\n// Entry/Exit Signals\ntk_cross_bull = tenkan > kijun\ntk_cross_bear = tenkan < kijun\ncs_cross_bull = ta.mom(close, cs_offset - 1) > 0\ncs_cross_bear = ta.mom(close, cs_offset - 1) < 0\nprice_above_kumo = close > ss_high\nprice_below_kumo = close < ss_low\nbullish = tk_cross_bull and cs_cross_bull and price_above_kumo and ta.crossover(macd\nbearish = tk_cross_bear and cs_cross_bear and price_below_kumo and ta.crossunder(macd\n// Configure trail stop level with input options\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nshortStopPrice = 0.0\nlongStopPrice := if strategy.position_size > 0\n    stopValue = close * (1 - longTrailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\nstrategy.entry('Long', strategy.long, when=bullish and long_entry and timePeriod)\nstrategy.exit('Exit', stop = longStopPrice, limit = shortStopPrice)\n//strategy.close('Long', when=bearish and not short_entry)\n//strategy.entry('Short', strategy.short, when=bearish and short_entry and timePeriod)\n//strategy.close('Short', when=bullish and not long_entry)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    The existing value of A is 0.0, so there was a distortion in the large time zone So I revised the closing price of A's first price."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 suc1098\n//@version=5\nstrategy(\"SeongMo_MA_V3(Elliot_helper)\",overlay = true)\nvar A=close\nvar B=0.0\nvar C=0.0\nif high[1] < high and low[1] < low  //A new high price\n        if close[1]<close // Rising Candle -> High Point\n        A:=high\n        if close[1]>close // Decline candle -> median\n        A:=(high+low)/2\nif high[1] > high and low[1] > low //A new low price\n       if close[1]>close // // Decline candle -> Low Point\n        A:=low\n        if close[1]<close // Rising candle -> median\n        A:=(high+low)/2\nif high[1] > high and low[1] < low // Previous Candle Range\n    B:=(high[1]+low[1])/2 // After calculating the median of the previous cans\n    C:= (100*(close-B)/close)// If the absolute value is 0.06 or less, the median value\n        if C >= -0.06 and C <= 0.06 \n        A:=(high+low)/2\n// High point if the closing price is large for the median value of the previous candle and fluctuat\n    if B <= close and C >= 0.06 \n        A:=high\n// Low point if the closing price is small and changes below -0.06 for the median of the previous ca\n    if B >= close and C <= -0.06 \n        A:=low\n//Select a reference point after comparing the high and low prices of the reported and new lows simu\nif high[1] < high and low[1] > low \n    if low[2] < low[1]\n        A:=high\n    if high[2] < high[1]\n        A:=low\nplot(A,color= color.white)\n//Update of new low price for previous candles requires fine counting\nplotshape(high[1] < high and low[1] > low and ((100*(high-low)/((high+low)/2))<= -0.6"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added a Medium Term Filter to Buy only if the Close is above the 55 Day average if onlyBuyWhenAbove55Average is true. Larry Connors sugested beeing above 200 Days, the Turtle Traders use 20 or 55 Days instead."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 I11L\n//@version=5\nstrategy(\"I11L - Reversal Trading Ideas by Larry Connors\", overlay=false, pyramiding\nlowestPointBars = input.int(7)\nrsiLength = input.int(2)\nsellBarrier = input.int(70, step=55)\nonlyBuyWhenAbove55Average = input.bool(false)\nisLowest = ta.lowest(close,lowestPointBars*(strategy.opentrades+1)) == close\nisHighest = ta.rsi(close,rsiLength) > sellBarrier\nisBuy = isLowest and (strategy.position_avg_price * (1-0.01*strategy.opentrades) > \nisClose = isHighest\nplot(ta.rsi(close,rsiLength), color=isBuy ?  color.green : isLowest ?  color.yellow\nplot(sellBarrier, color= color.red)\nif(isBuy)\n    strategy.entry(\"Buy\"+str.tostring(strategy.opentrades+1),strategy.long, comment\nif(isClose)\n    strategy.exit(\"Close\",limit=close)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                        Updated bands design and strategy settings.                             Release Notes:                        This is a massive update to the strategy, it is now profitable on multiple timeframes and cryptocurrencies with default settings. If you like it, adding it to your favorites would help us greatly! The risk to reward on this strategy is now 3.4, this is generally very high. Some trades on the 1h timeframe: \t\tSome trades on the 15m timeframe: Added entry conditions option. Added RSI filter. Added MFI filter. Added ATR based stop loss. Added risk to reward based take profit. Added consolidation filter. Added ADX filter. Added option to enable/disable closing trades when a trade in the opposite direction is opened. Optimized settings to show more realistic and reliable results than before. Added trades on the chart. Added an option to show/hide plots and trades. Cleaned code and added clearer comments."}, {"role": "assistant", "content": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA\n// @version=5\n// Original indicator by alexgrover.\n// Strategy version by Adulari, with added functionality.\n// Strategy\nstrategy('Extended Recursive Bands Strategy', overlay=true, commission_type=strategy.commission.percent\n// Inputs\nshowTrades = input.bool(false, title='Trades',group='Display Settings', confirm=true\nshowPlots = input.bool(false, title='Plots',group='Display Settings',confirm=true,\nrsiEntry = input.bool(true,title='RSI',group='Entry Conditions')\nmfiEntry = input.bool(true,title='MFI',group='Entry Conditions')\nadxEntry = input.bool(false,title='ADX',group='Entry Conditions')\ncfEntry = input.bool(false, title='CF', group='Entry Conditions')\nerbLength = input.int(250,minval=1,step=10, title='Length', group='ERB Settings',inline\nerbSource = input(close, title='Source', group='ERB Settings',inline='Length')\nerbMethod = input.string('Classic', options=['Classic', 'ATR', 'STDEV', 'AHLR', 'RFV'\nerbLookback = input.int(4,minval=1,title='Lookback', group='ERB Settings',inline='Method'\nerbBDC = input.bool(true, title='Bands Direction', group='ERB Settings')\nRR = input.float(3.4,title='RR',group='Risk Settings',inline='RR')\natrLength = input.int(14,minval=1,title='Length',inline='Length',group='ATR Settings'\natrMultiplier = input.float(4.0,minval=0.0,step=0.1,title='Multiplier',inline='Length'\nrsiLength = input.int(title='Length',minval=1, defval=14, group='RSI Settings',inline\nrsiSource = input(close, title=\"Source\", group='RSI Settings',inline='Length')\nrsiOversold = input.int(title='Oversold', minval=0,defval=30, group='RSI Settings'\nrsiOverbought = input.int(title='Overbought',minval=0, defval=69, group='RSI Settings'\nmfiLength = input.int(title='Length',minval=1, defval=14, group='MFI Settings',inline\nmfiSource = input(close, title=\"Source\", group='MFI Settings',inline='Length')\nmfiOversold = input.int(title='Oversold', minval=0,defval=50, group='MFI Settings'\nmfiOverbought = input.int(title='Overbought',minval=0, defval=50, group='MFI Settings'\ncfLength = input.int(59,minval=1, title='Length', group='CF Settings', inline='Length'\ncfLookback = input.int(36,minval=1, title='Lookback', group='CF Settings', inline=\nadxSmoothing = input.int(24,minval=1, title='ADX Smoothing', group='ADX Settings',\ndiLength = input.int(24,minval=1, title='DI Length', group='ADX Settings', inline=\nadxThreshold = input.float(18,minval=0, title='Threshold', group='ADX Settings', inline\nCbTiOD = input.bool(title='Close by Trade in Opposite Direction',defval=true,group\n// Calculate Methods\natr = ta.atr(erbLength)\nstdev = ta.stdev(erbSource, erbLength)\nahlr = ta.sma(high - low, erbLength)\nrfv = 0.\nrfv := ta.rising(erbSource, erbLength) or ta.falling(erbSource, erbLength) ? math.abs\n// Get ERB erbMethod\nf(a, b, c) =>\n    erbMethod == a ? b : c\nv(x) =>\n    f('ATR', atr, f('STDEV', stdev, f('AHLR', ahlr, f('RFV', rfv, x))))\n// Recursive Bands\nerbSC = 2 / (erbLength + 1)\nerbUpperBand = 0.\nerbUpperBand := math.max(nz(erbUpperBand[1], erbSource), erbSource) - erbSC * v(math.abs\nerbLowerBand = 0.\nerbLowerBand := math.min(nz(erbLowerBand[1], erbSource), erbSource) + erbSC * v(math.abs\nerbMiddleBand = (erbUpperBand+erbLowerBand)/2 // added recursive middle line\nerbOpenLong = ta.crossunder(low,erbLowerBand)\nerbOpenShort = ta.crossover(high,erbUpperBand)\n// RSI\nRSI = ta.rsi(rsiSource,rsiLength)\nrsiOpenLong = rsiEntry ? RSI<rsiOversold : true\nrsiOpenShort = rsiEntry ? RSI>rsiOverbought : true\n// MFI\nMFI = ta.mfi(mfiSource,mfiLength)\nmfiOpenLong = mfiEntry ? MFI<mfiOversold : true\nmfiOpenShort = mfiEntry ? MFI>mfiOverbought : true\n// ADX\n[_,_,ADX] = ta.dmi(diLength,adxSmoothing)\nadxOpen = adxEntry ? ADX>adxThreshold : true\n// Band Direction by Adulari\nbhdUptrendCount = 0\nbhdDowntrendCount = 0\nfor i = 0 to erbLookback-1\n    if erbLowerBand[i] > erbLowerBand[i+1]\n        bhdUptrendCount:=bhdUptrendCount+1\n    if erbUpperBand[i] < erbUpperBand[i+1]\n        bhdDowntrendCount:=bhdDowntrendCount+1\nbhdOpenLong = erbBDC ? bhdUptrendCount==erbLookback : true\nbhdOpenShort = erbBDC ? bhdDowntrendCount==erbLookback : true\n// ATR\nATR = ta.atr(atrLength)\natrLower = low-atr*atrMultiplier\natrHigher = high+atr*atrMultiplier\n// Consolidation Zones by Lonesometheblue\nfloat cfHighestBars = ta.highestbars(cfLookback) == 0 ? high : na\nfloat cfLowestBars = ta.lowestbars(cfLookback) == 0 ? low : na\nvar int cfDir = 0\nfloat cfZZ = na\nfloat cfPP = na\ncfIff = cfLowestBars and na(cfHighestBars) ? -1 : cfDir\ncfDir := cfHighestBars and na(cfLowestBars) ? 1 : cfIff\nif cfHighestBars and cfLowestBars\n    if cfDir == 1\n        cfZZ := cfHighestBars\n        cfZZ\n    else\n        cfZZ := cfLowestBars\n        cfZZ\nelse\n    cfIff = cfLowestBars ? cfLowestBars : na\n    cfZZ := cfHighestBars ? cfHighestBars : cfIff\n    cfZZ\nfor x = 0 to 1000 by 1\n    if na(close) or cfDir != cfDir[x]\n        break\n    if cfZZ[x]\n        if na(cfPP)\n            cfPP := cfZZ[x]\n            cfPP\n        else\n            if cfDir[x] == 1 and cfZZ[x] > cfPP\n                cfPP := cfZZ[x]\n                cfPP\n            if cfDir[x] == -1 and cfZZ[x] < cfPP\n                cfPP := cfZZ[x]\n                cfPP\nvar int cfCount = 0\nvar float cfHigh = na\nvar float cfLow = na\nfloat cfH = ta.highest(cfLength)\nfloat cfL = ta.lowest(cfLength)\nvar line cfUpperLine = na\nvar line cfLowerLine = na\nbool cfBreakout = false\nbool cfBreakdown = false\nif ta.change(cfPP)\n    if cfCount > cfLength\n        if cfPP > cfHigh\n            cfBreakout := true\n            cfBreakout\n        if cfPP < cfLow\n            cfBreakdown := true\n            cfBreakdown\n    if cfCount > 0 and cfPP <= cfHigh and cfPP >= cfLow\n        cfCount += 1\n        cfCount\n    else\n        cfCount := 0\n        cfCount\nelse\n    cfCount += 1\n    cfCount\nif cfCount >= cfLength\n    if cfCount == cfLength\n        cfHigh := cfH\n        cfLow := cfL\n        cfLow\n    else\n        cfHigh := math.max(cfHigh, high)\n        cfLow := math.min(cfLow, low)\n        cfLow\n    cfLowerLine\ncfOpen = cfEntry ? cfCount < cfLength : true\n// Stop Loss & Take Profit\nbarsSinceEntry = ta.barssince(bar_index==strategy.opentrades.entry_bar_index(0))\nmax_bars_back(atrLower, 5000)\nmax_bars_back(atrHigher, 5000)\nlongSL = atrLower[barsSinceEntry]\nshortSL = atrHigher[barsSinceEntry]\nlongTP = strategy.position_avg_price+(strategy.position_avg_price-longSL)*RR\nshortTP = strategy.position_avg_price-(shortSL-strategy.position_avg_price)*RR\n// Conditions\nCbTiODLong = CbTiOD ? true : strategy.position_size>0 or strategy.opentrades==0\nCbTiODShort = CbTiOD ? true : strategy.position_size<0 or strategy.opentrades==0\nopenLong = erbOpenLong and bhdOpenLong and rsiOpenLong and adxOpen and cfOpen and \nopenShort = erbOpenShort and bhdOpenShort and rsiOpenShort and adxOpen and cfOpen \ncloseLong = (low<longSL or high>longTP)\ncloseShort = (high>shortSL or low<shortTP)\n// Colors\nbeColor =  #675F76\nbuColor =  #a472ff\n// Plots\npA = plot(showPlots ? erbUpperBand : na, color=color.new(beColor, 0), linewidth=1,\npB = plot(showPlots ? erbLowerBand : na, color=color.new(buColor, 0), linewidth=1,\npC = plot(showPlots ? erbMiddleBand : na, color= color.rgb(120,123,134,0), linewidth\nfill(pC, pA, color=color.new(beColor,95))\nfill(pC, pB, color=color.new(buColor,95))\n// Orders\nif openLong\n    strategy.entry(id='Long',direction=strategy.long)\nif openShort\n    strategy.entry(id='Short',direction=strategy.short)\nif closeLong\n    strategy.close(id='Long')\nif closeShort\n    strategy.close(id='Short')\n// Trade Plots\nentryPlot = plot(showTrades ? strategy.opentrades > 0 ? strategy.position_avg_price\ntpPlot = plot(showTrades ? strategy.position_size > 0 ? longTP : strategy.position_size\nslPlot = plot(showTrades ? strategy.position_size > 0 ? longSL : strategy.position_size\nfill(entryPlot,slPlot,color=showTrades ? color.new(beColor,95) : na,editable=true)\nfill(entryPlot,tpPlot,color=showTrades ? color.new(buColor,95) : na,editable=true)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    snapshot update                                                    Release Notes:                                                    stoploss code error resolving"}, {"role": "assistant", "content": "//@version=5\nstrategy(title='Bollinger Band strategy with split, limit, stop', shorttitle='bb strategy'\n//Summary: Going Long or Short when Entering after Breaking the Bollinger Bands\\\n//At this time, the stop-loss, profit-taking price, and pyramiding standard\\\n// are determined from the difference between the position average price and the band price.\n//After entering the position, if the price crosses the mid-band line, the stop loss is adjusted to \n//each trade, entry position size = 10% of total cash\n//max pyramiding is 4\n//commission = 0.01%\nstart_time = input.time(timestamp(\"20 Jul 2020 00:00 +0300\"), \"Strstegy Start Date\"\nexit_time = input.time(timestamp(\"20 Jul 2023 00:00 +0300\"), \"Strategy Exit Date\")\nbgcolor(time[1]<start_time and time>=start_time? color.red:na)\nbgcolor(time[1]<exit_time and time>=exit_time? color.blue:na)\nin_period = time>=start_time and time<=exit_time\nbb_length = input.int(20)\nbb_mult = input.int(2)\n[middle, upper, lower] = ta.bb(close,bb_length, bb_mult)\nplot(middle, color= color.aqua)\nplot(upper, color= color.orange)\nplot(lower, color= color.orange)\nlong_cond = ta.crossover(close,lower)\nshort_cond = ta.crossunder(close,upper)\nvar saved_ph = 0.0\nif strategy.opentrades>0 and strategy.opentrades[1]==0 and strategy.position_size \n    saved_ph := upper[1]\nvar saved_pl = 0.0\nif strategy.opentrades>0 and strategy.opentrades[1]==0 and strategy.position_size \n    saved_pl := lower[1]\navg = strategy.position_avg_price\nlong_diff = saved_ph-avg\nshort_diff = saved_pl-avg\nlong_stoploss = avg - 1*long_diff\nshort_stoploss = avg - 1*short_diff\nlong_avgdown = avg - 0.5*long_diff\nshort_avgup = avg - 0.5*short_diff\nlong_profit_price = avg + 0.5*long_diff\nshort_profit_price = avg + 0.5*short_diff\nvar label _label = na\nif in_period\n    if long_cond and strategy.opentrades==0\n        strategy.entry(\"Long\",strategy.long)\n    if long_cond and strategy.opentrades >0 and (close[1]<long_avgdown or close[2]\n        strategy.entry(\"Long\",strategy.long)\n    if short_cond and strategy.opentrades==0\n        strategy.entry(\"Short\", strategy.short)\n    if short_cond and strategy.opentrades>0 and (close[1]>short_avgup or close[2]>\n        strategy.entry(\"Short\",strategy.short)\nplot(avg, style=plot.style_linebr)\nplot(strategy.position_size > 0? long_profit_price: na,color= color.green, style=\nplot(strategy.position_size > 0? long_avgdown: na,color= color.yellow, style=plot.style_linebr\nplot(strategy.position_size > 0? long_stoploss: na,color= color.red, style=plot.style_linebr\nplot(strategy.position_size < 0? short_profit_price: na,color= color.green, style\nplot(strategy.position_size < 0? short_avgup: na,color= color.yellow, style=plot.style_linebr\nplot(strategy.position_size < 0? short_stoploss: na,color= color.red, style=plot.style_linebr\nvar co = false\nif strategy.position_size > 0 and ta.crossover(close, middle)\n    co := true\nvar cu = false\nif strategy.position_size < 0 and ta.crossunder(close, middle)\n    cu := true\nif strategy.opentrades == 0\n    co := false\n    cu := false\nif strategy.position_size > 0\n    if co\n        strategy.exit(\"Long Exit\", \"Long\", limit=long_profit_price, stop=middle)\n    else\n        strategy.exit(\"Long Exit\", \"Long\", limit=long_profit_price, stop=long_stoploss\nif strategy.position_size < 0\n    if cu\n        strategy.exit(\"Short Exit\", \"Short\", limit=short_profit_price, stop=middle\n    else\n        strategy.exit(\"Short Exit\", \"Short\", limit=short_profit_price, stop=short_stoploss"}]}
{"messages": [{"role": "user", "content": "In this version of the script you can force to cancel your position after some amount of time indepedently on price action. For example, your bot open a short position with SL=1% and TP=2.4% but price did not reach any of this level over the course of to say 8 hours. In this case, position will be closed regardless of the price. Other interesting features are volume and slope filters. Slope is essentially a derivative of price action. If you don't like to buy your instrument under high volatility, for example, if a trend goes down too fast then you can filter long position which could be opened according to the strategy. Same thing for volume filter. If the volume is too high/too low, you might want to escape such setup in your trading strategy. Moreover, you can tune price shift for opening position. To say, if you believe that the signal for opening position comes too early everytime, you can force the strategy to buy at 1% lower price than the current price when the signal comes. Similar logic for short: open position price will be always higher than the price of the signal. If the price did not reach such level then position will be automatically cancel with a new signal arrival. Check the backtesting results to understand better the logic."}, {"role": "assistant", "content": "//@version=4\nstrategy(title = 'Cipher_B', overlay=true,initial_capital=10,default_qty_type = strategy.cash\n// PARAMETERS {\n// WaveTrend\nwtShow = input(true, title = 'Show WaveTrend', type = input.bool)\nwtBuyShow = input(true, title = 'Show Buy dots', type = input.bool)\nwtGoldShow = input(true, title = 'Show Gold dots', type = input.bool)\nwtSellShow = input(true, title = 'Show Sell dots', type = input.bool)\nwtDivShow = input(true, title = 'Show Div. dots', type = input.bool)\nvwapShow = input(true, title = 'Show Fast WT', type = input.bool)\nwtChannelLen = input(9, title = 'WT Channel Length', type = input.integer)\nwtAverageLen = input(12, title = 'WT Average Length', type = input.integer)\nwtMASource = input(hlc3, title = 'WT MA Source', type = input.source)\nwtMALen = input(3, title = 'WT MA Length', type = input.integer)\n// WaveTrend Overbought & Oversold lines\nobLevel = input(53, title = 'WT Overbought Level 1', type = input.integer)\nobLevel2 = input(60, title = 'WT Overbought Level 2', type = input.integer)\nobLevel3 = input(100, title = 'WT Overbought Level 3', type = input.integer)\nosLevel = input(-53, title = 'WT Oversold Level 1', type = input.integer)\nosLevel2 = input(-60, title = 'WT Oversold Level 2', type = input.integer)\nosLevel3 = input(-75, title = 'WT Oversold Level 3', type = input.integer)\n// Divergence WT\nwtShowDiv = input(true, title = 'Show WT Regular Divergences', type = input.bool)\nwtShowHiddenDiv = input(false, title = 'Show WT Hidden Divergences', type = input.bool\nshowHiddenDiv_nl = input(true, title = 'Not apply OB/OS Limits on Hidden Divergences'\nwtDivOBLevel = input(45, title = 'WT Bearish Divergence min', type = input.integer\nwtDivOSLevel = input(-65, title = 'WT Bullish Divergence min', type = input.integer\n// Divergence extra range\nwtDivOBLevel_addshow = input(false, title = 'Show 2nd WT Regular Divergences', type\nwtDivOBLevel_add = input(15, title = 'WT 2nd Bearish Divergence', type = input.integer\nwtDivOSLevel_add = input(-40, title = 'WT 2nd Bullish Divergence 15 min', type = input.integer\n// RSI+MFI\nrsiMFIShow = input(true, title = 'Show MFI', type = input.bool)\nrsiMFIperiod = input(60,title = 'MFI Period', type = input.integer)\nrsiMFIMultiplier = input(150, title = 'MFI Area multiplier', type = input.float)\nrsiMFIPosY = input(2.5, title = 'MFI Area Y Pos', type = input.float)\n// RSI\nrsiShow = input(false, title = 'Show RSI', type = input.bool)\nrsiSRC = input(close, title = 'RSI Source', type = input.source)\nrsiLen = input(14, title = 'RSI Length', type = input.integer)\nrsiOversold = input(30, title = 'RSI Oversold', minval = 50, maxval = 100, type = \nrsiOverbought = input(60, title = 'RSI Overbought', minval = 0, maxval = 50, type \n// Divergence RSI\nrsiShowDiv = input(false, title = 'Show RSI Regular Divergences', type = input.bool\nrsiShowHiddenDiv = input(false, title = 'Show RSI Hidden Divergences', type = input.bool\nrsiDivOBLevel = input(60, title = 'RSI Bearish Divergence min', type = input.integer\nrsiDivOSLevel = input(30, title = 'RSI Bullish Divergence min', type = input.integer\n// RSI Stochastic\nstochShow = input(true, title = 'Show Stochastic RSI', type = input.bool)\nstochUseLog = input(true, title=' Use Log?', type = input.bool)\nstochAvg = input(false, title='Use Average of both K & D', type = input.bool)\nstochSRC = input(close, title = 'Stochastic RSI Source', type = input.source)\nstochLen = input(14, title = 'Stochastic RSI Length', type = input.integer)\nstochRsiLen = input(14, title = 'RSI Length ', type = input.integer)\nstochKSmooth = input(3, title = 'Stochastic RSI K Smooth', type = input.integer)\nstochDSmooth = input(3, title = 'Stochastic RSI D Smooth', type = input.integer)\n// Divergence stoch\nstochShowDiv = input(false, title = 'Show Stoch Regular Divergences', type = input.bool\nstochShowHiddenDiv = input(false, title = 'Show Stoch Hidden Divergences', type = \n// Schaff Trend Cycle\ntcLine = input(false, title=\"Show Schaff TC line\", type=input.bool)\ntcSRC = input(close, title = 'Schaff TC Source', type = input.source)\ntclength = input(10, title=\"Schaff TC\", type=input.integer)\ntcfastLength = input(23, title=\"Schaff TC Fast Lenght\", type=input.integer)\ntcslowLength = input(50, title=\"Schaff TC Slow Length\", type=input.integer)\ntcfactor = input(0.5, title=\"Schaff TC Factor\", type=input.float)\n// Sommi Flag\nsommiFlagShow = input(false, title = 'Show Sommi flag', type = input.bool)\nsommiShowVwap = input(false, title = 'Show Sommi F. Wave', type = input.bool)\nsommiVwapTF = input('720', title = 'Sommi F. Wave timeframe', type = input.string)\nsommiVwapBearLevel = input(0, title = 'F. Wave Bear Level (less than)', type = input.integer\nsommiVwapBullLevel = input(0, title = 'F. Wave Bull Level (more than)', type = input.integer\nsoomiFlagWTBearLevel = input(0, title = 'WT Bear Level (more than)', type = input.integer\nsoomiFlagWTBullLevel = input(0, title = 'WT Bull Level (less than)', type = input.integer\nsoomiRSIMFIBearLevel = input(0, title = 'Money flow Bear Level (less than)', type \nsoomiRSIMFIBullLevel = input(0, title = 'Money flow Bull Level (more than)', type \n// Sommi Diamond\nsommiDiamondShow = input(false, title = 'Show Sommi diamond', type = input.bool)\nsommiHTCRes = input('60', title = 'HTF Candle Res. 1', type = input.string)\nsommiHTCRes2 = input('240', title = 'HTF Candle Res. 2', type = input.string)\nsoomiDiamondWTBearLevel = input(0, title = 'WT Bear Level (More than)', type = input.integer\nsoomiDiamondWTBullLevel = input(0, title = 'WT Bull Level (Less than)', type = input.integer\n// macd Colors\nmacdWTColorsShow = input(false, title = 'Show MACD Colors', type = input.bool)\nmacdWTColorsTF = input('240', title = 'MACD Colors MACD TF', type = input.string)\ndarkMode = input(false, title = 'Dark mode', type = input.bool)\n// Colors\ncolorRed =  #ff0000\ncolorPurple =  #e600e6\ncolorGreen =  #3fff00\ncolorOrange =  #e2a400\ncolorYellow =  #ffe500\ncolorWhite =  #ffffff\ncolorPink =  #ff00f0\ncolorBluelight =  #31c0ff\ncolorWT1 =  #90caf9\ncolorWT2 =  #0d47a1\ncolorWT2_ =  #131722\ncolormacdWT1a =  #4caf58\ncolormacdWT1b =  #af4c4c\ncolormacdWT1c =  #7ee57e\ncolormacdWT1d =  #ff3535\ncolormacdWT2a =  #305630\ncolormacdWT2b =  #310101\ncolormacdWT2c =  #132213\ncolormacdWT2d =  #770000\n// } PARAMETERS\n// FUNCTIONS {\n  // Divergences \nf_top_fractal(src) => src[4] < src[2] and src[3] < src[2] and src[2] > src[1] and \nf_bot_fractal(src) => src[4] > src[2] and src[3] > src[2] and src[2] < src[1] and \nf_fractalize(src) => f_top_fractal(src) ? 1 : f_bot_fractal(src) ? -1 : 0\nf_findDivs(src, topLimit, botLimit, useLimits) =>\n    fractalTop = f_fractalize(src) > 0 and (useLimits ? src[2] >= topLimit : true)\n    fractalBot = f_fractalize(src) < 0 and (useLimits ? src[2] <= botLimit : true)\n    highPrev = valuewhen(fractalTop, src[2], 0)[2]\n    highPrice = valuewhen(fractalTop, high[2], 0)[2]\n    lowPrev = valuewhen(fractalBot, src[2], 0)[2]\n    lowPrice = valuewhen(fractalBot, low[2], 0)[2]\n    bearSignal = fractalTop and high[2] > highPrice and src[2] < highPrev\n    bullSignal = fractalBot and low[2] < lowPrice and src[2] > lowPrev\n    bearDivHidden = fractalTop and high[2] < highPrice and src[2] > highPrev\n    bullDivHidden = fractalBot and low[2] > lowPrice and src[2] < lowPrev\n    [fractalTop, fractalBot, lowPrev, bearSignal, bullSignal, bearDivHidden, bullDivHidden\n        // RSI+MFI\nf_rsimfi(_period, _multiplier, _tf) => security(syminfo.tickerid, _tf, sma(((close\n   // WaveTrend\nf_wavetrend(src, chlen, avg, malen, tf) =>\n    tfsrc = security(syminfo.tickerid, tf, src)\n    esa = ema(tfsrc, chlen)\n    de = ema(abs(tfsrc - esa), chlen)\n    ci = (tfsrc - esa) / (0.015 * de)\n    wt1 = security(syminfo.tickerid, tf, ema(ci, avg))\n    wt2 = security(syminfo.tickerid, tf, sma(wt1, malen))\n    wtVwap = wt1 - wt2\n    wtOversold = wt2 <= osLevel\n    wtOverbought = wt2 >= obLevel\n    wtCross = cross(wt1, wt2)\n    wtCrossUp = wt2 - wt1 <= 0\n    wtCrossDown = wt2 - wt1 >= 0\n    wtCrosslast = cross(wt1[2], wt2[2])\n    wtCrossUplast = wt2[2] - wt1[2] <= 0\n    wtCrossDownlast = wt2[2] - wt1[2] >= 0\n    [wt1, wt2, wtOversold, wtOverbought, wtCross, wtCrossUp, wtCrossDown, wtCrosslast\n// Schaff Trend Cycle\nf_tc(src, length, fastLength, slowLength) =>\n    ema1 = ema(src, fastLength)\n    ema2 = ema(src, slowLength)\n    macdVal = ema1 - ema2   \n    alpha = lowest(macdVal, length)\n    beta = highest(macdVal, length) - alpha\n    gamma = (macdVal - alpha) / beta * 100\n    gamma := beta > 0 ? gamma : nz(gamma[1])\n    delta = gamma\n    delta := na(delta[1]) ? delta : delta[1] + tcfactor * (gamma - delta[1])\n    epsilon = lowest(delta, length)\n    zeta = highest(delta, length) - epsilon\n    eta = (delta - epsilon) / zeta * 100\n    eta := zeta > 0 ? eta : nz(eta[1])\n    stcReturn = eta\n    stcReturn := na(stcReturn[1]) ? stcReturn : stcReturn[1] + tcfactor * (eta - stcReturn\n    stcReturn\n// Stochastic RSI\nf_stochrsi(_src, _stochlen, _rsilen, _smoothk, _smoothd, _log, _avg) =>\n    src = _log ? log(_src) : _src\n    rsi = rsi(src, _rsilen)\n    kk = sma(stoch(rsi, rsi, rsi, _stochlen), _smoothk)\n    d1 = sma(kk, _smoothd)\n    avg_1 = avg(kk, d1)\n    k = _avg ? avg_1 : kk\n    [k, d1]\n// MACD\nf_macd(src, fastlen, slowlen, sigsmooth, tf) =>\n    fast_ma = security(syminfo.tickerid, tf, ema(src, fastlen))\n    slow_ma = security(syminfo.tickerid, tf, ema(src, slowlen))\n    macd = fast_ma - slow_ma,\n    signal = security(syminfo.tickerid, tf, sma(macd, sigsmooth))\n    hist = macd - signal\n    [macd, signal, hist]\n// MACD Colors on WT    \nf_macdWTColors(tf) =>\n    hrsimfi = f_rsimfi(rsiMFIperiod, rsiMFIMultiplier, tf)\n    [macd, signal, hist] = f_macd(close, 28, 42, 9, macdWTColorsTF)\n    macdup = macd >= signal\n    macddown = macd <= signal\n    macdWT1Color = macdup ? hrsimfi > 0 ? colormacdWT1c : colormacdWT1a : macddown\n    macdWT2Color = macdup ? hrsimfi < 0 ? colormacdWT2c : colormacdWT2a : macddown\n    [macdWT1Color, macdWT2Color]\n    // Get higher timeframe candle\nf_getTFCandle(_tf) => \n    _open  = security(heikinashi(syminfo.tickerid), _tf, open, barmerge.gaps_off, \n    _close = security(heikinashi(syminfo.tickerid), _tf, close, barmerge.gaps_off,\n    _high  = security(heikinashi(syminfo.tickerid), _tf, high, barmerge.gaps_off, \n    _low   = security(heikinashi(syminfo.tickerid), _tf, low, barmerge.gaps_off, barmerge.lookahead_off\n    hl2   = (_high + _low) / 2.0\n    newBar = change(_open)\n    candleBodyDir = _close > _open\n    [candleBodyDir, newBar]\n// Sommi flag\nf_findSommiFlag(tf, wt1, wt2, rsimfi, wtCross, wtCrossUp, wtCrossDown) =>    \n    [hwt1, hwt2, hwtOversold, hwtOverbought, hwtCross, hwtCrossUp, hwtCrossDown, hwtCrosslast\n        bearPattern = rsimfi < soomiRSIMFIBearLevel and\n                   wt2 > soomiFlagWTBearLevel and \n                   wtCross and \n                   wtCrossDown and \n                   hwtVwap < sommiVwapBearLevel\n                       bullPattern = rsimfi > soomiRSIMFIBullLevel and \n                   wt2 < soomiFlagWTBullLevel and \n                   wtCross and \n                   wtCrossUp and \n                   hwtVwap > sommiVwapBullLevel\n        [bearPattern, bullPattern, hwtVwap]\n    f_findSommiDiamond(tf, tf2, wt1, wt2, wtCross, wtCrossUp, wtCrossDown) =>\n    [candleBodyDir, newBar] = f_getTFCandle(tf)\n    [candleBodyDir2, newBar2] = f_getTFCandle(tf2)\n    bearPattern = wt2 >= soomiDiamondWTBearLevel and\n                   wtCross and\n                   wtCrossDown and\n                   not candleBodyDir and\n                   not candleBodyDir2                   \n    bullPattern = wt2 <= soomiDiamondWTBullLevel and\n                   wtCross and\n                   wtCrossUp and\n                   candleBodyDir and\n                   candleBodyDir2 \n    [bearPattern, bullPattern]\n // } FUNCTIONS  \n// CALCULATE INDICATORS {\n// RSI\nrsi = rsi(rsiSRC, rsiLen)\nrsiColor = rsi <= rsiOversold ? colorGreen : rsi >= rsiOverbought ? colorRed : colorPurple\n// RSI + MFI Area\nrsiMFI = f_rsimfi(rsiMFIperiod, rsiMFIMultiplier, timeframe.period)\nrsiMFIColor = rsiMFI > 0 ?  #3ee145 :  #ff3d2e\n// Calculates WaveTrend\n[wt1, wt2, wtOversold, wtOverbought, wtCross, wtCrossUp, wtCrossDown, wtCross_last\n // Stochastic RSI\n[stochK, stochD] = f_stochrsi(stochSRC, stochLen, stochRsiLen, stochKSmooth, stochDSmooth\n// Schaff Trend Cycle\ntcVal = f_tc(tcSRC, tclength, tcfastLength, tcslowLength)\n// Sommi flag\n[sommiBearish, sommiBullish, hvwap] = f_findSommiFlag(sommiVwapTF, wt1, wt2, rsiMFI\n//Sommi diamond\n[sommiBearishDiamond, sommiBullishDiamond] = f_findSommiDiamond(sommiHTCRes, sommiHTCRes2\n// macd colors\n[macdWT1Color, macdWT2Color] = f_macdWTColors(macdWTColorsTF)\n// WT Divergences\n[wtFractalTop, wtFractalBot, wtLow_prev, wtBearDiv, wtBullDiv, wtBearDivHidden, wtBullDivHidden\n    [wtFractalTop_add, wtFractalBot_add, wtLow_prev_add, wtBearDiv_add, wtBullDiv_add,\n[wtFractalTop_nl, wtFractalBot_nl, wtLow_prev_nl, wtBearDiv_nl, wtBullDiv_nl, wtBearDivHidden_nl\nwtBearDivHidden_ = showHiddenDiv_nl ? wtBearDivHidden_nl : wtBearDivHidden\nwtBullDivHidden_ = showHiddenDiv_nl ? wtBullDivHidden_nl : wtBullDivHidden\nwtBearDivColor = (wtShowDiv and wtBearDiv) or (wtShowHiddenDiv and wtBearDivHidden_\nwtBullDivColor = (wtShowDiv and wtBullDiv) or (wtShowHiddenDiv and wtBullDivHidden_\nwtBearDivColor_add = (wtShowDiv and (wtDivOBLevel_addshow and wtBearDiv_add)) or (\nwtBullDivColor_add = (wtShowDiv and (wtDivOBLevel_addshow and wtBullDiv_add)) or (\n// RSI Divergences\n[rsiFractalTop, rsiFractalBot, rsiLow_prev, rsiBearDiv, rsiBullDiv, rsiBearDivHidden\n[rsiFractalTop_nl, rsiFractalBot_nl, rsiLow_prev_nl, rsiBearDiv_nl, rsiBullDiv_nl,\nrsiBearDivHidden_ = showHiddenDiv_nl ? rsiBearDivHidden_nl : rsiBearDivHidden\nrsiBullDivHidden_ = showHiddenDiv_nl ? rsiBullDivHidden_nl : rsiBullDivHidden\nrsiBearDivColor = (rsiShowDiv and rsiBearDiv) or (rsiShowHiddenDiv and rsiBearDivHidden_\nrsiBullDivColor = (rsiShowDiv and rsiBullDiv) or (rsiShowHiddenDiv and rsiBullDivHidden_\n // Stoch Divergences\n[stochFractalTop, stochFractalBot, stochLow_prev, stochBearDiv, stochBullDiv, stochBearDivHidden\nstochBearDivColor = (stochShowDiv and stochBearDiv) or (stochShowHiddenDiv and stochBearDivHidden\nstochBullDivColor = (stochShowDiv and stochBullDiv) or (stochShowHiddenDiv and stochBullDivHidden\n// Small Circles WT Cross\nsignalColor = wt2 - wt1 > 0 ?  color.red :  color.lime\n// Buy signal.\nbuySignal = wtCross and wtCrossUp and wtOversold\nbuySignalDiv = (wtShowDiv and wtBullDiv) or \n               (wtShowDiv and wtBullDiv_add) or \n               (stochShowDiv and stochBullDiv) or \n               (rsiShowDiv and rsiBullDiv)\n    buySignalDiv_color = wtBullDiv ? colorGreen : \n                     wtBullDiv_add ? color.new(colorGreen, 60) : \n                     rsiShowDiv ? colorGreen : na\n// Sell signal\nsellSignal = wtCross and wtCrossDown and wtOverbought\n             sellSignalDiv = (wtShowDiv and wtBearDiv) or \n               (wtShowDiv and wtBearDiv_add) or\n               (stochShowDiv and stochBearDiv) or\n               (rsiShowDiv and rsiBearDiv)\n                    sellSignalDiv_color = wtBearDiv ? colorRed : \n                     wtBearDiv_add ? color.new(colorRed, 60) : \n                     rsiBearDiv ? colorRed : na\n// Gold Buy \nlastRsi = valuewhen(wtFractalBot, rsi[2], 0)[2]\nwtGoldBuy = ((wtShowDiv and wtBullDiv) or (rsiShowDiv and rsiBullDiv)) and\n           wtLow_prev <= osLevel3 and\n           wt2 > osLevel3 and\n           wtLow_prev - wt2 <= -5 and\n           lastRsi < 30           \n          // } CALCULATE INDICATORS\n// DRAW {\nbgcolor(darkMode ?  color.new(#000000, 80) : na)\nzLine = plot(0, color = color.new(colorWhite, 50))\n//  MFI BAR \nrsiMfiBarTopLine = plot(rsiMFIShow ? -95 : na, title = 'MFI Bar TOP Line', transp \nrsiMfiBarBottomLine = plot(rsiMFIShow ? -99 : na, title = 'MFI Bar BOTTOM Line', transp\nfill(rsiMfiBarTopLine, rsiMfiBarBottomLine, title = 'MFI Bar Colors', color = rsiMFIColor\nGlobal=input(title=\"Use Global trend?\", defval=true, type=input.bool,  group=\"Trend Settings\"\nregimeFilter_frame=input(title=\"Global trend timeframe\", defval=\"5\", options=['D',\nregimeFilter_length=input(title=\"Global trend length\", defval=1700, type=input.integer\nlocalFilter_length=input(title=\"Local trend filter length\", defval=20, type=input.integer\nlocalFilter_frame=input(title=\"Local trend filter timeframe\", defval=\"60\", options\nDiv_1=input(title=\"Only divergencies for long\", defval=true, type=input.bool,  group\nDiv_2=input(title=\"Only divergencies for short\", defval=true, type=input.bool,  group\nsommi_diamond_on=input(title=\"Sommi diamond alerts\", defval=false, type=input.bool\nCancel_all=input(title=\"Cancel all positions if price crosses local sma? (yellow line)\"\na_1=input(title=\"TP long\", defval=0.95,step=0.5, type=input.float,  group=\"TP/SL Settings\"\na_1_div=input(title=\"TP long div\", defval=0.95,step=0.5, type=input.float,  group=\na_2=input(title=\"TP short\", defval=0.95,step=1, type=input.float,  group=\"TP/SL Settings\"\nb_1=input(title=\"SL long\", defval=5,step=0.1, type=input.float,  group=\"TP/SL Settings\"\nb_2=input(title=\"SL short\", defval=5,step=0.1, type=input.float,  group=\"TP/SL Settings\"\nRSI_filter_checkbox = input(title=\"RSI filter ON\", defval=false, type=input.bool,  \nPrice_filter_checkbox=input(title=\"Price filter ON\", defval=false, type=input.bool\nPrice_filter_1_long=input(title=\"Long Price filter from\", defval=1000, type=input.integer\nPrice_filter_2_long=input(title=\"Long Price filter to\", defval=1200, type=input.integer\nPrice_filter_1_short=input(title=\"Short Price filter from\", defval=1000, type=input.integer\nPrice_filter_2_short=input(title=\"Short Price filter to\", defval=1200, type=input.integer\nLocal_filter_checkbox=input(title=\"Use Local trend?\", defval=true, type=input.bool\nslope_checkbox = input(title=\"Use Slope filter?\", defval=false, type=input.bool,  \nslope_number_long = input(title=\"Slope number long\", defval=-0.3,step=0.01, type=input.float\nslope_number_short = input(title=\"Slope number short\", defval=0.16,step=0.01, type\nslope_period = input(title=\"Slope period\", defval=300, type=input.integer,  group=\nlong_on = input(title=\"Only long?\", defval=true, type=input.bool,  group=\"Position Settings\"\nshort_on = input(title=\"Only short?\", defval=true, type=input.bool,  group=\"Position Settings\"\nvolume_ETH_spot_checkbox = input(title=\"Volume filter?\", defval=false, type=input.bool\nvolume_ETH_spot_number_more = input(title=\"Volume no more than:\", defval=3700, type\nvolume_ETH_spot_number_less = input(title=\"Volume no less than:\", defval=600, type\nlimit_checkbox = input(title=\"Shift open position?\", defval=false, type=input.bool\nlimit_shift = input(title=\"How many % to shift?\", defval=0.5,step=0.01, type=input.float\ncancel_in =  input(title=\"Cancel position in #bars?\", defval=false, type=input.bool\ncancel_in_num =  input(title=\"Number of bars\", defval=96, type=input.integer,  group\n//Name of ticker\n_str=tostring(syminfo.ticker)\n_chars = str.split(_str, \"\")\nint _len = array.size(_chars)\nint _beg = max(0, _len - 4)\nstring[] _substr = array.new_string(0)\nif _beg < _len\n    _substr := array.slice(_chars, 0, _beg)\nstring _return = array.join(_substr, \"\")\n//Hour sma\nbasis = security(syminfo.tickerid, localFilter_frame, ema(close, localFilter_length\nplot(basis, title=\"Local trend curve\", color= color.yellow, style=plot.style_linebr\n//Trend calculation with EMA\nf_sec(_market, _res, _exp) => security(_market, _res, _exp[barstate.isconfirmed ? \nema = sma(close, regimeFilter_length) \nemaValue = f_sec(\"BTCUSDTPERP\", regimeFilter_frame, ema)\nmarketPrice = f_sec(\"BTCUSDTPERP\", regimeFilter_frame, close)\nregimeFilter = Global?(marketPrice > emaValue or marketPrice[1] > emaValue[1]):true\nreverse_regime=Global?(marketPrice < emaValue or marketPrice[1] < emaValue[1]):true\nbgcolor(Global?regimeFilter ?  color.green :  color.red: color.yellow)\n//Local trend\nregimeFilter_local = Local_filter_checkbox ? close > basis: true //or close[1] > basis[1]\nreverse_regime_local = Local_filter_checkbox ? close < basis: true //or close[1] < basis[1]\n//RSI filter\nup = rma(max(change(close), 0), 14)\ndown = rma(-min(change(close), 0), 14)\nrsi_ = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))\nrsiMA = ema(rsi_,12)\n//local incline\nsma =security(syminfo.tickerid, '60', ema(close, 15))\nslope = (sma - sma[slope_period]) / slope_period\nslope_filter_long = slope_checkbox? slope > slope_number_long : true\nslope_filter_short = slope_checkbox? slope < slope_number_short : true\nvar long_check = true\nvar short_check = true\nif RSI_filter_checkbox\n    long_check:= rsiMA<40\n    short_check:= rsiMA>60\n//\nvalidlow  =  Div_1 ? buySignalDiv or wtGoldBuy  :  buySignal or buySignalDiv or wtGoldBuy\nvalidhigh =   Div_2 ? sellSignalDiv  :  sellSignal or sellSignalDiv\n//check volume of ETHUSDT\nvolume_ETH_spot = volume\nvolume_ETH_spot_filter = volume_ETH_spot_checkbox? volume_ETH_spot < volume_ETH_spot_number_more\n// Check if we have confirmation for our setup\nvar Price_long = true\nif Price_filter_checkbox\n    Price_long:=close>Price_filter_1_long and close<Price_filter_2_long\nvar Price_short = true\nif Price_filter_checkbox\n    Price_short:=close>Price_filter_1_short and close<Price_filter_2_short\nvalidlong = sommi_diamond_on  ? sommiBullishDiamond and strategy.position_size == \nvalidshort = sommi_diamond_on ? sommiBearishDiamond and strategy.position_size == \n// Save trade stop & target & position size if a valid setup is detected\nvar tradeStopPrice = 0.0\nvar tradeTargetPrice = 0.0\nvar TP=0.0\nvar limit_price=0.0\n//Detect valid long setups & trigger alert\nif validlong \n    if buySignalDiv or wtGoldBuy\n        limit_price:=limit_checkbox? close*(1-limit_shift*0.01) : close\n        tradeStopPrice :=  limit_price*(1-b_1*0.01)\n        tradeTargetPrice := limit_price*(1+a_1_div*0.01)\n        TP:= a_1_div\n        else\n        limit_price:=limit_checkbox? close*(1-limit_shift*0.01) : close\n        tradeStopPrice :=  limit_price*(1-b_1*0.01)\n        tradeTargetPrice := limit_price*(1+a_1*0.01)\n        TP:= a_1\n// if validlong \n//     if buySignalDiv or wtGoldBuy\n//         limit_price:=close \n//         tradeStopPrice :=  limit_price*(1-b_1*0.01)\n//         tradeTargetPrice := limit_price*(1+a_1_div*0.01)\n//         TP:= a_1_div\n    //     else\n//         limit_price:=close\n//         tradeStopPrice :=  limit_price*(1-b_1*0.01)\n//         tradeTargetPrice := limit_price*(1+a_1*0.01)\n//         TP:= a_1\n// Detect valid short setups & trigger alert\nif validshort \n    limit_price:=limit_checkbox? close*(1+limit_shift*0.01) : close\n    tradeStopPrice :=  limit_price*(1+b_2*0.01)\n    tradeTargetPrice  := limit_price*(1-a_2*0.01)\n    TP:= a_2\n// if validshort \n//     limit_price:= close\n//     tradeStopPrice :=  limit_price*(1+b_2*0.01)\n//     tradeTargetPrice  := limit_price*(1-a_2*0.01)\n//     TP:= a_2\nif cancel_in and barssince(validlong) == cancel_in_num or barssince(validshort) ==\n    strategy.cancel_all()\nif long_on \n    strategy.entry (id=\"Long\", long=strategy.long, limit=limit_price, when=validlong\nif short_on\n    strategy.entry (id=\"Short\", long=strategy.short, limit=limit_price, when=validshort\n//    condition:=true\n// if Cancel_all and strategy.position_size > 0 and (reverse_regime_local or reverse_regime)\n//     strategy.close_all(when=strategy.position_size != 0, comment='{\\n'     + '  \"name\": \"\",\\n'   \nif Cancel_all and strategy.position_size > 0 and reverse_regime_local\n    strategy.close_all(when=strategy.position_size != 0, comment='{\\n'\n     + '  \"name\": \"\",\\n'\n     + '  \"secret\": \"\",\\n'\n     + '  \"side\": \"sell\",\\n'\n     + '  \"symbol\": '+'\"'+_return+'\"'+',\\n'\n     + '  \"positionSide\": \"flat\"\\n'\n     + '}')\nif Cancel_all and strategy.position_size < 0 and regimeFilter_local\n    strategy.close_all(when=strategy.position_size != 0, comment='{\\n'\n     + '  \"name\": \"\",\\n'\n     + '  \"secret\": \"\",\\n'\n     + '  \"side\": \"buy\",\\n'\n     + '  \"symbol\": '+'\"'+_return+'\"'+',\\n'\n     + '  \"positionSide\": \"flat\"\\n'\n     + '}')\n     if cancel_in and strategy.position_size > 0 and barssince(validlong) > cancel_in_num\n    strategy.close_all(when=strategy.position_size != 0, comment='{\\n'\n     + '  \"name\": \"\",\\n'\n     + '  \"secret\": \"\",\\n'\n     + '  \"side\": \"sell\",\\n'\n     + '  \"symbol\": '+'\"'+_return+'\"'+',\\n'\n     + '  \"positionSide\": \"flat\"\\n'\n     + '}')\nif cancel_in and strategy.position_size < 0 and barssince(validshort) > cancel_in_num\n    strategy.close_all(when=strategy.position_size != 0, comment='{\\n'\n     + '  \"name\": \"\",\\n'\n     + '  \"secret\": \"\",\\n'\n     + '  \"side\": \"buy\",\\n'\n     + '  \"symbol\": '+'\"'+_return+'\"'+',\\n'\n     + '  \"positionSide\": \"flat\"\\n'\n     + '}')\n// Exit trades whenever our stop or target is hit\nstrategy.exit(id=\"Long Exit\", from_entry=\"Long\", limit=tradeTargetPrice, stop=tradeStopPrice\nstrategy.exit(id=\"Short Exit\", from_entry=\"Short\", limit=tradeTargetPrice,stop=tradeStopPrice"}]}
{"messages": [{"role": "user", "content": "Rob Booker Reversal Tabs Strategy is an updated version of Rob Bookers Reversal Tab study: Rob Booker Reversal Tabs While the original is a Pinescript study, this version can be switched between strategy and indicator mode. Rob Bookers script generates reversal signal based on MACD and Stochastics, it is not a true reversal system, default pyramiding value is set to 5. Inputs determine MACD and Stochastics settings. The only additional input is the \"Strategy Mode\" checkbox. This script works well on its own for some tickers, but like any reversal pattern generating scripts, traders will profit from looking at overall price action and trend strength before making a trade. From the original: A simple reversal pattern indicator that uses MACD and Stochastics. Created by Rob Booker and programmed by Andrew Palladino. Please note that I only updated the original to V5 and edited it to be a strategy, which was a grand total of 5 minutes of work. I updated it because I wanted to see how the script performs as a strategy and I'm publishing it in case others would like to use it. I take no credit whatsoever for the original and WILL take this version down if Rob Booker or his Team ask me to or decide to release their own strategy version of the original. Check out Rob Bookers scripts and ideas on his Tradingview account: robbooker"}, {"role": "assistant", "content": "//@version=5\nstrategy('RB Reversal Tabs Strategy', overlay=true, default_qty_type=strategy.cash,\n//Developer: Andrew Palladino\n//Owner: Rob Booker\n//Date Modified: 11/25/2018\n//Updated to Pinescript V5 and transformed into a Strategy by: Powerscooter 11/25/2022\nStrategyMode = input.bool(true,\"Strategy Mode\")\nmacd_fast_period = input(title='MACD Fast Period', defval=12)\nmacd_slow_period = input(title='MACD Slow Period', defval=26)\nmacd_signal_period = input(title='MACD Signal Period', defval=9)\nstoch_period = input(title='Stochastic RSI Period', defval=70)\nprc_k_period = input(title='%K Period', defval=30)\nprc_d_period = input(title='%D Period', defval=30)\nstoch_ob = input(title='Stochastic Overbought Level', defval=70)\nstoch_os = input(title='Stochastic Oversold Level', defval=30)\n[macd_line, signal_line, hist_line] = ta.macd(close, macd_fast_period, macd_slow_period\nfast_prc_k = 100 * (close - ta.lowest(low, stoch_period)) / (ta.highest(high, stoch_period\nfast_prc_d = ta.sma(fast_prc_k, prc_d_period)\nslow_prc_k = ta.sma(fast_prc_k, prc_k_period)\nslow_prc_d = ta.sma(slow_prc_k, prc_d_period)\nfull_prc_k = ta.sma(fast_prc_k, prc_k_period)\nfull_prc_d = ta.sma(full_prc_k, prc_d_period)\nis_buy_reversal = ta.crossover(macd_line, 0) and full_prc_k < stoch_os\nis_sell_reversal = ta.crossunder(macd_line, 0) and full_prc_k > stoch_ob\nplotshape(is_buy_reversal and not StrategyMode, style=shape.triangleup, color= color.new\nplotshape(is_sell_reversal and not StrategyMode, style=shape.triangledown, color= \n//Orders\nif is_buy_reversal and StrategyMode\n    strategy.entry(\"Long\",strategy.long)\nif is_sell_reversal and StrategyMode\n    strategy.entry(\"Short\",strategy.short)\n//plot(full_prc_k, color=blue)\n//plot(full_prc_d, color=red)\n//plot(macd_line, color=blue)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                        Version 2 Fixed an issue with the TP1 logic and position sizes                                                    Release Notes:                                                    - Added the alerts txt fields for the custom close long/short events                                                    Release Notes:                        Version 3 - Added a table displaying the opened trades data - works even with multiple opened trades - the table is fully customisable: colors, location, text size, and much more.... - Added a sample script commented at the beginning of the script                                                    Release Notes:                        Version 5 Fixed an issue with the TPs when pyramiding > 1 is enabled It was recalculating the TPs for every new pyramiding signal It's common usage that the TPs and SL are calculated at the first signal of the trend                                                    Release Notes:                        Version 5.1 Fixed an issue with the SL and TPs (again) Now it works as expected                                                    Release Notes:                        Version 5.2 Added the ability to create alerts using the \"alert() function call only mode\" which aren't based on the backtest orders fills but on my custom conditions Sometimes, the backtest fills the orders too late, especially during very quick price action events Example: imgur.com/a/NiH0MeT                            Release Notes:                        Version 6 - Added a Stop-Loss to Breakeven logic - Added a custom optional exit logic closing closing the opened trade(s) after X bars                                                    Release Notes:                                                    Fixed and Improved the trailing SL logic                                                    Release Notes:                        Version 7 Removed the TP2 logic as it prevented the exit SL/TP1 orders to get executed in real-time                                                    Release Notes:                                                    - Fixed the SL to Breakeven logic"}, {"role": "assistant", "content": "//@version=5\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Daveatt\n// # ========================================================================= #\n// #                   |  SAMPLE INDICATOR  |\n// # ========================================================================= #\n// Sample script to plug to the strategy template\n// //@version=5\n//indicator(title='Moving Average Cross', shorttitle='Moving Average Cross', overlay=true, precision\n// type_ma1 = input.string(title='MA1 type', defval='SMA', options=['RMA', 'SMA', 'EMA'])\n// length_ma1 = input(10, title='[ALL but VWAP] MA1 length')\n// type_ma2 = input.string(title='MA2 type', defval='SMA', options=['RMA', 'SMA', 'EMA'])\n// length_ma2 = input(100, title='[ALL but VWAP] MA2 length')\n// // MA\n// f_ma(smoothing, src, length) =>\n//     rma_1 = ta.rma(src, length)\n//     sma_1 = ta.sma(src, length)\n//     ema_1 = ta.]ema(src, length)\n//     iff_1 = smoothing == 'EMA' ? ema_1 : src\n//     iff_2 = smoothing == 'SMA' ? sma_1 : iff_1\n//     smoothing == 'RMA' ? rma_1 : iff_2\n// MA1 = f_ma(type_ma1, close, length_ma1)\n// MA2 = f_ma(type_ma2, close, length_ma2)\n// // buy and sell conditions\n// buy = ta.crossover(MA1, MA2)\n// sell = ta.crossunder(MA1, MA2)\n// plot(MA1, color=color.new(color.green, 0), title='Plot MA1', linewidth=3)\n// plot(MA2, color=color.new(color.red, 0), title='Plot MA2', linewidth=3)\n// plotshape(buy, title='LONG SIGNAL', style=shape.circle, location=location.belowbar, color=color.n\n// plotshape(sell, title='SHORT SIGNAL', style=shape.circle, location=location.abovebar, color=color\n// /////////////////////////// SIGNAL FOR STRATEGY /////////////////////////\n// Signal = buy ? 1 : sell ? -1 : 0\n// plot(Signal, title='\ud83d\udd0cConnector\ud83d\udd0c', display = display.data_window)\n// # ========================================================================= #\n// #                   |   SAMPLE INDICATOR  |\n// # ========================================================================= #\nVERSION = \"V7\"\nSCRIPT_NAME = \"BEST Strategy Template \" + VERSION\n    // # ========================================================================= #\n// #                   |   STRATEGY  |\n// # ========================================================================= #\n// These values are used both in the strategy() header and in the script's relevant inputs as defaul\n// Unless these values match in the script's Inputs and the TV backtesting Properties, results betwe\nInitCapital = 10000000\nInitPosition = 2.0\nInitCommission = 0.075\nInitPyramidMax = 1\nCalcOnorderFills = false\nProcessOrdersOnClose = true\nCalcOnEveryTick = false\nCloseEntriesRule = \"FIFO\"\nstrategy(title=SCRIPT_NAME, shorttitle=SCRIPT_NAME, \n overlay=true, pyramiding=InitPyramidMax, initial_capital=InitCapital, default_qty_type\n default_qty_value=InitPosition, commission_type=strategy.commission.percent, commission_value\n calc_on_every_tick=CalcOnEveryTick,\n precision=9, max_lines_count=500, max_labels_count=500)\n// # ========================================================================= #\n// # ========================================================================= #\n// #                   ||   Alerts  ||\n// # ========================================================================= #\n// # ========================================================================= #\ni_alert_txt_entry_long = input.text_area(defval = \"\", title = \"Long Entry Message\"\ni_alert_txt_entry_short = input.text_area(defval = \"\", title = \"Short Entry Message\"\ni_alert_txt_exit_SL_long = input.text_area(defval = \"\", title = \"Long Exit SL Message\"\ni_alert_txt_exit_TP1_long = input.text_area(defval = \"\", title = \"Long Exit TP1 Message\"\ni_alert_txt_exit_custom_long = input.text_area(defval = \"\", title = \"Long Custom Exit Message\"\ni_alert_txt_exit_SL_short = input.text_area(defval = \"\", title = \"Short Exit SL Message\"\ni_alert_txt_exit_TP1_short = input.text_area(defval = \"\", title = \"Short Exit TP1 Message\"\ni_alert_txt_exit_custom_short = input.text_area(defval = \"\", title = \"Short Custom Exit Message\"\n// \u2014\u2014\u2014\u2014\u2014 You capture the Source of your indicator here\next_source_ = input.source(close, title='Data source', group = \"General\")\n// Custom close signal\ncustom_close = input.bool(false, title='Use Custom Close?', group = \"General\")\n// Last trades data displayed in a table\ndisplay_last_trade_data = input.bool(true, title = \"Display the current opened trades data\"\n_table_location = input.string(title=\"Table Location\", defval=\"TOP RIGHT\", options\n_table_txt_size    = input.string(\"Normal\", title = \"Txt Size\", options=[\"Tiny\", \"Small\"\ntable_cell_bg_color = input.color( color.white, title = \"Cells Background Color\",\ntable_cell_txt_color = input.color( color.black, title = \"Cells Text Color\", group\ntable_frame_color = input.color( color.black, title = \"Frame Color\", group = \"Table\"\ntable_frame_width = input.int(1, title = \"Frame Width\", minval = 0, group = \"Table\"\ntable_border_color = input.color( color.black, title = \"Border Color\", group = \"Table\"\ntable_border_width = input.int(1, title = \"Border Width\", minval = 0, group = \"Table\"\ntable_header_bg_color = input.color( #0b3880, title = \"Header Background Color\", \ntable_header_txt_color = input.color( color.white, title = \"Header Text Color\", group\n// Pie Chart Winners/Losers\ndisplay_pie_chart = false//input.bool(true, title = \"Display Pie Chart Winners/Losers\", group = \"Pie Chart\")\n// \u2014\u2014\u2014\u2014\u2014 Bar Coloring\nclrBars = input.bool(true, title='Colour Candles to Trade Order state', group='Coloring'\nCloseSession = input.bool(false, title='Close positions at market at the end of each sess\nSession = input.session(title='Trading Session', defval='0000-2345', group='Session'\nOpenDirection = input.string(defval='ALL', title='Open  Trading Direction', options\nCloseDirection = input.string(defval='ALL', title='Close Trading Direction', options\ncloseOnOpposite = input.bool(true, title='Close on Opposite Signal', group='Strategy'\n// \u2014\u2014\u2014\u2014\u2014 Date range filtering\nDateFilter = input.bool(false, 'Date Range Filtering', group='Date')\n// \u2014\u2014\u2014\u2014\u2014 Syntax coming from https://www.tradingview.com/blog/en/new-parameter-for-date-input-added-to-pine-21812/\ni_startTime = input.time(defval=timestamp('01 Jan 2019 13:30 +0000'), title='Start Time'\ni_endTime = input.time(defval=timestamp('30 Dec 2021 23:30 +0000'), title='End Time'\nTradeDateIsAllowed() =>\n    DateFilter ? time >= i_startTime and time <= i_endTime : true\n// \u2014\u2014\u2014\u2014\u2014 Set the max losing streak length with an input\nsetmaxLosingStreak = input.bool(title='Set Max number of consecutive loss trades',\nmaxLosingStreak = input.int(title='Max of consecutive loss trades', defval=15, minval\nsetmaxWinStreak = input.bool(title='Set Max number of consecutive won trades', defval\nmaxWinStreak = input.int(title='Max Winning Streak Length', defval=15, minval=1, group\n// \u2014\u2014\u2014\u2014\u2014 Set the max consecutive days with a loss\nsetmaxLosingDaysStreak = input.bool(title='Set MAX consecutive days with a loss in a row'\nmaxLosingDaysStreak = input.int(title='Max of consecutive days with a loss in a row'\nsetMaxDrawdown = input.bool(title='Set Max Total DrawDown', defval=false, group='Risk Management'\n// \u2014\u2014\u2014\u2014\u2014 Input for the strategy's maximum drawdown (in % of strategy equity)\nmaxPercDd = input.int(title='Max Drawdown (%)', defval=10, minval=1, maxval=100, group\nsetMaxIntradayLoss = input.bool(title='Set Max Intraday Loss', defval=false, group\n// \u2014\u2014\u2014\u2014\u2014 Input for the strategy's maximum intraday loss (in % of strategy equity)\nmaxIntradayLoss = input.int(title='Max Intraday Loss (%)', defval=3, minval=1, maxval\nsetNumberDailyTrades = input.bool(title='Limit the number of trades per day', defval\nmaxDailyTrades = input.int(title='Number MAX of daily trades', defval=10, minval=1\nsetNumberWeeklyTrades = input.bool(title='Limit the number of trades per week', defval\nmaxWeeklyTrades = input.int(title='Number MAX of weekly trades', defval=50, minval\n// Hard Exit\n// # ========================================================================= #\n// #                   | Stop Loss |\n// # ========================================================================= #\nStopType = input.string(title='Stop Type Selection', defval='Percent', options=['None'\n// \u2014\u2014\u2014\u2014\u2014 Percent\nLossPerc = input.float(title='Stop Loss (%)', minval=0.0, step=0.5, defval=10, group\nTrailPerc = input.float(title='Trail Stop Loss (%)', minval=0.0, step=0.5, defval=\n// \u2014\u2014\u2014\u2014\u2014 ATR\natrStopLength = input.int(title='Stop Length', defval=14, group='ATR Stop Loss')\nriskRatioATR = input.float(defval=1, title='Risk Ratio', step=0.10, group='ATR Stop Loss'\n// # ========================================================================= #\n// #                   | Take Profit |\n// # ========================================================================= #\nTakeProfitType = input.string(title='Take Profit Type Selection', defval='Percent'\nTP1_ratio = 100//input.float(defval=50, title='Closing X% at TP1', group='Take Profit', tooltip='Example: 50 closin\n// \u2014\u2014\u2014\u2014\u2014 TP1 \u2014\u2014\u2014\u2014\u2014\n// \u2014\u2014\u2014\u2014\u2014 Percent\nProfitPerc1 = input.float(title='Take Profit (%)', minval=0.0, step=0.5, defval=5,\n// \u2014\u2014\u2014\u2014\u2014 ATR\natrTakeProfitLength1 = input.int(title='Take Profit Length', defval=14, group='ATR Take Profit 1'\nrewardRatioATR1 = input.float(defval=2, title='Reward Ratio', step=0.10, group='ATR Take Profit 1'\n// # ========================================================================= #\n// #                   | Stop Loss to Breakeven |\n// # ========================================================================= #\nuse_sl_be         = input.bool(false, title = \"Use Stop Loss to Breakeven Mode?\", \nsl_be_mode        = input.string(\"$\", title = \"Mode\", options=[\"pips\", \"%\", \"$\"], \nsl_be_value       = input.float(1, step = 0.1, minval = 0, title = \"Stop Loss to Breakeven +/- X\"\n// # ========================================================================= #\n// #                   | Custom Exit |\n// # ========================================================================= #\ncustom_exit_mode        = input.string(title='Custom Exit Type Selection', defval=\ni_custom_exit_nb_bars   = input.int(5, title = \"Nb bars to exit\", group = \"Custom Exit\"\nBIG_NUMBER_COUNT = 1000\n// variables initialisation\next_source = nz(ext_source_)\n// 1 is bull signal\nbull = ext_source == 1\n// -1 is bear signal\nbear = ext_source == -1\nplotshape(\n series     = bull and not bull[1],\n title      = \"Buy\",\n style      = shape.triangleup,\n location   = location.bottom,\n color      = color.new(color =  color.green, transp = 0),\n size       = size.normal\n )\nplotshape(\n series     = bear and not bear[1],\n title      = \"Sell\",\n style      = shape.triangledown,\n location   = location.top,\n color      = color.new(color =  color.red, transp = 0),\n size       = size.normal\n )\n// 2 exit custom close long\nexit_bull = custom_close and ext_source == 2\n// -2 exit custom close short\nexit_bear = custom_close and ext_source == -2\n// Entry Price\nentry_price = ta.valuewhen(condition=(bear[1] and strategy.position_size[1] >= 0) \nentry_price_long  = ta.valuewhen(condition=(bull and strategy.position_size <= 0),\nentry_price_short = ta.valuewhen(condition=(bear and strategy.position_size >= 0),\n// \u2014\u2014\u2014\u2014\u2014 RISK MANAGEMENT\ncondintradayloss = setMaxIntradayLoss ? maxIntradayLoss : 100\nstrategy.risk.max_intraday_loss(value=condintradayloss, type=strategy.percent_of_equity\ncondmaxdrawdown = setMaxDrawdown ? maxPercDd : 100\nstrategy.risk.max_drawdown(value=condmaxdrawdown, type=strategy.percent_of_equity)\n// daily trades calculation\noktoTradeDaily = true\ntradesIntradayCount = setNumberDailyTrades ? maxDailyTrades : BIG_NUMBER_COUNT\nstrategy.risk.max_intraday_filled_orders(count=tradesIntradayCount)\n// weekly trades calculation\ntradesLastWeek = 0\ntradesLastWeek := if dayofweek == dayofweek.monday and dayofweek != dayofweek[1]\n    strategy.closedtrades[1] + strategy.opentrades[1]\nelse\n    tradesLastWeek[1]\n// Calculate number of trades this week\nweeklyTrades = strategy.closedtrades + strategy.opentrades - tradesLastWeek\nokToTradeWeekly = setNumberWeeklyTrades ? weeklyTrades < maxWeeklyTrades : true\n// consecutive loss days in a row\ncountConsLossDays = setmaxLosingDaysStreak ? maxLosingDaysStreak : BIG_NUMBER_COUNT\nstrategy.risk.max_cons_loss_days(countConsLossDays)\n// Calculate the total losing streaks\n// Check if there's a new losing trade that increased the streak\nnewLoss = strategy.losstrades > strategy.losstrades[1] and strategy.wintrades == strategy.wintrades\n// Determine current losing streak length\nstreakLossLen = 0\nstreakLossLen := if newLoss\n    nz(streakLossLen[1]) + 1\nelse\n    if strategy.wintrades > strategy.wintrades[1] or strategy.eventrades > strategy.eventrades\n        0\n    else\n        nz(streakLossLen[1])\n// Check if losing streak is under max allowed\nokToTradeLossStreak = setmaxLosingStreak ? streakLossLen < maxLosingStreak : true\n// Calculate the total winning streaks\n// See if there's a new winner that increased the streak\nnewWin = strategy.wintrades > strategy.wintrades[1] and strategy.losstrades == strategy.losstrades\n// Figure out current winning streak length\nstreakWinLen = 0\nstreakWinLen := if newWin\n    nz(streakWinLen[1]) + 1\nelse\n    if strategy.losstrades > strategy.losstrades[1] or strategy.eventrades > strategy.eventrades\n        0\n    else\n        nz(streakWinLen[1])\n// Check if winning streak is under max allowed\nokToTradeWinStreak = setmaxWinStreak ? streakWinLen < maxWinStreak : true\nvar float longPercStopPrice = 0.\nvar float shortPercStopPrice = 0.\n// Stop loss management\nif strategy.position_size > 0\n    longPercStopPrice  := entry_price_long  * (1 - LossPerc)\nelse if strategy.position_size < 0\n    shortPercStopPrice := entry_price_short * (1 + LossPerc)\n// trailing\n// Determine trail stop loss prices\nvar float longTrailStopPrice = 0.0\nvar float shortTrailStopPrice = 0.0\nvar float final_SL_Long = 0.0\nvar float final_SL_Short = 0.0\nvar MaxReached = 0.0        // Max high/low reached since beginning of trade.\nsignal_candle = (bull and strategy.position_size <= 0)\n or (bear and strategy.position_size >= 0)\nif signal_candle[1]\n    MaxReached := strategy.position_size > 0 ? high : low\n// Update Max point reached during trade (used both for trailing stop reference point and in-trade m\n// start trailing only when beyong the breakeven point\nMaxReached := strategy.position_size > 0\n ? math.max(nz(MaxReached, high), high)\n : strategy.position_size < 0 ? math.min(nz(MaxReached,low), low) : na\n//if strategy.position_size > 0\n//    stopValue = close * (1 - TrailPerc)\n//    longTrailStopPrice := math.max(stopValue, longTrailStopPrice)\n//else\n//    longTrailStopPrice := 0\n//if strategy.position_size < 0\n//    stopValue = close * (1 + TrailPerc)\n//    shortTrailStopPrice := math.min(stopValue, shortTrailStopPrice)\n//else\n//    shortTrailStopPrice := 999999\nif strategy.position_size > 0\n    longTrailStopPrice  :=  MaxReached * (1 - TrailPerc)\nelse if strategy.position_size < 0\n    shortTrailStopPrice :=  MaxReached * (1 + TrailPerc)\nuseSL = StopType != 'None'\nuse_SL_Percent = StopType == 'Percent'\nuse_SL_Trail = StopType == 'Trailing'\nuse_SL_ATR = StopType == 'ATR'\n// Use this function to return the correct pip value for pips on Forex symbols\npip() => syminfo.mintick\n// ATR\n// Function atr (average true range) returns the RMA of true range. \n// True range is max(high - low, abs(high - close[1]), abs(low - close[1]))\natr_stop = ta.atr(atrStopLength)\natr_tp1 = ta.atr(atrTakeProfitLength1)\n// ATR used for Risk:Reward\nvar float RR_STOP_ATR = 0.0\n//RR_STOP_ATR := nz(RR_STOP_ATR[1])\nvar float RR_TP1_ATR = 0.0\n//RR_TP1_ATR := nz(RR_TP1_ATR[1])\n// Capturig the atr value at signal time only\nif (bull and strategy.position_size <= 0) or (bear and strategy.position_size >= 0\n    RR_STOP_ATR := atr_stop\n    RR_TP1_ATR := atr_tp1\nif (strategy.position_size <= 0 and bull)\n    if use_SL_Percent\n        final_SL_Long := longPercStopPrice\n    else if use_SL_ATR\n        final_SL_Long := entry_price_long - RR_STOP_ATR * riskRatioATR\nelse if (strategy.position_size >= 0 and bear)\n    if use_SL_Percent\n        final_SL_Short := shortPercStopPrice\n    else if use_SL_ATR\n        final_SL_Short := entry_price_short + RR_STOP_ATR * riskRatioATR\nif use_SL_Trail\n    if strategy.position_size > 0\n        final_SL_Long := longTrailStopPrice\n    else if strategy.position_size < 0\n        final_SL_Short := shortTrailStopPrice\n// Take Profit Manangement\nuseTakeProfit = TakeProfitType != 'None'\nuse_TP_Percent = TakeProfitType == 'Percent'\nuse_TP_ATR = TakeProfitType == 'ATR'\nvar float TP1longPrice = 0.\nvar float TP1shortPrice = 0.\nvar bool is_TP1_REACHED = false\nif (strategy.position_size <= 0 and bull)\n    TP1longPrice := use_TP_Percent ? entry_price_long * (1 + ProfitPerc1) : entry_price_long\nelse if (strategy.position_size >= 0 and bear)\n        TP1shortPrice := use_TP_Percent ? entry_price_short * (1 - ProfitPerc1) : entry_price_short\nif strategy.position_size[1] > 0 and high >= TP1longPrice\n    is_TP1_REACHED := true\nelse if strategy.position_size[1] < 0 and low <= TP1shortPrice\n    is_TP1_REACHED := true\n// Plot take profit values for confirmation\nplot(series=strategy.position_size > 0 and useTakeProfit ? TP1longPrice : na, color\nplot(series=strategy.position_size < 0 and useTakeProfit ? TP1shortPrice : na, color\n// Used for debug and check the ATR TP value\nplot(use_TP_ATR and strategy.position_size != 0 ? RR_TP1_ATR * rewardRatioATR1 : na\n// # ========================================================================= #\n// #                   |  Stop Loss To Breakeven |\n// # ========================================================================= #\nvar bool SL_BE_REACHED = false\nvar bool is_SL_REACHED = false\nif use_sl_be and useSL\n    current_profit = strategy.opentrades.profit(strategy.opentrades - 1)\n    if strategy.position_size[1] > 0\n        if not SL_BE_REACHED\n            if sl_be_mode == \"pips\" and current_profit * pip() >= sl_be_value * pip\n                final_SL_Long := entry_price_long //+ (sl_be_value * pip())\n                SL_BE_REACHED := true\n            else if sl_be_mode == \"$\" and current_profit >= sl_be_value\n                final_SL_Long := entry_price_long //+ (sl_be_value)\n                SL_BE_REACHED := true\n            else if sl_be_mode == \"%\" and math.abs(((high - entry_price_long) / entry_price_long\n                final_SL_Long := entry_price_long //* (1 + (sl_be_value/100))\n                SL_BE_REACHED := true\n    else if strategy.position_size[1] < 0\n        if not SL_BE_REACHED\n            if sl_be_mode == \"pips\" and current_profit * pip() >= sl_be_value * pip\n                final_SL_Short := entry_price_short //- (sl_be_value * pip())\n                SL_BE_REACHED := true\n            else if sl_be_mode == \"$\" and current_profit >= sl_be_value\n                final_SL_Short := entry_price_short// - (sl_be_value)\n                SL_BE_REACHED := true\n            else if sl_be_mode == \"%\" and math.abs(((entry_price_short - low) / low\n                final_SL_Short := entry_price_short// * (1 - (sl_be_value/100))\n                SL_BE_REACHED := true\n// Plot stop loss values for confirmation\nplot(series=strategy.position_size > 0 and useSL ? final_SL_Long : na, color= color.new\nplot(series=strategy.position_size < 0 and useSL ? final_SL_Short : na, color= color.new\n// Used for debug and check the ATR SL value\nplot(use_SL_ATR and strategy.position_size != 0 ? RR_STOP_ATR * riskRatioATR : na,\n// Session calculations\n// The BarInSession function returns true when\n// the current bar is inside the session parameter\nBarInSession(sess) =>\n    time(timeframe.period, sess) != 0\nin_session = BarInSession(Session)\nokToTradeInSession = CloseSession ? in_session : true\nnew_session = in_session and not in_session[1]\nbgcolor(color=CloseSession and BarInSession(Session)[1] ?  color.new(color.green,\n// consolidation of the conditions\nokToTrade = okToTradeWeekly and okToTradeLossStreak and okToTradeWinStreak and TradeDateIsAllowed\n// Orders part\nlongs_opened = strategy.position_size > 0\nshorts_opened = strategy.position_size < 0\ntrades_opened = strategy.position_size != 0\nlongs_opened_in_session = CloseSession and longs_opened\nshorts_opened_in_session = CloseSession and shorts_opened\n// trades_opened_in_session = CloseSession and trades_opened\nopen_all = OpenDirection == 'ALL'\nopen_all_longs = OpenDirection != 'SHORT'\nopen_all_shorts = OpenDirection != 'LONG'\nclose_all = CloseDirection == 'ALL'\nclose_all_longs = CloseDirection != 'SHORT'\nclose_all_shorts = CloseDirection != 'LONG'\n// Go long\nlongCondition = bull\nif longCondition and okToTrade and okToTradeInSession and open_all_longs\n    alert_message_long_txt = \"entry: \" + str.tostring(close) + \" sl: \" + str.tostring\n    strategy.entry('Long', strategy.long, alert_message=alert_message_long_txt, comment\n// Go Short\nshortCondition = bear\nif shortCondition and okToTrade and okToTradeInSession and open_all_shorts\n    alert_message_short_txt = \"entry: \" + str.tostring(close) + \" sl: \" + str.tostring\n    strategy.entry('Short', strategy.short, alert_message=alert_message_short_txt,\n// Execute Exits\nif closeOnOpposite and strategy.position_size > 0 and shortCondition  // and open_all_shorts\n    strategy.close(id='Long', comment='Short Signal\\nClose Long')\nif closeOnOpposite and strategy.position_size < 0 and longCondition  // and open_all_longs\n    strategy.close(id='Short', comment='Long Signal\\nClose Short')\n// # ========================================================================= #\n// #                   |  Custom User-Defined close |\n// # ========================================================================= #\nif strategy.position_size > 0 and exit_bull and close_all_longs\n    strategy.close(id='Long', alert_message=i_alert_txt_exit_custom_long, comment=\n    alert(i_alert_txt_exit_custom_long, alert.freq_once_per_bar_close)\nif strategy.position_size < 0 and exit_bear and close_all_shorts\n    strategy.close(id='Short', alert_message=i_alert_txt_exit_custom_short, comment\n    alert(i_alert_txt_exit_custom_short, alert.freq_once_per_bar_close)\n// # ========================================================================= #\n// #                   |  Custom template close |\n// # ========================================================================= #\ncustom_exit_bull = custom_exit_mode == \"Number of bars\" and ta.barssince(bull and \ncustom_exit_bear = custom_exit_mode == \"Number of bars\" and ta.barssince(bear and \n//plot(ta.barssince(bull and strategy.position_size <= 0), title = \"test\", display = display.data_wi\nif strategy.position_size > 0 and custom_exit_bull and close_all_longs\n    strategy.close(id='Long', alert_message=i_alert_txt_exit_custom_long, comment=\n    alert(i_alert_txt_exit_custom_long, alert.freq_once_per_bar_close)\nif strategy.position_size < 0 and custom_exit_bear and close_all_shorts\n    strategy.close(id='Short', alert_message=i_alert_txt_exit_custom_short, comment\n    alert(i_alert_txt_exit_custom_short, alert.freq_once_per_bar_close)\n// # ========================================================================= #\n// #                   |  SL/TP1/TP2 exits  |\n// # ========================================================================= #\nif strategy.position_size > 0 and close_all_longs\n    strategy.exit(id='Exit Long SL/TP', from_entry='Long', stop=useSL ? final_SL_Long\nif strategy.position_size < 0 and close_all_shorts\n    strategy.exit(id='Exit Short SL/TP', from_entry='Short', stop=useSL ? final_SL_Short\n// // Close all Longs only\n// if not okToTradeInSession and close_all_longs and longs_opened_in_session\n//     strategy.close(id=\"Long\")\n// // Close all Shorts only\n// if not okToTradeInSession and close_all_shorts and shorts_opened_in_session\n//     strategy.close(id=\"Short\")\n// Close all positions at the end of each session regardeless of their profit/loss\nif not okToTradeInSession and close_all and trades_opened\n    strategy.close_all()\n// Flatten strategy when max losing streak is reached\nclose_strat = not okToTradeWeekly or not okToTradeLossStreak or not okToTradeWinStreak\nif close_strat\n    // close all existing orders\n    strategy.close_all()\n// Colour code the candles\nbclr = not clrBars ? na : strategy.position_size == 0 ?  color.gray : longs_opened\nbarcolor(bclr, title='Trade State Bar Colouring')\n// # ========================================================================= #\n// #                   |   Entry Price  |\n// # ========================================================================= #\nplot(strategy.position_size != 0 ? strategy.position_avg_price : na, title = \"Entry Price\"\n// # ========================================================================= #\n// #                   |   Table  |\n// # ========================================================================= #\nf_location() =>\n    _loc = \"\"\n    if _table_location == \"TOP LEFT\"\n        _loc := position.top_left\n    else if _table_location == \"TOP CENTER\"    \n        _loc := position.top_center\n    else if _table_location == \"TOP RIGHT\" \n        _loc := position.top_right\n    else if _table_location == \"BOTTOM LEFT\"     \n        _loc := position.bottom_left\n    else if _table_location == \"BOTTOM CENTER\"  \n        _loc := position.bottom_center\n    else if _table_location == \"BOTTOM RIGHT\"  \n        _loc := position.bottom_right\n    _loc\nvar table_location = f_location()\nvar current_trades_table = table.new(position = table_location, \n columns = 8,\n rows = 10, \n bgcolor = table_header_bg_color, \n frame_color = table_frame_color, \n frame_width = table_frame_width, \n border_color = table_border_color, \n border_width = table_border_width\n )\ntable_txt_size = switch _table_txt_size\n    \"Tiny\" => size.tiny\n    \"Small\" => size.small\n    \"Normal\" => size.normal\n    \"Large\" => size.large\n    \"Huge\" => size.huge\ntradeDirection(_size) =>\n    _size < 0 ? \"Short\" : \"Long\"\nvar int nb_row = 0\n// Functions from the refman V5\n// Get the biggest max trade run up value from all of the open trades.\nmaxOpenTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))\n    result = maxRunup\n// Get the biggest max trade drawdown value from all of the open trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo\n    result = maxDrawdown\n// Calculate open profit or loss for the open positions.\ntradeOpenPL() =>\n    sumProfit = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumProfit += strategy.opentrades.profit(tradeNo)\n    result = sumProfit\n// Calculate avg entry price for the open positions.\ntradeAvgEntryPrice() =>\n    avgProfit = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        avgProfit += strategy.opentrades.entry_price(tradeNo)\n    result = nz(avgProfit / strategy.opentrades)\n// Return the number of opened longs and shorts\ntradeOpenNbLongsShorts() =>\n        nbLongs = 0\n    nbShorts = 0\n    for tradeNo = 0 to strategy.opentrades - 1\n        size = strategy.opentrades.size(tradeNo)\n        if size > 0\n            nbLongs += 1\n        else\n            nbShorts += 1\n    [nbLongs, nbShorts]\nif barstate.islastconfirmedhistory and strategy.opentrades > 0 and display_last_trade_data\n    table.cell(table_id = current_trades_table, column = 0, row = 0, text = \"Trade No\"\n    table.cell(table_id = current_trades_table, column = 1, row = 0, text = \"Direction\"\n    table.cell(table_id = current_trades_table, column = 2, row = 0, text = \"Entry Price\"\n    table.cell(table_id = current_trades_table, column = 3, row = 0, text = \"Entry Time\"\n    table.cell(table_id = current_trades_table, column = 4, row = 0, text = \"Profit/Loss\"\n    table.cell(table_id = current_trades_table, column = 5, row = 0, text = \"Max Drawdown\"\n    table.cell(table_id = current_trades_table, column = 6, row = 0, text = \"Max RunUp\"\n    table.cell(table_id = current_trades_table, column = 7, row = 0, text = \"Equity\"\n    for tradeNo = 0 to strategy.opentrades - 1\n        nb_row := tradeNo + 1\n        str_tradeNo    = str.tostring(nb_row)\n        str_direction   = tradeDirection(strategy.opentrades.size(tradeNo))\n        str_entry_Price = str.tostring(strategy.opentrades.entry_price(tradeNo), format.mintick\n        str_entry_Time  = str.format_time(strategy.opentrades.entry_time(tradeNo),\n        str_profit_loss = str.tostring(strategy.opentrades.profit(tradeNo), \"#.##\"\n        str_max_DD      = str.tostring(strategy.opentrades.max_drawdown(tradeNo), \n        str_max_runUP   = str.tostring(strategy.opentrades.max_runup(tradeNo), \"#.##\"\n        str_equity      = str.tostring(strategy.equity, \"#.##\") + \" \" + strategy.account_currency\n        table.cell(table_id = current_trades_table, column = 0, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 1, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 2, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 3, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 4, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 5, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 6, row = nb_row, text\n        table.cell(table_id = current_trades_table, column = 7, row = nb_row, text\n    // display Sum if there is more than 1 trade opened\n    if strategy.opentrades > 1 and nb_row == strategy.opentrades\n        // Creating the Total merged row\n        table.cell(table_id = current_trades_table, column = 0, row = strategy.opentrades\n        table.merge_cells(current_trades_table, 0, strategy.opentrades + 1, 7, strategy.opentrades\n        // Displaying the total\n        LastRow = strategy.opentrades + 2\n        str_nb_opened_trades = \"Opened trades: \" + str.tostring(strategy.opentrades\n        [nbLongs, nbShorts] = tradeOpenNbLongsShorts()\n        str_nbLongsShorts = \"\"\n        if nbLongs > 0\n            str_nbLongsShorts := \"Opened Longs: \" + str.tostring(nbLongs)\n            if nbShorts > 0\n                str_nbLongsShorts := str_nbLongsShorts + \"\\n\"\n        if nbShorts > 0\n            str_nbLongsShorts := str_nbLongsShorts + \"Opened Shorts: \" + str.tostring\n        str_avg_entry_price  = str.tostring(tradeAvgEntryPrice(), \"#.##\")\n        str_last_entry_Time  = \"Last Opened Trade Time: \" + str.format_time(strategy.opentrades.entry_time\n        str_sum_profit_loss = str.tostring(tradeOpenPL(), \"#.##\")\n        str_max_DD      = str.tostring(maxTradeDrawDown(), \"#.##\")\n        str_max_runUP   = str.tostring(maxOpenTradeRunUp(), \"#.##\")\n        str_equity      = str.tostring(strategy.equity, \"#.##\") + \" \" + strategy.account_currency\n        table.cell(table_id = current_trades_table, column = 0, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 1, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 2, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 3, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 4, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 5, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 6, row = LastRow, text\n        table.cell(table_id = current_trades_table, column = 7, row = LastRow, text\n        //table.cell(table_id = current_trades_table, column = 7, row = LastRow, text = str_equity, text_col\n// // # ========================================================================= #\n// // #                   |  PIE CHART  |\n// // # ========================================================================= #\n// r         = input.int (0    ,\"*Inside radius*  \",minval=0,maxval=50,step=10                      \n// R         = input.int (120  ,\"*Outside radius*\",minval=80,maxval=200,step=10         \n// w         = input.int (10   ,\"|Overlap|\",minval=0,maxval=10,step=2                               \n// p_x       = input.int (-50  ,\"<<==Shift==>> \" ,step=50                               ,tooltip=\"Ov\n// color CLR = na\n// win_rate  = math.round((strategy.wintrades / strategy.closedtrades) * 100, 2)\n// loss_rate = math.round((strategy.losstrades / strategy.closedtrades) * 100, 2)\n// C1 = int(win_rate * 360 / 100)\n// C2 = C1 + int(loss_rate * 360 / 100)\n// for i  = 0 to 360 by 1\n//     x0 = int(r*math.sin(math.toradians(i)))\n//     y0 = int(r*math.cos(math.toradians(i)))\n//     x  = int(R*math.sin(math.toradians(i)))\n//     y  = int(R*math.cos(math.toradians(i)))\n//     CLR := i < C1 ? color.lime : i < C2 ? color.red : color.fuchsia\n//     if barstate.islast and display_pie_chart\n//         line = line.new(bar_index+p_x+R+x0 , close+y0  , bar_index+p_x+ x+R, close + y        , c\n        //         L1   =label.new(bar_index+p_x+R    ,close      ,\"Winners/Losers \\n\ud83d\udd0eDistribution\ud83d\udd0d\" , \n// if display_pie_chart and strategy.closedtrades > 0\n//     L2=label.new(bar_index+p_x+R+ int( (r+R)/2*math.sin(math.toradians(C1/2)))     ,close+ int( (\n//     label.delete(L2[1])\n//     L3=label.new(bar_index+p_x+R+ int( (r+R)/2*math.sin(math.toradians((C1+C2)/2))),close+ int( (\n//     label.delete(L3[1])\nif strategy.position_size == 0 \n or (strategy.position_size > 0 and strategy.position_size[1] < 0)\n or (strategy.position_size < 0 and strategy.position_size[1] > 0)\n    is_TP1_REACHED := false\n    SL_BE_REACHED := false"}]}
{"messages": [{"role": "user", "content": "If ever in need for a quick way to swiftly check some random trades or brag to your 'friends'/buddies/pals/haters/followers/the_crowd with fabricated winnings .. This Script is for you. Either set the entry and exit dates for a maximum of up to 10 trades (either Long or Short) via Menu or simply drag the 'handler' to the desired time/date. Next fill in how many shares/contracts to enter and/or exit There is some Visual Feedback as well. (initially written specifically for someone .. now free for grabs)"}, {"role": "assistant", "content": "// This source code is subject to the terms of Je Buurman\n// \u00a9 Je_Buurman\n//@version=5\nstrategy(\"Je Buurmans Simple Manual Entries\", overlay=true)\ndirection       = input.string(\"Long\", options=[\"Long\", \"Short\"], title=\"Long or Short\"\nhow_many_active = input.int(defval=1, minval=1, maxval=10,title=\"How many trades are active\"\nL1_entry_date   = input.time(timestamp(\"1 Jan 2022 00:00\"), title=\"Entry 1 Date\", \nL1_entry_shares = input.float(10, title=\"Entry 1 shares\")\nL1_exit_date    = input.time(timestamp(\"21 Jan 2022 00:00\"), title=\"Exit 1 Date\", \nL1_exit_shares  = input.float(10, title=\"Exit 1 shares\")\nL2_entry_date   = input.time(timestamp(\"01 Feb 2022 00:00\"), title=\"Entry 2 Date\",\nL2_entry_shares = input.float(10, title=\"Entry 2 shares\")\nL2_exit_date    = input.time(timestamp(\"21 Feb 2022 00:00\"), title=\"Exit 2 Date\", \nL2_exit_shares  = input.float(10, title=\"Exit 2 shares\")\nL3_entry_date   = input.time(timestamp(\"01 Mar 2022 00:00\"), title=\"Entry 3 Date\",\nL3_entry_shares = input.float(10, title=\"Entry 3 shares\")\nL3_exit_date    = input.time(timestamp(\"21 Mar 2022 00:00\"), title=\"Exit 3 Date\", \nL3_exit_shares  = input.float(10, title=\"Exit 3 shares\")\nL4_entry_date   = input.time(timestamp(\"01 Apr 2022 00:00\"), title=\"Entry 4 Date\",\nL4_entry_shares = input.float(10, title=\"Entry 4 shares\")\nL4_exit_date    = input.time(timestamp(\"21 Apr 2022 00:00\"), title=\"Exit 4 Date\", \nL4_exit_shares  = input.float(10, title=\"Exit 4 shares\")\nL5_entry_date   = input.time(timestamp(\"01 May 2022 00:00\"), title=\"Entry 5 Date\",\nL5_entry_shares = input.float(10, title=\"Entry 5 shares\")\nL5_exit_date    = input.time(timestamp(\"21 May 2022 00:00\"), title=\"Exit 5 Date\", \nL5_exit_shares  = input.float(10, title=\"Exit 5 shares\")\nL6_entry_date   = input.time(timestamp(\"01 Jun 2022 00:00\"), title=\"Entry 6 Date\",\nL6_entry_shares = input.float(10, title=\"Entry 6 shares\")\nL6_exit_date    = input.time(timestamp(\"21 Jun 2022 00:00\"), title=\"Exit 6 Date\", \nL6_exit_shares  = input.float(10, title=\"Exit 6 shares\")\nL7_entry_date   = input.time(timestamp(\"01 Jul 2022 00:00\"), title=\"Entry 7 Date\",\nL7_entry_shares = input.float(10, title=\"Entry 7 shares\")\nL7_exit_date    = input.time(timestamp(\"21 Jul 2022 00:00\"), title=\"Exit 7 Date\", \nL7_exit_shares  = input.float(10, title=\"Exit 7 shares\")\nL8_entry_date   = input.time(timestamp(\"01 Aug 2022 00:00\"), title=\"Entry 8 Date\",\nL8_entry_shares = input.float(10, title=\"Entry 8 shares\")\nL8_exit_date    = input.time(timestamp(\"21 Aug 2022 00:00\"), title=\"Exit 8 Date\", \nL8_exit_shares  = input.float(10, title=\"Exit 8 shares\")\nL9_entry_date   = input.time(timestamp(\"01 Sep 2022 00:00\"), title=\"Entry 9 Date\",\nL9_entry_shares = input.float(10, title=\"Entry 9 shares\")\nL9_exit_date    = input.time(timestamp(\"21 Sep 2022 00:00\"), title=\"Exit 9 Date\", \nL9_exit_shares  = input.float(10, title=\"Exit 9 shares\")\nL10_entry_date  = input.time(timestamp(\"01 Oct 2022 00:00\"), title=\"Entry 10 Date\"\nL10_entry_shares= input.float(10, title=\"Entry 10 shares\")\nL10_exit_date   = input.time(timestamp(\"21 Oct 2022 00:00\"), title=\"Exit 10 Date\",\nL10_exit_shares = input.float(10, title=\"Exit 10 shares\")\nentryCondition1 = L1_entry_date == time and how_many_active>=1\nentryCondition2 = L2_entry_date == time and how_many_active>=2\nentryCondition3 = L3_entry_date == time and how_many_active>=3\nentryCondition4 = L4_entry_date == time and how_many_active>=4\nentryCondition5 = L5_entry_date == time and how_many_active>=5\nentryCondition6 = L6_entry_date == time and how_many_active>=6\nentryCondition7 = L7_entry_date == time and how_many_active>=7\nentryCondition8 = L8_entry_date == time and how_many_active>=8\nentryCondition9 = L9_entry_date == time and how_many_active>=9\nentryCondition10= L10_entry_date == time and how_many_active>=10\nif (entryCondition1)\n    strategy.entry(\"1\", direction=direction, qty=L1_entry_shares)\nif (entryCondition2)\n    strategy.entry(\"2\", direction=direction, qty=L2_entry_shares)\nif (entryCondition3)\n    strategy.entry(\"3\", direction=direction, qty=L3_entry_shares)\nif (entryCondition4)\n    strategy.entry(\"4\", direction=direction, qty=L4_entry_shares)\nif (entryCondition5)\n    strategy.entry(\"5\", direction=direction, qty=L5_entry_shares)\nif (entryCondition6)\n    strategy.entry(\"6\", direction=direction, qty=L6_entry_shares)\nif (entryCondition7)\n    strategy.entry(\"7\", direction=direction, qty=L7_entry_shares)\nif (entryCondition8)\n    strategy.entry(\"8\", direction=direction, qty=L8_entry_shares)\nif (entryCondition9)\n    strategy.entry(\"9\", direction=direction, qty=L9_entry_shares)\nif (entryCondition10)\n    strategy.entry(\"10\", direction=direction, qty=L10_entry_shares)\ncloseCondition1 = L1_exit_date == time and how_many_active>=1\ncloseCondition2 = L2_exit_date == time and how_many_active>=2\ncloseCondition3 = L3_exit_date == time and how_many_active>=3\ncloseCondition4 = L4_exit_date == time and how_many_active>=4\ncloseCondition5 = L5_exit_date == time and how_many_active>=5\ncloseCondition6 = L6_exit_date == time and how_many_active>=6\ncloseCondition7 = L7_exit_date == time and how_many_active>=7\ncloseCondition8 = L8_exit_date == time and how_many_active>=8\ncloseCondition9 = L9_exit_date == time and how_many_active>=9\ncloseCondition10= L10_exit_date == time and how_many_active>=10\nif (closeCondition1)\n    strategy.close(\"1\", \"C1\", qty=L1_exit_shares)\nif (closeCondition2)\n    strategy.close(\"2\", \"C2\", qty=L2_exit_shares)\nif (closeCondition3)\n    strategy.close(\"3\", \"C3\", qty=L3_exit_shares)\nif (closeCondition4)\n    strategy.close(\"4\", \"C4\", qty=L4_exit_shares)\nif (closeCondition5)\n    strategy.close(\"5\", \"C5\", qty=L5_exit_shares)\nif (closeCondition6)\n    strategy.close(\"6\", \"C6\", qty=L6_exit_shares)\nif (closeCondition7)\n    strategy.close(\"7\", \"C7\", qty=L7_exit_shares)\nif (closeCondition8)\n    strategy.close(\"8\", \"C8\", qty=L8_exit_shares)\nif (closeCondition9)\n    strategy.close(\"9\", \"C9\", qty=L9_exit_shares)\nif (closeCondition10)\n    strategy.close(\"10\", \"C10\", qty=L10_exit_shares)\nSimple_Entry_Table = table.new(position=position.top_right, columns = 2, rows=4, frame_width\ntable.cell(Simple_Entry_Table, column = 0, row = 0, text=\"Je Buurman - Simple Manual Entries\"\ntable.cell(Simple_Entry_Table, column = 0, row = 1, text=\"Succesful Trades\", text_color\ntable.cell(Simple_Entry_Table, column = 0, row = 2, text=\"Open Trades\", text_color\ntable.cell(Simple_Entry_Table, column = 0, row = 3, text=\"Profit or Loss\", text_color\ntable.merge_cells(Simple_Entry_Table, start_column = 0, start_row = 0, end_column"}]}
{"messages": [{"role": "user", "content": "#20 on the Myth-Busting bench, we are automating the \"I Found Super Easy 1 Minute Scalping System And Backtest It 100 Times\" strategy from \"Jessy Trading\" who claims 30.58% net profit over 100 trades in a couple of weeks with a 51% win rate and profit factor of 1.56 on EURUSD . This one surprised us quite a bit. Despite the title of this strategy indicating this is on the 1 min timeframe, the author demonstrates the backtesting manually on the 5 minute timeframe. Given the simplicity of this strategy only incorporating a couple of indicators, it's robustness being able to be profitable in both low and high timeframes and on multiple symbols was quite refreshing. The 3 settings which we need to pay most attention to here is the Hull Butterfly length, HalfTrend amplitude and the Max Number Of Bars Between Hull and HalfTrend Trigger. Depending on the timeframe and symbol, these settings greatly impact the performance outcomes of the strategy. I've listed a couple of these below. And as always, If you know of or have a strategy you want to see myth-busted or just have an idea for one, please feel free to message me. This strategy uses a combination of 3 open-source public indicators: Hull Butterfly Oscillator by LuxAlgo HalfTrend by Everget  Trading Rules 5 min candles but higher / lower candles work too. Stop loss at swing high/low Take Profit 1.5x the risk  Long Hull Butterfly gives us green column, Wait for HalfTrend to present an up arrow and enter trade.  Short  Hull Butterfly gives us a red column , Wait for HalfTrend to present a down arrow and enter trade.  Alternative Trading Settings for different time frames  1 Minute Timeframe Move the Hull Butterfly length from the default 11 to 9 Move the HalfTrend Amplitude from the default 2 to 1 Enabling ADX Filter with a 25 threshold  2 Hour Timeframe Move the HalfTrend Amplitude from the default 2 to 1 Laddered Take Profits from 14.5% to 19% with an 8% SL"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 myn\n//@version=5\nstrategy('Strategy Myth-Busting #20 - HalfTrend+HullButterfly - [MYN]', max_bars_back\n/////////////////////////////////////\n//* Put your strategy logic below *//\n/////////////////////////////////////\n// Hull Butterfly gives us green column,  Wait for HalfTrend to present an up arrow and enter trade.\n// Hull Butterfly gives us a red column , Wait for HalfTrend present a down arrow and enter trade.  \n// SL at swing high/low with TP 1.5 risk\n// Hull Butterfly Oscillator [LuxAlgo]\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n//-----------------------------------------------------------------------------}\n//Settings\n//----------------------------------------------------a-------------------------{\nlength = input(11, group=\"Hull Butterfly Oscillator\")\nmult = input(2., 'Levels Multiplier')\nsrc = input(close)\n//Style\nbull_css_0 = input.color( color.new(#0cb51a, 50), 'Bullish Gradient'\n  , inline = 'inline0'\n  , group = 'Style')\nbull_css_1 = input.color( #0cb51a, ''\n  , inline = 'inline0'\n  , group = 'Style')\nbear_css_0 = input.color( color.new(#ff1100, 50), 'Bearish Gradient'\n  , inline = 'inline1'\n  , group = 'Style')\nbear_css_1 = input.color( #ff1100, ''\n  , inline = 'inline1'\n  , group = 'Style')\n//-----------------------------------------------------------------------------}\n//Normalization variables\n//-----------------------------------------------------------------------------{\nvar short_len = int(length / 2)\nvar hull_len = int(math.sqrt(length))\nvar den1 = short_len * (short_len + 1) / 2\nvar den2 = length * (length + 1) / 2\nvar den3 = hull_len * (hull_len + 1) / 2\n//-----------------------------------------------------------------------------}\n//Hull coefficients\n//-----------------------------------------------------------------------------{\nvar lcwa_coeffs = array.new_float(hull_len, 0)\nvar hull_coeffs = array.new_float(0)\nif barstate.isfirst\n    //Linearly combined WMA coeffs\n    for i = 0 to length-1\n        sum1 = math.max(short_len - i, 0)\n        sum2 = length - i\n            array.unshift(lcwa_coeffs, 2 * (sum1 / den1) - (sum2 / den2))\n        //Zero padding of linearly combined WMA coeffs\n    for i = 0 to hull_len-2\n        array.unshift(lcwa_coeffs, 0)\n        //WMA convolution of linearly combined WMA coeffs\n    for i = hull_len to array.size(lcwa_coeffs)-1\n        sum3 = 0.\n        for j = i-hull_len to i-1\n            sum3 += array.get(lcwa_coeffs, j) * (i - j)\n                array.unshift(hull_coeffs, sum3 / den3)\n//-----------------------------------------------------------------------------}\n//Hull squeeze oscillator\n//-----------------------------------------------------------------------------{\nvar os  = 0\nvar len = array.size(hull_coeffs)-1\nhma     = 0.\ninv_hma = 0.\nfor i = 0 to len\n    hma += src[i] * array.get(hull_coeffs, i)\n    inv_hma += src[len-i] * array.get(hull_coeffs, i)\n    hso = hma - inv_hma\ncmean = ta.cum(math.abs(hso)) / bar_index * mult\nos := ta.cross(hso, cmean) or ta.cross(hso, -cmean) ? 0\n  : hso < hso[1] and hso > cmean ? -1\n  : hso > hso[1] and hso < -cmean ? 1\n  : os\n//-----------------------------------------------------------------------------}\n//Plot\n//-----------------------------------------------------------------------------{\n//Colors\ncss0 = color.from_gradient(hso, 0, cmean, bull_css_0, bull_css_1)\ncss1 = color.from_gradient(hso, -cmean, 0, bear_css_1, bear_css_0)\ncss = hso > 0 ? css0 : css1\nplotshape(os > os[1] and os == 1 , title='Arrow Up', style=shape.circle, location=\nplotshape(os < os[1] and os == -1, title='Arrow Down', style=shape.circle, location\nhullLongEntry = os > os[1] and os == 1 \nhullShortEntry = os < os[1] and os == -1\n// HalfTrend - Everget\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Copyright (c) 2021-present, Alex Orekhov (everget)\namplitude = input(title='Amplitude', defval=2, group=\"HalfTrend\")\nchannelDeviation = input(title='Channel Deviation', defval=2)\nshowArrows = input(title='Show Arrows', defval=true)\nshowChannels = input(title='Show Channels', defval=false)\nvar int trend = 0\nvar int nextTrend = 0\nvar float maxLowPrice = nz(low[1], low)\nvar float minHighPrice = nz(high[1], high)\nvar float up = 0.0\nvar float down = 0.0\nfloat atrHigh = 0.0\nfloat atrLow = 0.0\nfloat arrowUp = na\nfloat arrowDown = na\natr2 = ta.atr(100) / 2\ndev = channelDeviation * atr2\nhighPrice = high[math.abs(ta.highestbars(amplitude))]\nlowPrice = low[math.abs(ta.lowestbars(amplitude))]\nhighma = ta.sma(high, amplitude)\nlowma = ta.sma(low, amplitude)\nif nextTrend == 1\n    maxLowPrice := math.max(lowPrice, maxLowPrice)\n    if highma < maxLowPrice and close < nz(low[1], low)\n        trend := 1\n        nextTrend := 0\n        minHighPrice := highPrice\n        minHighPrice\nelse\n    minHighPrice := math.min(highPrice, minHighPrice)\n    if lowma > minHighPrice and close > nz(high[1], high)\n        trend := 0\n        nextTrend := 1\n        maxLowPrice := lowPrice\n        maxLowPrice\nif trend == 0\n    if not na(trend[1]) and trend[1] != 0\n        up := na(down[1]) ? down : down[1]\n        arrowUp := up - atr2\n        arrowUp\n    else\n        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])\n        up\n    atrHigh := up + dev\n    atrLow := up - dev\n    atrLow\nelse\n    if not na(trend[1]) and trend[1] != 1\n        down := na(up[1]) ? up : up[1]\n        arrowDown := down + atr2\n        arrowDown\n    else\n        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])\n        down\n    atrHigh := down + dev\n    atrLow := down - dev\n    atrLow\nht = trend == 0 ? up : down\nvar color buyColor =  color.blue\nvar color sellColor =  color.red\nhtColor = trend == 0 ? buyColor : sellColor\nhtPlot = plot(ht, title='HalfTrend', linewidth=2, color=htColor)\natrHighPlot = plot(showChannels ? atrHigh : na, title='ATR High', style=plot.style_circles\natrLowPlot = plot(showChannels ? atrLow : na, title='ATR Low', style=plot.style_circles\nfill(htPlot, atrHighPlot, title='ATR High Ribbon', color=color.new(sellColor, 90))\nfill(htPlot, atrLowPlot, title='ATR Low Ribbon', color=color.new(buyColor, 90))\nbuySignal = not na(arrowUp) and trend == 0 and trend[1] == 1\nsellSignal = not na(arrowDown) and trend == 1 and trend[1] == 0\nplotshape(showArrows and buySignal ? atrLow : na, title='Arrow Up', style=shape.triangleup\nplotshape(showArrows and sellSignal ? atrHigh : na, title='Arrow Down', style=shape.triangledown\nalertcondition(buySignal, title='Alert: HalfTrend Buy', message='HalfTrend Buy')\nalertcondition(sellSignal, title='Alert: HalfTrend Sell', message='HalfTrend Sell'\nhalfTrendLongEntry =  buySignal\nhalfTrendShortEntry = sellSignal\n//////////////////////////////////////\n//* Put your strategy rules below *//\n/////////////////////////////////////\ni_numLookbackBarsHull = input(3,title=\"Max Number Of Bars Between Hull and HalfTrend Tri\nlongCondition = halfTrendLongEntry and ta.barssince(hullLongEntry) <= i_numLookbackBarsHull\nshortCondition = halfTrendShortEntry and ta.barssince(hullShortEntry) <= i_numLookbackBarsHull\n//define as 0 if do not want to use\ncloseLongCondition = 0\ncloseShortCondition = 0\n// EMA Filter\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_emaFilterEnabled = input.bool(defval = false , title = \"Enable EMA Filter\", tooltip\ni_emaLength = input.int(200, title=\"EMA Length\", minval=1, group =\"EMA Filter\")\ni_emaSource = input.source(close,\"EMA Source\" , group =\"EMA Filter\")\nemaValue = i_emaFilterEnabled ? ta.ema(i_emaSource, i_emaLength) : na\nbool isEMAFilterEnabledAndCloseAboveMA = i_emaFilterEnabled ? i_emaSource > emaValue\nbool isEMAFilterEnabledAndCloseBelowMA = i_emaFilterEnabled ? i_emaSource < emaValue\n// ADX Filter\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_adxFilterEnabled = input.bool(defval = false , title = \"Enable ADX Filter\", tooltip\ni_adxVariant = input.string('ORIGINAL', title='ADX Variant', options=['ORIGINAL', \ni_adxSmoothing = input.int(14, title=\"ADX Smoothing\", group=\"ADX Filter\")\ni_adxDILength = input.int(14, title=\"DI Length\", group=\"ADX Filter\")\ni_adxLowerThreshold = input.float(25, title=\"ADX Threshold\", step=.5, group=\"ADX Filter\"\ncalcADX_Masanakamura(int _len) =>\n    _smoothedTrueRange = 0.0\n    _smoothedDirectionalMovementPlus = 0.0\n    _smoothed_directionalMovementMinus = 0.0\n    _trueRange = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs\n    _directionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high\n    _directionalMovementMinus = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz\n    _smoothedTrueRange := nz(_smoothedTrueRange[1]) - nz(_smoothedTrueRange[1]) / \n    _smoothedDirectionalMovementPlus := nz(_smoothedDirectionalMovementPlus[1]) - \n    _smoothed_directionalMovementMinus := nz(_smoothed_directionalMovementMinus[1]\n    DIP = _smoothedDirectionalMovementPlus / _smoothedTrueRange * 100\n    DIM = _smoothed_directionalMovementMinus / _smoothedTrueRange * 100\n    _DX = math.abs(DIP - DIM) / (DIP + DIM) * 100\n    adx = ta.sma(_DX, _len)\n    [DIP, DIM, adx]\n[DIPlusO, DIMinusO, ADXO] = ta.dmi(i_adxDILength, i_adxSmoothing)\n[DIPlusM, DIMinusM, ADXM] = calcADX_Masanakamura(i_adxDILength)\nadx = i_adxFilterEnabled and i_adxVariant == \"ORIGINAL\" ? ADXO : ADXM\nbool isADXFilterEnabledAndAboveThreshold = i_adxFilterEnabled ? adx > i_adxLowerThreshold\n///Start / End Time Periods\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_startPeriodEnabled = input.bool(true, 'Start', group='Date Range', inline='Start Period'\ni_startPeriodTime = input.time(timestamp('1 Jan 2019'), '', group='Date Range', inline\ni_endPeriodEnabled = input.bool(true, 'End', group='Date Range', inline='End Period'\ni_endPeriodTime = input.time(timestamp('31 Dec 2030'), '', group='Date Range', inline\nisStartPeriodEnabledAndInRange = i_startPeriodEnabled ? i_startPeriodTime <= time \nisEndPeriodEnabledAndInRange = i_endPeriodEnabled ? i_endPeriodTime >= time : true\n// Time-Of-Day Window\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired from https://www.tradingview.com/script/3BmID7aW-Highlight-Trading-Window-Simple-Hours-Time-of-Day-Filter\ni_timeFilterEnabled = input.bool(defval = false , title = \"Enable Time-Of-Day Window\"\ni_timeZone = input.string(title=\"Select Local Time Zone\", defval=\"GMT-5\", options=\ni_betweenTime = input.session('0700-0900',  title = \"Time Filter\", group=\"Time Window\"\nisWithinWindowOfTime(_position) =>                                                  \n    currentTimeIsWithinWindowOfTime = not na(time(timeframe.period, _position + ':1234567'\nbool isTimeFilterEnabledAndInRange = i_timeFilterEnabled ? isWithinWindowOfTime(i_betweenTime\nisStartEndPeriodsAndTimeInRange = isStartPeriodEnabledAndInRange and isEndPeriodEnabledAndInRange\n// Trade Direction \n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_tradeDirection = input.string('Long and Short', title='Trade Direction', options\n// Percent as Points\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nper(pcnt) =>\n    strategy.position_size != 0 ? math.round(pcnt / 100 * strategy.position_avg_price\n// Take profit 1\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_takeProfitTargetPercent1 = input.float(title='Take Profit 1 - Target %', defval=\ni_takeProfitQuantityPercent1 = input.int(title='% Of Position', defval=100, minval\n// Take profit 2\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_takeProfitTargetPercent2 = input.float(title='Take Profit 2 - Target %', defval=\ni_takeProfitQuantityPercent2 = input.int(title='% Of Position', defval=100, minval\n// Take profit 3\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_takeProfitTargetPercent3 = input.float(title='Take Profit 3 - Target %', defval=\ni_takeProfitQuantityPercent3 = input.int(title='% Of Position', defval=100, minval\n// Take profit 4\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_takeProfitTargetPercent4 = input.float(title='Take Profit 4 - Target %', defval=\n/// Stop Loss\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_stopLossPercent = input.float(title='Stop Loss (%)', defval=999, minval=0.01, step\nslLongClose = close < strategy.position_avg_price * (1 - i_stopLossPercent)\nslShortClose = close > strategy.position_avg_price * (1 + i_stopLossPercent)\n/// Leverage\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_leverage = input.float(1, 'Leverage', step=.5, group='Leverage')\ncontracts = math.min(math.max(.000001, strategy.equity / close * i_leverage), 1000000000\n/// Trade State Management\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nisInLongPosition = strategy.position_size > 0\nisInShortPosition = strategy.position_size < 0\n/// ProfitView Alert Syntax String Generation\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\ni_alertSyntaxPrefix = input.string(defval='CRYPTANEX_99FTX_Strategy-Name-Here', title\nalertSyntaxBase = i_alertSyntaxPrefix + '\\n#' + str.tostring(open) + ',' + str.tostring\n/// Trade Execution\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nlongConditionCalc = (longCondition and isADXFilterEnabledAndAboveThreshold and isEMAFilterEnabledAndCloseAboveMA\nshortConditionCalc = (shortCondition and isADXFilterEnabledAndAboveThreshold and isEMAFilterEnabledAndCloseBelowMA\nif isStartEndPeriodsAndTimeInRange\n    if longConditionCalc and i_tradeDirection != 'Short Only' and isInLongPosition\n        strategy.entry('Long', strategy.long, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:long', freq=alert.freq_once_per_bar_close\n    if shortConditionCalc and i_tradeDirection != 'Long Only' and isInShortPosition\n        strategy.entry('Short', strategy.short, qty=contracts)\n        alert(message=alertSyntaxBase + 'side:short', freq=alert.freq_once_per_bar_close\n        //Inspired from Multiple %% profit exits example by adolgo https://www.tradingview.com/script/kHhCik9f-Multip\n    strategy.exit('TP1', qty_percent=i_takeProfitQuantityPercent1, profit=per(i_takeProfitTargetPercent1\n    strategy.exit('TP2', qty_percent=i_takeProfitQuantityPercent2, profit=per(i_takeProfitTargetPercent2\n    strategy.exit('TP3', qty_percent=i_takeProfitQuantityPercent3, profit=per(i_takeProfitTargetPercent3\n    strategy.exit('i_takeProfitTargetPercent4', profit=per(i_takeProfitTargetPercent4\n    // Stop Loss\n    strategy.close('Long', qty_percent=100, comment='SL Long', when=slLongClose)\n    strategy.close('Short', qty_percent=100, comment='SL Short', when=slShortClose\n    // Conditional Closes\n    strategy.close('Long', qty_percent=100, comment='Close Long', when=closeLongCondition\n    strategy.close('Short', qty_percent=100, comment='Close Short', when=closeShortCondition\n/// Dashboard\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT\nshowDashboard = input.bool(group=\"Dashboard\", title=\"Show Dashboard\", defval=true)\nf_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>\n    _cellText = _title + \"\\n\" + _value\n    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor\n// Draw dashboard table\nif showDashboard\n    var bgcolor =  color.new(color.black,0)\n        // Keep track of Wins/Losses streaks\n    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades\n    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades\n    varip int winRow     = 0\n    varip int lossRow    = 0\n    varip int maxWinRow  = 0\n    varip int maxLossRow = 0\n    if newWin\n        lossRow := 0\n        winRow := winRow + 1\n    if winRow > maxWinRow\n        maxWinRow := winRow\n            if newLoss\n        winRow := 0\n        lossRow := lossRow + 1\n    if lossRow > maxLossRow\n        maxLossRow := lossRow\n    // Prepare stats table\n    var table dashTable = table.new(position.bottom_right, 1, 15, border_width=1)\n           if barstate.islastconfirmedhistory\n        // Update table\n        dollarReturn = strategy.netprofit\n        f_fillCell(dashTable, 0, 0, \"Start:\", str.format(\"{0,date,long}\", strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 1, \"End:\", str.format(\"{0,date,long}\", strategy.opentrades.entry_time\n        _profit = (strategy.netprofit / strategy.initial_capital) * 100\n        f_fillCell(dashTable, 0, 2, \"Net Profit:\", str.tostring(_profit, '##.##') \n        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time\n        f_fillCell(dashTable, 0, 3, \"Percent Per Day\", str.tostring(_profit / _numOfDaysInStrategy\n        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100\n        f_fillCell(dashTable, 0, 4, \"Percent Profitable:\", str.tostring(_winRate, \n        f_fillCell(dashTable, 0, 5, \"Profit Factor:\", str.tostring(strategy.grossprofit\n        f_fillCell(dashTable, 0, 6, \"Total Trades:\", str.tostring(strategy.closedtrades\n        f_fillCell(dashTable, 0, 8, \"Max Wins In A Row:\", str.tostring(maxWinRow, \n        f_fillCell(dashTable, 0, 9, \"Max Losses In A Row:\", str.tostring(maxLossRow"}]}
{"messages": [{"role": "user", "content": "This strategy is a combination of 2 indicators based on EMA(actually x3 EMAs and Williams ind. We usin this to see where EMA fast is above EMA slow(for long), entry position when price hit fast EMA and exit if trend changes or price overbought, or by stoploss 1%. The opposite for a short position. For better result You can change every EMA's, stoploss, Willam's ind and other visualisation in settings. If You find good combination - please, let me know(if You want). I will check it with ML, and attach it here. Original indicators will write in comments"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 svatvlad1993\n//@version=5\nstrategy(\"CM_SlingShotSystem\", overlay=true, margin_long = 100, margin_short = 100\n// do not use 'calc_on_every_tick = true', better to use lower timeframe\n// if You strong need - you can, but the part of code(some variables) should be overwritten\n//                                  CM_SLING_SHOT_SYSTEM\n// Has updated for pinescript v5\n// this is first indicator you provided https://tr.tradingview.com/script/GE7tSQK1-CM-Slin\n// this indicator based on EMA, so there are some reasons to use much bigger/lower EMA classic(see b\nsae = input(true, title=\"Show Aggressive Entry?, Or Use as Alert To Potential Conservative Entry?\"\nsce = input(true, title=\"Show Conservative Entry?\")\nst = input(true, title=\"Show Trend Arrows at Top and Bottom of Screen?\")\ndef = input(false, title=\"Only Choose 1 - Either Conservative Entry Arrows or 'B'-'S' Letters\"\npa = input(true, title=\"Show Conservative Entry Arrows?\")\nsl = input(false, title=\"Show 'B'-'S' Letters?\")\n//                                  EMA Definitions\n// This part for input each EMA for CM_SLING_SHOT_SYSTEM\nCM_SLING_SHOT_emaSlow_input = input.int(62 ,minval = 2)\nCM_SLING_SHOT_emaFast_input = input.int(38, minval = 1)\nemaSlow = ta.ema(close, CM_SLING_SHOT_emaSlow_input)\nemaFast = ta.ema(close, CM_SLING_SHOT_emaFast_input)\n//Aggressive Entry or Alert To Potential Trade\npullbackUpT() => emaFast > emaSlow and close < emaFast\npullbackDnT() => emaFast < emaSlow and close > emaFast\n//Conservative Entry Code For Highlight Bars\nentryUpT() => emaFast > emaSlow and close[1] < emaFast and close > emaFast\nentryDnT() => emaFast < emaSlow and close[1] > emaFast and close < emaFast\n//Conservative Entry True/False Condition\nentryUpTrend = emaFast > emaSlow and close[1] < emaFast and close > emaFast ? 1 : \nentryDnTrend = emaFast < emaSlow and close[1] > emaFast and close < emaFast ? 1 : \n//Define Up and Down Trend for Trend Arrows at Top and Bottom of Screen\nupTrend = emaFast >= emaSlow\ndownTrend = emaFast < emaSlow\n//Definition for Conseervative Entry Up and Down PlotArrows\ncodiff = entryUpTrend == 1 ? entryUpTrend : 0\ncodiff2 = entryDnTrend == 1 ? entryDnTrend : 0\n//Color definition for Moving Averages\ncol = emaFast > emaSlow ?  color.lime : emaFast < emaSlow ?  color.red :  color.yellow\n//Moving Average Plots and Fill\np1 = plot(emaSlow, title=\"Slow MA\", style=plot.style_linebr, linewidth=4, color=col\np2 = plot(emaFast, title=\"Fast MA\", style=plot.style_linebr, linewidth=2, color=col\nfill(p1, p2,  color.new(color.silver, 50))\n//Aggressive Entry, Conservative Entry Highlight Bars\nbarcolor(sae and pullbackUpT() ?  color.yellow : sae and pullbackDnT() ?  color.yellow\nbarcolor(sce and entryUpT() ?  color.aqua : sce and entryDnT() ?  color.aqua : na\n//Trend Triangles at Top and Bottom of Screen\nplotshape(st and upTrend ? upTrend : na, title=\"Conservative Buy Entry Triangle\",style\nplotshape(st and downTrend ? downTrend : na, title=\"Conservative Short Entry Triangle\"\n//Plot Arrows OR Letters B and S for Buy Sell Signals\nplotarrow(pa and codiff ? codiff : na, title=\"Up Entry Arrow\", colorup=color.new( \nplotarrow(pa and codiff2*-1 ? codiff2*-1 : na, title=\"Down Entry Arrow\", colordown\nplotchar(sl and codiff ? low - ta.tr : na, title=\"Buy Entry\", offset=0, char='B', \nplotchar(sl and codiff2 ? high + ta.tr : na, title=\"Short Entry\", offset=0, char='S'\n//                            Willams21EMA13 htc1977 edition\n// second indicator https://tr.tradingview.com/v/BYEfUEKp/\n//  input number of candles for diapason\nWillams_candles_back_length = input.int(21, minval=1)\nupper = ta.highest(Willams_candles_back_length)\nlower = ta.lowest(Willams_candles_back_length)\n// calc willy\nwillyout = 100 * (close - upper) / (upper - lower)\nsrc = willyout\nWillams_len = input.int(13, minval=1, title=\"Length\")\n// compute the EMA of willy\nemaout = ta.ema(willyout, Willams_len)\n// draw willy and EMA\ncurrent_price = close\n//                             EMA classic\n// You can use this EMA for bult indicator or/and inside strategy buy logic\n// You can ON/OFF EMA for calculating(but for OFF indicator there is another field in settings)\nswitcher_EMA = input.bool(true)\nEMA_classic_len = input.int(200, minval=1, title=\"Length\")\nEMA_OHLC = input(close, title=\"Source\")\noffset2 = input.int(title=\"Offset\", defval=0, minval=-500, maxval=500)\nout2 = ta.ema(EMA_OHLC, EMA_classic_len)\nplot(out2, title=\"EMA\", color= color.blue, offset=offset2)\nma(source, length, type) =>\n    switch type\n        \"SMA\" => ta.sma(source, length)\n        \"EMA\" => ta.ema(source, length)\n        \"SMMA (RMA)\" => ta.rma(source, length)\n        \"WMA\" => ta.wma(source, length)\n        \"VWMA\" => ta.vwma(source, length)\n// choose indicator - for You it is EMA\ntypeMA2 = input.string(title = \"Method\", defval = \"SMA\", options=[\"SMA\", \"EMA\", \"SMMA (RMA)\"\nsmoothingLength2 = input.int(title = \"Length\", defval = 5, minval = 1, maxval = 100\nsmoothingLine2 = ma(out2, smoothingLength2, typeMA2)\nplot(smoothingLine2, title=\"Smoothing Line\", color= #f37f20, offset=offset2, display\n// logic for strategy_ema_switcher\nvar long_EMA_classic = true\nvar short_EMA_classic = true\nif switcher_EMA == true\n    if close > out2\n        long_EMA_classic := true\n        short_EMA_classic := false\n    else\n        long_EMA_classic := false\n        short_EMA_classic := true\nelse\n    long_EMA_classic := true\n    short_EMA_classic := true\n// var for entered order + stop_loss for each side\nvar calc = 0\nvar cust_stop_long = 0.0\nvar cust_stop_short = 0.0\nif strategy.position_size == 0\n    cust_stop_long := 0.0\n    cust_stop_short := 0.0\ncustom_stop_percent = input.float(0.01, minval = 0.001, title = 'custom stop') //this is 1%, 55% = 0.55\n// logict enry order\nif calc == 0\n    if emaFast > emaSlow and ta.crossunder(low, emaFast) and low[1] > emaFast and \n        strategy.order('long_entry', strategy.long, 50)\n        alert('long_signal')\n        cust_stop_long := close - (close * custom_stop_percent)\n        strategy.exit('long_entry', stop=cust_stop_long)\n        calc := 1\n    if emaFast < emaSlow  and ta.crossover(high, emaFast) and high[1] < emaFast and\n        strategy.order('short_entry', strategy.short, 50)\n        alert('short_signal')\n        cust_stop_short := close + (close * custom_stop_percent)\n        strategy.exit('short_entry', stop=cust_stop_short)\n        calc := -1\n    // logic for close position\nif calc == 1 and (emaFast < emaSlow or (emaout > -20 and willyout > -20) or close \n    strategy.close('long_entry', immediately = true)\n    calc := 0\n    if calc == -1 and (emaFast > emaSlow or (emaout < -80 and willyout < -80) or close\n    strategy.close('short_entry', immediately = true)\n    calc := 0\nplot(strategy.equity)\n// a piece of advice\n// here are a lot of ema, probably You have to try some else indicators.\n// a lot of negative orders were also opened on period of small difference between emaslow and emafa\n// Play with variables, see profit, gave fan!!!\n// Arivadis"}]}
{"messages": [{"role": "user", "content": "iMoku\u2122 is a professional all-in-one solution for the famous Ichimoku Kinko Hyo indicator.  The algorithm includes:  1. Backtesting spot  2. Visual tool  3. Auto-trading functions  With iMoku you can test four different strategies.  Strategy 1: Cross Tenkan Sen - Kijun Sen  A long position is opened with 100% of the invested capital ($1000) when \"Tenkan Sen\" crossover \"Kijun Sen\".  Closing the long position on the opposite condition.  There are 3 different strength signals for this strategy: weak, normal, strong.  Weak: the signal is weak when the condition is true and the price is above the 'Kumo'  Normal: the signal is normal when the condition is true and the price is within the 'Kumo'  Strong: the signal is strong when the condition is true and the price is below the 'Kumo'  Strategy 2: Cross Price - Kijun Sen  A long position is opened with 100% of the invested capital ($1000) when the price crossover the 'Kijun Sen'.  Closing the long position on the opposite condition.  There are 3 different strength signals for this strategy: weak, normal, strong.  Weak: the signal is weak when the condition is true and the price is above the 'Kumo'  Normal: the signal is normal when the condition is true and the price is inside the 'Kumo'  Strong: the signal is strong when the condition is true and the price is below the 'Kumo'  Strategy 3: Kumo Breakout  A long position is opened with 100% of the invested capital ($1000) when the price breakup the 'Kumo'.  Closing the long position with a percentage stop loss and take profit on the invested capital.  Strategy 4: Kumo Twist  A long position is opened with 100% of the invested capital ($1000) when the 'Kumo' goes from negative to positive (called \"Twist\").  Closing the long position on the opposite condition.  There are 2 different strength signals for this strategy: weak, and strong.  Weak: the signal is weak when the condition is true and the price is above the 'Kumo'  Strong: the signal is strong when the condition is true and the price is below the 'Kumo'  This script is compliant with algorithmic trading.  You can use this script with trading terminals such as 3Commas or CryptoHopper. Connecting this script is very easy.  1. Enter the user interface  2. Select and activate a strategy  3. Copy your bot's links into the dedicated fields  4. Create and activate alert  Disclaimer: algorithmic trading involves risk, the user should consider aspects such as slippage, liquidity and costs when evaluating an asset. The Quant Science is not responsible for any kind of damage resulting from use of this script. By using this script you take all the responsibilities and risks."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 thequantscience\n/////////////////////////////// Design by The Quant Science \u2122  ////////////////////////////////////\nstart = 1000\n//@version=5\nstrategy(\" iMoku - The Quant Science \u2122 \", \n             overlay = true, \n             default_qty_type = strategy.percent_of_equity, \n             default_qty_value = 100,\n             currency = currency.EUR, \n             initial_capital = start, \n             commission_type = strategy.commission.percent, \n             commission_value = 0.10,\n             slippage = 1) \nconversionPeriods = input.int(\n         9, \n         minval=1, \n         title=\"Tenkan Sen Length\", \n         group = \"Indicator configuration\"\n         )\nbasePeriods = input.int(\n         26, minval=1, \n         title=\"Kjun Sen Length\", \n         group = \"Indicator configuration\"\n         )\nlaggingSpan2Periods = input.int(\n         52, \n         minval=1, \n         title=\"Leading Span B Length\", \n         group = \"Indicator configuration\"\n         )\ndisplacement = input.int(\n         26, minval=1, \n         title=\"Lagging Span\", \n         group = \"Indicator configuration\"\n         )\nstrategy_1 = input.bool(\n         false, \n         title = \"Tenkan Sen - Kijun Sen Strategy\", \n         group = \"Tenkan Sen - Kijun Sen Strategy Configuration\"\n         )\nstrategy_2 = input.bool(\n         false, \n         title = \"Price - Kijun Sen Strategy\", \n         group = \"Price - Kijun Sen Strategy Configuration\"\n         )\nstrategy_3 = input.bool(\n         false, \n         title = \"Kumo Breakout Strategy\", \n         group = \"Kumo Breakout Strategy Configuration\"\n         )\nstrategy_4 = input.bool(\n         false, \n         title = \"Kumo Twist Strategy\", \n         group = \"Kumo Twist Strategy Configuration\"\n         )\nstop_loss = input.float(\n         defval = 1, \n         minval = 0.01, \n         step = 0.05, \n         maxval = 500, \n         title = \"Stop Loss\", \n         group = \"Kumo Breakout Strategy Configuration\" \n         )\ntake_profit = input.float(\n         defval = 1, \n         minval = 0.01, \n         step = 0.05, \n         maxval = 500, \n         title = \"Take Profit\", \n         group = \"Kumo Breakout Strategy Configuration\"\n         )\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\ndonchian(len) => math.avg(\n         ta.lowest(\n             len\n             ), \n             ta.highest(\n                 len\n                 ))\nconversionLine = donchian(\n     conversionPeriods\n     )\nbaseLine = donchian(\n     basePeriods\n     )\nleadLine1 = math.avg(\n     conversionLine, \n     baseLine\n     )\nleadLine2 = donchian(\n     laggingSpan2Periods\n     )\nadj_leadLine1 = leadLine1[displacement -1]\nadj_leadLine2 = leadLine2[displacement -1]\n// 1. Cross Tenkan Sen - Kijun Sen \nprice_over_kumo = close > adj_leadLine1\nprice_under_kumo = close < adj_leadLine2\nprice_in_kumo = close > adj_leadLine1 \n     and close < adj_leadLine2\nstrong_xover_tenkan_kijun = ta.crossover(\n     conversionLine, \n     baseLine\n     ) \n     and price_over_kumo\nneutro_xover_tenkan_kijun = ta.crossover(\n     conversionLine, \n     baseLine\n     ) \n     and price_in_kumo\nlight_xover_tenkan_kijun = ta.crossover(\n     conversionLine, \n     baseLine\n     ) \n     and price_under_kumo\nclose_tenkan_kijun = ta.crossunder(\n     conversionLine, \n     baseLine\n     )\nSelectTenkanKijun(type) =>\n     switch type \n          \"Strong Crossover Tenkan Sen - Kijun Sen\" => strong_xover_tenkan_kijun\n          \"Neutro Crossover Tenkan Sen - Kijun Sen\" => neutro_xover_tenkan_kijun\n          \"Light Crossover Tenkan Sen - Kijun Sen\" => light_xover_tenkan_kijun       \ntype_input = input.string(\n     \"Strong Crossover Tenkan Sen - Kijun Sen\",\n     title = \"Select strategy: \",\n     options = [\"Strong Crossover Tenkan Sen - Kijun Sen\", \"Neutro Crossover Tenkan Sen - Kijun Sen\"\n     tooltip = \"\",\n     group = \"Tenkan Sen - Kijun Sen Strategy Configuration\"\n     )\nselect_tenkan_kijun = SelectTenkanKijun(\n     type_input\n     ) \n     and barstate.isconfirmed\nprice_entry_tenkan_kijun = ta.valuewhen(\n     select_tenkan_kijun, \n     close, \n     0\n     )\n// 2. Cross Price - Kijun Sen \nstrong_xover_price_kijun = ta.crossover(\n         close, \n         baseLine\n         ) \n         and price_over_kumo\nneutro_xover_price_kijun  = ta.crossover(\n         close, \n         baseLine\n         ) \n         and price_in_kumo\nlight_xover_price_kijun = ta.crossover(\n         close, \n         baseLine\n         ) \n         and price_under_kumo\nclose_price_kijun = ta.crossunder(\n     close,\n     baseLine\n     )\nSelectPriceKijun(type) =>\n     switch type \n          \"Strong Crossover Price - Kijun Sen\" => strong_xover_price_kijun\n          \"Neutro Crossover Price - Kijun Sen\" => neutro_xover_price_kijun\n          \"Light Crossover Price - Kijun Sen\" => light_xover_price_kijun        \ntype_input_2 = input.string(\n     \"Strong Crossover Price - Kijun Sen\",\n     title = \"Select strategy: \",\n     options = [\"Strong Crossover Price - Kijun Sen\", \"Neutro Crossover Price - Kijun Sen\"\n     tooltip = \"\",\n     group = \"Price - Kijun Sen Strategy Configuration\"\n     )\nselect_price_kijun = SelectPriceKijun(\n     type_input_2\n     ) \n     and barstate.isconfirmed\nprice_entry_price_kijun = ta.valuewhen(\n     select_price_kijun, \n     close, \n     0\n     )\n// 3. Kumo breakout \nkumo_breakout = ta.crossover(\n     close, \n     adj_leadLine1\n     ) \n// 4. Kumo Twist \nstrong_kumo_twist = ta.crossover(\n     adj_leadLine1, \n     adj_leadLine2\n     ) \n     and price_over_kumo\nlight_kumo_twist = ta.crossover(\n     adj_leadLine1, \n     adj_leadLine2\n     ) \n     and price_under_kumo\nclose_kumo_twist = ta.crossunder(\n     adj_leadLine1, \n     adj_leadLine2)\nSelectKumoTwist(type) =>\n     switch type \n          \"Strong Crossover Kumo Twist\" => strong_kumo_twist\n          \"Light Crossover Kumo Twist\" => light_kumo_twist       \ntype_input_3 = input.string(\n     \"Strong Crossover Kumo Twist\",\n     title = \"Select strategy: \",\n     options = [\"Strong Crossover Kumo Twist\", \"Light Crossover Kumo Twist\" ],\n     tooltip = \"\",\n     group = \"Kumo Twist Strategy Configuration\"\n     )\nselect_kumo_twist = SelectKumoTwist(\n     type_input_3\n     ) \n     and barstate.isconfirmed\nprice_entry_kumo_twist = ta.valuewhen(\n     select_kumo_twist, \n     close, \n     0\n     )\n// #################################################################################################\nvar tb = table.new(\n     position.bottom_left, \n     1, 1, \n     bgcolor =  color.new(\n         color.blue, \n         90\n         ))\nif barstate.isfirst\n    table.cell(\n      tb, \n      0, 0, \n      'Developed by The Quant Science\u2122'\n      ,text_size = size.normal\n      ,text_color =  color.new(\n           color.blue, \n           20\n           ))\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\nentry_string_1 = input.string(\n     title = \"Entry string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Tenkan Sen - Kijun Sen Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the open entry link in this field.\"\n     )\nexit_string_1 = input.string(\n     title = \"Exit string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Tenkan Sen - Kijun Sen Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the close exit link in this field.\"\n     )\nisLong  = false\nisLong := nz(\n     isLong[1], \n     false\n     )\nisSellLong  = false\nisSellLong := nz(\n     isSellLong[1], \n     false\n     )\nLONG = not isLong and select_tenkan_kijun\nprice_1 = ta.valuewhen(\n     LONG, \n     close, \n     0\n     )\nlot_1 = start / price_1\nCLOSE_LONG = not isSellLong and close_tenkan_kijun\nif (LONG) and strategy_1 == true \n     isLong := true\n     isSellLong := false\n    strategy.entry(\n         id = \"Tenkan Kijun Open\", \n         direction = strategy.long, \n         qty = lot_1, \n         limit = price_entry_tenkan_kijun\n         )\n    alert(\n         entry_string_1, \n         alert.freq_once_per_bar\n         )\n          if (CLOSE_LONG) and strategy_1 == true \n     isLong := false\n     isSellLong := true\n    strategy.close_all(\n         comment = \"Tenkan Kijun Closing\"\n         )\n    alert(\n         exit_string_1, \n         alert.freq_once_per_bar\n         )\n// #################################################################################################\nentry_string_2 = input.string(\n     title = \"Entry string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Price - Kijun Sen Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the open entry link in this field.\"\n     )\nexit_string_2 = input.string(\n     title = \"Exit string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Price - Kijun Sen Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the close exit link in this field.\"\n     )\nisLong_2  = false\nisLong_2 := nz(\n     isLong_2[1], \n     false\n     )\nisSellLong_2 = false\nisSellLong_2 := nz(\n     isSellLong_2[1], \n     false\n     )\nLONG_2 = not isLong_2 and select_price_kijun\nprice_2 = ta.valuewhen(\n     LONG_2, \n     close, \n     0\n     )\nlot_2 = start / price_2\nCLOSE_LONG_2 = not isSellLong_2 and close_price_kijun\nif (LONG_2) and strategy_2 == true \n     isLong_2 := true\n     isSellLong_2 := false\n    strategy.entry(\n         id = \"Price Kijun Open\", \n         direction = strategy.long, \n         qty = lot_2, \n         limit = price_entry_price_kijun\n         )\n    alert(\n         entry_string_2, \n         alert.freq_once_per_bar\n         )\nif (CLOSE_LONG_2) and strategy_2 == true \n     isLong_2 := false\n     isSellLong_2 := true\n    strategy.close_all(comment = \"Price Kijun Closing\")\n    alert(\n         exit_string_2, \n         alert.freq_once_per_bar\n         )\n// #################################################################################################\nentry_string_3 = input.string(\n     title = \"Entry string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Kumo Breakout Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the open entry link in this field.\"\n     )\nexit_string_3 = input.string(\n     title = \"Exit string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Kumo Breakout Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the close exit link in this field.\"\n     )\nisLong_3  = false\nisLong_3 := nz(\n     isLong_3[1], \n     false\n     )\nisSellLong_3  = false\nisSellLong_3 := nz(\n     isSellLong_3[1], \n     false \n     )\nLONG_3 = not isLong_3 and kumo_breakout \nprice_kumobrk = ta.valuewhen(\n     LONG_3, \n     close, \n     0\n     )\nlot_3 = start / price_kumobrk\ntake_profit_kumobrk_price = (\n     price_kumobrk * (\n          100 + \n          take_profit\n          ) / 100\n          )\nstop_loss_kumobrk_price = (\n     price_kumobrk * (\n         100 - \n         stop_loss\n         ) / 100\n         )\nif (LONG_3) and strategy_3 == true \n     isLong_3 := true\n     isSellLong_3 := false\n    strategy.entry(\n         id = \"Kumo Breakout Open\", \n         direction = strategy.long, \n         qty = lot_3, \n         limit = price_kumobrk\n         )\n    alert(\n         entry_string_3, \n         alert.freq_once_per_bar\n         )\nif (take_profit_kumobrk_price) \n     isLong_3 := false\n     isSellLong_3 := true\n    strategy.exit(\n         id = \"Kumo Breakout Closing\", \n         from_entry = \"Kumo Breakout Open\", \n         limit = take_profit_kumobrk_price, \n         stop = stop_loss_kumobrk_price\n         )\n    alert(\n         exit_string_3, \n         alert.freq_once_per_bar\n         )\nif (stop_loss_kumobrk_price) \n     isLong_3 := false\n     isSellLong_3 := true\n    strategy.exit(\n         id = \"Kumo Breakout Closing\", \n         from_entry = \"Kumo Breakout Open\", \n         limit = take_profit_kumobrk_price, \n         stop = stop_loss_kumobrk_price\n         )\n    alert(\n         exit_string_3, \n         alert.freq_once_per_bar\n         )\n// #################################################################################################\nentry_string_4 = input.string(\n     title = \"Entry string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Kumo Twist Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the open entry link in this field.\"\n     )\nexit_string_4 = input.string(\n     title = \"Exit string:\", \n     defval = \"#######\", \n     confirm = false, \n     group = \"Kumo Twist Strategy Configuration\",\n     tooltip = \"Enter 3Commas or Cryptohopper string link. Enter only the close exit link in this field.\"\n     )\nisLong_4  = false\nisLong_4 := nz(\n     isLong_4[1], \n     false\n     )\nisSellLong_4  = false\nisSellLong_4 := nz(\n     isSellLong_4[1], \n     false\n     )\nLONG_4 = not isLong_4 and select_kumo_twist\nprice_4 = ta.valuewhen(\n     LONG_4, \n     close, \n     0\n     )\nlot_4 = start / price_4\nCLOSE_LONG_4 = not isSellLong_4 and close_kumo_twist\nif (LONG_4) and strategy_4 == true \n     isLong_4 := true\n     isSellLong_4 := false\n    strategy.entry(\n         id = \"Kumo Twist Open\", \n         direction = strategy.long, \n         qty = lot_4, \n         limit = price_entry_kumo_twist\n         )\n    alert(\n         entry_string_4, \n         alert.freq_once_per_bar\n         )\nif (CLOSE_LONG_4) and strategy_4 == true \n     isLong_4 := false\n     isSellLong_4 := true\n    strategy.close_all(comment = \"Kumo Twist Closing\")\n    alert(\n         exit_string_4, \n         alert.freq_once_per_bar\n         )\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\nplot(\n     conversionLine, \n     color = color.new(\n          color.aqua, \n          65), \n          title = \"Conversion Line or Tenkan Sen\"\n          )\nplot(\n     baseLine, \n     color= color.new(\n         color.purple, \n         65), \n         title=\"Base Line or Kijun Sen\"\n         )\nplot(\n     close, \n     offset = -displacement + 1, \n     color=  color.new(\n         color.gray, \n         85\n         ), \n         title=\"Lagging Span Chokou\"\n         )\np1 = plot(\n     leadLine1, \n     offset = displacement - 1, \n     color=  color.aqua,\n      title=\"Leading Span A\"\n     )\np2 = plot(\n     leadLine2, \n     offset = displacement - 1, \n     color=  color.aqua,\n      title=\"Leading Span B\"\n     )\nfill(\n     p1, \n     p2, \n     color = leadLine1 > leadLine2 ? color.rgb(\n         21, 149, 253, 90\n         ) : color.rgb(\n             21, 149, 253, 90\n             ))\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################\n// #################################################################################################"}]}
{"messages": [{"role": "user", "content": "// This is a strategy that draws a trend line in the form of a slope whenever the high point and low point are updated. // The upper slope serves as a resistance line, and the lower slope serves as a support line. // Buy when the  of the candle crosses the slope"}, {"role": "assistant", "content": "// This is a strategy that draws a trend line in the form of a slope whenever the high point and low\n// The upper slope serves as a resistance line, and the lower slope serves as a support line.\n// Buy when the [close] of the candle crosses the slope\n//@version=5\nstrategy(\"Donchian Trendline - Support Resistance Slope [UhoKang]\", shorttitle=\"Donchian Trendline\"\n///////////////////////////////////// Time /////////////////////////////////////////////////////////\nstartYear   = input.int(2019, 'Start-Year', confirm=false, inline='1')\nstartMonth  = input.int(1,    'Month',      confirm=false, inline='1')\nstartDay    = input.int(1,    'Day',      confirm=false, inline='1')\nfinishYear  = input.int(2099, 'End-Year', confirm=false, inline='2')\nfinishMonth = input.int(1,    'Month',      confirm=false, inline='2')\nfinishDay   = input.int(1,    'Day',      confirm=false, inline='2')\nstartTime = timestamp(startYear, startMonth, startDay)\nfinishTime = timestamp(finishYear, finishMonth, finishDay)\ntestPeriod = time >= startTime and time <= finishTime\n//////////////////////// ATR BAND //////////////////////////////////////////////////////////////////\n// Inputs\natrPeriod = input.int(title = \"ATR Period\", defval = 14, minval = 1)\natrBandUpper = input(title = \"Source Upper\", defval = close)\natrBandLower = input(title = \"Source Lower\", defval = close)\natrMultiplierUpper = input.int(title = \"ATR Multiplier Upper\", defval = 1)\natrMultiplierLower = input.int(title = \"ATR Multiplier Lower\", defval = 1)\n// ATR ///////////////////////////////////////////////////////////////////////////////\n//------------------------------------------------------------------------------------\natr = ta.atr(atrPeriod)\natrBBUpper = atrBandUpper + (atr * atrMultiplierUpper)\natrBBLower = atrBandLower - (atr * atrMultiplierLower)\n/////////////////////////// Big Candle ///////////////////////////////////////////////\n//------------------------------------------------------------------------------------\ncandle_size = close>=open ? close-open :  open-close\ncandle_grade_guide = atrBBUpper - atrBBLower\ncandle_grade = candle_size > candle_grade_guide ? 3 : candle_size > candle_grade_guide\ncandle_grade_color = candle_grade == 3 ?  color.new(color.black, 0) : candle_grade\nbarcolor(candle_grade_color, title = \"Long candle\")\n///////////////////////////////////// Donchian ///////////////////////////////////////\n//------------------------------------------------------------------------------------\ndonchian_length = input(60)\ndonchian_top = ta.highest(high, donchian_length)\ndonchian_bot = ta.lowest(low, donchian_length)\ndonchian_mid = (donchian_top + donchian_bot) / 2\nplot_donchian_top = plot(donchian_top,  color= color.new(color.green, 90), title \nplot_donchian_bot = plot(donchian_bot,  color= color.new(color.red, 90), title = \nplot_donchian_mid = plot(donchian_mid,  color= color.new(color.orange, 0), title \nfill(plot_donchian_top, plot_donchian_mid, color= color.new(color.green, 95), title\nfill(plot_donchian_bot, plot_donchian_mid, color= color.new(color.red, 95), title\n///////////////////////////// Trendline //////////////////////////////////////////////////\n//------------------------------------------------------------------------------------\ndonchian_longTr = false\ndonchian_shortTr = false \nvar atrLongHeight = 0.0 \nvar atrShortHeight = 0.0 \nif high > donchian_top[1] \n    donchian_longTr := true \n    atrLongHeight := atrBBUpper[1] - atrBBLower[1]\nif low < donchian_bot[1] \n    donchian_shortTr := true\n    atrShortHeight := atrBBUpper[1] - atrBBLower[1]\ndonchian_Tr_color = donchian_longTr ?  color.new(color.green,70) : donchian_shortTr\n//////////////////////// Set var //////////////////////////////////////////////\n//------------------------------------------------------------------------------------\nslope_mult = input.float(0.03, step=0.01,  title = \"Slope x\")\nvar ph_M_Avg = 0.0 //slope avg high\nvar pl_M_Avg = 0.0 //slope avg low \nvar ph_M_Line = 0.0 //slope high\nvar pl_M_Line = 0.0 //slope low\nph_M = donchian_longTr[1]==true and high<donchian_top[1] ? high[1] : na\npl_M = donchian_shortTr[1]==true and low>donchian_bot[1] ? low[1] : na\nplot(ph_M,color= color.blue, style = plot.style_linebr, linewidth = 3, offset = -1\nplot(pl_M,color= color.blue, style = plot.style_linebr, linewidth = 3, offset = -1\n       /////////////////////////////////////////  Calc trendline /////////////////////////////\n//------------------------------------------------------------------------------------\nmirror_mode = input.bool(false , title = \"Mirror Line\")\nph_M_Avg := atrLongHeight * slope_mult\npl_M_Avg := atrShortHeight * slope_mult\n// Calc slope\nif mirror_mode \n    if ph_M\n        ph_M_Line := ph_M\n        pl_M_Line := donchian_mid[1]\n    else if pl_M\n        pl_M_Line := pl_M\n        ph_M_Line := donchian_mid[1]\n    else if ph_M_Line  \n        ph_M_Line := ph_M_Line[1] - ph_M_Avg\n        pl_M_Line := pl_M_Line[1] + pl_M_Avg\nelse \n    if ph_M\n        ph_M_Line := ph_M\n    else if ph_M_Line  \n        ph_M_Line := ph_M_Line[1] - ph_M_Avg\n    if pl_M\n        pl_M_Line := pl_M\n    else if pl_M_Line\n        pl_M_Line := pl_M_Line[1] + pl_M_Avg\n// Delete trendline\nif donchian_bot[1] > ph_M_Line\n    ph_M_Line := na\nif donchian_top[1] < pl_M_Line\n    pl_M_Line := na\n// Draw trendline\nplot(ph_M_Line, color= color.new(color.green,20), style = plot.style_circles, linewidth\nplot(pl_M_Line, color= color.new(color.maroon,20), style = plot.style_circles, linewidth\n// Trade \nph_longTr = false\nph_longExitTr = false\nph_shortTr = false\nph_shortExitTr = false \n//-----------------------------------------------------------------------------}\ncheck_short_mode = input.bool(true, title= \"Short Mode On\")\nif ta.crossover(close, ph_M_Line) \n    ph_longTr := true\nelse if ta.crossunder(close,pl_M_Line) or ta.crossunder(close, donchian_mid[1]) \n    ph_longExitTr := true \nif ta.crossunder(close, pl_M_Line)\n    ph_shortTr := true\nelse if ta.crossover(close,ph_M_Line) or ta.crossover(close, donchian_mid[1])\n    ph_shortExitTr := true\nph_Tr_color = ph_longTr ?  color.new(color.green,80) : ph_shortTr ?  color.new(color.red\nbgcolor(ph_Tr_color, title = \"Break Slope\")\nif ph_longTr and testPeriod\n    strategy.entry(\"L\", strategy.long)\nelse if ph_longExitTr \n    strategy.close(\"L\")\nif ph_shortTr and testPeriod and check_short_mode\n    strategy.entry(\"S\", strategy.short)\nelse if ph_shortExitTr \n    strategy.close(\"S\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    symbol : gold timeframe : h1 capital : 1000$ risk/trade : 30$ (3%) = (2.5)*stop loss/100 take profit : 1800 point stop loss : 1200 point buy ticket : 1. stochastic cross over < lower level(25) 2. close price > ema(Span A , Span B) shift back(1) sell ticket : 1. stochastic cross under > upper level(65) 2. close price < ema(Span A , Span B) shift back(1)"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"ICHI + STOCH V1\", overlay=true,initial_capital = 1000,default_qty_value =\nlength = input.int(20, minval=1)\nsmoothK = input(5)\nsmoothD = input(3)\nOverBought = input(25)\nOverSold = input(65)\nProfit = input(1800)\nStop = input(1200)\nk = ta.sma(ta.stoch(close, high, low, length), smoothK)\nd = ta.sma(k, smoothD)\nco = ta.crossover(k,d)\ncu = ta.crossunder(k,d)\nconversionPeriods = input.int(9, minval=1, title=\"Conversion Line Length\")\nbasePeriods = input.int(26, minval=1, title=\"Base Line Length\")\nlaggingSpan2Periods = input.int(52, minval=1, title=\"Leading Span B Length\")\ndisplacement = input.int(1, minval=1, title=\"Lagging Span\")\nconversionLine = math.avg(ta.lowest(conversionPeriods), ta.highest(conversionPeriods\nbaseLine = math.avg(ta.lowest(basePeriods), ta.highest(basePeriods))\nleadLine1 = math.avg(conversionLine, baseLine)\nleadLine2 = math.avg(ta.lowest(laggingSpan2Periods), ta.highest(laggingSpan2Periods\nTREND = ta.ema(math.avg(leadLine1,leadLine2),displacement)\n//plot(conversionLine, color=#2962FF, title=\"Conversion Line\")\n//plot(baseLine, color=#B71C1C, title=\"Base Line\")\n//plot(close, offset = -displacement + 1, color=#43A047, title=\"Lagging Span\")\nplot(TREND, color= #2962FF, title=\"TREND\")\np1 = plot(leadLine1,style=plot.style_line, offset = displacement - 1, color= #A5D6A7\n     title=\"Leading Span A\")\np2 = plot(leadLine2,style=plot.style_line, offset = displacement - 1, color= #EF9A9A\n     title=\"Leading Span B\")\nfill(p1, p2, color = leadLine1 > leadLine2 ?  color.rgb(67, 160, 71, 90) :  color.rgb\nclose_price = ta.sma(close,1)\npc = plot(close_price,style=plot.style_line, color= #2a0ab9,\n     title=\"Price Close\")\nif (not na(k) and not na(d))\n    if (co and k < OverSold)and(close_price > TREND)\n        strategy.entry(\"BUY order\", strategy.long, comment=\"BUY order\")\n        strategy.exit(\"exitBUY\", \"BUY order\", profit = Profit, loss = Stop)\n    if (cu and k > OverBought)and(close_price < TREND)\n        strategy.entry(\"SELL order\", strategy.short, comment=\"SELL order\")\n        strategy.exit(\"exitSELL\", \"SELL order\", profit = Profit, loss = Stop)\n//plot(strategy.equity, title=\"equity\", color=color.red, linewidth=2, style=plot.style_areabr)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added \"TF\" label indicating all conditions met. entry position at open the next trading day after all conditions met. exit position at open the next trading after TP 10% or CL 5% is met.                                                    Release Notes:                                                    Remove annoying TF label"}, {"role": "assistant", "content": "//@version=4\nstrategy(title=\"Pure Mark Minervini 10%TP 5%CL\", pyramiding = 0, commission_type=strategy.commission.percent\nma50 = sma(close,50)\nma150 = sma(close,150)\nma200 = sma(close,200)\nma200_22 = ma200[22]\nhigh_loopback = input(260, \"High Lookback Length\")\nlow_loopback = input(260, \"Low Lookback Length\")\nhighest_price = highest(high, high_loopback)\nlowest_price = lowest(low, low_loopback)\nabove52lo = ((close/lowest_price)-1)*100\nbelow52hi = (1-(close/highest_price))*100\nep = strategy.position_avg_price\nbuy = close>ma150 and close>ma200 and ma150>ma200 and ma200>ma200_22 and ma50>ma150\nsell = close>ep*1.1 or close<ep*0.95\nstrategy.entry(\"TF\", strategy.long, when = buy)\nstrategy.close(\"TF\", when = sell)"}]}
{"messages": [{"role": "user", "content": "This strategy uses the Fast Fourier Transform inspired from the source code of @tbiktag for the Fast Fourier Transform & @lazybear for the VMA filter. If you are not familiar with the Fast Fourier transform it is a variation of the Discrete Fourier Transform.  Veritasium on youtube has a great video on it with a follow up recommendation from 3brown1blue.  In short it will extract all the frequencies from a set of data.  @tbiktag laid the groundwork for creating the indicator which will allow you to isolate only those signals which are the most relevant and remove the noise.  I recommend having @tbiktag's FFT Transform indicator side by side with this to understand what my variation is doing by setting similar settings. Using this idea, you can then optimize a strategy to the frequencies that are best.  The main entry signal is when the FFT Signal crosses above or below the 0 line. Included with this strategy is the ability to optionally bi-directionally set: Stop Loss Trailing Stop Loss Take Profit Trailing Take Profit  Entries are optionally further filtered by use of the VMA using the algorithm from LazyBear which allows you to adjust a variable moving average with 3 market trend detections.  Green represents upwards momentum;  Blue sideways trading and Red downwards momentum.  The idea being to filter out buy or sell entries unless the market is moving in that direction, and this makes a big difference as you can see for yourself when you turn it off or on.  Turning it off will change the color of the FFT signal to orange instead of the green, blue, red colors. I have added 2 custom stop loss types as well for experimentation: 1. VMA Filter stop loss to exit the trade if the VMA detects a market trend direction change matching the rules you have set.  I have set this to off by default, but it is there so you can see what affect it may have on other tickers.  It can increase the profit factor but usually at a cost of net profit. 2. The Aroon Filter stop loss with different lengths for the short or long direction.  For the Aroon strategy (which is a trend change detector) it is considered bullish if the upper line (green in my code) is above 70 and the lower line (red in my code) is below 30 and the opposite for the bearish case.  With this in mind, I have set it to filter by default only the extreme ends (99 and 1) to increase profit factor and net profit but I encourage you to try different settings and see how it affects things.  Turning this off yields much higher net profit but at the cost of the profit factor and drawdown.  To disable this just uncheck the 'Use Aroon Filter Long' (or short) and it will also hide the aroon graphics and crosses on the plot. I will be adding more features in an attempt to lower the drawdown on this strategy but I hope you enjoy what I have so far!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Gentleman-Goat\n// credit to tbiktag for FFT\n// credit to lazybear for VMA\n// House Rules: This code borrows from the user tbiktag's source code (many thanks for making it ope\n// tbiktag --notes below regarding usage\n// This tool computes the one-dimensional N-point discrete Fourier Transform \n// (DFT) with the efficient Fast Fourier Transform (FFT) algorithm.\n// \n// The tool uses FFT to decompose the input time series into its \n// periodic constituents and seasonalities, in other words, its frequency \n// components. \n//\n// Subsequently it allows reconstructing the time-domain data while using \n// only the frequency components within a user-defined range (band-pass filtering). \n// Thereby, this tool can reveal the cyclical characteristics of the studied market,\n// and also remove high-frequency noise from the time series.\n// -- end tbiktag notes\n//@version=5\nstrategy(title=\"FFT Strategy\",shorttitle = \"FFT Strat\", overlay=false,max_lines_count\nimport tbiktag/FFTLibrary/1 as fft\n//-- FFT --\nsrc = input.source(title='Source', defval=ohlc4, group='Fourier Input', inline='linei1'\nN = input.int(title='Length', defval=128, options=[8, 16, 32, 64, 128, 256, 512, 1024\nispp = input.bool(title='Standardize Input Dataset', defval=true, group='Fourier Input'\nfreqdomain = input.bool(title='Show Frequency-Domain Power Spectrum', defval=false\nistable = input.bool(title='Dominant Cycles, Rows:', defval=false, group='Fourier Output'\nntabfreqs = input.int(title='', defval=5, minval=1, group='Fourier Output', inline\n//timedomain = input.bool(title='Show Inverse Fourier Transform (Filtered)', defval=false, group='Fo\nismoving = input.bool(title='Apply FFT Filter in a Moving Window', defval=true, group\nislowthrs = input.bool(title='', defval=true, group='Filtered Fourier Components',\nN_first = input.int(title='Lowest Allowed N', defval=1, minval=0, group='Filtered Fourier Components'\nishghthrs = input.bool(title='', defval=true, group='Filtered Fourier Components',\nN_last = input.int(title='Highest Allowed N ', defval=12, minval=0, group='Filtered Fourier Components'\nfixedstart = input.bool(title='', group='Fourier Filtering Time Range', inline='linebac1'\nfilter_start = input.time(title='', inline='linebac1', group='Fourier Filtering Time Range'\nfixedend = input.bool(title='', group='Fourier Filtering Time Range', inline='linebac2'\nfilter_end = input.time(title='', inline='linebac2', group='Fourier Filtering Time Range'\n//-- VMA Filter --\nuse_vma_filter = input.bool(defval=true,title=\"Use VMA Filter\",group=\"VMA Filter\")\nvma_src        = input.source(defval=close,title=\"VMA Src\",group=\"VMA Filter\")\nvma_length     = input.int(defval=65,title=\"VMA Length\",group=\"VMA Filter\")\nvma_timeframe  = input.timeframe(defval=\"240\",title=\"VMA Time Frame\",group=\"VMA Filter\"\nallow_vma_filter_long = input.string(defval=\"Green or Blue\",options=[\"Green\",\"Blue\"\nallow_vma_filter_short = input.string(defval=\"Blue\",options=[\"Green\",\"Blue\",\"Red\",\nuse_vma_filter_stop_loss = input.bool(defval=false,title=\"Use VMA Filter Stop Loss\"\ncancel_long_when_vma_filter = input.string(defval=\"Red\",options=[\"Green\",\"Blue\",\"Red\"\ncancel_short_when_vma_filter = input.string(defval=\"Green\",options=[\"Green\",\"Blue\"\n//-- Aroon Filter --\nuse_aroon_filter_long   = input.bool(defval=true,title=\"Use Aroon Filter Long\",group\nuse_aroon_filter_short  = input.bool(defval=true,title=\"Use Aroon Filter Short\",group\naroon_length_long       = input.int(defval=13,title=\"Length Long\", minval=1,group=\naroon_length_short      = input.int(defval=13,title=\"Length Short\", minval=1,group\naroon_upper_long_req    = input.float(defval=1,title=\"Green (Upper) Line Below % (Long)\"\naroon_lower_long_req    = input.float(defval=99,title=\"Red (Lower) Line Above % (Long)\"\naroon_upper_short_req   = input.float(defval=99,title=\"Green (Upper) Line Above % (Short)\"\naroon_lower_short_req   = input.float(defval=1,title=\"Red (Lower) Line Below % (Short)\"\naroon_upper_long = 100 * (ta.highestbars(high, aroon_length_long+1) + aroon_length_long\naroon_lower_long = 100 * (ta.lowestbars(low, aroon_length_long+1) + aroon_length_long\naroon_upper_short = 100 * (ta.highestbars(high, aroon_length_short+1) + aroon_length_short\naroon_lower_short = 100 * (ta.lowestbars(low, aroon_length_short+1) + aroon_length_short\naroonLongCross = false\nif(aroon_upper_long < aroon_upper_long_req and aroon_lower_long > aroon_lower_long_req\n    aroonLongCross := true\naroonShortCross = false\nif(aroon_upper_short > aroon_upper_short_req and aroon_lower_short < aroon_lower_short_req\n    aroonShortCross := true\nplot(aroon_upper_long*0.05 - 2.5, \"Aroon Up Long\", color= color.rgb(0,255,0,70), \nplot(aroon_lower_long*0.05 - 2.5, \"Aroon Down Long\", color= color.rgb(255,0,0,70)\nplot(aroon_upper_long*0.05 - 2.5, \"Aroon Up Short\", color= color.rgb(0,255,0,70),\nplot(aroon_lower_long*0.05 - 2.5, \"Aroon Down Short\", color= color.rgb(255,0,0,70\n//Arroon Points\n//long\naroon_high_boundary_long = 5 * (0+aroon_upper_long_req*0.01) - 2.5\naroon_low_boundary_long = 5 * (0+aroon_lower_long_req*0.01) - 2.5\nh1_arroon_long_upper = hline(aroon_high_boundary_long,color= color.green,display=\nh2_arroon_long_lower = hline(aroon_low_boundary_long,color= color.red,display=(use_aroon_filter_long\n//short\naroon_high_boundary_short = 5 * (0+aroon_upper_short_req*0.01) - 2.5\naroon_low_boundary_short = 5 * (0+aroon_lower_short_req*0.01) - 2.5\nh1_arroon_short_upper = hline(aroon_high_boundary_short,color= color.green,display\nh2_arroon_short_lower = hline(aroon_low_boundary_short,color= color.red,display=(\n// -- Strategy Specific --\nallow_long  = input.bool(defval=true,title=\"Long\",group=\"Allow Entry\")\nallow_short = input.bool(defval=true,title=\"Short\",group=\"Allow Entry\")\nuse_stop_loss_long                      = input.bool(defval=true,title=\"Use Long\",\nstop_loss_long_percentage               = input.float(defval=7.5,title=\"Long %\",group\nuse_stop_loss_short                     = input.bool(defval=true,title=\"Use Short\"\nstop_loss_short_percentage              = input.float(defval=8.0,title=\"Short %\",group\nuse_trailing_stop_loss_long             = input.bool(defval=false,title=\"Use Long\"\ntrailing_stop_loss_long_percentage      = input.float(defval=2.0,title=\"Long %\",group\nuse_trailing_stop_loss_short            = input.bool(defval=false,title=\"Use Short\"\ntrailing_stop_loss_short_percentage     = input.float(defval=2.0,title=\"Short %\",group\nuse_take_profit_long                    = input.bool(defval=true,title=\"Use Long\",\ntake_profit_long_percentage             = input.float(defval=105,title=\"Long %\",group\nuse_take_profit_short                   = input.bool(defval=true,title=\"Use Short\"\ntake_profit_short_percentage            = input.float(defval=50,title=\"Short %\",group\nuse_trailing_take_profit_long                       = input.bool(defval=false,title\ntrailing_take_profit_long_min_profit_percentage     = input.float(defval=10,title=\ntrailing_take_profit_long_percentage                = input.float(defval=2.0,title\nuse_trailing_take_profit_short                      = input.bool(defval=false,title\ntrailing_take_profit_short_min_profit_percentage    = input.float(defval=10,title=\ntrailing_take_profit_short_percentage               = input.float(defval=2.0,title\n//\n//\n// --- Initialiation ---\nbool    isinrange = (fixedstart ? time >= filter_start : true) and (fixedend ? time\nvar line[] tLines = array.new_line(N-1)\nvar line[] fLines = array.new_line(N/2-2)\n//\n// Look back and see how many datapoints are available\nint m    = int(math.log(N)/math.log(2)) // approximate log2\nint newM = 0\nfor j = 1 to m\n    if na(src[math.pow(2, j)])\n        break\n    newM := j\n// Use fewer datapoints, if there is not enough\nm := newM\nN := int(math.pow(2, newM))\n//\n//\n// -- Collect the data and apply FFT---\nfloat[] dat_re = array.new_float(na)\nfloat[] dat_im = array.new_float(na)\nif  N > 1 and (isinrange and ismoving or barstate.islast)\n    for i = 0 to N - 1\n        array.push(dat_re, src[i])\n        array.push(dat_im, 0.0)\n    if ispp\n        dat_re := array.standardize(dat_re)\n        dat_re\n    // forward FFT\n    fft.fft(dat_re, dat_im, \"Forward\")\n//\n//\n// Collect Fourier amplitudes squared (powers)\nfloat[] power = array.new_float(na)\nif barstate.islast and N > 1\n    for i = 0 to N-1\n        array.push(power,math.pow(array.get(dat_re,i),2) + math.pow(array.get(dat_im\n    array.set(power,0,0.0) // make sure that the 0th component doesn't affect the power spectrum\n//\n//\n// -- Apply inverse FFT using selected frequency components --\nfloat[] dat_re_filt = array.new_float(N)\nfloat[] dat_im_filt = array.new_float(N)\nN_first := islowthrs ? math.min(math.min(N_first, N_last), N / 2) : 0\nN_last  := ishghthrs ? math.min(N_last, N / 2) : N / 2\n// Apply the bandpass filter\nif N > 1 and (isinrange and ismoving or barstate.islast)\n    array.fill(dat_re_filt, 0.0)\n    array.fill(dat_im_filt, 0.0)\n    for i = N_first to N_last by 1\n        array.set(dat_re_filt, i, array.get(dat_re, i))\n        array.set(dat_im_filt, i, array.get(dat_im, i))\n        if i != 0\n            array.set(dat_re_filt, N - i, array.get(dat_re, N - i))\n            array.set(dat_im_filt, N - i, array.get(dat_im, N - i))\n    //inverse FFT\n    fft.fft(dat_re_filt, dat_im_filt, \"Inverse\")\n//\n// Apply the filter to real-time data\nfloat src_filtered = ismoving and isinrange ? array.get(dat_re_filt, 0) : na\n//\n//\n// --- Plotting --- \n// Time-domain subplot\n// if (barstate.islast) and timedomain and N > 1\n//     for i = 1 to N - 1\n//         float y_plt1 = array.get(dat_re_filt, i)\n//         float y_plt2 = array.get(dat_re_filt, i - 1)\n//         array.push(tLines, line.new(bar_index[i], y_plt1, bar_index[i - 1], y_plt2, width=2, colo\n//         line.delete(array.shift(tLines))\n// \n// Frequency-domain subplot\nif (barstate.islast) and freqdomain and N > 1\n    float y_zero  = array.max(dat_re_filt)\n    float y_scale = (array.max(dat_re_filt) - array.min(dat_re_filt)) / array.max(\n    line yax = line.new(bar_index, y_zero, bar_index[int(N / 2) + 5], y_zero, style\n    label ylb = label.new(bar_index[int(N / 2) + 6], y_zero, text='f', style=label.style_none\n    line.delete( yax[1])\n    label.delete(ylb[1])\n    for i = 0 to int(N / 2)-2\n        isinwindow = i >= N_first and i <= N_last\n        float y_plt = array.get(power, i)\n        array.push(fLines, line.new(bar_index[i], y_zero, bar_index[i], y_plt * y_scale\n        line.delete(array.shift(fLines))\n//\n//\n// --- Table ---\nvar table panel = table.new(position.top_right, 3, ntabfreqs + 1)\nif (barstate.islast) and istable and N > 1\n    ntabfreqs := math.min(ntabfreqs, N / 2)\n    // Table header\n    table.cell(panel, 0, 0, 'N', bgcolor= #AED6F1, text_size=size.small)\n    table.cell(panel, 1, 0, 'Cycle Period', bgcolor= #AED6F1, text_size=size.small\n    table.cell(panel, 2, 0, 'Rel. Power', bgcolor= #AED6F1, text_size=size.small)\n    // drop zero frequency from power array and sort it\n    power_sorted = array.copy(power)\n    array.remove(power_sorted, 0)\n    array.sort(power_sorted, order.descending)\n    //\n    for i = 0 to ntabfreqs - 1 by 1\n        // Period in left column\n        id = array.indexof(power, array.get(power_sorted, 2 * i))\n        table.cell(panel, 0, i + 1, str.format(\"{0,number,#}\",id), bgcolor= #DFEEF7\n        table.cell(panel, 1, i + 1, str.format(\"{0,number,#.#}\",float(N) / float(id\n        table.cell(panel, 2, i + 1, str.format(\"{0,number,#.####}\", array.get(power_sorted\n//\n//VMA (credit to LazyBear) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmakevma(src,l) =>\n    k = 1.0/l\n    pdm = math.max((src - src[1]), 0)\n    mdm = math.max((src[1] - src), 0)\n    pdmS = 0.0\n    pdmS := ((1 - k)*nz(pdmS[1]) + k*pdm)\n    mdmS = 0.0\n    mdmS := ((1 - k)*nz(mdmS[1]) + k*mdm)\n    s = pdmS + mdmS\n    pdi = pdmS/s\n    mdi = mdmS/s\n    pdiS = 0.0\n    pdiS := ((1 - k)*nz(pdiS[1]) + k*pdi)\n    mdiS = 0.0\n    mdiS := ((1 - k)*nz(mdiS[1]) + k*mdi)\n    d = math.abs(pdiS - mdiS)\n    s1 = pdiS + mdiS\n    iS = 0.0\n    iS := ((1 - k)*nz(iS[1]) + k*d/s1)\n    hhv = ta.highest(iS, l)\n    llv = ta.lowest(iS, l)\n    d1 = hhv - llv\n    vI = (iS - llv)/d1\n    vma = 0.0\n    vma := (1 - k*vI)*nz(vma[1]) + k*vI*src\n    vmaC=(vma > vma[1]) ?  color.green : (vma<vma[1]) ?  color.red : (vma==vma[1\n    [vma,vmaC]\n[vma,vmaC] = makevma(vma_src,vma_length)\nvma_val     = request.security(syminfo.tickerid, vma_timeframe==\"Same as chart\" ? \nvmaC_val   = request.security(syminfo.tickerid, vma_timeframe==\"Same as chart\" ? timeframe.period\nmet_vma_filter_rules(direction,vma_color) =>\n    met_filter_rules = false\n    //[\"Green\",\"Blue\",\"Red\",\"Green or Blue\",\"Blue or Red\",\"Red or Green\"]\n    if(direction==\"long\")\n        if(allow_vma_filter_long==\"Green\" and vma_color== color.green)\n            met_filter_rules := true\n        if(allow_vma_filter_long==\"Red\" and vma_color== color.red)\n            met_filter_rules := true\n        if(allow_vma_filter_long==\"Blue\" and vma_color== color.blue)\n            met_filter_rules := true\n        if(allow_vma_filter_long==\"Green or Blue\" and (vma_color== color.green or\n            met_filter_rules := true\n        if(allow_vma_filter_long==\"Blue or Red\" and (vma_color== color.blue or vma_color\n            met_filter_rules := true\n        if(allow_vma_filter_long==\"Red or Green\" and (vma_color== color.red or vma_color\n            met_filter_rules := true\n    if(direction==\"short\")\n        if(allow_vma_filter_short==\"Green\" and vma_color== color.green)\n            met_filter_rules := true\n        if(allow_vma_filter_short==\"Red\" and vma_color== color.red)\n            met_filter_rules := true\n        if(allow_vma_filter_short==\"Blue\" and vma_color== color.blue)\n            met_filter_rules := true\n        if(allow_vma_filter_short==\"Green or Blue\" and (vma_color== color.green or\n            met_filter_rules := true\n        if(allow_vma_filter_short==\"Blue or Red\" and (vma_color== color.blue or vma_color\n            met_filter_rules := true\n        if(allow_vma_filter_short==\"Red or Green\" and (vma_color== color.red or vma_color\n            met_filter_rules := true\n    met_filter_rules\nmet_vma_cancel_rules(direction,vma_color) =>\n    met_cancel_rules = false\n    //[\"Green\",\"Blue\",\"Red\",\"Green or Blue\",\"Blue or Red\",\"Red or Green\"]\n    if(direction==\"long\")\n        if(cancel_long_when_vma_filter==\"Green\" and vma_color== color.green)\n            met_cancel_rules := true\n        if(cancel_long_when_vma_filter==\"Red\" and vma_color== color.red)\n            met_cancel_rules := true\n        if(cancel_long_when_vma_filter==\"Blue\" and vma_color== color.blue)\n            met_cancel_rules := true\n        if(cancel_long_when_vma_filter==\"Green or Blue\" and (vma_color== color.green\n            met_cancel_rules := true\n        if(cancel_long_when_vma_filter==\"Blue or Red\" and (vma_color== color.blue\n            met_cancel_rules := true\n        if(cancel_long_when_vma_filter==\"Red or Green\" and (vma_color== color.red\n            met_cancel_rules := true\n    if(direction==\"short\")\n        if(cancel_short_when_vma_filter==\"Green\" and vma_color== color.green)\n            met_cancel_rules := true\n        if(cancel_short_when_vma_filter==\"Red\" and vma_color== color.red)\n            met_cancel_rules := true\n        if(cancel_short_when_vma_filter==\"Blue\" and vma_color== color.blue)\n            met_cancel_rules := true\n        if(cancel_short_when_vma_filter==\"Green or Blue\" and (vma_color== color.green\n            met_cancel_rules := true\n        if(cancel_short_when_vma_filter==\"Blue or Red\" and (vma_color== color.blue\n            met_cancel_rules := true\n        if(cancel_short_when_vma_filter==\"Red or Green\" and (vma_color== color.red\n            met_cancel_rules := true\n    met_cancel_rules\n//Plots & Boundaries\nplot(src_filtered, color=(use_vma_filter ? vmaC_val :  color.orange), title='filtered'\nplot(aroonLongCross ? src_filtered : na,color= color.green,style=plot.style_cross\nplot(aroonShortCross ? src_filtered : na,color= color.red,style=plot.style_cross,\nhline(0)\n//Actual Strategy Entries\nif(src_filtered>0 and src_filtered[1]<=0)\n    //If any the filter fails for any reason then no entry is allowed\n    passed_vma_filter = true\n    if(use_vma_filter)\n        passed_vma_filter := met_vma_filter_rules(\"long\",vmaC_val)\n        if(passed_vma_filter) //If it's disabled it assumes it passed by defaulting to true\n        if(allow_long==true)\n            strategy.entry(\"long\",strategy.long)\n        else\n            strategy.close(\"short\")\nif(src_filtered<0 and src_filtered[1]>=0)\n    //If any the filter fails for any reason then no entry is allowed\n    passed_vma_filter = true\n    if(use_vma_filter)\n        passed_vma_filter := met_vma_filter_rules(\"short\",vmaC_val)\n    if(passed_vma_filter)\n        if(allow_short==true)\n            strategy.entry(\"short\",strategy.short)\n        else\n            strategy.close(\"long\")\n//VMA Stop Loss\npassed_vma_cancel_long = false\npassed_vma_cancel_short = false\nif(use_vma_filter_stop_loss)\n    if(allow_long==true and strategy.position_size>0)\n        passed_vma_cancel_long := met_vma_cancel_rules(\"long\",vmaC_val)\n        if(passed_vma_cancel_long==true)\n            strategy.close(\"long\",comment=\"vma cancel\")\n    if(allow_short==true and strategy.position_size<0)\n        passed_vma_cancel_short := met_vma_cancel_rules(\"short\",vmaC_val)\n        if(passed_vma_cancel_short==true)\n            strategy.close(\"short\",comment=\"vma cancel\")\n//Aroon Stop Loss\nif(allow_long==true and strategy.position_size>0 and aroonLongCross and use_aroon_filter_long\n    strategy.close(\"long\",comment=\"aroon long stop loss\")\nif(allow_short==true and strategy.position_size<0 and aroonShortCross and use_aroon_filter_short\n    strategy.close(\"short\",comment=\"aroon short stop loss\")\n//Stop Loss, Take Profit, Trailing Stop Loss & Trailing Take Profit\nstop_loss_value_long    = strategy.position_avg_price*(1 - stop_loss_long_percentage\ntake_profit_value_long  = strategy.position_avg_price*(1 + take_profit_long_percentage\nstop_loss_value_short   = strategy.position_avg_price*(1 + stop_loss_short_percentage\ntake_profit_value_short = strategy.position_avg_price*(1 - take_profit_short_percentage\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nlongStopPrice := if (strategy.position_size > 0)\n    stopValue = close * (1 - trailing_stop_loss_long_percentage)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\n// Determine trailing short price\nshortStopPrice = 0.0\nshortStopPrice := if (strategy.position_size < 0)\n    stopValue = close * (1 + trailing_stop_loss_short_percentage)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\n// Determine trailing take profit long price\nlongTPStopPrice = 0.0\nvar longTPActive = false //To keep track of once the stop loss becomes active\nif(close>(strategy.opentrades.entry_price(0) * (1+trailing_take_profit_long_min_profit_percentage\n    longTPActive := true\nlongTPStopPrice := if (strategy.position_size >0)\n    stopValue = close * (1 - trailing_take_profit_long_percentage)\n    math.max(stopValue, longTPStopPrice[1])\nelse\n    0\n// Determine trailing take profit short price\nshortTPStopPrice = 0.0\nvar shortTPActive = false //To keep track of once the stop loss becomes active\nif(close<(strategy.opentrades.entry_price(0) * (1-trailing_take_profit_short_min_profit_percentage\n    shortTPActive := true\nshortTPStopPrice := if (strategy.position_size < 0)\n    stopValue = close * (1 + trailing_take_profit_short_percentage)\n    math.min(stopValue, shortTPStopPrice[1])\nelse\n    999999\n//plot(longStopPrice,color=color.orange)\n//plot(shortStopPrice,color=color.teal)\nif(use_trailing_stop_loss_long and close<=longStopPrice and close>strategy.opentrades.entry_price\n    strategy.close(\"long\",comment=\"Trailing Stop Loss Long\")\nif(use_trailing_stop_loss_short and close>=shortStopPrice and close<strategy.opentrades.entry_price\n    strategy.close(\"short\",comment=\"Trailing Stop Loss Short\")\n// Only when the trailing take profit becomes activated at its profit target will the trailing stop \nif(use_trailing_take_profit_long and close<=longTPStopPrice and longTPActive==true\n    strategy.close(\"long\",comment=\"Trailing Take Profit Stop Loss Long\")\nif(use_trailing_take_profit_short and close>=shortTPStopPrice and shortTPActive==true\n    strategy.close(\"short\",comment=\"Trailing Take Profit Stop Loss Short\")\n//Stop Loss, Take Profit & Trailing Stop Loss\nif(strategy.position_size>0) //Creates exit condition once long order is detected\n    strategy.exit(id=\"TP/SL Long\",from_entry=\"long\", limit=use_take_profit_long ? \nif(strategy.position_size<0) //Creates exit condition once short order is detected\n    strategy.exit(id=\"TP/SL Short\",from_entry=\"short\", limit=use_take_profit_short\n//Reset variables when any order is closed, exited or flipped direction\nif(strategy.opentrades == 0 or (strategy.position_size != strategy.position_size[1\n    longTPActive := false\n    shortTPActive := false"}]}
{"messages": [{"role": "user", "content": "This script demonstrates a fatal flaw with Trading View backtests involving trailing stops.  Trading View assumes the most optimistic case for trailing stops, always giving you the best case high/low of a bar instead of the worst or average case. Within a bar, the price could reverse against your position after the open and trigger your trailing stop for a loss before the price goes in your favor, but Trading View backtests do not consider this and instead always give you the best case returns.  This allows a trivial strategy to appear as though it would perform miracles. This strategy enters on a random bar and sets a trailing stop triggered one tick better than the current price with 0 trailing distance.  Trading View then generously gives this strategy the difference between the open price and best possible wick as a profit.  The only way this strategy can lose money in simulation is if the price goes straight down after entry and never retraces.  It works on all symbols on all timeframes due to this systematic problem with the Trading View backtester."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Copyright \u00a92022 and_then_it_CRASHED\n//@version=5\nstrategy(\"Backtest Broken\", overlay=true, margin_long=1, margin_short=1)\nif strategy.position_size == 0 and math.random(0,100) < 5\n    strategy.entry('Long', strategy.long)\n    strategy.exit('Close Long', 'Long', trail_price = close+syminfo.mintick, trail_offset"}]}
{"messages": [{"role": "user", "content": "Despite its crude name, the volatility system strategy, described by Richard Book\u00adstaber in 1984, follows the simple premise that once there is a big volatile movement, the market tends to follow it. Thus, it uses the ATR to measure the volatility, and issues orders when the current change of the closing price exceeds the threshold, calculated by the ATR times a configurable constant. It yields good results for some very specific charts, as you can see. However, I doubt it would work in the current market conditions, since it has no stop loss and no take profit, and the current noise levels obliterate this strategy, especially in small time frames. Maybe their integration to the strategy would yield better results, so feel free to add your own modifications."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 EduardoMattje\n//@version=5\nstrategy(\"Volatility System\", overlay=false, margin_long=0, margin_short=0, default_qty_type\n default_qty_value=100, process_orders_on_close=true, initial_capital=20000)\n// Inputs\nvar averageLength = input.int(14, \"Average length\", 2)\nvar multiplier = input.float(2.0, \"Multiplier\", 0.0, step=0.1)\n// Calculations\natr = ta.atr(averageLength) * multiplier\nclosingChange = ta.change(close, 1)\natrPenetration(int signal) =>\n    res = closingChange * signal > atr[1]\nlongCondition = atrPenetration(1)\nshortCondition = atrPenetration(-1)\n// Order calls\nif (longCondition)\n    strategy.entry(strategy.direction.long, strategy.long)\nif (shortCondition)\n    strategy.entry(strategy.direction.short, strategy.short)\n// Visuals\nplot(atr, \"ATR\",  color.white, 2)\nplot(math.abs(closingChange), \"Absolute close change\",  color.red)"}]}
{"messages": [{"role": "user", "content": "Double Inside Bar & Trend Strategy - Kaspricci This strategy combines the Double Inside Bar candlestick pattern with a trend filter. Once the second inside bar closes and price is above trend moving average, a buy stop order is placed at high of the candle. If price is below trend moving average, a sell stop order is placed at the low of the candle. This strategy is for educational purposes only! It is not meant to be a financial advice. Settings  Trend source, type of moving average and length for calculating trend  Stop Loss Type - default: ATR. You can switch between stop loss calculation based on Average True Range value or fixed value.  ATR Length / Factor / TP Ratio - default: 14 / 2.0 / 2.0. Used to calculate the Stop Loss as ATR * Factor and Take Profit as Stop Loss * TP Ratio.  FIX Stop Loss / Take Profit - default: 10 pips / 20 pips. In case you select Stop Loss Type = FIX, these value swill be used.  Risk in % - default: 1%, option to adjust the quantity of a trade based on a defined risk percentage. If enabled, it will overwrite the quantity parameter of the strategy settings.  On top you can filter trades by start and end date as well as time of the day."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Kaspricci\n//@version=5\nstrategy(\n     title = \"Double Inside Bar & Trend Strategy - Kaspricci\", \n     shorttitle = \"Double Inside Bar & Trend\", \n     overlay=true, \n     initial_capital = 100000, \n     currency = currency.USD, \n     default_qty_type = strategy.percent_of_equity, \n     default_qty_value = 100, \n     calc_on_every_tick = true, \n     close_entries_rule = \"ANY\")\n// ================================================ Entry Inputs ===================================\nheadlineEntry   = \"Entry Seettings\"\nmaSource        = input.source(defval = close,             group = headlineEntry, \nmaType          = input.string(defval = \"HMA\",             group = headlineEntry, \nmaLength        = input.int(   defval = 45,    minval = 1, group = headlineEntry, \nfloat ma = switch maType \n    \"EMA\"  => ta.ema(maSource,  maLength)\n    \"HMA\"  => ta.hma(maSource,  maLength)\n    \"SMA\"  => ta.sma(maSource,  maLength)\n    \"SWMA\" => ta.swma(maSource)\n    \"VWMA\" => ta.vwma(maSource, maLength)\n    \"WMA\"  => ta.wma(maSource,  maLength)\nplot(ma, \"Trend MA\",  color.purple)\n// ================================================ Trade Inputs ===================================\nheadlineTrade   = \"Trade Seettings\"\nstopLossType    = input.string(defval = \"ATR\",                         group = headlineTrade\natrLength       = input.int(   defval = 50,   minval = 1,              group = headlineTrade\natrFactor       = input.float( defval =  2.5, minval = 0, step = 0.05, group = headlineTrade\ntakeProfitRatio = input.float( defval =  2.0, minval = 0, step = 0.05, group = headlineTrade\nfixStopLoss     = input.float( defval = 10.0, minval = 0, step = 0.5,  group = headlineTrade\nfixTakeProfit   = input.float( defval = 20.0, minval = 0, step = 0.5,  group = headlineTrade\nuseRiskMagmt    = input.bool(  defval = true,                          group = headlineTrade\nriskPercent     = input.float( defval = 1.0,  minval = 0., step = 0.5, group = headlineTrade\n// ================================================ Filter Inputs ==================================\nheadlineFilter  = \"Filter Setings\"\n// date filter\nfilterDates     = input.bool(defval = false,                                 group\nstartDateTime   = input.time(defval = timestamp(\"2022-01-01T00:00:00+0000\"), group\nendDateTime     = input.time(defval = timestamp(\"2099-12-31T23:59:00+0000\"), group\ndateFilter      = not filterDates or (time >= startDateTime and time <= endDateTime\n// session filter\nfilterSession   = input.bool(title = \"Filter trades by session\", defval = false, group\nsession         = input.session(title = \"       Session\", defval = \"0045-2245\", group\nsessionFilter   = not filterSession or time(timeframe.period, session, timezone = \n// ================================================ Trade Entries and Exits ========================\n// calculate stop loss\nstopLoss        = switch stopLossType\n    \"ATR\" => nz(math.round(ta.atr(atrLength) * atrFactor / syminfo.mintick, 0), 0)\n    \"FIX\" => fixStopLoss\n// calculate take profit\ntakeProfit      = switch stopLossType\n    \"ATR\" => math.round(stopLoss * takeProfitRatio, 0)\n    \"FIX\" => fixTakeProfit\ndoubleInsideBar = high[2] > high[1] and high[2] > high[0] and low[2] < low[1] and \n// highlight mother candel and inside bar candles\nbgcolor(doubleInsideBar ?  color.rgb(33, 149, 243, 80) : na)\nbgcolor(doubleInsideBar ?  color.rgb(33, 149, 243, 80) : na, offset = -1)\nbgcolor(doubleInsideBar ?  color.rgb(33, 149, 243, 80) : na, offset = -2)\nvar float buyStopPrice  = na\nvar float sellStopPrice = na\nif (strategy.opentrades == 0 and dateFilter and sessionFilter and doubleInsideBar \n    buyStopPrice  := high[0] // high of recent candle (second inside bar)\n    sellStopPrice := low[0] // low of recent candle (second inside bar)\n    tradeID = str.tostring(strategy.closedtrades + strategy.opentrades + 1)\n    quantity = useRiskMagmt ? math.round(strategy.equity * riskPercent / stopLoss,\n    commentTemplate = \"{0} QTY: {1,number,#.##} SL: {2} TP: {3}\"\n    if (close > ma)\n        longComment = str.format(commentTemplate, tradeID + \"L\", quantity, stopLoss\n        strategy.entry(tradeID + \"L\", strategy.long, qty = quantity, stop = buyStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"L\", profit = takeProfit, loss = stopLoss\n    if (close < ma)\n        shortComment = str.format(commentTemplate, tradeID + \"S\", quantity, stopLoss\n        strategy.entry(tradeID + \"S\", strategy.short, qty = quantity, stop = sellStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"S\", profit = takeProfit, loss = stopLoss\n// as soon as the first pending order has been entered the remaing pending order shall be cancelled \nif strategy.opentrades > 0\n    currentTradeID = str.tostring(strategy.closedtrades + strategy.opentrades)\n    strategy.cancel(currentTradeID + \"S\")\n    strategy.cancel(currentTradeID + \"L\")"}]}
{"messages": [{"role": "user", "content": "This is an indicator that directly draws a trend line by clicking on the candle. Click to Create Trend lines !! Create a trend line by connecting A, B, and C with three vertices. 1. Draw Bear Trend line   Click  pivot high : First pivothigh of the downtrend line   Click  pivot low : pivotlow of the downtrend line    Click  pivot high : Second pivothigh of the downtrend line  2. Draw Bull Trend line   Click  pivot low : First pivotlow of the uptrend line   Click  pivot high : pivothigh of the uptrend line    Click  pivot low : Second pivotlow of the uptrend line  Modefiy Trendlines 1. Edit Bear Trend line   Drag Red,, 2. Edit Bull Trend line    Drag Green,,"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n//@version=5\nstrategy(\"Click Draw TrendLine [UhoKang] v2\", shorttitle=\"Click TrendLine v2\", overlay\n// This is an indicator that directly draws a trend line by clicking on the candle.\n// Click to Create Trend lines !!\n// Create a trend line by connecting A, B, and C with three vertices.\n// 1. Draw Bear Trend line\n//   Click [A] pivot high : First pivothigh of the downtrend line\n//   Click [B] pivot low : pivotlow of the downtrend line \n//   Click [C] pivot high : Second pivothigh of the downtrend line \n// 2. Draw Bull Trend line\n//   Click [A] pivot low : First pivotlow of the uptrend line\n//   Click [B] pivot high : pivothigh of the uptrend line \n//   Click [C] pivot low : Second pivotlow of the uptrend line \n// Modefiy Trendlines\n// 1. Edit Bear Trend line\n//   Drag Red[A],[B],[C]\n// 2. Edit Bull Trend line \n//   Drag Green[A],[B],[C]\n/////////////////////////////////////////////// TrendLine //////////////////////////////////////////\n// 1. input\nvar TriangleHigh_A = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bear Trendline : [A] Pivot high\"\nvar TriangleHigh_B = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bear Trendline : [B] Pivot low\"\nvar TriangleHigh_C = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bear Trendline : [C] Pivot high\"\nvar TriangleLow_A = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bull Trendline : [A] Pivot low\"\nvar TriangleLow_B = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bull Trendline : [B] Pivot high\"\nvar TriangleLow_C = input.time(timestamp(\"2021-12-30\"), confirm = true, title = \"Bull Trendline : [C] Pivot low\"\n// 2. get bar_index of pivotpoint (\ud53c\ubd07\uc758 \uc778\ub371\uc2a4\ub97c \uad6c\ud558\uae30)\nBigH1 = TriangleHigh_A == time ?  bar_index : na\nBigHR1 = TriangleHigh_B == time ?  bar_index : na\nBigH2 = TriangleHigh_C == time ?  bar_index : na\nBigL1 = TriangleLow_A == time ?  bar_index: na\nBigLR1 = TriangleLow_B == time ?  bar_index: na\nBigL2 = TriangleLow_C == time ?  bar_index : na\n// 2. get price of pivotpoint  (\ud53c\ubd07\uc758 \uac00\uaca9\uc744 \uad6c\ud558\uae30)\nBigH_price1 = BigH1 ? high : na\nBigH_price2 = BigH2 ? high : na\nBigL_price1 = BigL1 ? low : na\nBigL_price2 = BigL2 ? low : na\nBigHR_price1 = BigHR1 ? low : na\nBigLR_price1 = BigLR1 ? high : na\n// 3. set datas  (\uace0\uc810\uc758 \uc815\ubcf4\ub4e4\uc744 var \ubcc0\uc218\uc5d0 \uae30\ub85d\ud574\ub450\uae30)\n// trendlines var (\uae34\ucd94\uc138\uc120 \ubcc0\uc218 \uae30\ub85d)\nvar BigH_Line_index1 = int(na)\nvar BigH_Line_index2 = int(na)\nvar BigL_Line_index1 = int(na)\nvar BigL_Line_index2 = int(na)\nvar BigH_Line_price1 = float(na)\nvar BigH_Line_price2 = float(na)\nvar BigL_Line_price1 = float(na)\nvar BigL_Line_price2 = float(na)\nBigH_Line_index1 := BigH1? BigH1:  BigH_Line_index1 [1]\nBigH_Line_index2 := BigH2? BigH2:  BigH_Line_index2 [1]\nBigL_Line_index1 := BigL1? BigL1:  BigL_Line_index1 [1]\nBigL_Line_index2 := BigL2? BigL2:  BigL_Line_index2 [1]\nBigH_Line_price1 := BigH_price1? BigH_price1 : BigH_Line_price1 [1]\nBigH_Line_price2 := BigH_price2? BigH_price2 : BigH_Line_price2 [1]\nBigL_Line_price1 := BigL_price1? BigL_price1 : BigL_Line_price1 [1]\nBigL_Line_price2 := BigL_price2? BigL_price2 : BigL_Line_price2 [1]\n// parallel lines var (\ud3c9\ud589\uc120 \ubcc0\uc218 \uae30\ub85d)\nvar BigHR_Line_price1 = float(na)\nvar BigLR_Line_price1 = float(na)\nvar BigH_Atr = float(na)\nvar BigL_Atr = float(na)\nvar BigHR_index = int(na)\nvar BigLR_index = int(na)\nBigHR_Line_price1 := BigHR_price1? BigHR_price1 : BigHR_Line_price1 [1]\nBigLR_Line_price1 := BigLR_price1? BigLR_price1 : BigLR_Line_price1 [1]\nBigHR_index := BigHR1 ? BigHR1 : BigHR_index[1]\nBigLR_index := BigLR1 ? BigLR1 : BigLR_index[1]\n// mini trendlines var (\uc9e7\uc740\ucd94\uc138\uc120 \ubcc0\uc218 \uae30\ub85d)\nvar MidH_Line_index1 = int(na)\nvar MidH_Line_index2 = int(na)\nvar MidL_Line_index1 = int(na)\nvar MidL_Line_index2 = int(na)\nvar MidH_Line_price1 = float(na)\nvar MidH_Line_price2 = float(na)\nvar MidL_Line_price1 = float(na)\nvar MidL_Line_price2 = float(na)\n// 4. plotshape inputpoint on chart \uc785\ub825 \ubc1b\uc558\ub294\uc9c0 \ucc28\ud2b8\uc5d0 \ud45c\uc2dc\ud558\uae30\nplotshape(BigH1, location = location.abovebar, color= color.maroon, textcolor= color.yellow\nplotshape(BigHR1, location = location.belowbar, color= color.maroon, textcolor= \nplotshape(BigH2, location = location.abovebar, color= color.maroon, textcolor= color.yellow\nplotshape(BigL1, location = location.belowbar, color= color.olive, textcolor= color.white\nplotshape(BigLR1, location = location.abovebar, color= color.olive, textcolor= color.white\nplotshape(BigL2, location = location.belowbar, color= color.olive, textcolor= color.white\n// 5. plot startpoint of trendlines  (\ucd94\uc138\uc120\uc774 \uc0dd\uc131\ub41c \uc9c0\uc810\uc758 \ub77c\uc778 \uadf8\ub9ac\uae30) \nplot(BigH1 ? high : BigH2 ? high : na, color= color.new(color.maroon,30), style=plot.style_line\nplot(BigHR1 ? low : BigH1 ? high : na, color= color.new(color.maroon,80), style=plot.style_line\nplot(BigHR1 ? low : BigH2 ? high : na, color= color.new(color.maroon,80), style=plot.style_line\nplot(BigL1 ? low : BigL2 ? low : na, color= color.new(color.olive,30), style=plot.style_line\nplot(BigLR1 ? high : BigL1 ? low : na, color= color.new(color.olive,80), style=plot.style_line\nplot(BigLR1 ? high : BigL2 ? low : na, color= color.new(color.olive,80), style=plot.style_line\n/////////////////////////////////////////////////////// \ucd94 \uc138 \uc120 \uacc4 \uc0b0 \ud558 \uae30 ////////////////////////////////////////////////////////\n////////////////////////////////////////////////////// calc trendline //////////////////////////////\n// get avg of trendline (\ucd94\uc138\uc120 \uace1\ub960\uacc4\uc0b0)\navgLine(src1,src2, x1, x2) => // pivot price1, pivot price2, pivot index1, pivot index2  (\uac00\uaca91, \uac00\uaca92, \uc2dc\uc791\uc810, \ub05d\uc810)\n    avgLineRatio = (src1 - src2)/(x2-x1) \n    avgLineRatioLast = -(avgLineRatio * (bar_index-x2)) // x2 \uaf2d\uc9c0\uc810 ~ \ud604\uc7ac \uaf2d\uc9c0\uc810\uc758 \ucc28\uc774\ub97c \uacc4\uc0b0 \n    // calc trendlines (\ucd94\uc138\uc120 \uacc4\uc0b0)\nBigH_Avg = avgLine(BigH_Line_price1,BigH_Line_price2,BigH_Line_index1,BigH_Line_index2\nBigL_Avg = avgLine(BigL_Line_price1,BigL_Line_price2,BigL_Line_index1,BigL_Line_index2\nMidH_Avg = avgLine(MidH_Line_price1,MidH_Line_price2,MidH_Line_index1,MidH_Line_index2\nMidL_Avg = avgLine(MidL_Line_price1,MidL_Line_price2,MidL_Line_index1,MidL_Line_index2\nBigH_Line = BigH_Line_price2 + BigH_Avg \nBigL_Line = BigL_Line_price2 + BigL_Avg \nMidH_Line = MidH_Line_price2 + MidH_Avg \nMidL_Line = MidL_Line_price2 + MidL_Avg \n// calc triangles (\uc0bc\uac01\uc218\ub834 \uacc4\uc0b0) \nlineTop = float(na)\nlineMid = float(na)\nlineBot = float(na)\nif BigH_Line and BigL_Line and BigH_Line > BigL_Line\n    lineHeight = (BigH_Line - BigL_Line)/4 \n    lineTop := BigL_Line + (lineHeight*3)\n    lineMid := BigL_Line + (lineHeight*2)\n    lineBot := BigL_Line + (lineHeight*1)\n    // calc trendLine and parallel lines (\ucd94\uc138\uc120\uacfc \ud3c9\ud589\uc120\uc758 \uac04\uaca9\uacc4\uc0b0) \nBigH_Atr := (BigH_Line_price1 - BigHR_Line_price1)\nBigH_Atr:= BigH_Atr - (BigH_Line_price1-BigH_Line_price2) * (BigHR_index - BigH_Line_index1\nBigL_Atr := (BigLR_Line_price1 - BigL_Line_price1)\nBigL_Atr:= BigL_Atr + (BigL_Line_price1-BigL_Line_price2) * (BigLR_index - BigL_Line_index1\nBigH_TrendLineMax = BigH_Line - BigH_Atr\nBigH_TrendLineTop = BigH_Line - BigH_Atr*0.25\nBigH_TrendLineMid = BigH_Line - BigH_Atr*0.5\nBigH_TrendLineBot = BigH_Line - BigH_Atr*0.75\nBigL_TrendLineMax = BigL_Line + BigL_Atr\nBigL_TrendLineTop = BigL_Line + BigL_Atr*0.75\nBigL_TrendLineMid = BigL_Line + BigL_Atr*0.5\nBigL_TrendLineBot = BigL_Line + BigL_Atr*0.25\n// calc price line for trade (\ub9e4\uc218\uc120 \uacc4\uc0b0)\nLineRange = input.float(0.05, title = \"Grid percent value\", step = 0.01)\nBigH_Line_Buy2 = BigH_Line -(BigH_TrendLineMax - BigH_TrendLineTop )*LineRange*2\nBigH_Line_Buy1 = BigH_Line -(BigH_TrendLineMax - BigH_TrendLineTop )*LineRange\nBigH_Line_Sell1 = BigH_Line +(BigH_TrendLineMax - BigH_TrendLineTop )*LineRange\nBigH_Line_Sell2 = BigH_Line +(BigH_TrendLineMax - BigH_TrendLineTop )*LineRange*2\nBigL_Line_Buy2 = BigL_Line -(BigL_TrendLineBot - BigL_TrendLineMax )*LineRange*2\nBigL_Line_Buy1 = BigL_Line -(BigL_TrendLineBot - BigL_TrendLineMax )*LineRange\nBigL_Line_Sell1 = BigL_Line +(BigL_TrendLineBot - BigL_TrendLineMax )*LineRange\nBigL_Line_Sell2 = BigL_Line +(BigL_TrendLineBot - BigL_TrendLineMax )*LineRange*2\n// plot mini trendlines (\ucd94\uc138\uc120\uadf8\ub9ac\uae30)\nplot_BigH_LIne = plot(BigH_Line, color= color.new(color.maroon,0), style = plot.style_linebr\nplot_BigL_LIne = plot(BigL_Line, color= color.new(color.olive,0), style = plot.style_linebr\nplot(MidH_Line, color= color.new(color.red,0), style = plot.style_linebr, linewidth\nplot(MidL_Line, color= color.new(color.green,0), style = plot.style_linebr, linewidth\n// plot triangles (\uc0bc\uac01\uc218\ub834 \uadf8\ub9ac\uae30)\nplotTriTop = plot(lineTop, color =  color.new(color.green,60), title = \"Triangle line Top\"\nplotTriMid = plot(lineMid, color =  color.new(color.black,50), title = \"Triangle line Middle\"\nplotTriBot = plot(lineBot, color =  color.new(color.red,60), title = \"Triangle line Bottom\"\nfill(plot_BigH_LIne,plotTriTop, color =  color.new(color.green,70), title = \"Triangle fill Top\"\nfill(plot_BigH_LIne,plotTriMid, color =  color.new(color.green,90), title = \"Triangle fill Top\"\nfill(plot_BigL_LIne,plotTriMid, color =  color.new(color.red,90), title = \"Triangle fill Bottom\"\nfill(plot_BigL_LIne,plotTriBot, color =  color.new(color.red,70), title = \"Triangle fill Bottom\"\n// plot parallel lines (\ud3c9\ud589\uc120 \uadf8\ub9ac\uae30)\nplot_TrendHMax = plot(BigH_TrendLineMax, color= color.new(color.maroon,50), style\nplot_TrendHTop = plot(BigH_TrendLineTop, color= color.new(color.maroon,85), style\nplot_TrendHMid = plot(BigH_TrendLineMid, color= color.new(color.maroon,90), style\nplot_TrendHBot = plot(BigH_TrendLineBot, color= color.new(color.maroon,95), style\nfill(plot_TrendHMax,plot_TrendHMid, color =  color.new(color.maroon,90), title = \nplot_TrendLMax = plot(BigL_TrendLineMax, color= color.new(color.olive,50), style \nplot_TrendLTop = plot(BigL_TrendLineTop, color= color.new(color.olive,95), style \nplot_TrendLMid = plot(BigL_TrendLineMid, color= color.new(color.olive,90), style \nplot_TrendLBot = plot(BigL_TrendLineBot, color= color.new(color.olive,85), style \nfill(plot_TrendLMax,plot_TrendLMid, color =  color.new(color.olive,90), title = \"Bull parallel lines\"\n// draw start point of parallel lines (\ud3c9\ud589\uc120 \uc791\ub3c4\uc120 \uadf8\ub9ac\uae30)\nplot(BigHR1 ? low : BigH2 ? BigH_TrendLineMax : na, color= color.new(color.maroon\nplot(BigLR1 ? high : BigL2 ? BigL_TrendLineMax : na, color= color.new(color.olive\n// // plot price lines for trade (parallel lines) (\ud3c9\ud589\uc120\uc5d0 \ub9e4\uc218\uc120 \uadf8\ub9ac\uae30)\nplot(BigH_Line_Buy2, color= color.new(color.green,80), style = plot.style_linebr,\nplot(BigH_Line_Buy1, color= color.new(color.green,90), style = plot.style_linebr,\nplot(BigH_Line_Sell1, color= color.new(color.red,90), style = plot.style_linebr, \nplot(BigH_Line_Sell2, color= color.new(color.red,80), style = plot.style_linebr, \nplot(BigL_Line_Buy2, color= color.new(color.green,80), style = plot.style_linebr,\nplot(BigL_Line_Buy1, color= color.new(color.green,90), style = plot.style_linebr,\nplot(BigL_Line_Sell1, color= color.new(color.red,90), style = plot.style_linebr, \nplot(BigL_Line_Sell2, color= color.new(color.red,80), style = plot.style_linebr, \n// set trend\nvar trendline_trend = 0 \nif close > BigH_Line \n    trendline_trend := 1 \nelse if close < BigL_Line\n    trendline_trend := -1 \nelse \n    trendline_trend := 0\ntrendline_trend_color = trendline_trend > 0 ?  color.new(color.green,80) : trendline_trend\nbgcolor(trendline_trend_color ,  title = \"Plot Trendline Trend\")\n// set trigger \ntrendline_longTr = false\ntrendline_longExitTr = false \ntrendline_shortTr = false \ntrendline_shortExitTr = false \n// \nif trendline_trend == 0\n    if  ta.crossover(close, BigL_Line_Buy1) or ta.crossover(close, BigL_Line_Buy2)\n        trendline_longTr := true \n    if ta.crossunder(close, BigH_Line_Sell1) or ta.crossunder(close, BigH_Line_Sell2\n        trendline_shortTr := true \n    if ta.crossunder(close, lineTop)\n        trendline_longExitTr := true \n    if ta.crossover(close,lineBot)\n        trendline_shortExitTr := true \nif trendline_trend == -1 \n    if ta.crossover(close, BigL_Line) or ta.crossover(close, BigL_Line_Sell1) \n        trendline_longTr := true \n        trendline_shortExitTr := true \n    if close < BigL_Line_Sell2\n        trendline_longExitTr := true \nif trendline_trend == 1 \n    if ta.crossunder(close, BigH_Line) or ta.crossunder(close, BigH_Line_Buy1)\n        trendline_shortTr := true \n        trendline_longExitTr := true \n    if close > BigH_Line_Buy2\n        trendline_shortExitTr := true\n// Lets trade ----------------------------------------------------------------\ncheck_long_mode = input.bool(true, title = \"Long Mode On!\")\ncheck_short_mode = input.bool(false, title = \"Short Mode On!\")\nif trendline_longTr\n    if check_long_mode \n        strategy.entry(\"L\", strategy.long)\nelse if trendline_shortTr\n    if check_short_mode\n        strategy.entry(\"S\", strategy.short)    \nif trendline_longExitTr\n    strategy.close(\"L\")\nelse if trendline_shortExitTr\n    strategy.close(\"S\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Minor bug fixes"}, {"role": "assistant", "content": "//@version=5\nstrategy(\"EMA RSI Strategy\", overlay=true, default_qty_type=strategy.percent_of_equity\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Author       : AJ Rupasinghege\n// Date         : 06/11/2022\n// Release      : v8.0\n// Description  : If the last two closes are in ascending order, the rsi is below 50 and ascending, \n//                If the last two closes are in descending order, the rsi is above 50 and descending\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// INPUTS ////////////////////////////////////////////\nema_length = input(200, \"EMA Length\")\nrsi_buy_value = input(50, \"RSI Buy Value\")\nrsi_sell_value = input(50, \"RSI Sell Value\")\nshow_data = input.bool(0, \"Show Data\")\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// VARIABLES /////////////////////////////////////////\nvar stop_loss = 0.0\nvar last_trade_entry_price = 0.0\nvar low_value= 0.0\nvar atr = 0.0\nvar high_value = 0.0\nvar stop_loss_points = 0.0\nvar limit = 0.0\nvar bar_id_entry = 0\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// FUNCTIONS /////////////////////////////////////////\ngetTradeConditionsLong() =>\n    //@function         Used to calculate stop_loss, stop_loss points, limit and label values for long trades\n    //@param direction  (float) // strategy.poistion.size\n    //@returns          stop_loss, stop_loss_points, limit\n    //@Dependancies     low_value, atr, last_trade_entry_price,bar_id_entry\n    _stop_loss = low_value - atr\n    _stop_lossPoints = (last_trade_entry_price - _stop_loss) *100000\n    _limit = last_trade_entry_price + (last_trade_entry_price - low_value + atr) \n    value = \"OpenValue: \" + str.tostring(last_trade_entry_price) + \n         \"\\n OpenBarIndex: \" + str.tostring(bar_id_entry) + \n         \"\\n LowValue: \" + str.tostring(low_value) + \n         \"\\n atr: \" + str.tostring(atr) + \"\\n stop_loss: \" + \n         str.tostring(_stop_loss) + \"\\n Limit: \" +\n         str.tostring(_limit)\n    [_stop_loss,_stop_lossPoints,_limit, value]\ngetTradeConditionsShort() =>\n    //@function         Used to calculate stop_loss, stop_loss points, limit and label values for short trades\n    //@param direction  (float) // strategy.poistion.size\n    //@returns          stop_loss, stop_loss_points, limit\n    //@Dependancies     high_value, atr, last_trade_entry_price,bar_id_entry\n    _stop_loss = high_value + atr\n    _stop_lossPoints = (_stop_loss  -last_trade_entry_price) * 100000\n    _limit = last_trade_entry_price - (high_value - last_trade_entry_price + atr)\n    value = \"OpenValue: \" + str.tostring(last_trade_entry_price) + \n         \"\\n OpenBarIndex: \" + str.tostring(bar_id_entry) + \n         \"\\n HighValue: \" + str.tostring(high_value) + \n         \"\\n atr: \" + str.tostring(atr) + \"\\n stop_loss: \" + \n         str.tostring(_stop_loss)  + \"\\n Limit: \" +\n         str.tostring(_limit)\n    [_stop_loss,_stop_lossPoints,_limit, value]\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// SIGNALS ///////////////////////////////////////////\nema = ta.ema(close,ema_length)\nrsi = ta.rsi(close,14)\nema_buy_signal = ema < low\nema_sell_signal = ema > high\nrsi_buy_signal = rsi < rsi_buy_value and rsi[1] < rsi[0]\nrsi_sell_signal = rsi > rsi_sell_value and rsi[1] > rsi[0]\ntrend_buy_signal = close[2] < close[1] and close[1] < close[0]\ntrend_sell_signal = close[2] > close[1] and close[1] > close[0]\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// TRADES ////////////////////////////////////////////\nlong = trend_buy_signal \n         and ema_buy_signal \n         and rsi_buy_signal\nshort = trend_sell_signal \n         and ema_sell_signal  \n         and rsi_sell_signal\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// STRATEGY //////////////////////////////////////////\nif long \n    strategy.entry(\"Long\", strategy.long)\nif short \n    strategy.entry(\"Short\", strategy.short)\n   // Calculate Trade Entry Variables\nlast_trade_entry_price := strategy.opentrades.entry_price(strategy.opentrades - 1)\nbar_id_entry := strategy.opentrades.entry_bar_index(strategy.opentrades - 1) \natr := ta.atr(14) \nlow_value := ta.lowest(14)\nhigh_value := ta.highest(14)\n// Exit Strategy for Long Positions \nif (strategy.position_size[1] != strategy.position_size and strategy.position_size\n    [_stop_loss,_stop_loss_points, _limit, value] = getTradeConditionsLong()\n    stop_loss := _stop_loss\n    stop_loss_points := _stop_loss_points\n    limit := _limit\n        if show_data\n        label.new(bar_id_entry,stop_loss - 0.005,str.tostring(value),xloc = xloc.bar_index\n    strategy.exit(\"Long Exit\", \"Long\", trail_offset = stop_loss_points/2, trail_points\n// Exit Strategy for Short Positions \nif (strategy.position_size[1] != strategy.position_size and strategy.position_size\n    [_stop_loss,_stop_loss_points, _limit, value] = getTradeConditionsShort()\n    stop_loss := _stop_loss\n    stop_loss_points := _stop_loss_points\n    limit := _limit\n    if show_data\n        label.new(bar_id_entry,stop_loss + 0.005,str.tostring(value),xloc = xloc.bar_index\n    strategy.exit(\"Short Exit\", \"Short\", trail_offset = stop_loss_points/2, trail_points\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////// PLOTS /////////////////////////////////////////////\nplot(ema, \"EMA\", color =  color.blue, linewidth = 2 )\np1 = plot(strategy.position_size>0? stop_loss:na, style = plot.style_linebr , color\np2 = plot(strategy.position_size<0? stop_loss:na, style = plot.style_linebr , color\np3 = plot(strategy.position_size!=0?limit : na, style = plot.style_linebr , color \nfill(p1, p3, color =  color.new(color.green, 90))\nfill(p2, p3, color =  color.new(#e98787, 90))"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Add parameters: minPositionSize: Controls the minimum number of positions for a single transaction, if it is less than this number, skip this investment                                                    Release Notes:                                                    -------- version 1.2.2 changelog: add orderQty and closeOrderQty to data window for debug                                                    Release Notes:                                                    -------- version 1.2.3 changelog: add max drawdown histogram to all window"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \n// \u00a9 Stephan-Gao\n//@version=5\nstrategy(\"Linear EDCA v1.2.3\", overlay=true, default_qty_type = strategy.percent_of_equity\n  default_qty_value = 1, initial_capital = 10000, currency = currency.USD, commission_type\nstrategy.risk.allow_entry_in(strategy.direction.long)\n// \u5355\u4f4d\u5b9a\u6295\u6bd4\u7387\ndefInvestRatio = input.float(0.025, title = \"default invest ratio\", tooltip = \"The default fixed investment ratio, the strategy \n// \u6700\u5c0f\u5355\u7b14\u4e70\u5356\u5934\u5bf8\u6570\u91cf\nminPositionSize = input.float(0.001, title = \"min position size\", minval = 0)\n// \u5b9a\u4e70\u7684\u7ebf\u6027\u51fd\u6570\u659c\u7387\nbuySlope = input.float(-35, title = \"buy slope\", maxval = 0, tooltip = \"the slope of the linear function of the order to \n// \u5b9a\u5356\u7684\u7ebf\u6027\u51fd\u6570\u659c\u7387\nsellSlope = input.float(-0.7, title = \"sell slope\", maxval = 0, tooltip = \"the slope of the linear function of the order to \n// \u5b9a\u5356\u7684\u504f\u79fb\u5ea6\uff08\u5982\u679c\u662f\u6b63\u6570\uff0c\u5219\u5728\u5747\u7ebf\u4ee5\u4e0a\u4e00\u6bb5\u8ddd\u79bb\u8fd8\u4fdd\u6301\u4e70\u5165\uff1b\u5982\u679c\u662f\u8d1f\u6570\uff0c\u5219\u5728\u504f\u79bb\u5ea6\u4e3a0\u65f6\u5373\u5f00\u59cb\u5356\u51fa\u3002\u4e00\u822c\u5bf9\u4e8e\u725b\u5e02\u8f83\u957f\u7684\u5e02\u573a\uff0c\u4e00\u822c\u504f\u79fb\u4e3a\u6b63\u6570\uff09\nsellOffset = input.float(0.6, title = \"sell offset\", tooltip = \"The offset of the order to sell. If it is greater\n// \u6700\u5927\u5356\u51fa\u500d\u7387\uff08defInvestRatio * maxSellRate = \u6700\u5927\u5355\u6b21\u5356\u51fa\u4ed3\u4f4d\uff09\nmaxSellRate = input.float(5, title = \"max sell rate\", minval = 0, tooltip = \"Controls the maximum sell multiple. The maximum r\n// \u6700\u5927\u4e70\u5165\u500d\u7387\uff08defInvestRatio * maxBuyRate = \u6700\u5927\u5355\u6b21\u4e70\u5165\u4ed3\u4f4d\uff09\nmaxBuyRate = input.float(6, title = \"max buy rate\", minval = 0, tooltip = \"Controls the maximum buy multiple. The maximum ra\nmaPeriod = input(1100, \"MA Period\")\nsmoothing = input.string(defval=\"SMA\", options=[\"EMA\", \"SMA\"])\nuseDateFilter = input.bool(true, title=\"Filter Date Range of Backtest\", group = \"Backtest Date Range\"\nsettleOnEnd = input.bool(false, title=\"settle account on end\", group = \"Backtest Date Range\"\nstartDate = input.time(title=\"startDate\", defval=timestamp(\"2013-11-30T00:00+00:00\"\nendDate = input.time(title=\"endDate\", defval=timestamp(\"2022-09-16T00:00+00:00\"), \ninvestDayofweek = input.int(2, title = \"invest day of week\", tooltip = \"1 means Sunday, 2 means Monday, 7 means Saturday\"\nintervalDays = input.int(14, title=\"interval days\", group = \"Backtest Date Range\")\ninTradeWindow = not useDateFilter or (time >= startDate and time < endDate)\nvar int investBarIndex = 0\nisInvestDay() => timeframe.period == \"D\" and dayofweek == investDayofweek and bar_index\nma(smoothing, src, length) => \n    if smoothing == \"EMA\"\n        ta.ema(src, length)\n    else\n        if smoothing == \"SMA\"\n            ta.sma(src, length)\ncalInvestRate(deviation) => \n    float result = 0\n        if deviation >= 0\n        result := sellSlope * deviation + sellOffset\n        result := math.abs(result) > maxSellRate ? -maxSellRate : result\n    else\n        result := buySlope * deviation + 1\n        result := math.abs(result) > maxBuyRate ? maxBuyRate : result\n        result\n// \u5f53\u524d\u4ed3\u4f4d\u51c0\u503c\npositionValue() => strategy.position_size * close\n// \u5f53\u524d\u53ef\u52a8\u7528\u7684\u672c\u91d1\ncapitalValue() => strategy.equity - positionValue() > 0 ? strategy.equity - positionValue\n// \u76ee\u6807\u5355\u7b14\u6295\u8d44\u7684\u6570\u91cf\uff08order qty\uff09\norderQty(orderPercent) => \n    float resultQty = 0\n    targetOrderValue = strategy.equity * math.abs(orderPercent)\n    if capitalValue() <= 0\n        resultQty := 0\n    else if capitalValue() > 0 and capitalValue() > targetOrderValue\n        resultQty := targetOrderValue / close\n    else if capitalValue() <= targetOrderValue\n        resultQty := capitalValue() / close\n    resultQty := math.round_to_mintick(resultQty)\n    if resultQty > 0\n        resultQty := resultQty < minPositionSize ? 0 : resultQty\ncloseOrderQty(orderPercent) =>\n    float resultQty = 0\n    targetCloseValue = strategy.equity * math.abs(orderPercent)\n    if positionValue() <= 0\n        resultQty := 0\n    else if positionValue() > 0 and positionValue() > targetCloseValue\n        resultQty := targetCloseValue / close\n    else if positionValue() <= targetCloseValue\n        resultQty := positionValue() / close\n    resultQty := math.round_to_mintick(resultQty)\n    if resultQty > 0\n        resultQty := resultQty < minPositionSize ? 0 : resultQty\n//// Main ////\nmovingAverage = ma(smoothing, close, maPeriod)\nplot(movingAverage, \"MA\", linewidth = 2, color =  color.new(color.black, 0), display\ndeviation = (close - movingAverage) / movingAverage\ninvestRate = calInvestRate(deviation)\norderPercent = defInvestRatio * investRate\norderQty = orderQty(orderPercent)\nplot(orderQty, \"orderQty\", display = display.data_window)\ncloseOrderQty = closeOrderQty(orderPercent)\nplot(closeOrderQty, \"closeOrderQty\", display = display.data_window)\nif isInvestDay()\n    if investRate > 0\n        if orderQty > 0\n            orderPer = orderQty * close / strategy.equity\n            strategy.order(\"Buy\", strategy.long, qty = orderQty, comment = \"Buy \" \n            investBarIndex := bar_index\n    else\n        if closeOrderQty > 0\n            closeOrderPer = closeOrderQty * close / strategy.equity\n            strategy.close(\"Buy\", qty = closeOrderQty, comment = \"Sell \" + str.tostring\n            investBarIndex := bar_index\nif settleOnEnd and not inTradeWindow and inTradeWindow[1]\n    strategy.cancel_all()\n    strategy.close_all(comment=\"Date Range Exit\")\n// for debug\nror = 100 * (close - strategy.position_avg_price)/strategy.position_avg_price\nvar float maxLoss = 0\nif ror < 0 and maxLoss > ror\n    maxLoss := ror\nvar float maxGain = 0\nif ror > 0 and maxGain < ror\n    maxGain := ror\nplot(ror, \"positionReturn%\", color =  color.new(color.red, 0), style = plot.style_columns\nplot(maxLoss, \"positionMaxFloatLoss%\", color =  color.new(color.red, 0), style = \nplot(maxGain, \"positionMaxFloatGain%\", color =  color.new(color.green, 0), style \nplot(strategy.max_drawdown, \"max_drawdown\", color =  color.new(color.blue, 60), style\nplot(100 * deviation, \"deviation%\", display = display.data_window)\nplot(investRate, \"investRate\", display = display.data_window)\nplot(100*orderPercent, \"orderPercent%\", display = display.data_window)\nplot(100*positionValue()/strategy.equity, \"positionPercent%\", color =  color.new(\nplot(strategy.position_avg_price, \"positionAvgPrice\", linewidth = 1, color =  color.new\nplot(strategy.position_size, \"strategy.position_size\", display = display.data_window\nplot(strategy.equity, \"strategy.equity\", display = display.data_window)\nplot(strategy.openprofit, \"strategy.openprofit\", display = display.data_window)\nplot(strategy.netprofit, \"strategy.netProfit\", display = display.data_window)\nplot(positionValue(), \"positionValue()\", display = display.data_window)\nplot(capitalValue(), \"capitalValue()\", display = display.data_window)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Added the option to adjust the quantity of a trade based on a defined risk percentage. If enabled, it will overwrite the quantity parameter of the strategy settings.                                                    Release Notes:                                                    Adding custom alert messages that enable simple bot configurations. Supported list of variables wich will be replaced before triggering the alert:   #nl# => New line  #symbol# => The ticker e.g. EURUSD  #LongSL# => Long Stop loss, absolut price of stop loss (buy stop price - stop loss in ticks)  #LongTP1# => Long Take Profit 1, absolut price of take profit target at 50% of take profit (buy stop price + take profit in ticks * 0.5)  #LongTP2# => Long Take Profit 2, absolut price of take profit target at 100% of take profit (buy stop price + take profit in ticks)  #LongTPFULL# => Long Take Profit in FULL, same as #LongTP2#  #ShortSL# => Short Stop loss, absolut price of stop loss (sell stop price + stop loss in ticks)  #ShortTP1# => Short Take Profit 1, absolut price of take profit target at 50% of take profit (sell stop price - take profit in ticks * 0.5)  #ShortTP2# => Short Take Profit 2, absolut price of take profit target at 100% of take profit (sell stop price - take profit in ticks)  #ShortTPFULL# => Short Take Profit in FULL, same as #ShortTP2#  #TakeAmount1# => Percent to remove from trade on hitting TP1, eg. 1.0 (risk in percent * 0.5)  #TakeAmount2# => Percent to remove from trade on hitting TP2, eg. 2.0 (risk in percent)  #TakeAmountFULL# => Percent to remove from trade on hitting TP3, same as #TakeAmount2#  Please test the alerts carefully as I don't use them by my own! Leave a comment, in case you found a bug.                                                    Release Notes:                                                    Fixed a bug with too many pending orders created, when enabling the strategy feature \"on every tick\"."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Kaspricci\n//@version=5\nstrategy(\n     title = \"Trade Beta - The Only EURUSD Trading Strategy You Need - Kaspricci\",\n     shorttitle = \"The Only EURUSD Trading Strategy You Need - Kaspricci\", \n     overlay=true, \n     initial_capital = 1000, \n     currency = currency.USD, \n     default_qty_type = strategy.percent_of_equity, \n     default_qty_value = 100, \n     calc_on_every_tick = true, \n     close_entries_rule = \"ANY\")\nheadlineEntry   = \"Entry Seettings\"\ntooltipTF       = \"New York Stock Exchange opening hours from 13:30 - 20:00 GMT\"\nsession         = input.session(defval=\"1330-2000:23456\", title=\"Trading Time\", group\nsessionTime     = time(timeframe.period, session, \"GMT\")\n// swing high\nshSource        = input.source(defval = high, title = \"Swing High Source \", group \nshBars          = input.int(   defval = 5,    title = \"Bars \",              group \n// swing low\nslSource        = input.source(defval = low,  title = \"Swing Low Source  \", group \nslBars          = input.int(   defval = 5,    title = \"Bars \",              group \nheadlineTrade   = \"Trade Seettings\"\nstopLossType    = input.string(defval = \"ATR\", title = \"Stop Loss Type\", options =\natrLength       = input.int(defval = 14, title = \"   ATR: Length        \",   inline\natrFactor       = input.float(defval = 2.0, title = \"Factor        \", inline = \"ATR\"\ntakeProfitRatio = input.float(defval = 2.0, title = \"            TP Ration\", group\nfixStopLoss     = input.float(defval = 10.0, title = \"   FIX: Stop Loss    \",   inline\nfixTakeProfit   = input.float(defval = 20.0, title = \"Take Profit\", inline = \"FIX\"\nuseRiskMagmt    = input.bool(  title = \"\", defval = false, group = headlineTrade, \nriskPercent     = input.float( title = \"Risk in %       \", defval = 1.0, minval = \nstopLoss        = switch stopLossType\n    \"ATR\" => math.round(ta.atr(atrLength) * atrFactor / syminfo.mintick, 0)\n    \"FIX\" => fixStopLoss\ntakeProfit      = switch stopLossType\n    \"ATR\" => math.round(stopLoss * takeProfitRatio, 0)\n    \"FIX\" => fixTakeProfit\ninSession       = not na(sessionTime)\nvar float buyStopPrice  = na\nvar float sellStopPrice = na\nplot(inSession ? buyStopPrice  : na, title = \"Buy Stop Price\",  color =  color.green\nplot(inSession ? sellStopPrice : na, title = \"Sell Stop Price\", color =  color.red\nvar float swingHigh = na\nvar float swingLow  = na\nswingHigh := nz(ta.pivothigh(shSource, shBars, shBars), swingHigh[1])\nswingLow  := nz(ta.pivotlow( slSource, slBars, slBars), swingLow[1])\n///////////////////////////////////////////////////////////////////////////////\n// api bot values\nlongSL          = buyStopPrice - stopLoss * syminfo.mintick\nlongTP1         = buyStopPrice + takeProfit * syminfo.mintick * 0.5 // 50% of total take profit\nlongTP2         = buyStopPrice + takeProfit * syminfo.mintick // same as full\nlongTPFull      = buyStopPrice + takeProfit * syminfo.mintick\nshortSL         = sellStopPrice + stopLoss * syminfo.mintick\nshortTP1        = sellStopPrice - takeProfit * syminfo.mintick * 0.5 // 50% of total take profit\nshortTP2        = sellStopPrice - takeProfit * syminfo.mintick\nshortTPFull     = sellStopPrice - takeProfit * syminfo.mintick\ntakeAmount1     = riskPercent / 2\ntakeAmount2     = riskPercent\ntakeAmountFull  = riskPercent\nheadlineAlerts  = \"Alert Settings\"\ni_apiEnterLong  = input.text_area('Enter Long - 3commas,alerteron etc', 'API Entry - Long'\ni_apiExitLong   = input.text_area('Exit Long - 3commas,alerteron etc', 'API Exit - Long'\ni_apiEnterShort = input.text_area('Enter Short - 3commas,alerteron etc', 'API Entry - Short'\ni_apiExitShort  = input.text_area('Exit Short - 3commas,alerteron etc', 'API Exit - Short'\n// #nl# => New line\n// #side# => Buy or Sell (Long or Short)\n// #symbol# => The ticker e.g. BTCUSDT\nf_replaceKeys (_str) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#nl#\", \"\\n\")\n//    _value := str.replace_all(_value, \"#side#\", \"\\n\") // does not make sense to me...\n    _value := str.replace_all(_value, \"#symbol#\", syminfo.ticker)\n// #LongSL# => Long Stop loss\n// #LongTP1# => Long Take Profit 1\n// #LongTP2# => Long Take Profit 2\n// #LongTPFULL# => Long Take Profit in FULL\n// #TakeAmount1# => Percent to remove from trade on hitting TP1\n// #TakeAmount2# => Percent to remove from trade on hitting TP2\n// #TakeAmountFULL# => Percent to remove from trade on hitting TP3 (should be 100%)\nf_replaceLongTokens (_str, _sl, _tp1, _tp2, _tpFull, _ta1, _ta2, _taFull) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#LongSL#\", str.tostring(_sl))\n    _value := str.replace_all(_value, \"#LongTP1#\", str.tostring(_tp1))\n    _value := str.replace_all(_value, \"#LongTP2#\", str.tostring(_tp2))\n    _value := str.replace_all(_value, \"#LongTPFULL#\", str.tostring(_tpFull))\n    _value := str.replace_all(_value, \"#TakeAmount1#\", str.tostring(_ta1))\n    _value := str.replace_all(_value, \"#TakeAmount2#\", str.tostring(_ta2))\n    _value := str.replace_all(_value, \"#TakeAmountFULL#\", str.tostring(_taFull))\n// #ShortSL# => Short Stop loss\n// #ShortTP1# => Short Take Profit 1\n// #ShortTP2# => Short Take Profit 2\n// #ShortTPFULL# => Short Take Profit in FULL\n// #TakeAmount1# => Percent to remove from trade on hitting TP1\n// #TakeAmount2# => Percent to remove from trade on hitting TP2\n// #TakeAmountFULL# => Percent to remove from trade on hitting TP3 (should be 100%)\nf_replaceShortTokens (_str, _sl, _tp1, _tp2, _tpFull, _ta1, _ta2, _taFull) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#ShortSL#\", str.tostring(_sl))\n    _value := str.replace_all(_value, \"#ShortTP1#\", str.tostring(_tp1))\n    _value := str.replace_all(_value, \"#ShortTP2#\", str.tostring(_tp2))\n    _value := str.replace_all(_value, \"#ShortTPFULL#\", str.tostring(_tpFull))\n    _value := str.replace_all(_value, \"#TakeAmount1#\", str.tostring(_ta1))\n    _value := str.replace_all(_value, \"#TakeAmount2#\", str.tostring(_ta2))\n    _value := str.replace_all(_value, \"#TakeAmountFULL#\", str.tostring(_taFull))\ni_apiEnterLong  := f_replaceKeys (i_apiEnterLong)\ni_apiEnterLong  := f_replaceLongTokens (i_apiEnterLong, longSL, longTP1, longTP2, \ni_apiExitLong   := f_replaceKeys (i_apiExitLong)\ni_apiExitLong   := f_replaceLongTokens (i_apiExitLong, longSL, longTP1, longTP2, longTPFull\ni_apiEnterShort := f_replaceKeys (i_apiEnterShort)\ni_apiEnterShort := f_replaceShortTokens (i_apiEnterShort, shortSL, shortTP1, shortTP2\ni_apiExitShort  := f_replaceKeys (i_apiExitShort)\ni_apiExitShort  := f_replaceShortTokens (i_apiExitShort, shortSL, shortTP1, shortTP2\n// ----- handline trade entries and exits ----------------------------------------------------------\n// as soon as the session starts calculate stop prices based on recent swing high / low, create pend\nif barstate.isconfirmed and inSession and not inSession[1]\n    buyStopPrice  := swingHigh\n    sellStopPrice := swingLow\n    tradeID = str.tostring(strategy.closedtrades + strategy.opentrades + 1)\n    quantity = useRiskMagmt ? math.round(strategy.equity * riskPercent / stopLoss,\n    commentTemplate = \"{0} QTY: {1,number,#.##} SL: {2} TP: {3}\"\n    // price between recent swing high and low, a buy and sell stop order at swing high and low\n    if sellStopPrice < close and close < buyStopPrice\n        longComment = str.format(commentTemplate, tradeID + \"L\", quantity, stopLoss\n        strategy.entry(tradeID + \"L\", strategy.long, qty = quantity, stop = buyStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"L\", profit = takeProfit, loss = stopLoss\n        shortComment = str.format(commentTemplate, tradeID + \"S\", quantity, stopLoss\n        strategy.entry(tradeID + \"S\", strategy.short, qty = quantity, stop = sellStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"S\", profit = takeProfit, loss = stopLoss\n    // price above swing high, only one sell stop order at swingg high\n    if close > buyStopPrice\n        shortComment = str.format(commentTemplate, tradeID + \"S\", quantity, stopLoss\n        strategy.entry(tradeID + \"S\", strategy.short, qty = quantity, stop = buyStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"S\", profit = takeProfit, loss = stopLoss\n    // price below swing low, only one buy stop order at swing low\n    if close < sellStopPrice\n        longComment = str.format(commentTemplate, tradeID + \"L\", quantity, stopLoss\n        strategy.entry(tradeID + \"L\", strategy.long, qty = quantity, stop = sellStopPrice\n        strategy.exit(tradeID + \"SL\", tradeID + \"L\", profit = takeProfit, loss = stopLoss\n// once the session is gone, reset prices and cancel all remaining pending orders, close open orders\nif barstate.isconfirmed and not inSession\n    buyStopPrice := na\n    sellStopPrice := na\n    strategy.cancel_all()\n    currentTradeID = str.tostring(strategy.closedtrades + strategy.opentrades)\n    strategy.close(currentTradeID + \"L\", immediately = true, comment = \"L: session end\"\n    strategy.close(currentTradeID + \"S\", immediately = true, comment = \"S: session end\"\n// as soon as the first pending order has been entered the remaing pending order shall be cancelled \nif strategy.opentrades > 0\n    currentTradeID = str.tostring(strategy.closedtrades + strategy.opentrades)\n    strategy.cancel(currentTradeID + \"S\")\n    strategy.cancel(currentTradeID + \"L\")"}]}
{"messages": [{"role": "user", "content": "Big Whale Purchases and Sales - plots big whale transactions on your chart! People that hold more than 1% of a crypto currencies circulating supply are considered whales and have a huge influence on price, not just because they can move the market with their huge transactions, but also because other traders often track their wallets and follow their example. Taking a look at whale holdings, one can see why whale worship is so common in crypto: While Bitcoin has a relatively low whale concentration, many of the Top 100 Cryptocurrencies have whales control 60% or more of their circulating supply. Integrating IntoTheBlock data, this script plots the transactions of these whales and, in strategy mode, copy trades them. Features: Strategy Mode: Switches the script between an indicator and a strategy. Standard Deviations: The number of Standard Deviations that a transaction needs to surpass to be considered worth plotting. Setting this to 0 will show all whale transactions, higher settings will only show the biggest transactions. Blockchain: The Chain on which Whale activity is tracked."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Powerscooter\n//@version=5\nstrategy(\"Big Whale Purchases and Sales\", \"Big Whale Moves\", overlay=true, initial_capital\nUseStrategy = input.bool(false,\"Strategy Mode\", \"Use this box to switch between strategy and indic\n//Inputs\nStdDevs = input(2.0,\"Standard Deviations\", \"How many Standard Deviations need to be passed to\n//Chain ID\nSource = input.string(title=\"Blockchain\", defval=\"BTC\", options=[\"BTC\", \"ETH\", \"DOGE\"\n \"QNT\", \"BCH\", \"SAND\", \"MANA\", \"FXS\", \"AAVE\", \"CHZ\", \"HT\", \"LDO\", \"KCS\", \"AXS\", \"MKR\"\nSourceA = switch Source\n    \"BTC\"   => \"INTOTHEBLOCK:BTC_WHALESASSETS\"\n    \"ETH\"   => \"INTOTHEBLOCK:ETH_WHALESASSETS\"\n    \"DOGE\"  => \"INTOTHEBLOCK:DOGE_WHALESASSETS\"\n    \"ADA\"   => \"INTOTHEBLOCK:ADA_WHALESASSETS\"\n    \"MATIC\" => \"INTOTHEBLOCK:MATIC_WHALESASSETS\"\n    \"SHIB\"  => \"INTOTHEBLOCK:SHIB_WHALESASSETS\"\n    \"UNI\"   => \"INTOTHEBLOCK:UNI_WHALESASSETS\"\n    \"OKB\"   => \"INTOTHEBLOCK:OKB_WHALESASSETS\"\n    \"LEO\"   => \"INTOTHEBLOCK:LEO_WHALESASSETS\"\n    \"LINK\"  => \"INTOTHEBLOCK:LINK_WHALESASSETS\"\n    \"LTC\"   => \"INTOTHEBLOCK:LTC_WHALESASSETS\"\n    \"FTT\"   => \"INTOTHEBLOCK:FTT_WHALESASSETS\"\n    \"CRO\"   => \"INTOTHEBLOCK:CRO_WHALESASSETS\"\n    \"ALGO\"  => \"INTOTHEBLOCK:ALGO_WHALESASSETS\"\n    \"QNT\"   => \"INTOTHEBLOCK:QNT_WHALESASSETS\"\n    \"BCH\"   => \"INTOTHEBLOCK:BCH_WHALESASSETS\"\n    \"SAND\"  => \"INTOTHEBLOCK:SAND_WHALESASSETS\"\n    \"MANA\"  => \"INTOTHEBLOCK:MANA_WHALESASSETS\"\n    \"FXS\"   => \"INTOTHEBLOCK:FXS_WHALESASSETS\"\n    \"AAVE\"  => \"INTOTHEBLOCK:AAVE_WHALESASSETS\"\n    \"CHZ\"   => \"INTOTHEBLOCK:CHZ_WHALESASSETS\"\n    \"HT\"    => \"INTOTHEBLOCK:HT_WHALESASSETS\"\n    \"LDO\"   => \"INTOTHEBLOCK:LDO_WHALESASSETS\"\n    \"KCS\"   => \"INTOTHEBLOCK:KCS_WHALESASSETS\"\n    \"AXS\"   => \"INTOTHEBLOCK:AXS_WHALESASSETS\"\n    \"MKR\"   => \"INTOTHEBLOCK:MKR_WHALESASSETS\"\n    \"ZEC\"   => \"INTOTHEBLOCK:ZEC_WHALESASSETS\"\n    \"GRT\"   => \"INTOTHEBLOCK:GRT_WHALESASSETS\"\n    \"FTM\"   => \"INTOTHEBLOCK:FTM_WHALESASSETS\"\n    \"SNX\"   => \"INTOTHEBLOCK:SNX_WHALESASSETS\"\n    \"NEXO\"  => \"INTOTHEBLOCK:NEXO_WHALESASSETS\"\n    \"CRV\"   => \"INTOTHEBLOCK:CRV_WHALESASSETS\"\n    \"BIT\"   => \"INTOTHEBLOCK:BIT_WHALESASSETS\"\n    \"DASH\"  => \"INTOTHEBLOCK:DASH_WHALESASSETS\"\n    \"BAT\"   => \"INTOTHEBLOCK:BAT_WHALESASSETS\"\n    \"ENS\"   => \"INTOTHEBLOCK:ENS_WHALESASSETS\"\nAssets = request.security(SourceA, \"D\", close)\n//Define day to day change\nAssetMoves = ta.change(Assets,1)\n//Catch outliers\nvar float bot=0\nvar float top=0\nvar float mid=0\nif StdDevs != 0\n    [mid2,top2,bot2]=ta.bb(AssetMoves,21,StdDevs)\n    mid:=mid2\n    top:=top2\n    bot:=bot2\nelse\n    top:=0\n    bot:=0\n//Mark the corresponding Bars\nplotshape(AssetMoves>top and not UseStrategy,\"Purchase\",shape.triangleup, location.belowbar\nplotshape(AssetMoves<bot and not UseStrategy,\"Sale\",shape.triangledown, location.abovebar\n//Order Conditions\nLongCondition = AssetMoves>top and UseStrategy\nShortCondition = AssetMoves<bot and UseStrategy\n//Order Execution\nif LongCondition\n    strategy.entry(\"Long\", strategy.long)\nif ShortCondition\n    strategy.entry(\"Short\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "The relative strength index ( RSI ) is a momentum indicator used in technical analysis . RSI measures the speed and magnitude of a security's recent price changes to evaluate overvalued or undervalued conditions in the price of that security. The RSI is displayed as an oscillator (a line graph) on a scale of zero to 100. The RSI can do more than point to overbought and oversold securities. It can also indicate securities that may be primed for a trend reversal or corrective pullback in price. It can signal when to buy and sell. Traditionally, an RSI reading of 70 or above indicates an overbought situation. A reading of 30 or below indicates an oversold condition. A simple moving average ( SMA ) calculates the average of a selected range of prices, usually closing prices, by the number of periods in that range. The Strategy enters and closes the trade when the following conditions are met: LONG SMA100 is greater than SMA150 RSI is greater than 50 SHORT SMA100 is less than SMA150 RSI is less than 50 When a long position is opened, it remains open until the conditions for a short are met at which point the long position is closed and the short position is opened. Then, when the conditions for the long position are met, the short will be closed and a long will be opened. This strategy is back tested from 1 January 2022 to simulate how the strategy would work in a bear market. The strategy provides good returns. The strategy assumes each order is using 30% of the available coins to make the results more realistic and to simulate you only ran this strategy on 30% of your holdings. A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Coinrule\n//@version=5\nstrategy('RSI and SMA',\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=30,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2022, 1, 1, 0, 0)\nnotInTrade = strategy.position_size <= 0\n//==================================Buy Conditions============================================\n//RSI\nlength = input(14)\nrsi = ta.rsi(close, length)\n//SMA\nfastEMA = ta.sma(close, 100)\nslowEMA = ta.sma(close, 150)\nplot(fastEMA, color =  color.green)\nplot(slowEMA, color =  color.blue)\nbullish = ta.crossover(fastEMA, slowEMA) and rsi > 50\nbearish = ta.crossover(slowEMA, fastEMA) and rsi < 50\nstrategy.entry(\"Long\", strategy.long, when=bullish and timePeriod)\nstrategy.close(\"Exit\", when=bearish)\nstrategy.entry(\"Short\", strategy.short, when=bearish and timePeriod)\nstrategy.close(\"Exit\", when=bullish)"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Adding two features:  you can now select between two stop loss / take profit calculation methods. 1) fix values as before or 2) dynamic calculation based on Average True Range and multipliers for stop loss and take profit.  with dynamic stop loss your risk amount is changing too. I added an option to overwrite quantity and adjust it to meet a defined risk percent of equity (keep in mind that equity is changing with each closed trade. So also the total risk amount is changing.)                             Release Notes:                                                    Adding custom alert messages that align with davidd.tech strategies enabling simple bot configurations. Supported list of variables:  #nl# => New line  #symbol# => The ticker e.g. EURUSD  #LongSL# => Long Stop loss, absolut price of stop loss (buy stop price - stop loss in ticks)  #LongTP1# => Long Take Profit 1, absolut price of take profit target at 50% of take profit (buy stop price + take profit in ticks * 0.5)  #LongTP2# => Long Take Profit 2, absolut price of take profit target at 100% of take profit (buy stop price + take profit in ticks)  #LongTPFULL# => Long Take Profit in FULL, same as #LongTP2#  #ShortSL# => Short Stop loss, absolut price of stop loss (sell stop price + stop loss in ticks)  #ShortTP1# => Short Take Profit 1, absolut price of take profit target at 50% of take profit (sell stop price - take profit in ticks * 0.5)  #ShortTP2# => Short Take Profit 2, absolut price of take profit target at 100% of take profit (sell stop price - take profit in ticks)  #ShortTPFULL# => Short Take Profit in FULL, same as #ShortTP2#  #TakeAmount1# => Percent to remove from trade on hitting TP1, eg. 1.0 (risk in percent * 0.5)  #TakeAmount2# => Percent to remove from trade on hitting TP2, eg. 2.0 (risk in percent)  #TakeAmountFULL# => Percent to remove from trade on hitting TP3, same as #TakeAmount2#  Please test the alerts carefully as I don't use them by my own! Leave a comment, in case you found a bug.                                                    Release Notes:                                                    Fixed a bug with too many pending orders created, when enabling the strategy feature \"on every tick\".                                                    Release Notes:                                                    I made several changes to the script.  You can now define the time druing which the high and low are determined. Before it took always the first high and low of the first candle of the trading session. This way now you can use the script also on lower timeframes (<= 1h).   You can now disable the cancellation of the second pending offer.   Wehn enabling the risk based quantity calculation you can choose whether your risk amount is based on intitial capital (always the same) or on current balance (takes net profit of closed trades into account)  You can now disable the lot size based calculation of quantity, when risk based percentage is enabled.  I fixed a wrong quantity calculation, when using the script for non forex symbols."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Kaspricci\n//@version=5\nstrategy(\"50 Pips A Day Strategy - Kaspricci\", overlay=true, initial_capital = 1000\nheadlineEntry   = \"Entry Seettings\"\ntooltipTF       = \"Combined timeframe of London and New York Stock Exchange opening hours from 7:00 - 15:30 GMT and 13\nopeningSession  = input.session(defval=\"0700-0800:23456\", title=\"Opening Time\", group\nopeningTime     = time(timeframe.period, openingSession, \"GMT\")\ntradingSession  = input.session(defval=\"0800-2000:23456\", title=\"Trading Time\", group\ntradingTime     = time(timeframe.period, tradingSession, \"GMT\")\nbuyStopSource   = input.source( defval = high, title = \"Source for Buy Stop order\"\nbuyStopGap      = input.float(  defval = 2.0, minval = 0, step = 0.1, title = \" + Pips:\"\nsellStopSource  = input.source( defval = low, title = \"Source for Sell Stop order\"\nsellStopGap     = input.float(  defval = 2.0, minval = 0, step = 0.1, title = \" - Pips:\"\nclosePending    = input.bool(   defval = true, group = headlineEntry, title = \"Cancel pending order when new trade entered?\"\nheadlineTrade   = \"Trade Seettings\"\nstopLossType    = input.string(defval = \"FIX\", title = \"Stop Loss Type\", options =\natrLength       = input.int(defval = 14, title = \"   ATR: Length        \",   inline\natrFactor       = input.float(defval = 2.0, title = \"Factor        \", inline = \"ATR\"\ntakeProfitRatio = input.float(defval = 2.0, title = \"            TP Ration\", group\nfixStopLoss     = input.float(defval = 15.0, title = \"   FIX: Stop Loss    \",   inline\nfixTakeProfit   = input.float(defval = 50.0, title = \"Take Profit\", inline = \"FIX\"\nuseRiskMagmt    = input.bool(  title = \"\", defval = false, group = headlineTrade, \nriskPercent     = input.float( title = \"Risk in %       \", defval = 1.0, minval = \nrsikCapital     = input.string(defval = \"Balance\",                     group = headlineTrade\napplyLotSizing  = input.bool(defval = true, title = \"Apply Lot sizing\", tooltip = \nstopLoss        = switch stopLossType\n    \"ATR\" => math.round(ta.atr(atrLength) * atrFactor / syminfo.mintick, 0)\n    \"FIX\" => fixStopLoss\ntakeProfit      = switch stopLossType\n    \"ATR\" => math.round(stopLoss * takeProfitRatio, 0)\n    \"FIX\" => fixTakeProfit\n// calculate quantity\nbaseCapital = switch rsikCapital\n    \"Balance\" => strategy.initial_capital + strategy.netprofit\n    \"Initial\" => strategy.initial_capital\nriskAmount      = strategy.convert_to_symbol(baseCapital * riskPercent)\ntickValue       = syminfo.pointvalue * syminfo.mintick\nriskBasedQty    = riskAmount / stopLoss / tickValue\nriskBasedQty    := applyLotSizing ? math.round(riskBasedQty / 100000, 2) * 100000 \nquantity        = useRiskMagmt ? riskBasedQty : na // if NaN the default from strategy settings will \ninTradingTime   = not na(tradingTime)\ninOpeningTime   = not na(openingTime)\nvar float buyStopPrice  = na\nvar float sellStopPrice = na\nplot(inTradingTime ? buyStopPrice  : na, title = \"Buy Stop Price\",  color =  color.green\nplot(inTradingTime ? sellStopPrice : na, title = \"Sell Stop Price\", color =  color.red\n///////////////////////////////////////////////////////////////////////////////\n// api bot values\nlongSL          = buyStopPrice - stopLoss * syminfo.mintick\nlongTP1         = buyStopPrice + takeProfit * syminfo.mintick * 0.5 // 50% of total take profit\nlongTP2         = buyStopPrice + takeProfit * syminfo.mintick // same as full\nlongTPFull      = buyStopPrice + takeProfit * syminfo.mintick\nshortSL         = sellStopPrice + stopLoss * syminfo.mintick\nshortTP1        = sellStopPrice - takeProfit * syminfo.mintick * 0.5 // 50% of total take profit\nshortTP2        = sellStopPrice - takeProfit * syminfo.mintick\nshortTPFull     = sellStopPrice - takeProfit * syminfo.mintick\ntakeAmount1     = riskPercent / 2\ntakeAmount2     = riskPercent\ntakeAmountFull  = riskPercent\nheadlineAlerts  = \"Alert Settings\"\ni_apiEnterLong  = input.text_area('Enter Long - 3commas,alerteron etc', 'API Entry - Long'\ni_apiExitLong   = input.text_area('Exit Long - 3commas,alerteron etc', 'API Exit - Long'\ni_apiEnterShort = input.text_area('Enter Short - 3commas,alerteron etc', 'API Entry - Short'\ni_apiExitShort  = input.text_area('Exit Short - 3commas,alerteron etc', 'API Exit - Short'\n// #nl# => New line\n// #side# => Buy or Sell (Long or Short)\n// #symbol# => The ticker e.g. BTCUSDT\nf_replaceKeys (_str) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#nl#\", \"\\n\")\n//    _value := str.replace_all(_value, \"#side#\", \"\\n\") // does not make sense to me...\n    _value := str.replace_all(_value, \"#symbol#\", syminfo.ticker)\n// #LongSL# => Long Stop loss\n// #LongTP1# => Long Take Profit 1\n// #LongTP2# => Long Take Profit 2\n// #LongTPFULL# => Long Take Profit in FULL\n// #TakeAmount1# => Percent to remove from trade on hitting TP1\n// #TakeAmount2# => Percent to remove from trade on hitting TP2\n// #TakeAmountFULL# => Percent to remove from trade on hitting TP3 (should be 100%)\nf_replaceLongTokens (_str, _sl, _tp1, _tp2, _tpFull, _ta1, _ta2, _taFull) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#LongSL#\", str.tostring(_sl))\n    _value := str.replace_all(_value, \"#LongTP1#\", str.tostring(_tp1))\n    _value := str.replace_all(_value, \"#LongTP2#\", str.tostring(_tp2))\n    _value := str.replace_all(_value, \"#LongTPFULL#\", str.tostring(_tpFull))\n    _value := str.replace_all(_value, \"#TakeAmount1#\", str.tostring(_ta1))\n    _value := str.replace_all(_value, \"#TakeAmount2#\", str.tostring(_ta2))\n    _value := str.replace_all(_value, \"#TakeAmountFULL#\", str.tostring(_taFull))\n// #ShortSL# => Short Stop loss\n// #ShortTP1# => Short Take Profit 1\n// #ShortTP2# => Short Take Profit 2\n// #ShortTPFULL# => Short Take Profit in FULL\n// #TakeAmount1# => Percent to remove from trade on hitting TP1\n// #TakeAmount2# => Percent to remove from trade on hitting TP2\n// #TakeAmountFULL# => Percent to remove from trade on hitting TP3 (should be 100%)\nf_replaceShortTokens (_str, _sl, _tp1, _tp2, _tpFull, _ta1, _ta2, _taFull) =>\n    _value = _str\n    _value := str.replace_all(_value, \"#ShortSL#\", str.tostring(_sl))\n    _value := str.replace_all(_value, \"#ShortTP1#\", str.tostring(_tp1))\n    _value := str.replace_all(_value, \"#ShortTP2#\", str.tostring(_tp2))\n    _value := str.replace_all(_value, \"#ShortTPFULL#\", str.tostring(_tpFull))\n    _value := str.replace_all(_value, \"#TakeAmount1#\", str.tostring(_ta1))\n    _value := str.replace_all(_value, \"#TakeAmount2#\", str.tostring(_ta2))\n    _value := str.replace_all(_value, \"#TakeAmountFULL#\", str.tostring(_taFull))\ni_apiEnterLong  := f_replaceKeys (i_apiEnterLong)\ni_apiEnterLong  := f_replaceLongTokens (i_apiEnterLong, longSL, longTP1, longTP2, \ni_apiExitLong   := f_replaceKeys (i_apiExitLong)\ni_apiExitLong   := f_replaceLongTokens (i_apiExitLong, longSL, longTP1, longTP2, longTPFull\ni_apiEnterShort := f_replaceKeys (i_apiEnterShort)\ni_apiEnterShort := f_replaceShortTokens (i_apiEnterShort, shortSL, shortTP1, shortTP2\ni_apiExitShort  := f_replaceKeys (i_apiExitShort)\ni_apiExitShort  := f_replaceShortTokens (i_apiExitShort, shortSL, shortTP1, shortTP2\n// ----- handline trade entries and exits ----------------------------------------------------------\nvar float openingHigh = na\nvar float openingLow  = na\n// determine high and low druing opening session\nif barstate.isconfirmed and inOpeningTime\n    openingHigh     := math.max(buyStopSource,  nz(openingHigh[1], buyStopSource))\n    openingLow      := math.min(sellStopSource, nz(openingLow[1],  sellStopSource)\n    buyStopPrice  := openingHigh + buyStopGap * 10 * syminfo.mintick\n    sellStopPrice := openingLow - sellStopGap * 10 * syminfo.mintick\n// as soon as the trading session starts calculate stop prices based on high / low of first closing \nif barstate.isconfirmed and inTradingTime and not inTradingTime[1]\n    tradeID = str.tostring(strategy.closedtrades + strategy.opentrades + 1)\n    strategy.entry(tradeID + \"L\", strategy.long, qty = quantity, stop = buyStopPrice\n    strategy.exit(tradeID + \"SL\", tradeID + \"L\", profit = takeProfit, loss = stopLoss\n    strategy.entry(tradeID + \"S\", strategy.short, qty = quantity, stop = sellStopPrice\n    strategy.exit(tradeID + \"SL\", tradeID + \"S\", profit = takeProfit, loss = stopLoss\n// once the session is gone, reset prices and cancel all remaining pending orders, close open orders\nif barstate.isconfirmed and not inTradingTime and inTradingTime[1]\n    buyStopPrice    := na\n    sellStopPrice   := na\n    openingHigh     := na\n    openingLow      := na\n    strategy.cancel_all()\n    currentTradeID = str.tostring(strategy.closedtrades + strategy.opentrades)\n    strategy.close(currentTradeID + \"L\", immediately = true, comment = \"L: session end\"\n    strategy.close(currentTradeID + \"S\", immediately = true, comment = \"S: session end\"\n// as soon as the first pending order has been entered the remaing pending order shall be cancelled \nif strategy.opentrades > 0 and closePending\n    currentTradeID = str.tostring(strategy.closedtrades + strategy.opentrades)\n    strategy.cancel(currentTradeID + \"L\")\n    strategy.cancel(currentTradeID + \"S\")"}]}
{"messages": [{"role": "user", "content": "This script is based on an idea of monthly statistics that have been found across tradingview community scripts. This is an improved version with weekly results with the ability to define the size of every group (number of weeks within one group). Initial setup of the strategy 1. Set the period to calculate the results between. 2. Set the statistic precision and group size. 3. Enable \"Recalculate\" \u2192 \"On every tick\" under the strategy \"Properties\" section. The logic under the hood 1. Get the period between which to calculate the strategy. 2. Calculate the first day of the first week within the period. 3. Calculate the latest day of the latest week within the period. 4. Calculate the results of the selected period. 5. Group the values by the defined number of cells. 6. Calculate the summary of every group. 7. Render the table. Please, be careful. To use this tool you will need to enable the \"Recalculate\" \u2192 \"On every tick\" option but it means that your strategy will be executed on every tick instead of bar close. It can cause unexpected results in your strategy behaviour."}, {"role": "assistant", "content": "//@version=5\nstrategy('Strategy weekly results as numbers v1', overlay=true, default_qty_type=strategy.percent_of_equity\nafter = input.time(title='Trade after', defval=timestamp('01 Jan 2019 00:00 UTC'),\nbefore = input.time(title='Trade before', defval=timestamp('31 Dec 2024 23:59 UTC'\nstatisticPrecision = input.int(title='Statistic precision', group='Statistic visualisation'\nstatisticGroupSize = input.int(title='Statistic group size', group='Statistic visualisation'\n// determinet whether the starategy should be traded between the period\nisTradeEnabled = time >= after and time < before\n// *******************************************************************************************\n// Core strategy simulation logic\n// *******************************************************************************************\n// calculate rsi strategy emulation data\nrsiEmulationData = ta.rsi(close, 7)\nrsiEmulationCrossover = ta.crossover(rsiEmulationData, 70)\nrsiEmulationCrossunder = ta.crossunder(rsiEmulationData, 30)\n// entry loogic based on the rsi calculations\nif (isTradeEnabled and rsiEmulationCrossover)\n    strategy.entry('Long', strategy.long)\nif (isTradeEnabled and rsiEmulationCrossunder)\n    strategy.entry('Short', strategy.short)\n// *******************************************************************************************\n// Weekly statistics table\n// *******************************************************************************************\n// define statistic variables\nvar statisticTable = table(na)\nvar statisticPeriodTime = array.new_int(0)\nvar statisticPeriodResult = array.new_float(0)\nvar statisticIsLatestCalculated = bool(na)\nvar statisticResultHighest = float(na)\nvar statisticResultLowest = float(na)\nvar statisticColorGray = color.new( color.gray, transp = 60)\nvar statisticColorGreen = color.new( color.green, transp = 60)\nvar statisticColorRed = color.new( color.red, transp = 60)\n// claculate current period result\nbarResult = not na(strategy.equity[1])\n             ? (strategy.equity / strategy.equity[1] - 1) : 0\nisPeriodChanged = not na(time[1]) and weekofyear(time) != weekofyear(time[1])\ncurrentPeriodResult = 0.0\ncurrentPeriodResult := not na(currentPeriodResult[1]) and not isPeriodChanged\n                       ? ((1 + currentPeriodResult[1]) * (1 + barResult) - 1) : 0.0\n// initialise highest and lowest results variables\nstatisticResultHighest := na(statisticResultHighest) ? currentPeriodResult : statisticResultHighest\nstatisticResultLowest := na(statisticResultLowest) ? currentPeriodResult : statisticResultLowest\n// search for highest and lowest results\nstatisticResultHighest := currentPeriodResult > statisticResultHighest ? currentPeriodResult\nstatisticResultLowest := currentPeriodResult < statisticResultLowest ? currentPeriodResult\n// new week while trade is active\nif isPeriodChanged and isTradeEnabled\n    timeCalculated = time - 1000 * 60 * 60 * 24 * 7\n    resultCalculated = currentPeriodResult[1]\n    statisticIsLatestCalculated := false\n    array.push(statisticPeriodTime, timeCalculated)\n    array.push(statisticPeriodResult, resultCalculated)\n// latest bar while trade is active\nif barstate.islast and isTradeEnabled\n    timeCalculated = time - 1000 * 60 * 60 * 24 * (dayofweek(time) - 2)\n    resultCalculated = currentPeriodResult\n    array.push(statisticPeriodTime, timeCalculated)\n    array.push(statisticPeriodResult, resultCalculated)\n// new week after trade disabled\nif isPeriodChanged and not isTradeEnabled and not na(statisticIsLatestCalculated) \n    timeCalculated = time - 1000 * 60 * 60 * 24 * (dayofweek(time) + 5)\n    resultCalculated = currentPeriodResult[1]\n    statisticIsLatestCalculated := true\n    array.push(statisticPeriodTime, timeCalculated)\n    array.push(statisticPeriodResult, resultCalculated)\n// render statistics table\nif barstate.islast\n    statisticLength = array.size(statisticPeriodResult)\n    statisticTableSteps = math.floor(statisticLength / statisticGroupSize) + (statisticLength\n    statisticTable := table.new(position.bottom_right, columns = statisticGroupSize\n    // render headers\n    for i = 0 to (statisticGroupSize - 1)\n        statisticHeaderContent = str.tostring(i + 1)\n        table.cell(statisticTable, 1 + i, 0, statisticHeaderContent, bgcolor = statisticColorGray\n    // render time points\n    for i = 0 to (statisticTableSteps - 1)\n        statisticPointContent = str.format(\"{0,date,medium}\", array.get(statisticPeriodTime\n        table.cell(statisticTable, 0, 1 + i, statisticPointContent, bgcolor = statisticColorGray\n    // render the result\n    statisticResultCummulative = 0.0\n    for i = 0 to (array.size(statisticPeriodTime) - 1)\n        statisticColumn = 1 + i % statisticGroupSize\n        statisticRow = 1 + math.floor(i / statisticGroupSize)\n        statisticResult = array.get(statisticPeriodResult, i)\n        statisticResultCummulative := (i % statisticGroupSize == 0) ? 0.0 : statisticResultCummulative\n        statisticResultCummulative := (1 + statisticResultCummulative) * (1 + statisticResult\n        statisticResultColor = statisticResult > 0 ? statisticColorGreen : statisticColorRed\n        table.cell(statisticTable, statisticColumn, statisticRow, str.tostring(math.round\n        // if it is the last item of the row or data array\n        isStatisticLastOfTheRow = ((i + 1) % statisticGroupSize) == 0\n        isStatisticLastOfTheData = i == (statisticLength - 1)\n        if (isStatisticLastOfTheRow or isStatisticLastOfTheData)\n            resultsTableCummulativeCellColor = statisticResultCummulative > 0 ? statisticColorGreen\n            resultsTableCummulativeCellContent = str.tostring(math.round(statisticResultCummulative\n            table.cell(statisticTable, 1 + statisticGroupSize, statisticRow, resultsTableCummulativeCellContent"}]}
{"messages": [{"role": "user", "content": "About this Strategy This supertrend strategy uses the Heikin Ashi candles to generate the supertrend but enters and exits trades using normal candle close prices. If you use the standard built in Supertrend indicator on Heikin Ashi candles, it will produce very unrealistic backtesting results because it uses the Heikin Ashi prices instead of the real prices. However, by signaling the supertrend reversals using Heikin Ashi while using standard candle close prices for the entries and exits, it corrects the backtesting errors and gives you a more realistic equity curve. You should set the chart to use standard candles and then hide them (the strategy creates the candles).  This strategy includes: Plotting of Heikin Ashi candles Heikin Ashi Supertrend Long and Short Entry Signals Move stop loss after trade is X% in profit Profit Target Stop Loss Built in Alertatron automation  Alertatron Trade Automation Integration For Alertatron integration, be sure to configure the strategy settings and \"Enable Webhook Messages\" before creating an alert with {{strategy.order.alert_message}} in the body of your alert message. Be sure to enable webhooks and point it to your Incoming Alertatron webhook URL. Notes While this strategy does pretty well during trending markets, It's worth noting that the Buy and Hold ROI is much better during peak times of the bull market Not financial advice. Do not risk more than you can afford to lose."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 jordanfray\n//@version=5\n//  About This Indicator\n//  The default settings for this indicator are for BTC/USDT and intended to be used on the 3D timef\n//  This indicator does a great job identifying whether the market is bullish, bearish, or consolida\n//  This can also work well on lower time frames to help identify when a trend is strong or when it'\nstrategy(\"Heikin Ashi Supertrend\", overlay=true, max_bars_back=5000, default_qty_type\nimport jordanfray/threengine_global_automation_library/89 as bot\nimport jordanfray/obvFilter/2 as obv\n//  Colors - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\ngreen                               =  color.new(#2DBD85,0)\nlightGreen                          =  color.new(#2DBD85,90)\nred                                 =  color.new(#E02A4A,0)\nlightRed                            =  color.new(#E02A4A,90)\nyellow                              =  color.new(#FFED00,0)\nlightYellow                         =  color.new(#FFED00,90)\npurple                              =  color.new(#5A00FF,0)\nblue                                =  color.new(#0C6090,0)\noceanBlue                           =  color.new(#0C6090,0)\nskyBlue                             =  color.new(#00A5FF,0)\nlightBlue                           =  color.new(#00A5FF,80)\nblack                               =  color.new(#000000,0)\ngray                                =  color.new(#AAAAAA,0)\nwhite                               =  color.new(#ffffff,0)\ntransparent                         =  color.new(#000000,100)\n//  Tooltips\nalertatronSecretTip                 = \"The key that is configured in Alertatron that sel\nexchangeTooltip                     = \"Pick the exchange that your Alertatron API Secret\nexchangeCurrencyOverrideTip         = \"If you want to use a different base currency than\nexchangeCurrencySymbolTip           = \"If you want to use a different symbol than the cu\nmoveStopToolTip                     = \"If enabled, the stop loss will be moved to a pric\n//  Strategy Settings - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nstrategyIdentifier                  = input.string(defval=\"HASTXXXUSDT (Nm)\", title\nsupertrendAtrPeriod                 = input.int(defval = 10, step = 1, title = \"ATR Length\"\nsupertrendAtrMultiplier             = input.float(defval = 2.7, step = 0.1, title \nlotSize                             = input.float(defval=100, title=\"Lot Size\", group\nlotSizeType                         = input.string(defval=\"Dollars\", title=\"Lot Size Type\"\n profitTargetPercent                 = input.float(defval = 47.0, title = \"Profit Target (%)\"\nstopLimitTrigger                    = input.float(defval=21, title=\"Stop Limit Trigger (%)\"\nstopLimitOffset                     = input.float(defval=0.10, title=\"Stop Limit Offset (%)\"\nenableMoveStopToBreakEven           = input.bool(defval=true, title=\"Move Stop Loss\"\nmoveTo                              = input.float(defval=1.0, title=\"to (%)\", tooltip\nmoveAfter                           = input.float(defval=4.0, title=\"after (%)\", tooltip\nmanuallyCloseTrade                  = input.bool(defval=false, title=\"Manullay Close Trade?\"\ndateTimeClosed                      = input.time(defval=timestamp(\"01 Jan 2022 00:00\"\npriceClosed                         = input.price(defval=0.0, title=\"Price Trade Was Closed At\"\n//  Trade Automation\nenableWebhookMessages               = input.bool(defval=false, title=\"Enable Webook Messages\"\ntradeAutomationExchange             = input.string(defval=\"ByBit\", options=[\"ByBit\"\ntradeAutomationSecret               = input.string(defval=\"haStEthUsdt\", title=\"Alertatron API Secret\"\ntradeAutomationLeverage             = input.int(defval=1, title=\"Leverage Amount\",\ntradeAutomationLeverageType         = input.string(defval=\"Cross\", title=\"Leverage Type\"\ntradeAutomationCurrencyOverride     = input.string(defval=\"\", title=\"Currency Override\"\ntradeAutomationSymbolOverride       = input.string(defval=\"\", title=\"Symbol Override\"\nexchangeQtyDecimals                 = input.int(defval=3, title=\"Order QTY Decimal Rounding\"\nshowDebugTable                      = input.bool(defval=false, title=\"Show Debug Table\"\n//  Position States\ncurrentlyInLongPosition = strategy.position_size > 0\ncurrentlyInShortPosition = strategy.position_size < 0\ncurrentlyInAPosition = strategy.position_size != 0\n//  Heikin Ashi Candles\nhaOpen = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, open\nhaHigh = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, high\nhaLow = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, low\nhaClose = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, \nplotcandle(haOpen < haClose ? haOpen : na, haHigh, haLow, haClose, title='Green Candles'\nplotcandle(haOpen >= haClose ? haOpen : na, haHigh, haLow, haClose, title='Red Candles'\nplot(display=display.status_line, series=haOpen, color=green)\nplot(display=display.status_line, series=haHigh, color=green)\nplot(display=display.status_line, series=haLow, color=red)\nplot(display=display.status_line, series=haClose, color=red)\n//  HA Supertrend\nhaTrueRange = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period\nhaSupertrendUp = ((haHigh + haLow) / 2) - (supertrendAtrMultiplier * haTrueRange)\nhaSupertrendDown = ((haHigh + haLow) / 2) + (supertrendAtrMultiplier * haTrueRange\nfloat trendingUp = na\nfloat trendingDown = na\ndirection = 0\ntrendingUp := haClose[1] > trendingUp[1] ? math.max(haSupertrendUp,trendingUp[1]) \ntrendingDown := haClose[1] < trendingDown[1] ? math.min(haSupertrendDown,trendingDown\ndirection := haClose > trendingDown[1] ? 1: haClose < trendingUp[1]? -1: nz(direction\nsupertrend = direction == 1 ? trendingUp : trendingDown\nsupertrendUp = ta.change(direction) < 0\nsupertrendDown = ta.change(direction) > 0\n//  Average Entry Price\nfloat averageEntryPrice = currentlyInAPosition ? strategy.position_avg_price : close\njustClosedPosition = ta.change(averageEntryPrice)\nbarsSinceOpen = currentlyInAPosition ? (bar_index - strategy.opentrades.entry_bar_index\n//  Profit and Loss\nprofitAndLoss = strategy.opentrades.profit(0)\nprofitAndLossPercent = math.round(((close - averageEntryPrice) / averageEntryPrice\n//  Profit Target\nprofitTarget = currentlyInLongPosition ? averageEntryPrice + (averageEntryPrice * \n//  Stop Loss Criteria\nfloat stopLossLimitPrice        = currentlyInLongPosition ? math.round(averageEntryPrice\nfloat stopLossTriggerPrice      = currentlyInLongPosition ? math.round(stopLossLimitPrice\n//  Move Stop Loss\nfloat moveStopLossAfter = currentlyInLongPosition ? math.round(averageEntryPrice +\nvar bool moveStopTriggered = false\nmoveStopLossTo = currentlyInLongPosition ? math.round(averageEntryPrice + (averageEntryPrice\nif currentlyInLongPosition and high > moveStopLossAfter and enableMoveStopToBreakEven\n    moveStopTriggered := true\nif currentlyInShortPosition and low < moveStopLossAfter and enableMoveStopToBreakEven\n    moveStopTriggered := true\n    if enableMoveStopToBreakEven and moveStopTriggered\n    stopLossLimitPrice := moveStopLossTo\n    stopLossTriggerPrice := currentlyInLongPosition ? math.round(stopLossLimitPrice\nif not currentlyInAPosition or justClosedPosition\n    moveStopTriggered := false\n//  Entry/Exit Criteria\nbool openLong = supertrendDown\nbool openShort = supertrendUp\nbool exitLong = currentlyInLongPosition and close > profitTarget\nbool exitShort = currentlyInShortPosition and close < profitTarget\nbool longStopLoss = currentlyInLongPosition and close < stopLossTriggerPrice and barsSinceOpen\nbool shortStopLoss = currentlyInShortPosition and close > stopLossTriggerPrice and\nbool manuallyCloseShort = currentlyInShortPosition and manuallyCloseTrade and time\nbool manuallyCloseLong = currentlyInLongPosition and manuallyCloseTrade and time ==\n//  Alertatron Webhook Messages - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n[symbol,baseCurrency] = bot.getPairOverrides(tradeAutomationSymbolOverride,tradeAutomationCurrencyOverride\n[contractCount,entryAmount] = bot.getLotSize(lotSizeType, lotSize, tradeAutomationLeverage\nstring enterLongAlertMessage    = enableWebhookMessages ? bot.getAlertatronMarketEntryMessage\nstring enterShortAlertMessage   = enableWebhookMessages ? bot.getAlertatronMarketEntryMessage\nstring exitLongAlertMessage     = enableWebhookMessages ? bot.getAlertatronMarketExitMessage\nstring exitShortAlertMessage    = enableWebhookMessages ? bot.getAlertatronMarketExitMessage\n//  Long Entries/Exits - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nif openLong\n    strategy.entry(id=\"Long\", direction=strategy.long, qty=contractCount, alert_message\nif exitLong\n    strategy.close(id=\"Long\", qty_percent=100, comment=\"Exit Long\", alert_message=\nif longStopLoss\n    strategy.exit(id=moveStopTriggered ? \"Moved Stop\" : \"Stop Loss\", from_entry=\"Long\"\nif manuallyCloseLong\n    strategy.exit(id=\"Manually Close Long\", from_entry=\"Long\", qty_percent=100, stop\n//  Short Entries/Exits - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nif openShort\n    strategy.entry(id=\"Short\", direction=strategy.short, qty=contractCount, alert_message\nif exitShort\n    strategy.close(id=\"Short\", qty_percent=100, comment=\"Exit Short\", alert_message\nif shortStopLoss\n    strategy.exit(id=moveStopTriggered ? \"Moved Stop\" : \"Stop Loss\", from_entry=\"Short\"\nif manuallyCloseShort\n    strategy.exit(id=\"Manually Close Short\", from_entry=\"Short\", qty_percent=100, \n//  Plots, Lines, and Labels\nbodyMiddle = plot((haOpen + haClose) / 2, display=display.none)\ndownTrend = plot(direction < 0 ? supertrend : na, \"Down Trend\", color = red, style\nupTrend = plot(direction < 0? na : supertrend, \"Up Trend\", color = green, style=plot.style_linebr\nfill(bodyMiddle, upTrend, lightGreen, fillgaps=false)\nfill(bodyMiddle, downTrend, lightRed, fillgaps=false)\ncolor stopLossColor = red\ncolor stopLossBackgroundColor = red\nif currentlyInLongPosition and stopLossLimitPrice > averageEntryPrice\n    stopLossColor := green\n    stopLossBackgroundColor := lightGreen\nelse\n    if currentlyInShortPosition and stopLossLimitPrice < averageEntryPrice\n        stopLossColor := green\n        stopLossBackgroundColor := lightGreen\n    else\n        stopLossColor := red\n        stopLossBackgroundColor := lightRed\nvar label stopLossLabel = na\nvar label moveStopAfterLabel = na\nvar label averageEntryLabel = na\nvar label profitAndLossLabel = na\nvar label profitTargetLabel = na\nvar line stopLossTriggerLine = na\nvar line moveStopAfterLine = na\nvar line stopLossLimitLine = na\nvar line averageEntryLine = na\nvar line profitTargetLine = na\nvar linefill stopLossBackground = na\nvar linefill profitTargetBackground = na\nlabel.delete(stopLossLabel)\nlabel.delete(moveStopAfterLabel)\nlabel.delete(averageEntryLabel)\nlabel.delete(profitAndLossLabel)\nlabel.delete(profitTargetLabel)\nline.delete(stopLossTriggerLine)\nline.delete(moveStopAfterLine)\nline.delete(stopLossLimitLine)\nline.delete(averageEntryLine)\nline.delete(profitTargetLine)\nlinefill.delete(stopLossBackground)\nlinefill.delete(profitTargetBackground)\nstring stopLossLabelText = na\nif moveStopLossAfter and not moveStopTriggered\n    stopLossLabelText           := \"\u2002Stop Trigger\u2002|\u2002\" + str.format(\"{0,number,currency}\"\nelse\n    stopLossLabelText           := \"\u2002Stop Trigger\u2002|\u2002\" + str.format(\"{0,number,currency}\"\nxOffset = 2 * timeframe.in_seconds(timeframe.period) * 1000 \nprofitAndLossLabel              := label.new(x=time + xOffset, xloc=xloc.bar_time,\naverageEntryLabel               := label.new(x=time + xOffset, xloc=xloc.bar_time,\nstopLossLabel                   := label.new(x=time + xOffset, xloc=xloc.bar_time,\naverageEntryLine                := line.new(x1=strategy.opentrades.entry_bar_index\nprofitTargetLine                := line.new(x1=strategy.opentrades.entry_bar_index\nprofitTargetLabel               := label.new(x=time + xOffset, xloc=xloc.bar_time,\nstopLossTriggerLine             := line.new(x1=strategy.opentrades.entry_bar_index\nstopLossLimitLine               := line.new(x1=strategy.opentrades.entry_bar_index\nstopLossBackground              := linefill.new(averageEntryLine, stopLossLimitLine\nprofitTargetBackground          := linefill.new(averageEntryLine, profitTargetLine\nif enableMoveStopToBreakEven\n    moveStopAfterLabel          := label.new(x=time + xOffset, xloc=xloc.bar_time,\n    moveStopAfterLine           := line.new(x1=strategy.opentrades.entry_bar_index\nstopLimitStatus                 = plot(stopLossLimitPrice, color=stopLossColor, display\nstopTriggerStatus               = plot(stopLossTriggerPrice, color=stopLossColor, \naverageEntryStatus              = plot(averageEntryPrice, color=oceanBlue, display\nif not currentlyInAPosition\n    label.delete(stopLossLabel)\n    label.delete(moveStopAfterLabel)\n    label.delete(averageEntryLabel)\n    label.delete(profitAndLossLabel)\n    label.delete(profitTargetLabel)\n    line.delete(stopLossTriggerLine)\n    line.delete(moveStopAfterLine)\n    line.delete(stopLossLimitLine)\n    line.delete(averageEntryLine)\n    line.delete(profitTargetLine)\n    linefill.delete(stopLossBackground)\n    linefill.delete(profitTargetBackground)\n// Alertatron Automation Status Message\nwarning_color = enableWebhookMessages == true ? red : green\nvar table status = table.new(position=position.top_right, columns=2, rows=100, bgcolor\nrowCount2 = 0\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + strategyIdentifier, text_color=white, \ntable.cell(status, 1, rowCount2, text=\"\u2002\", text_color=white, text_halign=text.align_left\nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Webhook Enabled\", text_color=white, text_halign\ntable.cell(status, 1, rowCount2, text=str.tostring(enableWebhookMessages) + \"\u2002\", text_color\nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Exchange\", text_color=white, text_halign\ntable.cell(status, 1, rowCount2, text=tradeAutomationExchange + \"\u2002\", text_color=white\nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Code\", text_color=white, text_halign=\ntable.cell(status, 1, rowCount2, text=tradeAutomationSecret == \"\" ? \"N/A\" : tradeAutomationSecret\nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Leverage\", text_color=white, text_halign\ntable.cell(status, 1, rowCount2, text=str.tostring(tradeAutomationLeverageType) + \nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Pair\", text_color=white, text_halign=\ntable.cell(status, 1, rowCount2, text=str.tostring(symbol) + bot.getPairDividerForExchange\nrowCount2 += 1\nlotSizeDisplay = lotSizeType == \"Percent Of Account\" ? str.format(\"{0,number,percent}\"\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Lot Size\", text_color=white, text_halign\ntable.cell(status, 1, rowCount2, text=lotSizeDisplay + \"\u2002\", text_color=white, text_halign\nrowCount2 += 1\ntable.cell(status, 0, rowCount2, text=\"\u2002\" + \"Account Size\", text_color=white, text_halign\ntable.cell(status, 1, rowCount2, text=str.format(\"{0,number,currency}\" + \"\u2002\", strategy.initial_capital\nrowCount2 += 1\n//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n//  D E B U G   M O D E - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nif showDebugTable\n    var table debug = table.new(position=position.bottom_left, columns=2, rows=100\n        rowCount = 0\n    table.cell(debug, 0, rowCount, text=\"enterLongAlertMessage: \", text_color=white\n    table.cell(debug, 1, rowCount, text=str.tostring(enterLongAlertMessage), text_color\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"enterShortAlertMessage: \", text_color=white\n    table.cell(debug, 1, rowCount, text=str.tostring(enterShortAlertMessage), text_color\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"exitLongAlertMessage: \", text_color=white\n    table.cell(debug, 1, rowCount, text=str.tostring(exitLongAlertMessage), text_color\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"exitShortAlertMessage: \", text_color=white\n    table.cell(debug, 1, rowCount, text=str.tostring(exitShortAlertMessage), text_color\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"moveStopTriggered: \", text_color=white, text_halign\n    table.cell(debug, 1, rowCount, text=str.tostring(moveStopTriggered), text_color\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"longStopLoss (stopLossTriggerPrice): \", text_color\n    table.cell(debug, 1, rowCount, text=str.tostring(longStopLoss) + \" | \" + str.tostring\n    rowCount += 1\n    table.cell(debug, 0, rowCount, text=\"barsSinceOpen\", text_color=white, text_halign\n    table.cell(debug, 1, rowCount, text=str.tostring(barsSinceOpen), text_color=white"}]}
{"messages": [{"role": "user", "content": "There are some ideas out there that the market is like a collection of quantum events and that it could all be broken down into sine waves.  I created this script to put that to the test. The idea is simple, I tested 3 different factors that could be put into sine wave form. 1.) Bar Change 2.) Volume Average Change 3.) Coin Flip For the bar change, I simply allow the sine wave to move upwards or downwards if the bars have changed color in their sequence.  For example, if there were 3 red bars and 1 green bar, it would not move the sine wave up or down until the green bar appeared. For the average volume change, it was the same idea, except that the sine wave could only move up or down if the volume had moved up or below the average value of the length given for calculating the average volume. Finally, the coin flip simply simulates flipping a coin, and allows the sine wave to move one direction or the other once it has a side that is different from the previous chosen side.  For example, heads, heads, heads, tails (once it flipped to tails, this would allow it to move a direction). The sine wave trading theory that I watched claimed that if you know the correct sine wave # (which is how large the peak is, and/or the sine wave count which is how many peaks and valleys occur) that you can successfully predict future trades.  Their claims that the reason it does not look like a perfect sine wave for these events is because there is different amounts of trading going on, thus the timing will be slightly off. I am posting this to disagree with their ideas.  For example, if you select to turn on trading for coin flip and turn off bar change, you will see the coin flip did better on the default settings! It just so happens that any setting will eventually be good, making all the sine wave variations just completely random if you win or not. I posted this to demonstrate how silly trading sine waves is.  The real trick is using cosine and tangent waves... lol j/k I hope this helps someone avoid this scam concept."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Gentleman-Goat\n//@version=5\nstrategy(\"Sine Wave Theory\",overlay=false, precision = 2, initial_capital = 1000,shorttitle\nvar bar_change_wave_direction = input.int(defval=1,title=\"Starting Wave Direction\",\nbar_change_sine_wave_number = input.int(defval=28,title=\"Sine Wave #\",group=\"Bar Change\"\nbar_change_sine_wave_res = input.timeframe(defval=\"D\",title=\"Resolution\",group=\"Bar Change\"\nbar_change_trade = input.bool(defval=true,title=\"Trade\",group=\"Bar Change\")\nvar volume_wave_direction = input.int(defval=1,title=\"Starting Wave Direction\",group\navg_volume_length = input.int(7,title=\"Lookback Length\",group=\"Volume\")\nvolume_sine_wave_number = input.int(defval=28,title=\"Sine Wave #\",group=\"Volume\")\nvolume_sine_wave_res = input.timeframe(defval=\"D\",title=\"Resolution\",group=\"Volume\"\nvolume_trade = input.bool(defval=false,title=\"Trade\",group=\"Volume\")\nvar coin_flip_wave_direction = input.int(defval=1,title=\"Starting Wave Direction\",group\ncoin_flip_sine_wave_number = input.int(defval=28,title=\"Sine Wave #\",group=\"Coin Flip\"\ncoin_flip_seed = input.int(defval=1,title=\"Seed #\",group=\"Coin Flip\")\ncoin_flip_trade = input.bool(defval=false,title=\"Trade\",group=\"Coin Flip\")\navg_volume = ta.sma(volume,avg_volume_length)\n//Green or Red Candle\nbar_color = close>open ?  color.green :  color.red\nbar_color_time_adj = request.security(syminfo.tickerid, bar_change_sine_wave_res, bar_color\n//Above or Below Average\nvolume_state = (volume>avg_volume) ?  color.blue :  color.purple\nvolume_state_time_adj = request.security(syminfo.tickerid, volume_sine_wave_res, volume_state\n //Coinflip\ncoin_flip = math.random(0,100,coin_flip_seed)>=50 ?  color.teal :  color.yellow\nvar bar_change_wave_count = 0\nvar volume_wave_count = 0\nvar coin_flip_wave_count = 0\n//Wave Counters\nif(volume_state_time_adj[1] != volume_state_time_adj)\n    volume_wave_count := volume_wave_count + volume_wave_direction\nif(bar_color_time_adj[1] != bar_color_time_adj)\n    bar_change_wave_count := bar_change_wave_count + bar_change_wave_direction\nif(coin_flip[1] != coin_flip)\n    coin_flip_wave_count := coin_flip_wave_count + coin_flip_wave_direction\n//Direction changers\nif(math.abs(bar_change_wave_count) == bar_change_sine_wave_number and bar_color_time_adj\n    bar_change_wave_direction := bar_change_wave_direction * -1\nif(math.abs(volume_wave_count) == volume_sine_wave_number and volume_state_time_adj\n    volume_wave_direction := volume_wave_direction * -1\nif(math.abs(coin_flip_wave_count) == coin_flip_sine_wave_number and coin_flip[1] !=\n    coin_flip_wave_direction := coin_flip_wave_direction * -1\n//Entry positions\nif(bar_change_wave_count==bar_change_sine_wave_number and bar_change_trade==true)\n    strategy.entry(id=\"short\",direction=strategy.short)\nif(bar_change_wave_count==bar_change_sine_wave_number*-1 and bar_change_trade==true\n    strategy.entry(id=\"long\",direction=strategy.long)\nif(volume_wave_count==volume_sine_wave_number and volume_trade==true)\n    strategy.entry(id=\"short-volume\",direction=strategy.short)\nif(volume_wave_count==volume_sine_wave_number*-1 and volume_trade==true)\n    strategy.entry(id=\"long-volume\",direction=strategy.long)\nif(coin_flip_wave_count==coin_flip_sine_wave_number and coin_flip_trade==true)\n    strategy.entry(id=\"short-coinflip\",direction=strategy.short)\nif(coin_flip_wave_count==coin_flip_sine_wave_number*-1 and coin_flip_trade==true)\n    strategy.entry(id=\"long-coinflip\",direction=strategy.long)\nhline(0, title='Center', color= color.white, linestyle=hline.style_dashed, linewidth\nplot(bar_change_wave_count,title=\"Bar Change\", color=bar_color, linewidth=2)\nplot(volume_wave_count,title=\"Volume Average Change\", color=volume_state, linewidth\nplot(coin_flip_wave_count,title=\"Coin Flip Change\", color=coin_flip, linewidth=2)"}]}
{"messages": [{"role": "user", "content": "This is a DCA Strategy backtester + signals, built to emulate the 3Commas DCA bots. It uses your choice of 4 different buy signals, 2 of which can be adjusted in the settings. Everything is customizable so you can backtest specific settings with different buy signals and find the best performing strategy for your risk tolerance and capital. It can be used to backtest strategies on stocks as well, but just make sure your base order is larger than the share price for the entire backtesting range or it will not calculate properly. You can use this template to code your own buy signals and then backtest them as a DCA strategy if you know some basic pine script. The indicator shows all of your backtesting orders on the chart. The red line is your take profit level, the blue line is your average price level, the white line is your first order and the green lines are your average down orders. If you enable a stop loss in the settings your stop loss will be shown as an orange line once all of your average down orders have been hit, it will not be set until price has dipped below your covered trading range. These levels update when things change during backtesting so you can visualize your strategy and how it would perform as well as see if your percentage deviation is large enough to cover dips. When backtesting trades are taken, the chart will show where they were taken(in backtesting) along with info on those trades such as the number each order is, the size of that order and the percentage deviation that order is from the initial buy. SENDING SIGNALS TO 3COMMAS Tradingview cannot sync this backtester to 3Commas and with the way alerts are setup for strategies on Tradingview, the best option for you to give signals to your bot would be to use this backtester to figure out what trigger you want to use and then setup that indicator separately to send alerts to your bot. All of the indicators used for signals in this backtester are available for free and can be configured to match this backtester and send alerts to 3Commas for you. Just make sure you set your alerts to once per bar close and don\u2019t use less than a 15 second timeframe because then you could trigger the Tradingview threshold for alerts and get your alerts shut off. You can also use this backtester with your own buy triggers if you know a little pine script. Just make copy of the script and code in your own buy signals and see how it backtests. INFO PANEL FOR ANALYZING YOUR STRATEGY The right hand side of the screen will show an info panel that shows a lot of different information so you can quickly see your bot settings and how it performed right on the screen. In the top right corner you will see in purple your bot settings. These include your stoploss % if turned on, take profit %, average down order %, average down order % multiplier, volume multiplier, max number of orders allowed and size of your base order. The top section of the first column \u201cCurrent Trade\u201d shows these stats: the open trade\u2019s average price, the open trade\u2019s take profit price, the open trade\u2019s PNL, how far price is from your open tarde\u2019s take profit level in percentage, your open position size and number of open orders. The bottom section of the first column \u201cOverall Performance\u201d shows these stats: total number of trades taken during backtesting range, the largest amount of trades that were open at one time during backtesting, the max drawdown, the average number of bars per trade, gross profit, net profit, percent profit from your initial capital, current portfolio value and your initial capital. CUSTOMIZABLE OPTIONS TO FIND THE PERFECT STRATEGY Stoploss On/Off This will turn your stoploss on or off. By default it is set to off and will not affect anything unless turned on. Stoploss Percentage This is the percentage below your final average down order price that will be set as a stoploss to keep your account from going too far in the red on big dips. Take Profit Percentage - This is the percentage of profit you want the trade to hit before taking profit on your entire DCA trade. This level updates everytime you average down. Average Down Percentage - This is the percentage that price has to drop from your initial order to initiate your first safety order. If the Average Down Percent Multiplier is set to 1 then this percentage will be the same for every average down order. Average Down Percentage Multiplier - This multiplies your Average Down Percentage so each safety order needs a larger percentage deviation than the previous one. This keeps your buys closer together at the beginning and further apart when you hit more orders so you can extend your trading range but still be aggressive when price is going sideways. Volume Multiplier Per New Order - This multiplies the size of each trade based on your base order. If you set it to a 2x multiplier then each average down order will be 2 times the size of the last one. So for example, a $100 base order with a 2x multiplier would have these values for the first 3 average down orders: 200, 400, 800. Size Of Base Order - This is the size of your first position entry and will be used as a starting point for the volume multiplier. If your base order is $100 then it will buy $100 worth of whatever crypto you are backtesting this on. If you are looking at stock charts, you need to make sure your base order is higher than the share price across the entire backtesting range or it will not perform correctly. Max Number Of Orders - This is the maximum number of orders the bot can take, including your base order. Adjust this to suit the amount of capital you are willing to allocate to your bot based on how much money it will require to run according to your bot settings. TIPS ON HOW TO USE FOR BEST RESULTS If you don\u2019t have a lot of capital to work with, then use longer timeframes with a reasonable take profit percentage so that you don\u2019t need a lot of average down orders. You can also try keeping the volume multiplier close to 1. You can use the 3Commas dca bot settings page to see how much capital you will need for your strategy if you match it to the settings you have on this indicator. You can also check to see how much of a percentage deviation your bot is covering to make sure you have a reasonable range to trade in and orders to cover big dips. You can also check your coverage by seeing how far down the chart the green lines cover, which are your average down orders. Make sure the initial capital in the properties tab of the settings has enough to cover all of your orders otherwise you will get unrealistic backtesting results. Also, make sure you leave the order size in the properties tab on contracts so it calculates your trades correctly. The only settings you need to touch in the properties tab is the initial capital. Unless you are trading somewhere that has lower commission fees, then you can change that to match, but leave all the other settings as is for it to function properly. Increasing the volume multiplier will make your average price and take profit target follow the price action a lot closer as price falls, but it can also lead to having very large orders very quickly once you get into the 1.5-3x multiple range. Try using a high volume multiplier with less safety orders and you will get better results, however you need to have money on the sidelines to add on major dips to keep your bot turning a profit. Be very careful with this as greed and impatience will hurt your overall performance. This bot is meant to make money with lots of small wins so don\u2019t get greedy and make sure you have enough money to cover large dips. If you are being aggressive with your bot, then I recommend only using 25% or less of your portfolio to trade aggressively and then use the smart trade feature on 3commas to add chunks of funds to your trades when price dips below your last safety order. Or if you want it to run without any supervision, then use lower volume multipliers and have lots of safety orders that can cover entire bear markets and still keep buying lower. It\u2019s a good idea to have some capital on the sidelines that you can add in when price dips quickly. This will help lower your average price and allow your bot to get out in profit quicker. 3Commas bot has a smart trade feature that will allow you to track your average price when adding extra funds and it will automatically update your other orders which is very convenient. Look at the longer timeframes when price dips and only add chunks at major areas where price is very likely to bounce. Or you can be aggressive when trading and add to your position when price dips and is at a likely bounce zone to maximize profits. Only trade coins that have a good amount of liquidity as the larger your orders get, the harder it will be to sell if there isn\u2019t much liquidity. Also, beware of how large your first order is as it will usually be a market order and can move the market if there is not much liquidity. Since this bot takes a lot of trades and performs best when taking small profits consistently, you will need to factor in exchange fees. The bot is set to .5% commission(you can change this) on the buy and sell orders as most exchanges charge that amount. Some exchanges offer no fee trading on certain coins so be sure to look around for those so you can keep the commissions and maximize profits. I strongly encourage you to try out a lot of different setting combinations across multiple different coins and do it across a few months to see how it would have performed under various market conditions. This will help you get a better idea of how much of a percentage deviation you\u2019ll need to be able to cover to keep your bot running and making constant profits. You can also use the deep backtesting feature of the strategy panel to see how it would have done, but just beware that the info panel of the indicator will not reflect deep backtesting results, only the normal backtesting range. MARKETS This backtester can be used on any market including crypto, stocks, forex & futures. You just need to make sure your base order is larger than the share price when using this on things besides crypto. TIMEFRAMES This backtester can be used on all timeframes."}, {"role": "assistant", "content": "// \u00a9 FriendOfTheTrend\n//@version=5\nstrategy('3Commas Bot DCA Backtester & Signals FREE', shorttitle=\"3Commas Bot DCA Backtester & Signals FREE\"\n calc_on_every_tick=true, backtest_fill_limits_assumption=1, default_qty_type=strategy.fixed\n commission_value=.05, process_orders_on_close=true, initial_capital=26000, margin_long\n//Choose Strategy\nstrategy = input.string(\"MACD\", title=\"Buy Signal Strategy\", options=[\"MFI\", \"RSI\"\nstrategyLevelTrigger = input.int(20, title=\"Signal Threshold Level\", tooltip=\"This number is the threshold that MFI or RSI will\nstrategyLength = input.int(14, title=\"Indicator Length\", tooltip=\"This is the length used for RSI and MFI. MACD use\n//Inputs\nstoplossOn = input.bool(false, title=\"Stoploss On\", group=\"DCA Bot Settings\")\nstoploss = input.float(5, title=\"Stoploss %\", minval=.0001, step=.001, group=\"DCA Bot Settings\"\ntakeProfit = input.float(.5, title=\"Take Profit %\", minval=.0001, step=.001, group\navgDown = input.float(.5, title=\"Average Down %\", minval=.0001, step=.001, group=\"DCA Bot Settings\"\npercentScale = input.float(1.2, title=\"Avg Down % Multiplier\", minval=.0001, step=\nmultiplier = input.float(1.5, title=\"Volume Multiplier\", minval=1, step=.001, tooltip\nmaxOrders = input.int(12, title=\"Max # Of Orders\", group=\"DCA Bot Settings\")\nquantity = input.float(100, title=\"Size Of Base Order\", minval=.000000001, step=.000000001\n//Info Table On/Off\ndataTableOn = input.bool(true, title=\"Info Table On/Off\", group=\"Info Tables\")\n//Average Down Levels On/Off\norderLevelsOn = input.bool(true, title=\"Turn Average Down Levels On/Off\", group=\"Average Down Levels\"\n//Table Positions\nbright = position.bottom_right\nbleft = position.bottom_left\nbcenter = position.bottom_center\ntright = position.top_right\ntleft = position.top_left\ntcenter = position.top_center\nmright = position.middle_right\nmleft = position.middle_left\nmcenter = position.middle_center\ntablePosition = input.string(bright, title=\"Percentage Table Position\", options=[bright\n//Buy Signals\nbuy = false\n//MACD\nfastMa = ta.sma(close, 12)\nslowMa = ta.sma(close, 26)\nmacd = fastMa - slowMa\nsignal = ta.sma(macd, 9)\nif  strategy == \"MACD\" and ta.crossover(macd, signal)\n    buy := true\n//MFI\nmfi = ta.mfi(close, strategyLength)\nif strategy == \"MFI\" and mfi <= strategyLevelTrigger\n    buy := true\n//RSI\nrsi = ta.rsi(close, strategyLength)\nif strategy == \"RSI\" and rsi <= strategyLevelTrigger\n    buy := true\n//Stochastic RSI\nsmoothK = 3\nsmoothD = 3\nlengthRSI = 14\nlengthStoch = 14\nrsi1 = ta.rsi(close, lengthRSI)\nk = ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)\nd = ta.sma(k, smoothD)\nif  strategy == \"Stochastic RSI\" and ta.crossover(k, d)\n    buy := true\n//Alerts\nif buy\n    alert(\"Place Open Deal Code From 3Commas Here.\", alert.freq_once_per_bar_close\n// Order Quantity Adjustments With Volume Multiplier\nquantityConverted = quantity/close\nquantMultiplied1 = quantityConverted * multiplier\nquantMultiplied2 = quantMultiplied1 * multiplier\nquantMultiplied3 = quantMultiplied2 * multiplier\nquantMultiplied4 = quantMultiplied3 * multiplier\nquantMultiplied5 = quantMultiplied4 * multiplier\nquantMultiplied6 = quantMultiplied5 * multiplier\nquantMultiplied7 = quantMultiplied6 * multiplier\nquantMultiplied8 = quantMultiplied7 * multiplier\nquantMultiplied9 = quantMultiplied8 * multiplier\nquantMultiplied10 = quantMultiplied9 * multiplier\nquantMultiplied11 = quantMultiplied10 * multiplier\nquantMultiplied12 = quantMultiplied11 * multiplier\nquantMultiplied13 = quantMultiplied12 * multiplier\nquantMultiplied14 = quantMultiplied13 * multiplier\nquantMultiplied15 = quantMultiplied14 * multiplier\nquantMultiplied16 = quantMultiplied15 * multiplier\nquantMultiplied17 = quantMultiplied16 * multiplier\nquantMultiplied18 = quantMultiplied17 * multiplier\nquantMultiplied19 = quantMultiplied18 * multiplier\nquantMultiplied20 = quantMultiplied19 * multiplier\nquantMultiplied21 = quantMultiplied20 * multiplier\nquantMultiplied22 = quantMultiplied21 * multiplier\nquantMultiplied23 = quantMultiplied22 * multiplier\nquantMultiplied24 = quantMultiplied23 * multiplier\nquantMultiplied25 = quantMultiplied24 * multiplier\nquantMultiplied26 = quantMultiplied25 * multiplier\nquantMultiplied27 = quantMultiplied26 * multiplier\nquantMultiplied28 = quantMultiplied27 * multiplier\nquantMultiplied29 = quantMultiplied28 * multiplier\nquantMultiplied30 = quantMultiplied29 * multiplier\nquantMultiplied31 = quantMultiplied30 * multiplier\nquantMultiplied32 = quantMultiplied31 * multiplier\nquantMultiplied33 = quantMultiplied32 * multiplier\nquantMultiplied34 = quantMultiplied33 * multiplier\nquantMultiplied35 = quantMultiplied34 * multiplier\nquantMultiplied36 = quantMultiplied35 * multiplier\nquantMultiplied37 = quantMultiplied36 * multiplier\nquantMultiplied38 = quantMultiplied37 * multiplier\nquantMultiplied39 = quantMultiplied38 * multiplier\nquantMultiplied40 = quantMultiplied39 * multiplier\nquantMultiplied41 = quantMultiplied40 * multiplier\nquantMultiplied42 = quantMultiplied41 * multiplier\nquantMultiplied43 = quantMultiplied42 * multiplier\nquantMultiplied44 = quantMultiplied43 * multiplier\nquantMultiplied45 = quantMultiplied44 * multiplier\nquantMultiplied46 = quantMultiplied45 * multiplier\nquantMultiplied47 = quantMultiplied46 * multiplier\nquantMultiplied48 = quantMultiplied47 * multiplier\nquantMultiplied49 = quantMultiplied48 * multiplier\nquantMultiplied50 = quantMultiplied49 * multiplier\n// Average Down Levels\navgDown1 = (avgDown * percentScale) + avgDown\navgDown2 = (avgDown1 * percentScale) + avgDown\navgDown3 = (avgDown2 * percentScale) + avgDown\navgDown4 = (avgDown3 * percentScale) + avgDown\navgDown5 = (avgDown4 * percentScale) + avgDown\navgDown6 = (avgDown5 * percentScale) + avgDown\navgDown7 = (avgDown6 * percentScale) + avgDown\navgDown8 = (avgDown7 * percentScale) + avgDown\navgDown9 = (avgDown8 * percentScale) + avgDown\navgDown10 = (avgDown9 * percentScale) + avgDown\navgDown11 = (avgDown10 * percentScale) + avgDown\navgDown12 = (avgDown11 * percentScale) + avgDown\navgDown13 = (avgDown12 * percentScale) + avgDown\navgDown14 = (avgDown13 * percentScale) + avgDown\navgDown15 = (avgDown14 * percentScale) + avgDown\navgDown16 = (avgDown15 * percentScale) + avgDown\navgDown17 = (avgDown16 * percentScale) + avgDown\navgDown18 = (avgDown17 * percentScale) + avgDown\navgDown19 = (avgDown18 * percentScale) + avgDown\navgDown20 = (avgDown19 * percentScale) + avgDown\navgDown21 = (avgDown20 * percentScale) + avgDown\navgDown22 = (avgDown21 * percentScale) + avgDown\navgDown23 = (avgDown22 * percentScale) + avgDown\navgDown24 = (avgDown23 * percentScale) + avgDown\navgDown25 = (avgDown24 * percentScale) + avgDown\navgDown26 = (avgDown25 * percentScale) + avgDown\navgDown27 = (avgDown26 * percentScale) + avgDown\navgDown28 = (avgDown27 * percentScale) + avgDown\navgDown29 = (avgDown28 * percentScale) + avgDown\navgDown30 = (avgDown29 * percentScale) + avgDown\navgDown31 = (avgDown30 * percentScale) + avgDown\navgDown32 = (avgDown31 * percentScale) + avgDown\navgDown33 = (avgDown32 * percentScale) + avgDown\navgDown34 = (avgDown33 * percentScale) + avgDown\navgDown35 = (avgDown34 * percentScale) + avgDown\navgDown36 = (avgDown35 * percentScale) + avgDown\navgDown37 = (avgDown36 * percentScale) + avgDown\navgDown38 = (avgDown37 * percentScale) + avgDown\navgDown39 = (avgDown38 * percentScale) + avgDown\navgDown40 = (avgDown39 * percentScale) + avgDown\navgDown41 = (avgDown40 * percentScale) + avgDown\navgDown42 = (avgDown41 * percentScale) + avgDown\navgDown43 = (avgDown42 * percentScale) + avgDown\navgDown44 = (avgDown43 * percentScale) + avgDown\navgDown45 = (avgDown44 * percentScale) + avgDown\navgDown46 = (avgDown45 * percentScale) + avgDown\navgDown47 = (avgDown46 * percentScale) + avgDown\navgDown48 = (avgDown47 * percentScale) + avgDown\navgDown49 = (avgDown48 * percentScale) + avgDown\navgDown50 = (avgDown49 * percentScale) + avgDown\n//Strategy Trade Signal\nif strategy.opentrades == 0 and buy and barstate.isconfirmed \n    strategy.entry('Bull #1', strategy.long, qty=quantityConverted, comment='Buy #1'\n// Plot Entry & Average Down Levels\nplot(strategy.opentrades.entry_price(0), title=\"Order #1\", color= color.white)\nplot(maxOrders >= 2 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 3 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 4 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 5 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 6 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 7 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 8 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 9 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 - \nplot(maxOrders >= 10 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 11 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 12 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 13 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 14 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 15 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 16 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 17 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 18 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 19 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 20 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 21 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 22 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 23 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 24 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 25 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 26 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 27 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 28 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 29 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 30 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 31 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 32 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 33 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 34 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 35 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 36 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 37 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 38 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 39 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 40 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 41 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 42 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 43 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 44 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 45 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 46 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 47 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 48 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 49 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 50 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nplot(maxOrders >= 51 and orderLevelsOn ? strategy.opentrades.entry_price(0) * (1 -\nif strategy.opentrades == 1 and maxOrders >= 2\n    strategy.entry('Bull #1', strategy.long, qty=quantMultiplied1, limit=strategy.opentrades.entry_price\n     comment=\"Buy #2 \" + str.tostring(avgDown * 100, format.percent))\nif strategy.opentrades == 2 and maxOrders >= 3\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied2, limit=strategy.opentrades.entry_price\n     comment=\"Buy #3 \" + str.tostring(avgDown1 * 100, format.percent))\nif strategy.opentrades == 3 and maxOrders >= 4\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied3, limit=strategy.opentrades.entry_price\n     comment=\"Buy #4 \" + str.tostring(avgDown2 * 100, format.percent))\nif strategy.opentrades == 4 and maxOrders >= 5\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied4, limit=strategy.opentrades.entry_price\n     comment=\"Buy #5 \" + str.tostring(avgDown3 * 100, format.percent))\nif strategy.opentrades == 5 and maxOrders >= 6\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied5, limit=strategy.opentrades.entry_price\n     comment=\"Buy #6 \" + str.tostring(avgDown4 * 100, format.percent))\nif strategy.opentrades == 6 and maxOrders >= 7\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied6, limit=strategy.opentrades.entry_price\n     comment=\"Buy #7 \" + str.tostring(avgDown5 * 100, format.percent))\nif strategy.opentrades == 7 and maxOrders >= 8\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied7, limit=strategy.opentrades.entry_price\n     comment=\"Buy #8 \" + str.tostring(avgDown6 * 100, format.percent))\nif strategy.opentrades == 8 and maxOrders >= 9\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied8, limit=strategy.opentrades.entry_price\n     comment=\"Buy #9 \" + str.tostring(avgDown7 * 100, format.percent))\nif strategy.opentrades == 9 and maxOrders >= 10\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied9, limit=strategy.opentrades.entry_price\n     comment=\"Buy #10 \" + str.tostring(avgDown8 * 100, format.percent))\nif strategy.opentrades == 10 and maxOrders >= 11\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied10, limit=strategy.opentrades.entry_price\n     comment=\"Buy #11 \" + str.tostring(avgDown9 * 100, format.percent))\nif strategy.opentrades == 11 and maxOrders >= 12\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied11, limit=strategy.opentrades.entry_price\n     comment=\"Buy #12 \" + str.tostring(avgDown10 * 100, format.percent))\nif strategy.opentrades == 12 and maxOrders >= 13\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied12, limit=strategy.opentrades.entry_price\n     comment=\"Buy #13 \" + str.tostring(avgDown11 * 100, format.percent))\nif strategy.opentrades == 13 and maxOrders >= 14\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied13, limit=strategy.opentrades.entry_price\n     comment=\"Buy #14 \" + str.tostring(avgDown12 * 100, format.percent))\nif strategy.opentrades == 14 and maxOrders >= 15\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied14, limit=strategy.opentrades.entry_price\n     comment=\"Buy #15 \" + str.tostring(avgDown13 * 100, format.percent))\nif strategy.opentrades == 15 and maxOrders >= 16\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied15, limit=strategy.opentrades.entry_price\n     comment=\"Buy #16 \" + str.tostring(avgDown14 * 100, format.percent))\nif strategy.opentrades == 16 and maxOrders >= 17\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied16, limit=strategy.opentrades.entry_price\n     comment=\"Buy #17 \" + str.tostring(avgDown15 * 100, format.percent))\nif strategy.opentrades == 17 and maxOrders >= 18\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied17, limit=strategy.opentrades.entry_price\n     comment=\"Buy #18 \" + str.tostring(avgDown16 * 100, format.percent))\nif strategy.opentrades == 18 and maxOrders >= 19\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied18, limit=strategy.opentrades.entry_price\n     comment=\"Buy #19 \" + str.tostring(avgDown17 * 100, format.percent))\nif strategy.opentrades == 19 and maxOrders >= 20\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied19, limit=strategy.opentrades.entry_price\n     comment=\"Buy #20 \" + str.tostring(avgDown18 * 100, format.percent))\nif strategy.opentrades == 20 and maxOrders >= 21\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied20, limit=strategy.opentrades.entry_price\n     comment=\"Buy #21 \" + str.tostring(avgDown19 * 100, format.percent))\nif strategy.opentrades == 21 and maxOrders >= 22\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied21, limit=strategy.opentrades.entry_price\n     comment=\"Buy #22 \" + str.tostring(avgDown20 * 100, format.percent))\nif strategy.opentrades == 22 and maxOrders >= 23\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied21, limit=strategy.opentrades.entry_price\n     comment=\"Buy #23 \" + str.tostring(avgDown21 * 100, format.percent))\nif strategy.opentrades == 23 and maxOrders >= 24\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied22, limit=strategy.opentrades.entry_price\n     comment=\"Buy #24 \" + str.tostring(avgDown22 * 100, format.percent))\nif strategy.opentrades == 24 and maxOrders >= 25\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied23, limit=strategy.opentrades.entry_price\n     comment=\"Buy #25 \" + str.tostring(avgDown23 * 100, format.percent))\nif strategy.opentrades == 25 and maxOrders >= 26\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied24, limit=strategy.opentrades.entry_price\n     comment=\"Buy #26 \" + str.tostring(avgDown24 * 100, format.percent))\nif strategy.opentrades == 26 and maxOrders >= 27\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied25, limit=strategy.opentrades.entry_price\n     comment=\"Buy #27 \" + str.tostring(avgDown25 * 100, format.percent))\nif strategy.opentrades == 27 and maxOrders >= 28\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied26, limit=strategy.opentrades.entry_price\n     comment=\"Buy #28 \" + str.tostring(avgDown26 * 100, format.percent))\nif strategy.opentrades == 28 and maxOrders >= 29\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied27, limit=strategy.opentrades.entry_price\n     comment=\"Buy #29 \" + str.tostring(avgDown27 * 100, format.percent))\nif strategy.opentrades == 29 and maxOrders >= 30\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied28, limit=strategy.opentrades.entry_price\n     comment=\"Buy #30 \" + str.tostring(avgDown28 * 100, format.percent))\nif strategy.opentrades == 30 and maxOrders >= 31\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied29, limit=strategy.opentrades.entry_price\n     comment=\"Buy #31 \" + str.tostring(avgDown29 * 100, format.percent))\nif strategy.opentrades == 31 and maxOrders >= 32\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied30, limit=strategy.opentrades.entry_price\n     comment=\"Buy #32 \" + str.tostring(avgDown30 * 100, format.percent))\nif strategy.opentrades == 32 and maxOrders >= 33\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied31, limit=strategy.opentrades.entry_price\n     comment=\"Buy #33 \" + str.tostring(avgDown31 * 100, format.percent))\nif strategy.opentrades == 33 and maxOrders >= 34\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied32, limit=strategy.opentrades.entry_price\n     comment=\"Buy #34 \" + str.tostring(avgDown32 * 100, format.percent))\nif strategy.opentrades == 34 and maxOrders >= 35\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied33, limit=strategy.opentrades.entry_price\n     comment=\"Buy #35 \" + str.tostring(avgDown33 * 100, format.percent))\nif strategy.opentrades == 35 and maxOrders >= 36\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied34, limit=strategy.opentrades.entry_price\n     comment=\"Buy #36 \" + str.tostring(avgDown34 * 100, format.percent))\nif strategy.opentrades == 36 and maxOrders >= 37\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied35, limit=strategy.opentrades.entry_price\n     comment=\"Buy #37 \" + str.tostring(avgDown35 * 100, format.percent))\nif strategy.opentrades == 37 and maxOrders >= 38\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied36, limit=strategy.opentrades.entry_price\n     comment=\"Buy #38 \" + str.tostring(avgDown36 * 100, format.percent))\nif strategy.opentrades == 38 and maxOrders >= 39\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied37, limit=strategy.opentrades.entry_price\n     comment=\"Buy #39 \" + str.tostring(avgDown37 * 100, format.percent))\nif strategy.opentrades == 39 and maxOrders >= 40\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied38, limit=strategy.opentrades.entry_price\n     comment=\"Buy #40 \" + str.tostring(avgDown38 * 100, format.percent))\nif strategy.opentrades == 40 and maxOrders >= 41\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied39, limit=strategy.opentrades.entry_price\n     comment=\"Buy #41 \" + str.tostring(avgDown39 * 100, format.percent))\nif strategy.opentrades == 41 and maxOrders >= 42\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied40, limit=strategy.opentrades.entry_price\n     comment=\"Buy #42 \" + str.tostring(avgDown40 * 100, format.percent))\nif strategy.opentrades == 42 and maxOrders >= 43\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied41, limit=strategy.opentrades.entry_price\n     comment=\"Buy #43 \" + str.tostring(avgDown41 * 100, format.percent))\nif strategy.opentrades == 43 and maxOrders >= 44\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied42, limit=strategy.opentrades.entry_price\n     comment=\"Buy #44 \" + str.tostring(avgDown42 * 100, format.percent))\nif strategy.opentrades == 44 and maxOrders >= 45\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied43, limit=strategy.opentrades.entry_price\n     comment=\"Buy #45 \" + str.tostring(avgDown43 * 100, format.percent))\nif strategy.opentrades == 45 and maxOrders >= 46\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied44, limit=strategy.opentrades.entry_price\n     comment=\"Buy #46 \" + str.tostring(avgDown44 * 100, format.percent))\nif strategy.opentrades == 46 and maxOrders >= 47\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied45, limit=strategy.opentrades.entry_price\n     comment=\"Buy #47 \" + str.tostring(avgDown45 * 100, format.percent))\nif strategy.opentrades == 47 and maxOrders >= 48\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied46, limit=strategy.opentrades.entry_price\n     comment=\"Buy #48 \" + str.tostring(avgDown46 * 100, format.percent))\nif strategy.opentrades == 48 and maxOrders >= 49\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied47, limit=strategy.opentrades.entry_price\n     comment=\"Buy #49 \" + str.tostring(avgDown47 * 100, format.percent))\nif strategy.opentrades == 49 and maxOrders >= 50\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied48, limit=strategy.opentrades.entry_price\n     comment=\"Buy #50 \" + str.tostring(avgDown48 * 100, format.percent))\n if strategy.opentrades == 50 and maxOrders >= 51\n    strategy.entry(\"Bull #1\", strategy.long, qty=quantMultiplied49, limit=strategy.opentrades.entry_price\n     comment=\"Buy #51 \" + str.tostring(avgDown49 * 100, format.percent))\n// Exit Long Position\nstoplossPrice = 0.0\nif stoplossOn and strategy.opentrades == maxOrders\n    stoplossPrice := strategy.opentrades.entry_price(maxOrders - 1) * (1 - stoploss\nstrategy.exit(\"Bull #1\", limit=strategy.position_avg_price * (1 + takeProfit), stop\n// Find Max Number Of Orders\nmaxOrdersAtOnce = ta.highest(strategy.opentrades, 10000)\nlargestOrder = \"Highest # Of Open Trades \" + str.tostring(maxOrdersAtOnce, \"#.##\")\n// Function that calculates the average amount of bars in a trade.\navgBarsPerTrade() =>\n    sumBarsPerTrade = 0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        // Loop through all closed trades, starting with the oldest.\n        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index\n    result = nz(sumBarsPerTrade / strategy.closedtrades)\n//Label Text\nstoplossText = stoplossOn ? \"SL \" + str.tostring(stoploss*100, \"#.##\") + \"%\" : \"SL Off\"\npercToRecover = (((strategy.position_avg_price * (1 + takeProfit)) / close) - 1) *\navgPrice = \"Avg Price $\" + str.tostring(strategy.position_avg_price, \"#.##\")\npnl = \"Trade PnL \" + str.tostring(((close - strategy.position_avg_price) / strategy.position_avg_price\ntpPrice = \"TP Price $\" + str.tostring(strategy.position_avg_price * (1 + takeProfit\nposSize = \"Pos Size \" + str.tostring(strategy.position_size, \"#.##\") + \" Units\"\nnumOrders = \"# Of Open Orders \" +str.tostring(strategy.opentrades)\npercRecovery = \"From Take Profit \" + str.tostring(percToRecover, format.percent) +\nclosedTrades = \"Total # Trades \" + str.tostring(strategy.closedtrades)\ninitialCapital = \"Initial Capital $\" + str.tostring(strategy.initial_capital)\nmaxDrawdown = \"Max Drawdown $\" + str.tostring(strategy.max_drawdown, \"#.##\")\navgBarsPerTrade = \"Avg Bars Per Trade \" + str.tostring(avgBarsPerTrade(), \"#\")\ngrossProfit = \"Gross Profit $\" + str.tostring(strategy.grossprofit, \"#.##\")\nnetProfit = \"Net Profit $\" + str.tostring(strategy.netprofit, \"#.##\")\nequity = \"Portfolio Value $\" + str.tostring(strategy.equity, \"#.##\")\npercentProfit = \"Percent Profit \" + str.tostring((strategy.netprofit/strategy.initial_capital\n// Plot Average Price, SL And TP Level\navgPriceLine = plot(strategy.position_avg_price, title=\"Position Average Price\", color\ntpLevel = plot(strategy.position_avg_price * (1+takeProfit), title=\"Take Profit Level\"\nstopLevel = plot(stoplossOn and strategy.opentrades == maxOrders ? stoplossPrice :\n//Plot Price Difference Table\ndataTable = table.new(tablePosition, columns=2, rows=19, bgcolor= color.blue, frame_color\nif dataTableOn\n    table.cell(table_id=dataTable, column=0, row=0, text=\"Current Trade\", height=0\n    table.cell(table_id=dataTable, column=0, row=1, text=avgPrice, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=2, text=tpPrice, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=3, text=pnl, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=4, text=percRecovery, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=5, text=posSize, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=6, text=numOrders, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=7, text=\"Overall Performance\", height\n    table.cell(table_id=dataTable, column=0, row=8, text=closedTrades, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=9, text=largestOrder, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=10, text=maxDrawdown, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=11, text=avgBarsPerTrade, height=\n    table.cell(table_id=dataTable, column=0, row=12, text=grossProfit, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=13, text=netProfit, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=14, text=percentProfit, height=0,\n    table.cell(table_id=dataTable, column=0, row=15, text=equity, height=0, text_color\n    table.cell(table_id=dataTable, column=0, row=16, text=initialCapital, height=0\n    table.cell(table_id=dataTable, column=1, row=0, text=\"Settings\", height=0, text_color\n    table.cell(table_id=dataTable, column=1, row=1, text=stoplossText, height=0, text_color\n    table.cell(table_id=dataTable, column=1, row=2, text=\"TP \" + str.tostring(takeProfit\n    table.cell(table_id=dataTable, column=1, row=3, text=\"AD \" + str.tostring(avgDown\n    table.cell(table_id=dataTable, column=1, row=4, text=\"AD%M \" + str.tostring(percentScale\n    table.cell(table_id=dataTable, column=1, row=5, text=\"VM \" + str.tostring(multiplier\n    table.cell(table_id=dataTable, column=1, row=6, text=\"M#O \" + str.tostring(maxOrders\n    table.cell(table_id=dataTable, column=1, row=7, text=\"BO $\" + str.tostring(quantity\n// Share price too high for base order label\nwarningTable = table.new(position.top_center, columns=1, rows=1, bgcolor= color.orange\nif strategy.closedtrades == 0 and close > quantity\n    table.cell(table_id=warningTable, column=0, row=0, text=\"Share Price Is Higher Than Base Order\""}]}
{"messages": [{"role": "user", "content": "this just sample of our strategies we published with open source, to learning our investor the way of trading and analysis, this strategy just for study and learning  in this strategy we use expontial moving avarage 20 , 50 , 200 and the we build this strategy when the price move up ema 200 and ema 20,50 cross up the 200 ema in this conditions the strargey will open long postion  and the oppisit it is true for short postion in this sitation the price should be under ema 200 and the ema 20 , 50 should cross under 200 ema then the strategy will open the short postion  we try this strategy on forex ,crypto and futures and it give us  very good result ,, also we try this postion on multi time frame we find the stragey give us good result on 1 hour time frame . in the end our advice for you before you use any stratgy you should have the knowledg of the indecators how it is work and also you should have information about the market you trade and the last news for this market beacuse it effect so much on the price moving . so we hope this strategy give you brefing of the way we work and build our strategy"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 rt-maax\n//@version=5\nstrategy(title = \"rt maax EMA cross strategy\", shorttitle = \"rt maax ema \", overlay\n     currency = currency.USD, default_qty_type = strategy.cash, default_qty_value =\nfastema = ta.ema (close , 50)\nfema=ta.ema(close,20)\nslowema= ta.ema(close,200)\nprice = close\n// === INPUT BACKTEST RANGE ===\nfromMonth = input.int(defval = 1,    title = \"From Month\",  minval = 1, maxval = 12\nfromDay   = input.int(defval = 1,    title = \"From Day\",    minval = 1, maxval = 31\nfromYear  = input.int(defval = 2021, title = \"From Year\",   minval = 1970)\nthruMonth = input.int(defval = 10,    title = \"Thru Month\",  minval = 1, maxval = 12\nthruDay   = input.int(defval = 25,    title = \"Thru Day\",    minval = 1, maxval = 31\nthruYear  = input.int(defval = 2112, title = \"Thru Year\",   minval = 1970)\n// === INPUT SHOW PLOT ===\nshowDate  = input(defval = true, title = \"Show Date Range\")\n// === FUNCTION EXAMPLE ===\nlongCondition1= ta.crossover (fema , fastema) \nlongcondition2= fema> slowema\nlongcondition3=fastema>slowema\nif (longCondition1 and longcondition2 and longcondition3 )\n    stoploss=low*0.97\n    takeprofit=high*1.12\n    strategy.entry(\"Long Entry\", strategy.long)\n    strategy.exit (\"exit\",\"long\",stop=stoploss,limit=takeprofit)\n   shortCondition1 = ta.crossunder (fema , fastema )\nshortcondition2= fastema< slowema\nshortcondition3= fema< slowema\nif (shortCondition1 and shortcondition2 and shortcondition3 )\n    stoploss=low*0.97 \n    takeprofit=high*1.5\n    strategy.entry(\"Short Entry\", strategy.short)\n    strategy.exit(\"exit\",\"short\",stop=stoploss,limit=takeprofit)"}]}
{"messages": [{"role": "user", "content": "\u5747\u7dda\u64cd\u4f5c-\u6708\u5b63 \u9019\u662f\u5747\u7dda\u64cd\u4f5c-\u6708\u5b63 \u6b63\u5728\u6e2c\u8a66\u767c\u5e03"}, {"role": "assistant", "content": "//@version=4\nstrategy(\"\u5747\u7dda\u64cd\u4f5c-\u6708\u5b63\", overlay=true, initial_capital = 100000, default_qty_type = strategy.percent_of_equity\nsma20 = sma(close, 20)\nsma60 = sma(close, 60)\nplot(sma20, title=\"\u6708\u7dda\", color= color.purple,linewidth=2)\nplot(sma60, title=\"\u5b63\u7dda\", color= color.yellow,linewidth=2)\nbacktest_year = input(title=\"backtest_year\",type=input.integer,defval=2020)\nbacktest_month = input(title=\"backtest_month\",type=input.integer,defval=10)\nbacktest_date = input(title=\"backtest_date\",type=input.integer,defval=1)\nbacktest_start_time = timestamp(backtest_year,backtest_month,backtest_date,0,0,0)\nto_long = sma20 > sma60  and close > highest(10)*0.9 // \u9ec3\u91d1\u4ea4\u53c9\nto_close = sma20 < sma60 // \u6b7b\u4ea1\u4ea4\u53c9\nto_exit = close < highest(10)*0.9 //\u80a1\u50f9\u56b4\u91cd\u56de\u6a94\nto_stop = close < 0.9*strategy.position_avg_price \n// to_long = crossover(sma20, sma60)   // \u9ec3\u91d1\u4ea4\u53c9\n// to_close = crossunder(sma20, sma60) // \u6b7b\u4ea1\u4ea4\u53c9\n//plotchar(to_long, char=\"B\", text=\"\u8cb7\", color=color.red, location=location.belowbar)\n//plotchar(to_close, char=\"S\", text=\"\u8ce3\", color=color.green, location=location.abovebar)\n//strategy.close(\"open long\",when = tslide, comment=\"\u591a\u55ae\u6ed1\u50f97%\u51fa\u5834\")\nif time > backtest_start_time\n    strategy.entry(\"golden\", strategy.long,  when=to_long,comment=\"\u591a\u55ae\u5165\u5834\")\n    strategy.close(\"golden\",  when=to_exit,comment=\"\u591a\u55ae\u6ed1\u50f97%\u51fa\u5834\")\n    strategy.close(\"golden\",  when=to_close,comment=\"\u6708\u7dda\u5b63\u7dda\u6b7b\u4ea1\u4ea4\u53c9\")\n    strategy.close(\"golden\",  when=to_stop,comment=\"\u8667\u640d10%\u5f37\u8feb\u505c\u640d\")"}]}
{"messages": [{"role": "user", "content": "TestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTest TestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTest TestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTest TestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTest"}, {"role": "assistant", "content": "//@version=4\nstrategy(\"\u5747\u7dda\u64cd\u4f5c-\u6708\u5b63\", overlay=true, initial_capital = 100000, default_qty_type = strategy.percent_of_equity\nsma20 = sma(close, 20)\nsma60 = sma(close, 60)\nplot(sma20, title=\"\u6708\u7dda\", color= color.purple,linewidth=2)\nplot(sma60, title=\"\u5b63\u7dda\", color= color.yellow,linewidth=2)\nbacktest_year = input(title=\"backtest_year\",type=input.integer,defval=2020)\nbacktest_month = input(title=\"backtest_month\",type=input.integer,defval=10)\nbacktest_date = input(title=\"backtest_date\",type=input.integer,defval=1)\nbacktest_start_time = timestamp(backtest_year,backtest_month,backtest_date,0,0,0)\nto_long = sma20 > sma60  and close > highest(10)*0.9 // \u9ec3\u91d1\u4ea4\u53c9\nto_close = sma20 < sma60 // \u6b7b\u4ea1\u4ea4\u53c9\nto_exit = close < highest(10)*0.9 //\u80a1\u50f9\u56b4\u91cd\u56de\u6a94\nto_stop = close < 0.9*strategy.position_avg_price \n// to_long = crossover(sma20, sma60)   // \u9ec3\u91d1\u4ea4\u53c9\n// to_close = crossunder(sma20, sma60) // \u6b7b\u4ea1\u4ea4\u53c9\n//plotchar(to_long, char=\"B\", text=\"\u8cb7\", color=color.red, location=location.belowbar)\n//plotchar(to_close, char=\"S\", text=\"\u8ce3\", color=color.green, location=location.abovebar)\n//strategy.close(\"open long\",when = tslide, comment=\"\u591a\u55ae\u6ed1\u50f97%\u51fa\u5834\")\nif time > backtest_start_time\n    strategy.entry(\"golden\", strategy.long,  when=to_long,comment=\"\u591a\u55ae\u5165\u5834\")\n    strategy.close(\"golden\",  when=to_exit,comment=\"\u591a\u55ae\u6ed1\u50f97%\u51fa\u5834\")\n    strategy.close(\"golden\",  when=to_close,comment=\"\u6708\u7dda\u5b63\u7dda\u6b7b\u4ea1\u4ea4\u53c9\")\n    strategy.close(\"golden\",  when=to_stop,comment=\"\u8667\u640d10%\u5f37\u8feb\u505c\u640d\")"}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    Updating script to use my Net Liquidity Library. Now all you need to do is update the library version when I publish a new version of it"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 calebsandfort\n//@version=5\nstrategy(\"SPX Fair Value Strategy Ultimate\", overlay=false, initial_capital = 1000000\nimport calebsandfort/NetLiquidityLibrary/16\u200aas NetLiquidityLibrary\nmode = input.string(\"Short Only\", \"Strategy\", [\"Short Only\", \"Long Only\", \"Long/Short\"\ninverse = input.bool(false, \"Inverse\")\nstartDate = input.int(title=\"Start Day\", defval=31, minval=1, maxval=31)\nstartMonth = input.int(title=\"Start Month\", defval=12, minval=1, maxval=12)\nstartYear = input.int(title=\"Start Year\", defval=2021, minval=1800, maxval=2100)\n// See if this bar's time happened on/after start date\nafterStartDate = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate\nuseCloseDate = input.bool(true, title=\"Use Close Date\")\ncloseDay = input.int(title=\"Close Day\", defval=21, minval=1, maxval=31)\ncloseMonth = input.int(title=\"Close Month\", defval=10, minval=1, maxval=12)\ncloseYear = input.int(title=\"Close Year\", defval=2022, minval=1800, maxval=2100)  \n// See if this bar's time happened on/after end date\nafterEndDate = year == closeYear and month == closeMonth and dayofmonth == closeDay\nnet_liquidity = NetLiquidityLibrary.get_net_liquidity()\n// plotchar(year, \"year\", \"\", location.top)\n// plotchar(month, \"month\", \"\", location.top)\n// plotchar(dayofmonth, \"dayofmonth\", \"\", location.top)\n// plotchar(net_liquidity, \"net_liquidity\", \"\", location.top)\nspx_fair_value = net_liquidity/1000000000/1.1 -1625\nspx = request.security(\"SP:SPX\", \"D\", close)\ndiff = spx - spx_fair_value\nplot(spx_fair_value > 0 ? diff : na, title = \"Spread\", color =  color.orange, trackprice\nhline(350, title='Overbought', color= color.red, linestyle=hline.style_dotted, linewidth\nhline(0, title='Zero', color= color.gray, linestyle=hline.style_dotted, linewidth=\nhline(-150, title='Oversold', color= color.green, linestyle=hline.style_dotted, linewidth\noverbought_signal = net_liquidity > 0.0 and (diff[1] < 350 and diff[0] > 350)\noversold_signal = net_liquidity > 0.0 and (diff[1] > -150 and diff[0] < -150)\nbarcolor(overbought_signal ?  color.purple : oversold_signal ?  color.blue : na)\nqty = (strategy.initial_capital + strategy.netprofit + strategy.openprofit)/close\nqty_adj = strategy.opentrades > 0 ? math.abs(strategy.opentrades.size(0) * 1) : qty\nif (mode == \"Long/Short\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")        \n        else if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n        else if (afterStartDate and oversold_signal)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n        else if (afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Short Only\")\n    if (inverse)\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")\n    else\n        if (overbought_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and oversold_signal) or (useCloseDate and afterEndDate)\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\nelse if (mode == \"Long Only\")\n    if (inverse)\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Short\", strategy.short, qty = qty[0], comment = \"SE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Short\", qty_percent=100, comment=\"close\")\n    else\n        if (oversold_signal and afterStartDate)\n            strategy.entry(\"Long\", strategy.long, qty = qty[0], comment = \"LE\")\n                        if ((afterStartDate and overbought_signal) or (useCloseDate and afterEndDate\n            strategy.close(\"Long\", qty_percent=100, comment=\"close\")"}]}
{"messages": [{"role": "user", "content": "Today I am sharing with the community trend cross strategy template that incorporates any combination of over 20 built in indicators. Some of these indicators are in the Pine library, and some have been custom coded and contributed over time by the beloved Pine Coder community. Identifying a trend cross is a common trend following strategy and a common custom-code request from the community. Using this template, users can now select from over 400 different potential trend combinations and setup alerts without any custom coding required. This Multi-Trend cross template has a very inclusive library of trend calculations/indicators built-in, and will plot any of the 20+ indicators/trends that you can select in the settings. How it works: Simple trend cross strategies go long when the fast trend crosses over the slow trend, and/or go short when the fast trend crosses under the slow trend. Options for either trend direction are built-in to this strategy template. The script is also coded in a way that allows you to enable/modify pyramid settings and scale into a position over time after a trend has crossed. Use cases: These types of strategies can reduce the volatility of returns and can help avoid large market downswings. For instance, those running a longer term trend-cross strategy may have not realized half the down swing of the bear markets or crashes in 02', 08', 20', etc. However, in other years, they may have exited the market from time to time at unfavorable points that didn't end up being a down turn, or at times the market was ranging sideways. Some also use them to reduce volatility and then add leverage to attempt to beat buy/hold of the underlying asset within an acceptable drawdown threshold.  Special thanks to @Duyck, @everget, @KivancOzbilgic and @LazyBear for coding and contributing earlier versions of some of these custom indicators in Pine.  This script incorporates all of the following indicators. Each of them can be selected and modified from within the indicator settings:     ALMA - Arnaud Legoux Moving Average     DEMA - Double Exponential Moving Average     DSMA - Deviation Scaled Moving Average - Contributed by Everget     EMA - Exponential Moving Average     HMA - Hull Moving Average     JMA - Jurik Moving Average - Contributed by Everget     KAMA - Kaufman's Adaptive Moving Average - Contributed by Everget     LSMA - Linear Regression , Least Squares Moving Average     RMA - Relative Moving Average     SMA - Simple Moving Average     SMMA - Smoothed Moving Average     Price Source - Plotted based on source selection     TEMA - Triple Exponential Moving Average     TMA - Triangular Moving Average     VAMA - Volume Adjusted Moving Average - Contributed by Duyck     VIDYA - Variable Index Dynamic Average - Contributed by KivancOzbilgic     VMA - Variable Moving Average - Contributed by LazyBear     VWMA - Volume Weighted Moving Average     WMA - Weighted Moving Average     WWMA - Welles Wilder's Moving Average     ZLEMA - Zero Lag Exponential Moving Average - Contributed by KivancOzbilgic  Disclaimer: This is not financial advice. Open-source scripts I publish in the community are largely meant to spark ideas that can be used as building blocks for part of a more robust trade management strategy. If you would like to implement a version of any script, I would recommend making significant additions/modifications to the strategy & risk management functions. If you don\u2019t know how to program in Pine, then hire a Pine-coder. We can help!"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// @version=5\n// Author = TradeAutomation\nstrategy(title=\"Multi Trend Cross Strategy Template\", shorttitle=\"Multi Trend Cross Strategy\"\n// Backtest Date Range Inputs // \nStartTime = input.time(defval=timestamp('01 Jan 2000 05:00 +0000'), group=\"Date Range\"\nEndTime = input.time(defval=timestamp('01 Jan 2099 00:00 +0000'), group=\"Date Range\"\nInDateRange = time>=StartTime and time<=EndTime\n// Trend Selector //\nTrendSelectorInput = input.string(title=\"Fast Trend Selector\", defval=\"EMA\", group\nTrendSelectorInput2 = input.string(title=\"Slow Trend Selector\", defval=\"EMA\", group\nsrc = input.source(close, \"Price Source\", group=\"Core Settings\", tooltip=\"This is the price source being used for the trend\nlength = input.int(10, \"Fast Trend Length\", group=\"Core Settings\", step=5, tooltip\nlength2 = input.int(200, \"Slow Trend Length\", group=\"Core Settings\", step=5, tooltip\nLineWidth = input.int(1, \"Line Width\", group=\"Core Settings\", tooltip=\"This is the width of the line plotted that repres\n// Individual Moving Average / Regression Setting //\nAlmaOffset = input.float(0.85, \"ALMA Offset\", group=\"Individual Trend Settings\", tooltip\nAlmaSigma = input.float(6, \"ALMA Sigma\", group=\"Individual Trend Settings\", tooltip\nATRFactor = input.float(3, \"ATR Multiplier For SuperTrend\", group=\"Individual Trend Settings\"\nATRLength = input.int(12, \"ATR Length For SuperTrend\", group=\"Individual Trend Settings\"\nssfLength = input.int(20, \"DSMA Super Smoother Filter Length\", minval=1, tooltip=\"This only applies when EDSMA is selected\"\nssfPoles = input.int(2, \"DSMA Super Smoother Filter Poles\", options=[2, 3], tooltip\nJMApower = input.int(2, \"JMA Power Parameter\", group=\"Individual Trend Settings\", \nphase = input.int(-45, title=\"JMA Phase Parameter\", step=10, minval=-110, maxval=110\nKamaAlpha = input.float(3, \"KAMA's Alpha\", minval=1,step=0.5, group=\"Individual Trend Settings\"\nLinRegOffset = input.int(0, \"Linear Regression Offset\", group=\"Individual Trend Settings\"\nVAMALookback =input.int(12, \"VAMA Volatility lookback\", group=\"Individual Trend Settings\"\n// Trend Indicators With Library Functions //\nALMA = ta.alma(src, length, AlmaOffset, AlmaSigma) \nEMA = ta.ema(src, length)\nHMA = ta.hma(src, length)\nLinReg = ta.linreg(src, length, LinRegOffset)\nRMA = ta.rma(src, length)\nSMA = ta.sma(src, length)\nVWMA = ta.vwma(src, length)\nWMA = ta.wma(src, length)\nALMA2 = ta.alma(src, length2, AlmaOffset, AlmaSigma) \nEMA2 = ta.ema(src, length2)\nHMA2 = ta.hma(src, length2)\nLinReg2 = ta.linreg(src, length2, LinRegOffset)\nRMA2 = ta.rma(src, length2)\nSMA2 = ta.sma(src, length2)\nVWMA2 = ta.vwma(src, length2)\nWMA2 = ta.wma(src, length2)\n// Additional Trend Indicators Built In And/Or Open Sourced //\n//DEMA\nde1 = ta.ema(src, length)\nde2 = ta.ema(de1, length)\nDEMA = 2 * de1 - de2\nde3 = ta.ema(src, length2)\nde4 = ta.ema(de3, length2)\nDEMA2 = 2 * de3 - de4\n// Ehlers Deviation-Scaled Moving Average - DSMA [Everget]\nPI = 2 * math.asin(1)\nget2PoleSSF(src, length) =>\n    arg = math.sqrt(2) * PI / length\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(arg)\n    c2 = b1\n    c3 = -math.pow(a1, 2)\n    c1 = 1 - c2 - c3\n    var ssf = 0.0\n    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])\nget3PoleSSF(src, length) =>\n    arg = PI / length\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(1.738 * arg)\n    c1 = math.pow(a1, 2)\n    coef2 = b1 + c1\n    coef3 = -(c1 + b1 * c1)\n    coef4 = math.pow(c1, 2)\n    coef1 = 1 - coef2 - coef3 - coef4\n    var ssf = 0.0\n    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[\nzeros = src - nz(src[2])\navgZeros = (zeros + zeros[1]) / 2\n// Ehlers Super Smoother Filter \nssf = ssfPoles == 2\n     ? get2PoleSSF(avgZeros, ssfLength)\n     : get3PoleSSF(avgZeros, ssfLength)\n// Rescale filter in terms of Standard Deviations\nstdev = ta.stdev(ssf, length)\nscaledFilter = stdev != 0\n     ? ssf / stdev\n     : 0\nalpha1 = 5 * math.abs(scaledFilter) / length\nEDSMA = 0.0\nEDSMA := alpha1 * src + (1 - alpha1) * nz(EDSMA[1])\nget2PoleSSF2(src, length2) =>\n    arg = math.sqrt(2) * PI / length2\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(arg)\n    c2 = b1\n    c3 = -math.pow(a1, 2)\n    c1 = 1 - c2 - c3\n    var ssf2 = 0.0\n    ssf2 := c1 * src + c2 * nz(ssf2[1]) + c3 * nz(ssf2[2])\nget3PoleSSF2(src, length2) =>\n    arg = PI / length2\n    a1 = math.exp(-arg)\n    b1 = 2 * a1 * math.cos(1.738 * arg)\n    c1 = math.pow(a1, 2)\n    coef2 = b1 + c1\n    coef3 = -(c1 + b1 * c1)\n    coef4 = math.pow(c1, 2)\n    coef1 = 1 - coef2 - coef3 - coef4\n    var ssf2 = 0.0\n    ssf2 := coef1 * src + coef2 * nz(ssf2[1]) + coef3 * nz(ssf2[2]) + coef4 * nz(ssf2\n// Ehlers Super Smoother Filter \nssf2 = ssfPoles == 2\n     ? get2PoleSSF2(avgZeros, ssfLength)\n     : get3PoleSSF2(avgZeros, ssfLength)\n// Rescale filter in terms of Standard Deviations\nstdev2 = ta.stdev(ssf2, length2)\nscaledFilter2 = stdev2 != 0\n     ? ssf2 / stdev2\n     : 0\nalpha12 = 5 * math.abs(scaledFilter2) / length2\nEDSMA2 = 0.0\nEDSMA2 := alpha12 * src + (1 - alpha12) * nz(EDSMA2[1])\n//JMA [Everget]\nphaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5\nbeta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)\nalpha = math.pow(beta, JMApower)\nvar JMA = 0.0\nvar e0 = 0.0\ne0 := (1 - alpha) * src + alpha * nz(e0[1])\nvar e1 = 0.0\ne1 := (src - e0) * (1 - beta) + beta * nz(e1[1])\nvar e2 = 0.0\ne2 := (e0 + phaseRatio * e1 - nz(JMA[1])) * math.pow(1 - alpha, 2) + math.pow(alpha\nJMA := e2 + nz(JMA[1])\nbeta2 = 0.45 * (length2 - 1) / (0.45 * (length2 - 1) + 2)\nalpha2 = math.pow(beta2, JMApower)\nvar JMA2 = 0.0\nvar e02 = 0.0\ne02 := (1 - alpha2) * src + alpha2 * nz(e02[1])\nvar e12 = 0.0\ne12 := (src - e02) * (1 - beta2) + beta2 * nz(e12[1])\nvar e22 = 0.0\ne22 := (e02 + phaseRatio * e12 - nz(JMA2[1])) * math.pow(1 - alpha2, 2) + math.pow\nJMA2 := e22 + nz(JMA2[1])\n//KAMA [Everget]\nvar KAMA = 0.0\nfastAlpha = 2.0 / (KamaAlpha + 1)\nslowAlpha = 2.0 / 31\nmomentum = math.abs(ta.change(src, length))\nvolatility = math.sum(math.abs(ta.change(src)), length)\nefficiencyRatio = volatility != 0 ? momentum / volatility : 0\nsmoothingConstant = math.pow((efficiencyRatio * (fastAlpha - slowAlpha)) + slowAlpha\nKAMA := nz(KAMA[1], src) + smoothingConstant * (src - nz(KAMA[1], src))\nvar KAMA2 = 0.0\nmomentum2 = math.abs(ta.change(src, length2))\nvolatility2 = math.sum(math.abs(ta.change(src)), length2)\nefficiencyRatio2 = volatility2 != 0 ? momentum2 / volatility2 : 0\nsmoothingConstant2 = math.pow((efficiencyRatio2 * (fastAlpha - slowAlpha)) + slowAlpha\nKAMA2 := nz(KAMA2[1], src) + smoothingConstant2 * (src - nz(KAMA2[1], src))\n//SMMA\nvar SMMA = 0.0\nSMMA := na(SMMA[1]) ? ta.sma(src, length) : (SMMA[1] * (length - 1) + src) / length\nvar SMMA2 = 0.0\nSMMA2 := na(SMMA2[1]) ? ta.sma(src, length2) : (SMMA2[1] * (length2 - 1) + src) / \n//TEMA\nt1 = ta.ema(src, length)\nt2 = ta.ema(t1, length)\nt3 = ta.ema(t2, length)\nTEMA = 3 * (t1 - t2) + t3\nt12 = ta.ema(src, length2)\nt22 = ta.ema(t12, length2)\nt32 = ta.ema(t22, length2)\nTEMA2 = 3 * (t12 - t22) + t32\n//TMA\nTMA = ta.sma(ta.sma(src, math.ceil(length / 2)), math.floor(length / 2) + 1)\nTMA2 = ta.sma(ta.sma(src, math.ceil(length2 / 2)), math.floor(length2 / 2) + 1)\n//VAMA [Duyck]\nmid=ta.ema(src,length)\ndev=src-mid\nvol_up=ta.highest(dev,VAMALookback)\nvol_down=ta.lowest(dev,VAMALookback)\nVAMA = mid+math.avg(vol_up,vol_down)\nmid2=ta.ema(src,length2)\ndev2=src-mid2\nvol_up2=ta.highest(dev2,VAMALookback)\nvol_down2=ta.lowest(dev2,VAMALookback)\nVAMA2 = mid2+math.avg(vol_up2,vol_down2)\n//VIDYA [KivancOzbilgic]\nvar VIDYA=0.0\nVMAalpha=2/(length+1)\nud1=src>src[1] ? src-src[1] : 0\ndd1=src<src[1] ? src[1]-src : 0\nUD=math.sum(ud1,9)\nDD=math.sum(dd1,9)\nCMO=nz((UD-DD)/(UD+DD))\nVIDYA := na(VIDYA[1]) ? ta.sma(src, length) : nz(VMAalpha*math.abs(CMO)*src)+(1-VMAalpha\nvar VIDYA2=0.0\nVMAalpha2=2/(length2+1)\nud12=src>src[1] ? src-src[1] : 0\ndd12=src<src[1] ? src[1]-src : 0\nUD2=math.sum(ud12,9)\nDD2=math.sum(dd12,9)\nCMO2=nz((UD2-DD2)/(UD2+DD2))\nVIDYA2 := na(VIDYA2[1]) ? ta.sma(src, length2) : nz(VMAalpha2*math.abs(CMO2)*src)+\n//VMA [LazyBear]\nsc = 1/length\npdm = math.max((src - src[1]), 0)\nmdm = math.max((src[1] - src), 0)\nvar pdmS = 0.0\nvar mdmS = 0.0\npdmS := ((1 - sc)*nz(pdmS[1]) + sc*pdm)\nmdmS := ((1 - sc)*nz(mdmS[1]) + sc*mdm)\ns = pdmS + mdmS\npdi = pdmS/s\nmdi = mdmS/s\nvar pdiS = 0.0\nvar mdiS = 0.0\npdiS := ((1 - sc)*nz(pdiS[1]) + sc*pdi)\nmdiS := ((1 - sc)*nz(mdiS[1]) + sc*mdi)\nd = math.abs(pdiS - mdiS)\ns1 = pdiS + mdiS\nvar iS = 0.0\niS := ((1 - sc)*nz(iS[1]) + sc*d/s1)\nhhv = ta.highest(iS, length) \nllv = ta.lowest(iS, length) \nd1 = hhv - llv\nvi = (iS - llv)/d1\nvar VMA=0.0\nVMA := na(VMA[1]) ? ta.sma(src, length) : sc*vi*src + (1 - sc*vi)*nz(VMA[1])\nsc2 = 1/length2\npdm2 = math.max((src - src[1]), 0)\nmdm2 = math.max((src[1] - src), 0)\nvar pdmS2 = 0.0\nvar mdmS2 = 0.0\npdmS2 := ((1 - sc2)*nz(pdmS2[1]) + sc2*pdm2)\nmdmS2 := ((1 - sc2)*nz(mdmS2[1]) + sc2*mdm2)\ns2 = pdmS2 + mdmS2\npdi2 = pdmS2/s2\nmdi2 = mdmS2/s2\nvar pdiS2 = 0.0\nvar mdiS2 = 0.0\npdiS2 := ((1 - sc2)*nz(pdiS2[1]) + sc2*pdi2)\nmdiS2 := ((1 - sc2)*nz(mdiS2[1]) + sc2*mdi2)\nd2 = math.abs(pdiS2 - mdiS2)\ns12 = pdiS2 + mdiS2\nvar iS2 = 0.0\niS2 := ((1 - sc2)*nz(iS2[1]) + sc2*d2/s12)\nhhv2 = ta.highest(iS2, length) \nllv2 = ta.lowest(iS2, length) \nd12 = hhv2 - llv2\nvi2 = (iS2 - llv2)/d12\nvar VMA2=0.0\nVMA2 := na(VMA2[1]) ? ta.sma(src, length2) : sc2*vi2*src + (1 - sc2*vi2)*nz(VMA2[1\n//WWMA\nvar WWMA=0.0\nWWMA := (1/length)*src + (1-(1/length))*nz(WWMA[1])\nvar WWMA2=0.0\nWWMA2 := (1/length2)*src + (1-(1/length2))*nz(WWMA2[1])\n//Zero Lag EMA [KivancOzbilgic]\nEMA1a = ta.ema(src,length)\nEMA2a = ta.ema(EMA1a,length)\nDiff = EMA1a - EMA2a\nZLEMA = EMA1a + Diff\nEMA12 = ta.ema(src,length2)\nEMA22 = ta.ema(EMA12,length2)\nDiff2 = EMA12 - EMA22\nZLEMA2 = EMA12 + Diff2\n// Trend Mapping and Plotting //\nFastTrend = TrendSelectorInput == \"ALMA\" ? ALMA : TrendSelectorInput == \"DEMA\" ? DEMA\nSlowTrend = TrendSelectorInput2 == \"ALMA\" ? ALMA2 : TrendSelectorInput2 == \"DEMA\" \nplot(FastTrend, color= color.green, linewidth=LineWidth)\nplot(SlowTrend, color= color.red, linewidth=LineWidth)\n//Short & Long Options\nLong = input.bool(true, \"Model Long Trades\", group=\"Core Settings\")\nShort = input.bool(false, \"Model Short Trades\", group=\"Core Settings\")\n// Entry & Exit Functions //\nif (InDateRange and Long==true and FastTrend>SlowTrend)\n    strategy.entry(\"Long\", strategy.long, alert_message=\"Long\")\nif (InDateRange and Long==true and FastTrend<SlowTrend)\n    strategy.close(\"Long\", alert_message=\"Close Long\")\nif (InDateRange and Short==true and FastTrend<SlowTrend)\n    strategy.entry(\"Short\", strategy.short, alert_message=\"Short\")\nif (InDateRange and Short==true and FastTrend>SlowTrend)\n    strategy.close(\"Short\", alert_message=\"Cover Short\")  \nif (not InDateRange)\n    strategy.close_all(alert_message=\"End of Date Range\")"}]}
{"messages": [{"role": "user", "content": "This is a strategy using Bollinger Bands. The strategy is predicated around having low volatility in price action and then looking to capture a move when price starts to trend outside of the Bollinger bands. This strategy has only been backtested for 1 month but it has promising results so I will be sharing it looking for feedback. I run this strategy on the ERUSD 1 min chart."}, {"role": "assistant", "content": "//@version=4\n// Step 1) Define strategy settings\nstrategy(title=\"BOLLY Bands\", overlay=true, pyramiding=4, initial_capital=100000, commission_type\n// BOLLY \nlength = input(22, minval=1)\nsrc = input(ohlc4, title=\"Source\")\nmult = input(title=\"StdDev\", type=input.float , defval=2.0, minval=0.001, maxval=50\nbasis = sma(src, length)\ndev = mult * stdev(src, length)\nupper = basis + dev\nlower = basis - dev\noffset = input(type=input.integer, defval=0, title = \"Offset\", minval = -500, maxval\nplot(basis, \"Basis\", color= #FF6D00, offset = offset)\np1 = plot(upper, \"Upper\", color= #2962FF, offset = offset)\np2 = plot(lower, \"Lower\", color= #2962FF, offset = offset)\nfill(p1, p2, title = \"Background\", color= color.rgb(33, 150, 243, 95))\n// Stop loss inputs\natrLen = input(title=\"ATR Length\", type=input.integer, defval=10)\nstopOffset = input(title=\"Stop Offset Multiple\", type=input.float, defval=2, step=.25\n// Position sizing inputs\nusePosSize = input(title=\"Use Position Sizing?\", type=input.bool, defval=true)\nmaxRisk = input(title=\"Max Position Risk %\", type=input.float, defval=2, step=.25)\nmaxExposure = input(title=\"Max Position Exposure %\", type=input.float, defval=10, step\nmarginPerc = input(title=\"Margin %\", type=input.integer, defval=10)\natrValue = atr(atrLen)\nt1 = time(timeframe.period, \"0000-2400\")\nbgcolor(t1 ?  color.blue : na)\ntradeWindow = t1\n// Calculate position size\nriskEquity = maxRisk * 0.01 * strategy.equity\nriskTrade = atrValue * stopOffset * syminfo.pointvalue\nmaxPos = maxExposure * 0.01 * strategy.equity / \n   (marginPerc * 0.01 * close * syminfo.pointvalue)\nposSize = usePosSize ? min(floor(riskEquity / riskTrade), maxPos) : 1\ndistance = upper - lower\nenterLong = close < lower and tradeWindow and dev < 0.00025\nenterShort = close > upper and tradeWindow and dev < 0.00025\ntp=input(title = \"Take Profit (PIPs)\", type=input.integer, defval=300, step=25)\nsl=input(title = \"Stop Loss (PIPs)\", type=input.integer, defval=100, step=25)\ntrailPTS = input(title=\"Trail Points\", type=input.integer, defval=70, step=10)\ntrailOff = input(title=\"Trail Offset\", type=input.integer, defval=30, step=10)\n// Step 6) Submit entry orders\nif enterLong\n    strategy.entry(id=\"EL\", long=true, qty=posSize)\nif enterShort\n    strategy.entry(id=\"ES\", long=false, qty=posSize)\nif (strategy.position_size > 0)\n    strategy.exit(id=\"XL\", from_entry=\"EL\", trail_points = trailPTS, trail_offset =\nif (strategy.position_size > 0)\n    strategy.exit(id=\"XL1\", from_entry=\"EL\", profit = tp, qty_percent = 100, comment\nif (strategy.position_size > 0)\n    strategy.exit(id=\"XL2\", from_entry=\"EL\", loss = sl, qty_percent = 100, comment \nif (strategy.position_size < 0)\n    strategy.exit(id=\"XS\", from_entry=\"ES\", trail_points = trailPTS, trail_offset =\nif (strategy.position_size < 0)\n    strategy.exit(id=\"XS1\", from_entry=\"EL\", profit = tp, qty_percent = 100, comment\nif (strategy.position_size < 0)\n    strategy.exit(id=\"XS2\", from_entry=\"EL\", loss = sl, qty_percent = 100, comment \nstrategy.close_all(when=not tradeWindow)"}]}
{"messages": [{"role": "user", "content": "This script is just for reference to see the trading range. Do not use this strategy logic, it is just Test strategy. The trading range is colored depending on whether it is profitable or not. You can change the color if you want. When you declare the strategy, put (process_orders_on_close=true,calc_on_every_tick=true, max_boxes_count=500) in your script. Then it can show you current open trading as well. If you use switching strategy (e.g longposition to shortposition right away), it may not show you the range properly. In that case, reduse the test period. IT IS Repainting Reference. If you want to see your strategy result visually, Just copy and paste from line 22 in my script. Good Luck everyone. \u110c\u1165\u11ab\u1105\u1163\u11a8 \u1100\u1165\u1105\u1162 \u1100\u1175\u1100\u1161\u11ab \u1103\u1169\u11bc\u110b\u1161\u11ab\u110b\u1173\u11af \u1107\u1169\u110b\u1167\u110c\u116e\u1102\u1173\u11ab \u110c\u1175\u1111\u116d\u110b\u1175\u11b8\u1102\u1175\u1103\u1161. \u110b\u1175 \u110c\u1175\u1111\u116d\u110b\u1166 \u110a\u1173\u110b\u1175\u11ab \u110c\u1165\u11ab\u1105\u1163\u11a8\u110b\u1173\u11ab \u1103\u1161\u11ab\u1109\u116e\u11ab \u1110\u1166\u1109\u1173\u1110\u1173\u110b\u116d\u11bc \u110b\u1175\u11b8\u1102\u1175\u1103\u1161. \u110c\u1165\u11af\u1103\u1162 \u1109\u1161\u110b\u116d\u11bc\u1112\u1161\u110c\u1175 \u1106\u1161\u1109\u1166\u110b\u116d. \u1100\u1161\u11a8 \u1100\u1165\u1105\u1162\u1100\u1175\u1100\u1161\u11ab\u110b\u1173\u11ab \u1109\u116e\u110b\u1175\u11a8\u110b\u1175\u1102\u1163 \u110b\u1161\u1102\u1175\u1102\u1163\u110b\u1166 \u1104\u1161\u1105\u1161 \u1109\u1162\u11a8\u1101\u1161\u11af\u110b\u1175 \u110c\u1165\u11bc\u1112\u1162 \u110c\u1175\u11b8\u1102\u1175\u1103\u1161. \u1109\u1162\u11a8\u1101\u1161\u11af\u110b\u1173\u11ab \u110b\u1167\u1105\u1165\u1107\u116e\u11ab\u110b\u1175 \u1107\u1167\u11ab\u1100\u1167\u11bc\u1112\u1161\u1109\u1175\u11af \u1109\u116e \u110b\u1175\u11bb\u1109\u1173\u11b8\u1102\u1175\u1103\u1161. \u110c\u1165\u11ab\u1105\u1163\u11a8\u110b\u1173\u11af \u1109\u1165\u11ab\u110b\u1165\u11ab\u1107\u116e\u110b\u1166 process_orders_on_close=true,calc_on_every_tick=true, max_boxes_count=500 \u110b\u1173\u11af \u1102\u1165\u11c2\u110b\u1173\u1109\u1175\u1106\u1167\u11ab \u1112\u1167\u11ab\u110c\u1162 \u110b\u1169\u1111\u1173\u11ab \u1100\u1165\u1105\u1162\u1103\u1169 \u1107\u1169\u1109\u1175\u11af \u1109\u116e \u110b\u1175\u11bb\u1109\u1173\u11b8\u1102\u1175\u1103\u1161. \u1109\u1173\u110b\u1171\u110e\u1175\u11bc \u110c\u1165\u11ab\u1105\u1163\u11a8(\u1105\u1169\u11bc\u110b\u1166\u1109\u1165 \u1109\u116d\u11ba\u110b\u1173\u1105\u1169 \u1107\u1161\u1105\u1169 \u110c\u1165\u11ab\u1112\u116a\u11ab\u1112\u1161\u1102\u1173\u11ab \u110c\u1165\u11ab\u1105\u1163\u11a8)\u110b\u1173\u11af \u110a\u1173\u1109\u1175\u1102\u1173\u11ab \u1107\u116e\u11ab\u1103\u1173\u11af\u110b\u1173\u11ab \u110b\u1161\u1106\u1161 \u1110\u1166\u1109\u1173\u1110\u1173 \u1100\u1175\u1100\u1161\u11ab\u110b\u1173\u11af \u110c\u116e\u11af\u110b\u1175\u1105\u1161\u1102\u1173\u11ab \u1100\u1167\u11bc\u1100\u1169\u1105\u1173\u11af \u1107\u1161\u11ae\u110b\u1173\u1109\u1175\u11af \u1109\u116e \u110b\u1175\u11bb\u1109\u1173\u11b8\u1102\u1175\u1103\u1161. \u110b\u1175 \u110c\u1175\u1111\u116d\u1102\u1173\u11ab \u1105\u1175\u1111\u1166\u110b\u1175\u1110\u1175\u11bc\u110b\u1175 \u1103\u116c\u11af \u1109\u116e \u110b\u1175\u11bb\u1109\u1173\u11b8\u1102\u1175\u1103\u1161. \u110c\u1165\u11ab\u1105\u1163\u11a8 \u1100\u1167\u11af\u1100\u116a\u1105\u1173\u11af \u1102\u116e\u11ab\u110b\u1173\u1105\u1169 \u1107\u1169\u1100\u1169 \u1109\u1175\u11c1\u110b\u1173\u1109\u1175\u11ab \u1107\u116e\u11ab\u1103\u1173\u11af\u110b\u1173\u11ab 22\u1107\u1165\u11ab\u110d\u1162 \u110c\u116e\u11af \u1107\u116e\u1110\u1165 \u110f\u1161\u1111\u1175\u1112\u1161\u1109\u1175\u1106\u1167\u11ab \u1103\u116c\u11b8\u1102\u1175\u1103\u1161. \u1112\u1162\u11bc\u110b\u116e\u11ab\u110b\u1175 \u110b\u1175\u11bb\u1100\u1175\u11af.. ---strategy set--- default_qty_value=10 commission_value=0.04 slippage=2"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 potatoshop\n//@version=5\nstrategy(\"Trading range display with Box\",\"Box\", overlay = true,process_orders_on_close\n  commission_type=strategy.commission.percent,default_qty_value=10,commission_value\n// Just simple strategy for test. Put your strategy here. \na= ta.sma(close, 14)\nb= ta.sma(close, 20)\nplot(a,color= color.white)\nplot(b,color= color.blue)\nlongCondition = ta.crossover(a,b)\nif (longCondition)\n    strategy.entry(\"L\", strategy.long)\ncloseCondition = ta.crossunder(a,b)\nif (closeCondition)\n    strategy.close(\"L\",comment = \"CL\")\n// From here on, just Copy and Paste  \n// 1.Making the trading signal to get the (left,right) for Box.     left, right \ub97c \uad6c\ud558\uae30 \uc704\ud55c \uc2dc\uadf8\ub110 \nis_trading = strategy.position_size != 0                     // \uac70\ub798 \ud3ec\uc9c0\uc158\uc774 0\uc774 \uc544\ub2c8\uba74 \uac70\ub798\uc911\uc73c\ub85c \ud310\ub2e8\ud558\uba70, true\ub97c \ub9ac\ud134.\nis_trading_L = strategy.position_size > 0\nis_trading_S = strategy.position_size < 0\ntradingstart = (is_trading == true and is_trading[1] == false)     \ntradingstart_L =  (is_trading_L == true and is_trading_L[1] == false)  \ntradingstart_S =  (is_trading_S == true and is_trading_S[1] == false)  \ntradingend = (is_trading == false and is_trading[1] == true)           \ntradingend_L =  (is_trading_L == false and is_trading_L[1] == true)    \ntradingend_S =  (is_trading_S == false and is_trading_S[1] == true)    \n// plotchar(tradingstart,text=\"start\",textcolor = color.white) // check the signal \uc2dc\uadf8\ub110 \ud655\uc778\uc6a9.\n// plotshape(tradingend,text=\"End\",textcolor = color.white)   \n// 2.Get the left, right.                        left, right \uc5d0 \uc88c\ud45c \uae30\uc900 \ub9cc\ub4e4\uc5b4 \uc8fc\uae30. \nvar left_L = bar_index , var left_S = bar_index \nvar right_L = bar_index , var right_S = bar_index \nif tradingstart_L \n    left_L := bar_index -1                                       // \uac70\ub798 \uc2dc\uc791\uc774 \ud655\uc815\ub41c \ubd09\uc774 \uc9c4\uc9dc \uc2dc\uc810\ubcf4\ub2e4 1\ubd09 \uc774\ud6c4\uc5d0 \ub098\uc624\ubbc0\ub85c \uc77c\ubd80\ub7ec -1\uc744 \ud588\ub2e4.\nif tradingend_L or (barstate.islast and is_trading_L)              // \uacfc\uac70\ub370\uc774\ud0c0\ub97c \ucc98\ub9ac\ud560\ub54c\ub294 \uac70\ub798 \uc885\ub8cc \uc2dc\uc810\ub9cc \ud544\uc694\ud558\uc9c0\ub9cc, \ud604\uc7ac \uac70\ub798\uc911\uc77c\ub54c\ub294 \uc9c0\uae08\uc758 \uc815\ubcf4\ub97c \n    right_L := bar_index -1\nif tradingstart_S\n    left_S := bar_index -1                                       \nif tradingend_S or (barstate.islast and is_trading_S)               \n    right_S := bar_index -1\n//3.We need two box to make body and wick.    body \uc640 wick \ub290\ub08c\uc73c\ub85c \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c top, bottom\uc744 \uac01\uac01 \ub098\ub204\uc5b4 \ub9cc\ub4e4\uc5c8\ub2e4. \nentry = barstate.islast and is_trading? strategy.opentrades.entry_price(strategy.opentrades\nexit = barstate.islast ? close : strategy.closedtrades.exit_price(strategy.closedtrades\n// body\ntop_body = math.max(entry,exit)            \nbottom_body = math.min(entry,exit)\n// wick\nlen_L = right_L and left_L ?  right_L - left_L +1 : 1   \nhigh_session_L = ta.highest(high,len_L)\nlow_session_L = ta.lowest(low,len_L)\nlen_S = right_S and left_S ?  right_S - left_S +1 : 1   \nhigh_session_S = ta.highest(high,len_S)\nlow_session_S = ta.lowest(low,len_S)\n// Box color part.\nDEFAULT_COLOR_GROWTH =  color.rgb(0, 150, 136, 50)\nDEFAULT_COLOR_FALL =  color.rgb(244, 67, 54, 50)\ncolor_growth = input.color(DEFAULT_COLOR_GROWTH, title='', inline='Body')\ncolor_fall = input.color(DEFAULT_COLOR_FALL, title='Body', inline='Body')\ncolor_border_growth = color.rgb(color.r(color_growth), color.g(color_growth), color.b\ncolor_border_fall = color.rgb(color.r(color_fall), color.g(color_fall), color.b(color_fall\npast_profit = strategy.closedtrades.profit(strategy.closedtrades-1)\nnow_profit = strategy.opentrades.profit(strategy.opentrades-1)\ncolorBD =  barstate.islast and is_trading? (now_profit > 0 ? color_growth : color_fall\ncolorBL =  barstate.islast and is_trading? (now_profit > 0 ? color_border_growth :\n// 4. Box part\nvar box last_box1_L = na\nvar box last_box2_L = na\n// Long Position Box\nif tradingend_L and not barstate.isrealtime // 1. \uacfc\uac70 \ub370\uc774\ud0c0\ub85c \ud655\uc778\ub41c \ubd09\uc5d0\uc11c\ub9cc \uc2e4\ud589.\n    box.delete(last_box1_L) , box.delete(last_box2_L)\n    box.new(left_L,high_session_L,right_L,low_session_L, border_color = colorBL, bgcolor\n    box.new(left_L,top_body,right_L,bottom_body, border_color = colorBD, bgcolor =\n    left_L := na\n    right_L := na\nif barstate.islast                         // 2. \ud604\uc7ac\ubd09\uc5d0\uc11c \uac70\ub798\uc911\uc778\uc9c0 \ud655\uc778\ud6c4 \uc2e4\ud589. \n    if tradingend_L\n        last_box1_L := na\n        last_box2_L := na        \n    else if is_trading_L\n        right_L := bar_index -1              \n        box.delete(last_box1_L) , box.delete(last_box2_L)\n        last_box1_L := box.new(left_L,high_session_L,right_L,low_session_L, border_color\n        last_box2_L := box.new(left_L,top_body,right_L,bottom_body, border_color =\n// Short Position Box\nvar box last_box1_S = na\nvar box last_box2_S = na\nif tradingend_S and not barstate.isrealtime \n    box.delete(last_box1_S) , box.delete(last_box2_S)\n    box.new(left_S,high_session_S,right_S,low_session_S, border_color = colorBL, bgcolor\n    box.new(left_S,top_body,right_S,bottom_body, border_color = colorBD, bgcolor =\n    left_S := na\n    right_S := na\nif barstate.islast                         \n    if tradingend\n        last_box1_S := na\n        last_box2_S := na        \n    else if is_trading_S\n        right_S := bar_index -1              \n        box.delete(last_box1_S) , box.delete(last_box2_S)\n        last_box1_S := box.new(left_S,high_session_S,right_S,low_session_S, border_color\n        last_box2_S := box.new(left_S,top_body,right_S,bottom_body, border_color ="}]}
{"messages": [{"role": "user", "content": "Release Notes:                                                    English: - You can now specify an ending date for testings, with the previously available starting date you can customize testing date range. Espa\u00f1ol: - Ahora puedes especificar una fecha de finalizaci\u00f3n para las pruebas, con la fecha de inicio disponible anteriormente ya puedes personalizar el rango completo de testeo.                                                    Release Notes:                                                    English: - Fixed Stop Loss ATR bug. Espa\u00f1ol: - Arreglado bug con el Stop Loss tipo ATR."}, {"role": "assistant", "content": "// Copyright \u00a9 2022, Jos\u00e9 Manuel Gassin P\u00e9rez-Traverso, All rights reserved.\n// \u00a9 JoseMetal\n//@version=5\n// \u00c9sta estrategia se basa en los rebotes de canales (ya sea Bandas de Bollinger o Keltner \n// elegir el tipo de stop loss o take profit, ya sea utilizando m\u00ednimos/m\u00e1ximos anteriores, ATR o \n// La entrada de posiciones tambi\u00e9n tiene variedad de opciones, por ejemplo, se puede entrar cuando \n// De \u00e9ste modo y con todas \u00e9stas opciones se puede realizar un backtest exhaustivo para buscar \n//== Constantes\nc_verde_radiactivo =  color.rgb(0, 255, 0, 0)\nc_verde            =  color.rgb(0, 128, 0, 0)\nc_verde_oscuro     =  color.rgb(0, 80, 0, 0)\nc_rojo_radiactivo  =  color.rgb(255, 0, 0, 0)\nc_rojo             =  color.rgb(128, 0, 0, 0)\nc_rojo_oscuro      =  color.rgb(80, 0, 0, 0)\nnoneColor          =  color.new(color.white, 100)\n//== Declarar estrategia y per\u00edodo de testeo\nstrategy(\"Channels Strategy [JoseMetal]\", shorttitle=\"Channels Strategy [JoseMetal]\"\nGRUPO_per_pruebas = \"Per\u00edodo de pruebas\"\nfecha_inicio     = input.time(0, \"\u2022 Fecha de inicio\", group=GRUPO_per_pruebas, tooltip\nfecha_fin_usar   = input.bool(false, \"Fecha de finalizaci\u00f3n\", group=GRUPO_per_pruebas\nfecha_fin        = input.time(timestamp(\"1 Jan 2999\"), \"\", group=GRUPO_per_pruebas\nvela_en_fecha    = time >= fecha_inicio and (fecha_fin_usar ? time <= fecha_fin : \nposicion_abierta = strategy.position_size != 0\nLONG_abierto     = strategy.position_size > 0\nSHORT_abierto    = strategy.position_size < 0\n//== Condiciones de entrada y salida de estrategia\nGRUPO_P           = \"Posiciones\"\nP_indicador       = input.string(\"Canales de Keltner\", \"Indicador\", [\"Bandas de Bollinger\"\nP_permitir_LONGS  = input.bool(title=\"\u00bfLONGS?\", group=GRUPO_P, defval=true)\nP_permitir_SHORTS = input.bool(title=\"\u00bfSHORTS?\", group=GRUPO_P, defval=true)\nP_cond_entrada    = input.string(\"Cierre fuera de la banda y luego cierre dentro\",\nGRUPO_TPSL       = \"Stop Loss y Take Profit\"\nTP_SL_tipo_SL    = input.string(\"Banda extendida\", \"Tipo de Stop Loss\", options=[\"Mecha anterior\"\nTP_SL_tipo_TP    = input.string(\"Banda contraria\",  \"Tipo de Take Profit\", options\nTPSL_SL_ATR_mult = input.float(title=\"\u2022 (Solo ATR) Multiplicador Stop Loss / Take \nTPSL_TP_ATR_mult = input.float(title=\"\", group=GRUPO_TPSL, defval=1.8, minval=0.1,\nTPSL_SL_BB_dev   = input.float(title=\"\u2022 (Solo STOP LOSS con BB) Desviaci\u00f3n est\u00e1ndar\"\nTPSL_SL_KC_mult  = input.float(title=\"\u2022 (Solo STOP LOSS con KC) Multiplicador\", group\nTP_SL_TP_dinamico = input.bool(title=\"Take Profit din\u00e1mico\", group=GRUPO_TPSL, defval\n//== Inputs de indicadores\n// ATR\nGRUPO_ATR      = \"ATR\"\nATR_referencia = input.source(title=\"\u2022 Referencia / Longitud\", group=GRUPO_ATR, defval\nATR_length     = input.int(title=\"\", group=GRUPO_ATR, defval=7, minval=1, inline=\"atr_calc\"\nATR            = ta.atr(ATR_length)\nATR_sl         = ATR * TPSL_SL_ATR_mult\nATR_tp         = ATR * TPSL_TP_ATR_mult\nATR_LONG_sl    = ATR_referencia - ATR_sl // De forma contraria el inferior se puede usar co\nATR_LONG_tp    = ATR_referencia + ATR_tp // El ATR sobre las velas se puede usar como TAKE \nATR_SHORT_sl   = ATR_referencia + ATR_sl // \"\"\nATR_SHORT_tp   = ATR_referencia - ATR_tp // Para Shorts es al rev\u00e9s\nGRUPO_BB  = \"Bollinger Bands\"\nBB_length = input.int(title=\"\u2022 Long. / Desv. \", group=GRUPO_BB, defval=20, minval=\nBB_dev   = input.float(title=\"\", group=GRUPO_BB, defval=2.0, minval=0.01, step=0.5\n[BB_mid, BB_upper, BB_lower]  = ta.bb(close, BB_length, BB_dev)\n[_, BB_upper_SL, BB_lower_SL] = ta.bb(close, BB_length, TPSL_SL_BB_dev)\nGRUPO_KC  = \"Keltner Channel\"\nKC_length = input.int(title=\"\u2022 Long. / Mult. \", group=GRUPO_KC, defval=35, minval=\nKC_mult   = input.float(title=\"\", group=GRUPO_KC, defval=1.5, minval=0.01, step=0.5\n[KC_mid, KC_upper, KC_lower]  = ta.kc(close, KC_length, KC_mult, true)\n[_, KC_upper_SL, KC_lower_SL] = ta.kc(close, KC_length, TPSL_SL_KC_mult, true)\n//== C\u00e1lculo de condiciones\n// Asignar variables comunes en funci\u00f3n del indicador seleccionado\nbanda_superior = BB_upper\nmedia_movil    = BB_mid\nbanda_inferior = BB_lower\nbanda_extendida_sup_SL = BB_upper_SL\nbanda_extendida_inf_SL = BB_lower_SL\nif (P_indicador == \"Canales de Keltner\")\n    banda_superior := KC_upper\n    media_movil    := KC_mid\n    banda_inferior := KC_lower\n    banda_extendida_sup_SL := KC_upper_SL\n    banda_extendida_inf_SL := KC_lower_SL\n// Calcular condiciones de entrada\nlongCondition1  = false\nshortCondition1 = false\nif (P_cond_entrada == \"Mecha fuera de la banda\")\n    longCondition1  := low < banda_inferior\n    shortCondition1 := high > banda_superior\nelse if (P_cond_entrada == \"Mecha fuera de la banda y luego cierre dentro\")\n    longCondition1  := low[1] < banda_inferior and close > banda_inferior\n    shortCondition1 := high[1] > banda_superior and close < banda_superior\nelse if (P_cond_entrada == \"Cierre fuera de la banda\")\n    longCondition1  := close < banda_inferior\n    shortCondition1 := close > banda_superior\nelse // Cierre fuera de la banda y luego cierre dentro\n    longCondition1  := close[1] < banda_inferior and close > banda_inferior\n    shortCondition1 := close[1] > banda_superior and close < banda_superior\n//== Entrada (deben cumplirse todas para entrar)\nlongCondition2  = true\nlongCondition3  = true\nlong_conditions = longCondition1 and longCondition2 and longCondition3\n//entrar_en_LONG  = P_permitir_LONGS and long_conditions and vela_en_fecha and not \nentrar_en_LONG  = P_permitir_LONGS and long_conditions and vela_en_fecha and ATR >\nshortCondition2  = true\nshortCondition3  = true\nshort_conditions = shortCondition1 and shortCondition2 and shortCondition3\n//entrar_en_SHORT  = P_permitir_SHORTS and short_conditions and vela_en_fecha and not \nentrar_en_SHORT  = P_permitir_SHORTS and short_conditions and vela_en_fecha and ATR\nvar LONG_take_profit  = 0.0\nvar LONG_stop_loss    = 0.0\nvar SHORT_take_profit = 0.0\nvar SHORT_stop_loss   = 0.0\nif (entrar_en_LONG and not posicion_abierta)\n    LONG_stop_loss   := TP_SL_tipo_SL == \"Mecha anterior\" ? (P_cond_entrada == \"Mecha fuera de la banda\"\n    LONG_take_profit := TP_SL_tipo_TP == \"Banda contraria\" ? banda_superior : TP_SL_tipo_TP\n    strategy.entry(\"Abrir Long\", strategy.long)\n    strategy.exit(\"Cerrar Long\", \"Abrir Long\", limit=LONG_take_profit, stop=LONG_stop_loss\nelse if (entrar_en_SHORT and not posicion_abierta)\n    SHORT_stop_loss   := TP_SL_tipo_SL == \"Mecha anterior\" ? (P_cond_entrada == \"Mecha fuera de la banda\"\n    SHORT_take_profit := TP_SL_tipo_TP == \"Banda contraria\" ? banda_inferior : TP_SL_tipo_TP\n    strategy.entry(\"Abrir Short\", strategy.short)\n    strategy.exit(\"Cerrar Short\", \"Abrir Short\", limit=SHORT_take_profit, stop=SHORT_stop_loss\nif (posicion_abierta and TP_SL_TP_dinamico)\n    if (LONG_abierto)\n        LONG_take_profit := TP_SL_tipo_TP == \"Banda contraria\" ? banda_superior : \n        strategy.exit(\"Cerrar Long\", \"Abrir Long\", limit=LONG_take_profit, stop=LONG_stop_loss\n    else\n        SHORT_take_profit := TP_SL_tipo_TP == \"Banda contraria\" ? banda_inferior :\n        strategy.exit(\"Cerrar Short\", \"Abrir Short\", limit=SHORT_take_profit, stop\n//== Ploteo en pantalla\nbgcolor(entrar_en_LONG ?  color.new(color.green, 90) : entrar_en_SHORT ?  color.new\n// ATR\nplot(TP_SL_tipo_TP == \"ATR\" ? ATR_LONG_tp : na, style=plot.style_stepline, color= \nplot(TP_SL_tipo_SL == \"ATR\" ? ATR_LONG_sl : na, style=plot.style_stepline, color= \nplot(TP_SL_tipo_TP == \"ATR\" ? ATR_SHORT_tp : na, style=plot.style_stepline, color=\nplot(TP_SL_tipo_SL == \"ATR\" ? ATR_SHORT_sl : na, style=plot.style_stepline, color=\n// Canal y media\nplot(banda_superior, \"Banda superior\",  color.aqua)\nplot(media_movil, \"Media m\u00f3vil\",  color.orange)\nplot(banda_inferior, \"Banda inferior\",  color.aqua)\n// Bandas extendidas\nplot(TP_SL_tipo_SL == \"Banda extendida\" ? banda_extendida_sup_SL : na, \"Banda superior extendida (Stop Loss)\"\nplot(TP_SL_tipo_SL == \"Banda extendida\" ? banda_extendida_inf_SL : na, \"Banda inferior extendida (Stop Loss)\"\n// Precio de compra, Take Profit, Stop Loss y relleno\navg_position_price_plot = plot(series=posicion_abierta ? strategy.position_avg_price\nLONG_tp_plot            = plot(LONG_abierto and LONG_take_profit > 0.0 ? LONG_take_profit\nLONG_sl_plot            = plot(LONG_abierto and LONG_stop_loss > 0.0? LONG_stop_loss\nfill(avg_position_price_plot, LONG_tp_plot, color= color.new(color.olive, 85))\nfill(avg_position_price_plot, LONG_sl_plot, color= color.new(color.maroon, 85))\nSHORT_tp_plot            = plot(SHORT_abierto and SHORT_take_profit > 0.0 ? SHORT_take_profit\nSHORT_sl_plot            = plot(SHORT_abierto and SHORT_stop_loss > 0.0 ? SHORT_stop_loss\nfill(avg_position_price_plot, SHORT_tp_plot, color= color.new(color.olive, 85))\nfill(avg_position_price_plot, SHORT_sl_plot, color= color.new(color.maroon, 85))"}]}
{"messages": [{"role": "user", "content": "Hello All  This is non-repainting Supertrend\u00a0Multi Time Frame\u00a0script,  I got so many request on Supertrend with Multi Time Frame. This is for all of them ..I am making it open for all so you can change its coding according to your need. How the Basic Indicator works SuperTrend is one of the most common ATR based trailing stop indicators. In this version you can change the ATR calculation method from the settings. Default method is RMA. The indicator is easy to use and gives an accurate reading about an ongoing trend. It is constructed with two parameters, namely period and multiplier. The default values used while constructing a Supertrend indicator are 10 for\u00a0average true range\u00a0or trading period and three for its multiplier. The\u00a0average true range\u00a0(ATR) plays an important role in 'Supertrend' as the indicator uses ATR to calculate its value. The ATR indicator signals the degree of price\u00a0volatility\u00a0. The buy and sell signals are generated when the indicator starts plotting either on top of the closing price or below the closing price. A buy signal is generated when the \u2018Supertrend\u2019 closes above the price and a sell signal is generated when it closes below the closing price. It also suggests that the trend is shifting from descending mode to ascending mode. Contrary to this, when a \u2018Supertrend\u2019 closes above the price, it generates a sell signal as the colour of the indicator changes into red. A \u2018Supertrend\u2019 indicator can be used on spot,\u00a0futures, options\u00a0or forex, or even crypto markets and also on daily, weekly and hourly charts as well, but generally, it fails in a sideways-moving market. How the Strategy  works  This is developed based on SuperTrend.  Use two time frame for confirm all entry signals.  Two time frame SuperTrend works as Trailing stop for both long and short positions.  More securely execute orders, because it is wait until confine two time frames(example : daily and 30min)  Each time frame developed as customisable for user to any timeframe.  User can choose trading position side from Long, Short, and Both.  Custom Stop Loss level,  user can enter Stop Loss percentage based on timeframe using.  Multiple Take Profit levels with customisable TP price percentage and position size.  Back-testing with custom time frame.  This strategy is develop for specially for automation purpose.  The strategy includes:  Entry for Long and Short.  Take Profit.  Stop Loss.  Trailing Stop Loss.  Position Size.  Exit Signal.  Risk Management Feature.  Backtesting.  Trading Alerts.  Use the strategy with alerts This strategy is alert-ready. All you have to do is:  Go on a pair you would like to trade  Create an alert  Select the strategy as a Trigger  Wait for new orders to be sent to you  This is develop for specially for automating trading on any exchange, if you need to get that automating service for this strategy or any Tradingview strategy or indicator please contact me I am have 8 year experience on that field.   I hope you enjoy it! Thanks, Ranga"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 ranga_trading\n//@version=5\nstrategy(title='SuperTrend Multi Time Frame Long and Short Trading Strategy with Take Profit, Stop Loss and in buil\ntf1 = input.timeframe('D', title='Timeframe 1')\ntf2 = input.timeframe('W', title='Timeframe 2')\nlength = input(title='ATR Period', defval=22)\nmult = input.float(title='ATR Multiplier', step=0.1, defval=3.0)\nshowLabels = input(title='Show Buy/Sell Labels ?', defval=true)\nuseClose = input(title='Use Close Price for Extremums ?', defval=true)\nhighlightState = input(title='Highlight State ?', defval=true)\natr = mult * ta.atr(length)\nlongStop = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr\nlongStopPrev = nz(longStop[1], longStop)\nlongStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop\nshortStop = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr\nshortStopPrev = nz(shortStop[1], shortStop)\nshortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop\nvar int dir = 1\ndir := close > shortStopPrev ? 1 : close < longStopPrev ? -1 : dir\nvar color longColor =  color.green\nvar color shortColor =  color.red\nlongStopPlot = plot(dir == 1 ? longStop : na, title='Long Stop', style=plot.style_linebr\nbuySignal = dir == 1 and dir[1] == -1\nplotshape(buySignal ? longStop : na, title='Long Stop Start', location=location.absolute\nshortStopPlot = plot(dir == 1 ? na : shortStop, title='Short Stop', style=plot.style_linebr\nsellSignal = dir == -1 and dir[1] == 1\nplotshape(sellSignal ? shortStop : na, title='Short Stop Start', location=location.absolute\nmidPricePlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0, display\nlongFillColor = highlightState ? dir == 1 ? longColor : na : na\nshortFillColor = highlightState ? dir == -1 ? shortColor : na : na\nfill(midPricePlot, longStopPlot, title='Long State Filling', color=longFillColor, \nfill(midPricePlot, shortStopPlot, title='Short State Filling', color=shortFillColor\n// CE Function\nce() =>\n    atr2 = mult * ta.atr(length)\n    longStop2 = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr2\n    longStop2Prev = nz(longStop2[1], longStop2)\n    longStop2 := close[1] > longStop2Prev ? math.max(longStop2, longStop2Prev) : longStop2\n    shortStop2 = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr2\n    shortStop2Prev = nz(shortStop2[1], shortStop2)\n    shortStop2 := close[1] < shortStop2Prev ? math.min(shortStop2, shortStop2Prev)\n    var int dir2 = 1\n    dir2 := close > shortStop2Prev ? 1 : close < longStop2Prev ? -1 : dir2\n    ce = dir2 == 1 ? longStop2 : shortStop2\n    [dir2, ce]\n[side, ce_plot] = ce()\nce1_plot = request.security(syminfo.tickerid, tf1, ce_plot[1], barmerge.gaps_off, \nce2_plot = request.security(syminfo.tickerid, tf2, ce_plot[1], barmerge.gaps_off, \nce1 = request.security(syminfo.tickerid, tf1, side[1], barmerge.gaps_off, barmerge.lookahead_on\nce2 = request.security(syminfo.tickerid, tf2, side[1], barmerge.gaps_off, barmerge.lookahead_on\nlong = buySignal and ce1 > 0 and ce2 > 0\nshort = sellSignal and ce1 < 0 and ce2 < 0\ntradeType = input.string('BOTH', title='What trades should be taken : ', options=[\n// Position Management Tools\npos = 0.0\nif tradeType == 'BOTH'\n    pos := long ? 1 : short ? -1 : pos[1]\n    pos\nif tradeType == 'LONG'\n    pos := long ? 1 : pos[1]\n    pos\nif tradeType == 'SHORT'\n    pos := short ? -1 : pos[1]\n    pos\nlongCond = long and (pos[1] != 1 or na(pos[1]))\nshortCond = short and (pos[1] != -1 or na(pos[1]))\nplot(ce1_plot, title='Timeframe 1 CE', color=ce1 > 0 ?  #008000 :  #800000, linewidth\nplot(ce2_plot, title='Timeframe 2 CE', color=ce2 > 0 ?  color.green :  color.red\n// EXIT FUNCTIONS //\ni_sl = input.float(5.0, title='Stop Loss %', minval=0, group='Trades')\nsl = i_sl > 0 ? i_sl / 100 : 99999\nlong_entry = ta.valuewhen(longCond, close, 0)\nshort_entry = ta.valuewhen(shortCond, close, 0)\n// Simple Stop Loss + 2 Take Profits\nsl_long = strategy.position_avg_price * (1 - sl)\nsl_short = strategy.position_avg_price * (1 + sl)\n// Position Adjustment\nlong_sl = low < sl_long and pos[1] == 1\nshort_sl = high > sl_short and pos[1] == -1\nif long_sl or short_sl\n    pos := 0\n    pos\nlong_exit = sellSignal and pos[1] == 1\nshort_exit = buySignal and pos[1] == -1\nif long_exit or short_exit\n    pos := 0\n    pos\ntp1percent = input.int(5, title='TP1 %', group='Trades') / 100.0\ntp2percent = input.int(10, title='TP2 %', group='Trades') / 100.0\ntp3percent = input.int(15, title='TP3 %', group='Trades') / 100.0\ntp1amt = input.int(10, title='TP1 Amount %', group='Trades')\ntp2amt = input.int(15, title='TP2 Amount %', group='Trades')\ntp3amt = input.int(20, title='TP3 Amount %', group='Trades')\n//  Strategy Backtest Limiting Algorithm\ni_startTime = input.time(defval=timestamp('01 Jun 2021 13:30 +0000'), title='Backtesting Start Time'\ni_endTime = input.time(defval=timestamp('30 Sep 2099 19:30 +0000'), title='Backtesting End Time'\ntimeCond = time > i_startTime and time < i_endTime\nKeepLastPosition = input(false)\n// Make sure we are within the bar range, Set up entries and exit conditions\nstrategy.entry('long', strategy.long, when=longCond == true and tradeType != 'SHORT'\nstrategy.entry('short', strategy.short, when=shortCond == true and tradeType != 'LONG'\nvar float Qty1 = na\nvar float Qty2 = na\nvar float Qty3 = na\nvar float Qty4 = na\nif strategy.position_size == 0\n    equity_q = (strategy.initial_capital + strategy.netprofit) / close\n    Qty1 := equity_q * tp1amt / 100.0\n    Qty2 := equity_q * tp2amt / 100.0\n    Qty3 := equity_q * tp3amt / 100.0\n    Qty4 := equity_q - Qty1 - Qty2 - Qty3\n    Qty4\nstrategy.exit('Exit1', qty=Qty1, stop=sl_long, limit=strategy.position_avg_price *\nstrategy.exit('Exit2', qty=Qty2, stop=sl_long, limit=strategy.position_avg_price *\nstrategy.exit('Exit3', qty=Qty3, stop=sl_long, limit=strategy.position_avg_price *\nstrategy.exit('Exit4', qty=Qty4, stop=sl_long, when=strategy.position_size > 0 and\nstrategy.close('long', when=long_exit, comment='CE Exit')\nstrategy.exit('Exit1', qty=Qty1, stop=sl_short, limit=strategy.position_avg_price \nstrategy.exit('Exit2', qty=Qty2, stop=sl_short, limit=strategy.position_avg_price \nstrategy.exit('Exit3', qty=Qty3, stop=sl_short, limit=strategy.position_avg_price \nstrategy.exit('Exit4', qty=Qty4, stop=sl_short, when=strategy.position_size < 0 and\nstrategy.close('short', when=short_exit, comment='CE Exit')\nplot(strategy.position_size > 0 ? strategy.position_avg_price * (1 + tp1percent) :\nplot(strategy.position_size > 0 ? strategy.position_avg_price * (1 + tp2percent) :\nplot(strategy.position_size > 0 ? strategy.position_avg_price * (1 + tp3percent) :\nplot(strategy.position_size > 0 ? sl_long : na, color= color.new(color.red, 0), style\nplot(strategy.position_size > 0 ? strategy.position_avg_price : na, color= color.new\nplot(strategy.position_size < 0 ? strategy.position_avg_price * (1 - tp1percent) :\nplot(strategy.position_size < 0 ? strategy.position_avg_price * (1 - tp2percent) :\nplot(strategy.position_size < 0 ? strategy.position_avg_price * (1 - tp3percent) :\nplot(strategy.position_size < 0 ? sl_short : na, color= color.new(color.red, 0), \nplot(strategy.position_size < 0 ? strategy.position_avg_price : na, color= color.new"}]}
{"messages": [{"role": "user", "content": "Hi all, It's bear market so let's have a look at the misery index.  Misery index = inflation(%) + unemployment (%) It's only possible to use this chart on the monthly (as misery index is updated monthly), but just for fun I added a strategy to it. If misery index increases you short and you go long when MI decreases. Enjoy p.s. the band is pretty cool too"}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 DynamicSignalLab\n//@version=5\nstrategy(\"Misery index\", overlay=false)\nunemployment = request.security(\"FRED:UNRATE\",\"M\",close) \ninflation = request.security(\"ECONOMICS:USIRYY\",\"M\",close)\nmisery = unemployment+inflation\nplot(misery)\nlongCondition = misery<misery[1]\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nshortCondition = misery>misery[1]\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)"}]}
{"messages": [{"role": "user", "content": "The Ichimoku Cloud is a collection of technical indicators that show support and resistance levels, as well as momentum and trend direction. It does this by taking multiple averages and plotting them on a chart. It also uses these figures to compute a \u201ccloud\u201d that attempts to forecast where the price may find support or resistance in the future. The Ichimoku Cloud was developed by Goichi Hosoda, a Japanese journalist, and published in the late 1960s. It provides more data points than the standard candlestick chart. While it seems complicated at first glance, those familiar with how to read the charts often find it easy to understand with well-defined trading signals. The Ichimoku Cloud is composed of five lines or calculations, two of which comprise a cloud where the difference between the two lines is shaded in. The lines include a nine-period average, a 26-period average, an average of those two averages, a 52-period average, and a lagging closing price line. The cloud is a key part of the indicator. When the price is below the cloud, the trend is down. When the price is above the cloud, the trend is up. The above trend signals are strengthened if the cloud is moving in the same direction as the price. For example, during an uptrend, the top of the cloud is moving up, or during a downtrend, the bottom of the cloud is moving down. DMI is simple to interpret. When +DI > - DI, it means the price is trending up. On the other hand, when -DI > +DI , the trend is weak or moving on the downside. The ADX does not give an indication about the direction but about the strength of the trend. Typically values of ADX above 25 mean that the trend is steeply moving up or down, based on the -DI and +D positioning. This script aims to capture swings in the DMI, and thus, in the trend of the asset, using a contrarian approach. Trading on high values of ADX, the strategy tries to spot extremely oversold and overbought conditions. Values of ADX above 45 may suggest that the trend has overextended and is may be about to reverse. This strategy combines the Ichimoku Cloud with the ADX indicator to better enter trades. Long orders are placed when these basic signals are triggered. Long Position: Tenkan-Sen is above the Kijun-Sen Chikou-Span is above the close of 26 bars ago Close is above the Kumo Cloud MACD line crosses over the signal line -DI is greater than +DI ADX is greater than 45 Close Position: 3% increase trailing 3% decrease trailing The script is backtested from 1 January 2018 and provides good returns. The strategy assumes each order is using 30% of the available coins to make the results more realistic and to simulate you only ran this strategy on 30% of your holdings. A trading fee of 0.1% is also taken into account and is aligned to the base fee applied on Binance. This script also works well on MATIC (1d timeframe), ETH (1d timeframe), and SOL (1d timeframe)."}, {"role": "assistant", "content": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \u00a9 Coinrule\n//@version=5\nstrategy('Ichimoku Cloud with ADX with Trailing Stop Loss',\n         overlay=true,\n         initial_capital=1000,\n         process_orders_on_close=true,\n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=30,\n         commission_type=strategy.commission.percent,\n         commission_value=0.1)\nshowDate = input(defval=true, title='Show Date Range')\ntimePeriod = time >= timestamp(syminfo.timezone, 2018, 1, 1, 0, 0)\n// Inputs\nts_bars = input.int(9, minval=1, title='Tenkan-Sen Bars')\nks_bars = input.int(26, minval=1, title='Kijun-Sen Bars')\nssb_bars = input.int(52, minval=1, title='Senkou-Span B Bars')\ncs_offset = input.int(26, minval=1, title='Chikou-Span Offset')\nss_offset = input.int(26, minval=1, title='Senkou-Span Offset')\nlong_entry = input(true, title='Long Entry')\nshort_entry = input(true, title='Short Entry')\nmiddle(len) => math.avg(ta.lowest(len), ta.highest(len))\n// Ichimoku Components\ntenkan = middle(ts_bars)\nkijun = middle(ks_bars)\nsenkouA = math.avg(tenkan, kijun)\nsenkouB = middle(ssb_bars)\n// Plot Ichimoku Kinko Hyo\nplot(tenkan, color= color.new(#0496ff, 0), title='Tenkan-Sen')\nplot(kijun, color= color.new(#991515, 0), title='Kijun-Sen')\nplot(close, offset=-cs_offset + 1, color= color.new(#459915, 0), title='Chikou-Span'\nsa = plot(senkouA, offset=ss_offset - 1, color= color.new(color.green, 0), title='Senkou-Span A'\nsb = plot(senkouB, offset=ss_offset - 1, color= color.new(color.red, 0), title='Senkou-Span B'\nfill(sa, sb, color=senkouA > senkouB ?  color.green :  color.red, title='Cloud color'\nss_high = math.max(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\nss_low = math.min(senkouA[ss_offset - 1], senkouB[ss_offset - 1])\n// ADX\n[pos_dm, neg_dm, avg_dm] = ta.dmi(14, 14)\n// Entry/Exit Signals\ntk_cross_bull = tenkan > kijun\ntk_cross_bear = tenkan < kijun\ncs_cross_bull = ta.mom(close, cs_offset - 1) > 0\ncs_cross_bear = ta.mom(close, cs_offset - 1) < 0\nprice_above_kumo = close > ss_high\nprice_below_kumo = close < ss_low\nbullish = tk_cross_bull and cs_cross_bull and price_above_kumo and avg_dm < 45 and \nbearish = tk_cross_bear and cs_cross_bear and price_below_kumo and avg_dm > 45 and \n// Configure trail stop level with input options\nlongTrailPerc = input.float(title='Trail Long Loss (%)', minval=0.0, step=0.1, defval\nshortTrailPerc = input.float(title='Trail Short Loss (%)', minval=0.0, step=0.1, defval\n// Determine trail stop loss prices\nlongStopPrice = 0.0\nshortStopPrice = 0.0\nlongStopPrice := if strategy.position_size > 0\n    stopValue = close * (1 - longTrailPerc)\n    math.max(stopValue, longStopPrice[1])\nelse\n    0\nshortStopPrice := if strategy.position_size < 0\n    stopValue = close * (1 + shortTrailPerc)\n    math.min(stopValue, shortStopPrice[1])\nelse\n    999999\nstrategy.entry('Long', strategy.long, when=bullish and long_entry and timePeriod)\nstrategy.exit('Long', stop = longStopPrice, limit = shortStopPrice)\n//strategy.entry('Short', strategy.short, when=bearish and short_entry and timePeriod)\n//strategy.exit('Short', stop = longStopPrice, limit = shortStopPrice)"}]}
